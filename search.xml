<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Review | Medium | 1004. Max Consecutive Ones III</title>
    <url>/2020/07/28/1004.%20Max%20Consecutive%20Ones%20III/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">946. Validate Stack Sequences</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/validate-stack-sequences/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.</p>
<p>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using <code>sliding window</code> to maintain just at most <code>K</code> zeros in the window.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; A.length; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] == <span class="number">0</span>)K--;</span><br><span class="line">            <span class="keyword">while</span>(start &lt;= end &amp;&amp; K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[start] == <span class="number">0</span>)K++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end - start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actually we can just using <code>if</code> instead of <code>while</code> cause we need the max length of 1s. So we can either matain the same size or increasing the size of window instead decrease it.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; A.length; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] == <span class="number">0</span>)K--;</span><br><span class="line">            <span class="keyword">if</span>(K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[start] == <span class="number">0</span>)K++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end - start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 1248. Count Number of Nice Subarrays</title>
    <url>/2020/07/29/1248.%20Count%20Number%20of%20Nice%20Subarrays/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1248-Count-Number-of-Nice-Subarrays-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1248. Count Number of Nice Subarrays</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/submissions/" target="_blank" rel="noopener"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given an array of integers nums and an integer k. A subarray is called nice if there are k odd numbers on it.</p>
<p>Return the number of nice sub-arrays.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,2,1,1], k = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,4,6], k = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no odd numbers in the array.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Navie-Solution">Navie Solution</h4>
<p>Apparently using sliding window. Keep the window that matain K odd numbers. Then perform <code>atMost</code> algo, to get the number of subarray with exactly <code>k</code> odd numbers.</p>
<p><code>k = atMost(k) - atMost(k-1)</code></p>
<h4 id="Optimized-Solution">Optimized Solution</h4>
<p>Based on the sliding window, we record the number of even num and to get all the subarray number. It’s true that when we add the even number from 0 to max one , then we can get all the possible nums of combination.</p>
<h3 id="Code">Code</h3>
<h4 id="Sliding-Window-with-atMost">Sliding Window with atMost</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atMost(A, k) - atMost(A, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atMost</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, n = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            k -= A[j] % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                k+=A[i] % <span class="number">2</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
<h4 id="Optimized-Solution-v2">Optimized Solution</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; n; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( k == <span class="number">0</span>)&#123;</span><br><span class="line">                k+=A[start++]%<span class="number">2</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 1153. String Transforms Into Another String</title>
    <url>/2020/07/27/1153.%20String%20Transforms%20Into%20Another%20String/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1153-String-Transforms-Into-Another-String-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1153. String Transforms Into Another String</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/string-transforms-into-another-string/"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions.</p>
<p>In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character.</p>
<p>Return true if and only if you can transform str1 into str2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Convert &apos;c&apos; to &apos;e&apos; then &apos;b&apos; to &apos;d&apos; then &apos;a&apos; to &apos;c&apos;. Note that the order of conversions matter.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: str1 = &quot;leetcode&quot;, str2 = &quot;codeleet&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to transform str1 to str2.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Tricky-Part">Tricky Part</h4>
<p>We can use HashMap to store the link of chars. For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a -&gt; b, b-&gt;c , c-&gt;d</span><br></pre></td></tr></table></figure>
<p>So each time when we scan from both str1 and str2, we check the str2 character with the one stored in map of str1, if it non exist then set default one with str2’ char. Otherwise, if they are different, like the link in map is <code>a-&gt;c</code> but the reality is <code>a-&gt;d</code> then return false, because one character can’t transform to two different chars at same time.</p>
<h4 id="Special-Edge-case">Special/Edge case :</h4>
<p>First case is two string are equal then we return true.</p>
<p>Second one is like the unique chars of both strs are same and have 26 chars. But in order to transform one to another we need a temp char that is unused, like <code> temp -&gt; a, a -&gt; b , b-&gt; c , c-&gt; temp</code>. Same as swap two number in array. So in this case we can’t perform the transformation, because there is just 26 chars and no more for us to mark as temp, so just return false.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str1.equals(str2))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(str1 == <span class="keyword">null</span> || str1.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(str1.charAt(i), str2.charAt(i)) != str2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(str1.charAt(i),str2.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> set.size() &lt; <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 113. Path Sum II</title>
    <url>/2020/07/22/113.%20Path%20Sum%20II/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-113-Path-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">113. Path Sum II</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/path-sum-ii/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s simple and clear we have to use DFS + backtracking to get all the possible paths.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res,sum,templist);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> sum, List&lt;Integer&gt; templist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        templist.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        &#125;</span><br><span class="line">        help(root.left,res,sum - root.val, templist);</span><br><span class="line">        help(root.right,res,sum-root.val, templist);</span><br><span class="line">        templist.remove(templist.size() -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 138. Copy List with Random Pointer</title>
    <url>/2020/07/23/138.%20Copy%20List%20with%20Random%20Pointer/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-138-Copy-List-with-Random-Pointer-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">138. Copy List with Random Pointer</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/copy-list-with-random-pointer/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p>The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p>
<p>val: an integer representing Node.val</p>
<p>random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.</p>
<img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="leetcode 138">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Easy to come up with <code>HashMap</code> solution. Keep record of the node and it’s new copied one. And assign each next and ramdon to the copied one.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> Node(node.val));</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(node).next = map.get(node.next);</span><br><span class="line">            map.get(node).random = map.get(node.random);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 255. Verify Preorder Sequence in Binary Search Tree</title>
    <url>/2020/07/22/255.%20Verify%20Preorder%20Sequence%20in%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-255-Verify-Preorder-Sequence-in-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">255. Verify Preorder Sequence in Binary Search Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p>
<p>You may assume each number in the sequence is unique.</p>
<p>Consider the following binary search tree:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [5,2,6,1,3]</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [5,2,1,3,6]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<ol>
<li>
<p>Using DFS and loop the whole array to find the bigger index, then dfs the left and right part.</p>
</li>
<li>
<p>Using stack to iterate the tree. When current node is bigger than the peek in the stack, let low equal to the popped one, until the peek is greater than current node.</p>
</li>
</ol>
<h3 id="Code">Code</h3>
<ol>
<li>DFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max == -<span class="number">1</span> &amp;&amp; a[i] &gt; temp) max = i;</span><br><span class="line">            <span class="keyword">if</span>(max != -<span class="number">1</span> &amp;&amp; a[i] &lt; temp) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bigger == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> help(a, start + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> help(a, start + <span class="number">1</span>, max - <span class="number">1</span>) &amp;&amp; help(a, max, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Stack</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : preorder) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; low)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!path.empty() &amp;&amp; p &gt; path.peek())</span><br><span class="line">                low = path.pop();</span><br><span class="line">            path.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 209. Minimum Size Subarray Sum</title>
    <url>/2020/07/25/209.%20Minimum%20Size%20Subarray%20Sum/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-209-Minimum-Size-Subarray-Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">209. Minimum Size Subarray Sum</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/minimum-size-subarray-sum/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br><span class="line">Follow up:</span><br><span class="line">If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Two-pointers-Sliding-window">Two pointers + Sliding window</h4>
<p>Since the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don’t have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices.</p>
<h4 id="Binary-search-Presum-array">Binary search + Presum array</h4>
<p>Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search.</p>
<h3 id="Code">Code</h3>
<h4 id="Two-pointers">Two pointers</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; len)&#123;</span><br><span class="line">            sum+=nums[end];</span><br><span class="line">            <span class="keyword">while</span>(start &lt;= end &amp;&amp; sum&gt;= s)&#123;</span><br><span class="line">                sum-=nums[start];</span><br><span class="line">                res = Math.min(res, end - start + <span class="number">1</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
<h4 id="Binary-Search">Binary Search</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// preSum[i] for i in [0, n-1], preSum[j] for j in [i+1, n]</span></span><br><span class="line">            <span class="keyword">int</span> j = binarySearch(i + <span class="number">1</span>, n + <span class="number">1</span> , preSum, s + preSum[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">                res = Math.min(res, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == n + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span>[] preSum, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = low, r = high;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (preSum[mid] &gt;= key) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == high ? -<span class="number">1</span> : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(nlogn) S:O(n)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 234. Palindrome Linked List</title>
    <url>/2020/07/28/234-Palindrome-Linked-List/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-234-Palindrome-Linked-List-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">234. Palindrome Linked List</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/palindrome-linked-list/"><font size="4">LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a singly linked list, determine if it is a palindrome.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using two pointers to find the two half of linkedlist, and reverse one of them. Then start comparation one by one.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span> )&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverse(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span> &amp;&amp; fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val != fast.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 269. Alien Dictionary</title>
    <url>/2020/07/25/269.%20Alien%20Dictionary/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-269-Alien-Dictionary-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">269. Alien Dictionary</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/alien-dictionary/"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;wrt&quot;,</span><br><span class="line">  &quot;wrf&quot;,</span><br><span class="line">  &quot;er&quot;,</span><br><span class="line">  &quot;ett&quot;,</span><br><span class="line">  &quot;rftt&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;wertf&quot;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s simple to come up with DFS and BFS solutions.</p>
<h4 id="DFS">DFS</h4>
<p>We can build a graph of connectin characters and make a topological sort using DFS. We can define different state of a character during DFS.</p>
<p><code>state[i] = -1</code> : Not even exist.</p>
<p><code>state[i] = 0</code> : Exist. Non-visited.</p>
<p><code>state[i] = 1</code> : Visiting.</p>
<p><code>state[i] = 2</code> : Visited.</p>
<h4 id="BFS">BFS</h4>
<p>We can using solution like indegree sorting to create a indegree of each character. And also create a set of other characters that ranks after current character. <code>Eg: wrf -&gt; w : r</code></p>
<h4 id="Edge-case-consideration">Edge case consideration</h4>
<p>In the new test cases ,there exist some cases like <code> 'abc', 'ab'</code>,which will occur ERROR when we using original code. So we have to add some code to return this case with “”.</p>
<p>Only thing we need to do is just compare the two adjcent string to check whether the first one can be made up with the whole next one.</p>
<h3 id="Code">Code</h3>
<h4 id="DFS-v2">DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//     private final int N = 26;</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">boolean</span>[][] cnt = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(!build(words))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(words,i))<span class="keyword">return</span><span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String[] words, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        state[i] = <span class="number">1</span>; <span class="comment">// visiting</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(state[j] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(state[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dfs(words,j))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[i] = <span class="number">2</span>;</span><br><span class="line">        sb.append((<span class="keyword">char</span>)(i+<span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">build</span><span class="params">(String[] words)</span></span>&#123;</span><br><span class="line">        Arrays.fill(state,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : words[i].toCharArray())&#123;</span><br><span class="line">                state[c-<span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    String w1 = words[i-<span class="number">1</span>];</span><br><span class="line">                    String w2 = words[i];</span><br><span class="line">                    <span class="keyword">int</span> len = Math.min(w1.length(), w2.length());</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;len; k++)&#123;</span><br><span class="line">                        <span class="keyword">char</span> c1 = w1.charAt(k);</span><br><span class="line">                        <span class="keyword">char</span> c2 = w2.charAt(k);</span><br><span class="line">                        <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">                            cnt[c1-<span class="string">'a'</span>][c2-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(w1.length() &gt; w2.length() &amp;&amp; w1.substring(<span class="number">0</span>,len).equals(w2.substring(<span class="number">0</span>,len)))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS-v2">BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;Character, Set&lt;Character&gt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; degree=<span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(String s: words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">                degree.put(c,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            String cur=words[i];</span><br><span class="line">            String next=words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur.length() &gt; next.length() &amp;&amp; cur.startsWith(next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> length=Math.min(cur.length(), next.length());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c1=cur.charAt(j);</span><br><span class="line">                <span class="keyword">char</span> c2=next.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c1!=c2)&#123;</span><br><span class="line">                    Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(c1)) set=map.get(c1);</span><br><span class="line">                    <span class="keyword">if</span>(!set.contains(c2))&#123;</span><br><span class="line">                        set.add(c2);</span><br><span class="line">                        map.put(c1, set);</span><br><span class="line">                        degree.put(c2, degree.get(c2)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Character&gt; q=<span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: degree.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree.get(c)==<span class="number">0</span>) q.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> c=q.remove();</span><br><span class="line">            result+=c;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c2: map.get(c))&#123;</span><br><span class="line">                    degree.put(c2,degree.get(c2)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(degree.get(c2)==<span class="number">0</span>) q.add(c2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result.length()!=degree.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 341. Flatten Nested List Iterator</title>
    <url>/2020/07/20/341.%20Flatten%20Nested%20List%20Iterator/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">341. Flatten Nested List Iterator</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/flatten-nested-list-iterator/"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a nested list of integers, implement an iterator to flatten it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,1,2,1,1].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Typical flatten array question. We can using stack to add each part from right to left, in order to keep the <code>leftmost</code> at the top of stack.</p>
<p>In <code>hasNext()</code> we have to check the peek, if the peek is integer then we just return true. If not it means it’a <code>nestedList</code> so we have to flatten it and push back to the stack.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    Stack&lt;NestedInteger&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        help(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext() ? stack.pop().getInteger() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.peek().isInteger())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            help(stack.pop().getList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;NestedInteger&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            stack.push(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 297. Serialize and Deserialize Binary Tree</title>
    <url>/2020/07/23/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/submissions/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.</p>
<p>You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<ul>
<li>
<p>Serialize: Using stringbuilder to take tree into a string split with &quot; &quot; using preorder + dfs.</p>
</li>
<li>
<p>Deserialize: Using the result from serialize to form a new tree preorderly.</p>
</li>
</ul>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)res.append(<span class="string">"null"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(root.left,res);</span><br><span class="line">            serial(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String source)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = source.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> des(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">des</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.equals(<span class="string">"null"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        node.left = des(queue);</span><br><span class="line">        node.right = des(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 329. Longest Increasing Path in a Matrix</title>
    <url>/2020/07/17/329.%20Longest%20Increasing%20Path%20in%20a%20Matrix/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-329-Longest-Increasing-Path-in-a-Matrix-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">329. Longest Increasing Path in a Matrix</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It is a typical <code>recursive + memo</code> question. We might think using db at first, but it is unnecessary. We can just DFS every number and keep a memo of it’s max length of increasing path in <code>memo[i][j]</code>.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, memo);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            max = Math.max(max,  <span class="number">1</span> + dfs(matrix, x, y, memo));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T: O(n^2) S: O(n^2)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 346. Moving Average from Data Stream</title>
    <url>/2020/07/20/346.%20Moving%20Average%20from%20Data%20Stream/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-346-Moving-Average-from-Data-Stream-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">346. Moving Average from Data Stream</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/moving-average-from-data-stream/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Simple question that we can using circular queue to solve it. When the queue reach size then we poll one element and substract it from the sum.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        s = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size() == s)&#123;</span><br><span class="line">            sum-=queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(val);</span><br><span class="line">        sum+=val;</span><br><span class="line">        <span class="keyword">return</span> sum/queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 350. Intersection of Two Arrays II</title>
    <url>/2020/07/20/350.%20Intersection%20of%20Two%20Arrays%20II/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-350-Intersection-of-Two-Arrays-II-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">350. Intersection of Two Arrays II</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given two arrays, write a function to compute their intersection.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>We can using one hashmap to store each number’s frequency in the nums1 array. Then make a loop in nums2. If the num in nums2 exist in map and it’s frequency is bigger than 0 then add it to res.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">                map.put(num,map.get(num)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)&#123;</span><br><span class="line">            ans[index++]=res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <url>/2020/07/23/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">426. Convert Binary Search Tree to Sorted Doubly Linked List</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.</p>
<p>You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p>
<p>We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p>
<img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root = [4,2,5,1,3]</span><br></pre></td></tr></table></figure>
<img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using the benifit of inorder to traverse the tree.</p>
<p>As we all know that inorder is an assending array. So we can using DFS to inorder traverse the whole tree.</p>
<p>Hence during the middle line code, all we need to do is linking the nodes and reassign the new node to the variables.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        pre.right = head; <span class="comment">// link the pre.right to the head</span></span><br><span class="line">        head.left = pre;  <span class="comment">// link the head.left to the pre. In order to make the listnode cycled.</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)head = cur; <span class="comment">// pre is used to store the left node of cur. If pre is null, it means cur has no node in the left, so the head should be cur.</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = cur; <span class="comment">// otherwise we link pre node to cur using pre.right = cur like `pre-&gt;cur`; </span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.left = pre; <span class="comment">// linking pre to the cur node like `pre&lt;-cur` (We have link those two before from `pre-&gt;cur`)</span></span><br><span class="line">        pre = cur; <span class="comment">// updating the value of pre and keeping dfs.</span></span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>LinkedList</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 351. Android Unlock Patterns</title>
    <url>/2020/07/17/351.%20Android%20Unlock%20Patterns/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-351-Android-Unlock-Patterns-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">351. Android Unlock Patterns</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/android-unlock-patterns/" target="_blank" rel="noopener"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.</p>
<p><strong>Rules for a valid pattern:</strong></p>
<ul>
<li>Each pattern must connect at least m keys and at most n keys.</li>
<li>All the keys must be distinct.</li>
<li>If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern.</li>
<li>No jumps through non selected key is allowed.</li>
<li>The order of keys used matters.</li>
</ul>
<img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png">
<p>Explanation:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 1 | 2 | 3 |</span><br><span class="line">| 4 | 5 | 6 |</span><br><span class="line">| 7 | 8 | 9 |</span><br><span class="line"></span><br><span class="line">Invalid move: 4 - 1 - 3 - 6</span><br><span class="line">Line 1 - 3 passes through key 2 which had not been selected in the pattern.</span><br><span class="line"></span><br><span class="line">Invalid move: 4 - 1 - 9 - 2</span><br><span class="line">Line 1 - 9 passes through key 5 which had not been selected in the pattern.</span><br><span class="line"></span><br><span class="line">Valid move: 2 - 4 - 1 - 3 - 6</span><br><span class="line">Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern</span><br><span class="line"></span><br><span class="line">Valid move: 6 - 5 - 4 - 1 - 9 - 2</span><br><span class="line">Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>First thought is using DFS to find all the possible path and count it’s total count. But it can be optimized by using a skip array.</p>
<p>The optimization idea is that 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.</p>
<p>Skip array store the number that between two numbers with only one interval.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cur: the current position</span></span><br><span class="line">    <span class="comment">// remain: the steps remaining</span></span><br><span class="line">    <span class="keyword">int</span>[][] skip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">boolean</span> seen[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> remain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        seen[cur] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// If vis[i] is not visited and (two numbers are adjacent or skip number is already visited)</span></span><br><span class="line">            <span class="keyword">if</span>(!seen[i] &amp;&amp; (skip[cur][i] == <span class="number">0</span> || seen[skip[cur][i]])) &#123;</span><br><span class="line">                res+= DFS(i, remain - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seen[cur] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">3</span>] = skip[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        skip[<span class="number">3</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">        skip[<span class="number">7</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">1</span>] = skip[<span class="number">2</span>][<span class="number">8</span>] = skip[<span class="number">8</span>][<span class="number">2</span>] = skip[<span class="number">3</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">3</span>] = skip[<span class="number">4</span>][<span class="number">6</span>] = skip[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// DFS search each length from m to n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i) &#123;</span><br><span class="line">            res+= DFS(<span class="number">1</span>, i - <span class="number">1</span>) * <span class="number">4</span>; <span class="comment">// start with 1(same as 3, 7, 9 ), so we multiply 4 here.</span></span><br><span class="line">            res+= DFS(<span class="number">2</span>, i - <span class="number">1</span>) * <span class="number">4</span>; <span class="comment">// start with 2(same as 4,6,8), so we multiply 4 here.</span></span><br><span class="line">            res+= DFS(<span class="number">5</span>, i - <span class="number">1</span>); <span class="comment">// start with 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V^2) S:O(V)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 348. Design Tic-Tac-Toe</title>
    <url>/2020/07/17/348.%20Design%20Tic-Tac-Toe/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-348-Design-Tic-Tac-Toe-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">348. Design Tic-Tac-Toe</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/design-tic-tac-toe/"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Design a Tic-tac-toe game that is played between two players on a n x n grid.</p>
<p>You may assume the following rules:</p>
<p>A move is guaranteed to be valid and is placed on an empty block.<br>
Once a winning condition is reached, no more moves is allowed.<br>
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| | |</span><br><span class="line">| | | |    // Player 1 makes a move at (0, 0).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 2 makes a move at (0, 2).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 1 makes a move at (2, 2).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 2 makes a move at (1, 1).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 1 makes a move at (2, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 2 makes a move at (1, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 1 makes a move at (2, 1).</span><br><span class="line">|X|X|X|</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s a simple question. We can use two array to store the score in rows and cols. And keep two record for diag and antidiag directions. If anyone of them reach to the size, then return current player. Otherwise just return 0.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rows;</span><br><span class="line">    <span class="keyword">int</span>[] cols;</span><br><span class="line">    <span class="keyword">int</span> diag;</span><br><span class="line">    <span class="keyword">int</span> antidiag;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicTacToe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        diag = <span class="number">0</span>;</span><br><span class="line">        antidiag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> row The row of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> col The column of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@return</span> The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = player == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        rows[row] += step;</span><br><span class="line">        cols[col] += step;</span><br><span class="line">        <span class="keyword">if</span>(row == col)&#123;</span><br><span class="line">            diag+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col == cols.length - row - <span class="number">1</span>)&#123;</span><br><span class="line">            antidiag+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = rows.length;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rows[row]) == size || Math.abs(cols[col]) == size || Math.abs(diag) == size || Math.abs(antidiag) == size)<span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 53. Maximum Subarray</title>
    <url>/2020/07/28/53-Maximum-Subarray/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-53-Maximum-Subarray-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">53. Maximum Subarray</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/maximum-subarray/"><font size="4">LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure>
<h4 id="Follow-Up">Follow Up</h4>
<p>If you have figured out the O(n) solution, try coding another solution using the <code>divide and conquer</code> approach, which is more subtle.</p>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Greedy">Greedy</h4>
<p>It’s the first navie solution we can come with. Keep a record of sum and update only when the new sum is positive. Otherwise let current num be the sum value.</p>
<h4 id="DP">DP</h4>
<p>Based on the <code>greedy</code> solution, we can using <code>DP</code> to easily solve it. The basic idea is same.</p>
<p>The transition function is <code>dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0)</code>. Only add <code>nums[i]</code> to previous sum only when the sum is positive, otherwise only set <code>dp[i]</code> with current <code>nums[i]</code></p>
<h4 id="Divide-and-Conquer">Divide and Conquer</h4>
<p>Follow up solution. Just divide array into left and right part, and caculate another left and right parts of each part. Then reutrn the sum. If <code>leftsum</code> is bigger than both <code>rightsum</code> and <code>crosssum</code>, just return it. Same as rightsum and crosssum.</p>
<h3 id="Code">Code</h3>
<h4 id="Greedy-v2">Greedy</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=num;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(sum,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
<h4 id="DP-v2">DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            dp[i] = nums[i] + (dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i-<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<h4 id="Divide-and-Conquer-v2">Divide and Conquer</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxsum = subArray(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subArray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">return</span> A[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftsum = subArray(A, left, mid); <span class="comment">//left part of the subarray sum, condition 1</span></span><br><span class="line">        <span class="keyword">int</span> rightsum = subArray(A, mid+<span class="number">1</span>, right); <span class="comment">//right part of the subarray sum, condition 2</span></span><br><span class="line">        <span class="keyword">int</span> middlesum = midSubArray(A, left, mid, right); <span class="comment">//cross part of the subarray sum, condition 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftsum &gt;= rightsum &amp;&amp; leftsum &gt;= middlesum)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightsum &gt;= leftsum &amp;&amp; rightsum &gt;= middlesum)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> middlesum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">midSubArray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> rightsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; leftsum)&#123;</span><br><span class="line">                leftsum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mid + <span class="number">1</span>; j &lt;= right; j++)&#123;</span><br><span class="line">            sum += A[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightsum)&#123;</span><br><span class="line">                rightsum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftsum + rightsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(nlogn) S:O(1)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 79. Word Search</title>
    <url>/2020/07/21/79.%20Word%20Search/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">341. Flatten Nested List Iterator</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/word-search/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/submissions/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Clearly we can using <code>DFS</code> and <code>Backtracking</code> to find the matched path in four different directions. Temperaily changing <code>borad[i][j</code>] to <code>'#'</code> before next DFS.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,word,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == word.length())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || board[i][j] != word.charAt(start))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,word,i+<span class="number">1</span>,j,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i-<span class="number">1</span>,j,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i,j+<span class="number">1</span>,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i,j-<span class="number">1</span>,start+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word.charAt(start);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 683. K Empty Slots</title>
    <url>/2020/07/29/683.%20K%20Empty%20Slots/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-683-K-Empty-Slots"><table><tr><td bgcolor="#E74C3C"><font color="white">683. K Empty Slots</font></td></tr></table></h2>
<p></p>
<p><a href="https://leetcode.com/problems/k-empty-slots/" target="_blank" rel="noopener"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days.</p>
<p>You are given an array bulbs of length N where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed.</p>
<p>Given an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactly K bulbs between them that are all turned off.</p>
<p>If there isn’t such day, return -1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">bulbs: [1,3,2]</span><br><span class="line">K: 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]</span><br><span class="line">On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]</span><br><span class="line">On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]</span><br><span class="line">We return 2 because on the second day, there were two on bulbs with one off bulb between them.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="TreeSet">TreeSet</h4>
<p>Using TreeSet to get the higher and lower pos of bulb in the previous. The only requirement is <code> currentDay - lower - 1 == K || higher - currentDay - 1 == K</code>.</p>
<p><code>set.lower(pos)</code> is going to find the first lower element from <code>pos</code> in the set.</p>
<p><code>set.higher(pos)</code> is going to find the first higher element from <code>pos</code> in the set.</p>
<h4 id="Straight-Forward">Straight Forward</h4>
<p>Checking by date. Create a new array of <code>days</code> to store the open time of each position bulb.</p>
<p>The only thing we need to do is keeping a window of size K and check left,right and current bulb’s open day. If <code>days[left] &lt; currentDay &amp;&amp; days[right] &lt; currentDay</code>, it means both left and right bulb will open before the currentDay. Like <code> ..open - close - open.. , assuming K is 1</code>, meeting the requirement of the question.</p>
<h3 id="Code">Code</h3>
<h4 id="TreeSet-v2">TreeSet</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] bulbs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bulbs.length;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">1</span>; day&lt;=n; day++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = bulbs[day-<span class="number">1</span>];</span><br><span class="line">            set.add(pos);</span><br><span class="line">            Integer lower = set.lower(pos);</span><br><span class="line">            Integer higher = set.higher(pos);</span><br><span class="line">            <span class="keyword">if</span>(lower != <span class="keyword">null</span> &amp;&amp; pos - lower -<span class="number">1</span> == k)<span class="keyword">return</span> day;</span><br><span class="line">            <span class="keyword">if</span>(higher != <span class="keyword">null</span> &amp;&amp; higher - pos - <span class="number">1</span> == k)<span class="keyword">return</span> day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T: O(NlogN) S:O(N)</p>
<h4 id="Straight-Forward-v2">Straight Forward</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] bulbs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bulbs == <span class="keyword">null</span> || bulbs.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = bulbs.length;</span><br><span class="line">        <span class="keyword">int</span>[] days = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            days[bulbs[i]-<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; right &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(days[i] &gt; days[left] &amp;&amp; days[i] &gt; days[right])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i == right)&#123;</span><br><span class="line">                res = Math.min(res, Math.max(days[left], days[right]));</span><br><span class="line">            &#125;</span><br><span class="line">            left = i;</span><br><span class="line">            right = left + k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 802. Find Eventual Safe States</title>
    <url>/2020/07/20/802.%20Find%20Eventual%20Safe%20States/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">802. Find Eventual Safe States</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/find-eventual-safe-states/"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</p>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
<p>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="leetcode 802">
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="1-Topological-DFS">1. Topological + DFS</h4>
<p>We can use Topological sort and DFS to get the circle. Using seen[] to keep record of each node’s state in the looping.</p>
<p>Three different states:</p>
<ul>
<li>0 means <code>unvisited</code> unsafe</li>
<li>1 means <code>visiting</code>  unsafe</li>
<li>2 means <code>visited</code>   safe<br>
We only need to add the node that has state == 2, which is the safe state.</li>
</ul>
<h4 id="2-Topologial-BFS-degree-solution">2. Topologial + BFS degree solution</h4>
<p>Originally we using BFS to find a circle in an indegree array. In this question we have to loop from the end point, so we need to reverse the whole graph to a indegree array. Then we just add the node with degree of 0 into the res array.</p>
<h3 id="Code">Code</h3>
<ul>
<li>Topological + DFS</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,i,state))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> node, <span class="keyword">int</span>[] state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[node] !=<span class="number">0</span> )<span class="keyword">return</span> state[node] == <span class="number">2</span>;</span><br><span class="line">        state[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,num,state))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[node] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V+E) S:O(V)</p>
<ul>
<li>Topological + BFS + Reverse Graph</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        List&lt;Integer&gt;[] map = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            map[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[i])&#123;</span><br><span class="line">                map[num].add(i);</span><br><span class="line">                indegree[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            res.add(node);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : map[node])&#123;</span><br><span class="line">                indegree[num]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[num] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V+E) S:O(V)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 785. Is Graph Bipartite</title>
    <url>/2020/07/27/785.%20Is%20Graph%20Bipartite/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-785-Is-Graph-Bipartite-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">785. Is Graph Bipartite </font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/is-graph-bipartite/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given an undirected graph, return true if and only if it is bipartite.</p>
<p>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<p>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Soluiton">Soluiton</h3>
<p>We can use both DFS and BFS to check whether a node is both current and neighboor. The main idea is using two different state to mark the current node and its all neighboors. If any neighboor has been already marked, just check that neighboor’s state equals to the <code>target color</code> or not, which is also the next color that we want to color the neighboor. It’s kinda like loop each level, but mark each level with different color like <code>black -1</code> or <code>white 1</code>, which is repeatedly.</p>
<h3 id="Code">Code</h3>
<h4 id="DFS">DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == <span class="number">0</span> &amp;&amp; !DFS(graph,color,<span class="number">1</span>,i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] color, <span class="keyword">int</span> target_color, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> color[i] == target_color;</span><br><span class="line">        &#125;</span><br><span class="line">        color[i] = target_color;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!DFS(graph,color,-target_color,num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS">BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] color = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] != <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            queue.add(i);</span><br><span class="line">            color[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[temp])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(color[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                        color[next] = -color[temp];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[next] != -color[temp])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 946. Validate Stack Sequences</title>
    <url>/2020/07/22/946.%20Validate%20Stack%20Sequences/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">946. Validate Stack Sequences</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/validate-stack-sequences/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p>
<h3 id="Example">Example</h3>
<p>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>We can solve this by simulating a real stack. We first Loop through the pushed array, keep pushing pushed elements into stack if the top element on the stack is different from the current one of popped;</p>
<p>Keep poping out of the top element from stack if it is same as the current one of popped;<br>
Check if the stack is empty after loop.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; idx &lt; popped.length &amp;&amp; stack.peek() == popped[idx])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx == popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Questions 1 💪</title>
    <url>/2020/05/12/Font-end%20Interview/</url>
    <content><![CDATA[<h2 id="HTML-篇">HTML 篇</h2>
<h3 id="HTML5语义化">HTML5语义化</h3>
<p>就是用合理、正确的标签来展示内容，如h1h2h3 p 这些。<br>
pros：1.易于阅读，当样式表现丢失时，结构方便读者阅读。<br>
2.利于开发维护，类别清晰。</p>
<a id="more"></a>
<h3 id="结构">结构</h3>
<img src="https://res.cloudinary.com/duc8au3q3/image/upload/v1557709663/1_tchbca.png">
1.header
定义文档或者文档的部分区域的页眉，应作为介绍内容或者导航链接栏的容器。
2.nav
包含多个超链接的区域，包含可以跳转到其他页面或者该页面其他部分的链接列表。
3.main
定义文档的主要部分，只能有一个，
<h3 id="为什么最好把-CSS-的link标签放在head之间？为什么最好把JS的script标签恰好放在body之前，有例外情况吗？">为什么最好把 CSS 的link标签放在head之间？为什么最好把JS的script标签恰好放在body之前，有例外情况吗？</h3>
<p>1.把link放在head中<br>
首先，这是规范文档的要求。其次，是为了让页面逐步呈现，提高用户体验。若放在底部，部分浏览器不能逐步呈现甚至加载失败。<br>
这样做可以防止呈现空白页或者无样式页面。<br>
2.把script放在/body之前<br>
脚本在下载时和执行期前，会阻止HTML解析，放在底部是为了保证html能够顺利加载，将页面尽快呈现。<br>
例外的情况是脚本里包含document.write()时。或者是script使用defer属性，放在head中。</p>
<h3 id="什么是渐进式渲染（progressive-rendering）？">什么是渐进式渲染（progressive rendering）？</h3>
<p>是用于提高网页性能，以尽快呈现网页的技术，现多用于移动端(移动端网速不稳定)<br>
1.图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。<br>
2.分层次渲染。页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。<br>
3.异步加载 HTML 片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。</p>
<h3 id="viewport">viewport</h3>
<p>视图窗口，在移动web开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动web站点跨设备显示效果基本一致.</p>
<h3 id="Reflow和Repaint">Reflow和Repaint</h3>
<p>Reflow<br>
当涉及到DOM节点的布局属性发生改变时，会重新计算该属性，并重新描绘相应的元素，称为回流。<br>
Repaint<br>
当影响DOM元素可见性的属性发生变化时，浏览器会重新描述该元素，称为重绘。<br>
但Repaint和Reflow是不可避免的，只能说对性能的影响减到最小。</p>
<h3 id="img中的alt和元素的title属性作用">img中的alt和元素的title属性作用</h3>
<p>alt<br>
如果无法显示图像，浏览器会显示alt指定的元素。<br>
img<br>
鼠标悬浮时显示title内容。</p>
<h3 id="href和src区别">href和src区别</h3>
<p>href超文本引用，用于a和link元素上<br>
src是引用资源，替换当前元素。浏览器解析到src时会暂停其他任务，也是为什么js应该放在底部的原因。</p>
<h3 id="浏览器渲染过程">浏览器渲染过程</h3>
<p>1.解析html生成DOM树<br>
2.解析css生成cssom树<br>
3.将dom和cssom合并成渲染树<br>
4.遍历渲染树开始布局，计算每个位置的大小<br>
5.将渲染树每个节点绘制到屏幕上</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Lazy Day 1</title>
    <url>/2019/05/09/Lazy-Day-1/</url>
    <content><![CDATA[<h2 id="lazy-day-1">lazy day 1</h2>
<p>恩，开个贴记录一下鸽的每一天，警醒一下。</p>
<p>不过今天也算例外，一直在忙找实习的事情，耽误了一天，希望最后能有适合的实习吧。</p>
<p>就这样。</p>
<p>Ps: 再吃中心食堂的冷面我就是弟弟，弟中弟那种。</p>
]]></content>
      <categories>
        <category>lazyday</category>
      </categories>
      <tags>
        <tag>鸽</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 104 / DP(1) 💪</title>
    <url>/2020/07/03/DP01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-256-Paint-House-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">256. Paint House</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/paint-house/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line">All costs are positive integers.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. </span><br><span class="line">             Minimum cost: 2 + 5 + 3 = 10.</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;costs.length; i++)&#123;</span><br><span class="line">            costs[i][<span class="number">0</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            costs[i][<span class="number">1</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">0</span>],costs[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            costs[i][<span class="number">2</span>] += Math.min(costs[i-<span class="number">1</span>][<span class="number">1</span>],costs[i-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = costs.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(costs[n][<span class="number">0</span>],costs[n][<span class="number">1</span>]),costs[n][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because there is only 3 colors, so we can easily updating different colors. The 1st row is the prices for the 1st house, we can change the matrix to present sum of prices from the 2nd row. i.e, the costs[1][0] represent minimum price to paint the second house red plus the 1st house. Choosing min value between the different color of the above line.</p>
<p>T:O(N) S:O(1)</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-265-Paint-House-II-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">265. Paint House II</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/paint-house-ii/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line">All costs are positive integers.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [[1,5,3],[2,9,4]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; </span><br><span class="line">             Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<p>Different from the previous painting problem, this question need k different colors.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span> || costs[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = costs.length;</span><br><span class="line">        <span class="keyword">int</span> n = costs[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (k == j) <span class="keyword">continue</span>;</span><br><span class="line">                    min = Math.min(min, dp[i - <span class="number">1</span>][k]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = (min == Integer.MAX_VALUE ? <span class="number">0</span> : min) + costs[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = Math.min(res, dp[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP</p>
<p>dp[i][k] means paint ith house using k color.</p>
<p>To compute dp[i][j], we need to find out the minimum cost of previous house using different color.</p>
<p>Iterate all possible color of previous house except the color of current house to find min cost.</p>
<p>T:O(N * k^2) S:O(N*k)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1277-Count-Square-Submatrices-with-All-Ones-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1277. Count Square Submatrices with All Ones</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: matrix =</span><br><span class="line">[</span><br><span class="line">  [0,1,1,1],</span><br><span class="line">  [1,1,1,1],</span><br><span class="line">  [0,1,1,1]</span><br><span class="line">]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: </span><br><span class="line">There are 10 squares of side 1.</span><br><span class="line">There are 4 squares of side 2.</span><br><span class="line">There is  1 square of side 3.</span><br><span class="line">Total number of squares = 10 + 4 + 1 = 15.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        matrix[i][j] = Math.min(Math.min(matrix[i][j-<span class="number">1</span>],matrix[i-<span class="number">1</span>][j]),matrix[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res+=matrix[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Key point is that we take the right-bottom most point to find the side of square. In DP process, we choose the min side from the previous position ( left, up and left-up). Then we change the current dp[i][j] to be that value. And add it to the res.</p>
<p>T:O(MN) S:O(N)</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1220-Count-Vowels-Permutation-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1220. Count Vowels Permutation</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/count-vowels-permutation/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v4">Example</h3>
<p>Given an integer n, your task is to count how many strings of length n can be formed under the following rules:</p>
<p>Each character is a lower case vowel (‘a’, ‘e’, ‘i’, ‘o’, ‘u’)</p>
<p>Each vowel ‘a’ may only be followed by an ‘e’.</p>
<p>Each vowel ‘e’ may only be followed by an ‘a’ or an ‘i’.</p>
<p>Each vowel ‘i’ may not be followed by another ‘i’.</p>
<p>Each vowel ‘o’ may only be followed by an ‘i’ or a ‘u’.</p>
<p>Each vowel ‘u’ may only be followed by an ‘a’.</p>
<p>Since the answer may be too large, return it modulo 10^9 + 7.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> MOD = (<span class="keyword">int</span>) (<span class="number">1e9</span> + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            0: a</span></span><br><span class="line"><span class="comment">            1: e</span></span><br><span class="line"><span class="comment">            2: i</span></span><br><span class="line"><span class="comment">            3: o</span></span><br><span class="line"><span class="comment">            4: u</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">4</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">2</span>]) % MOD;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">1</span>] = (dp[i][<span class="number">0</span>] + dp[i][<span class="number">2</span>]) % MOD;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">2</span>] = (dp[i][<span class="number">3</span>] + dp[i][<span class="number">1</span>]) % MOD;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">3</span>] = (dp[i][<span class="number">2</span>]) % MOD;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">4</span>] = (dp[i][<span class="number">2</span>] + dp[i][<span class="number">3</span>]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            ans = (ans + dp[n][i]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using long instead of int in dp[] array. We also need to mod intermediate result. Transition function is easily to get. Which is updating the current sum by adding all possible words after the current character.</p>
<p>T:O(N) S:O(N)</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>HOG Learning Notes (1)</title>
    <url>/2019/03/01/HURF/</url>
    <content><![CDATA[<h2 id="HOG-features">HOG features</h2>
<p>Currently, HOG (Histogram of Oriented Gradient) is one of the mainstream feature descriptors of pedestrian detection based on machine learning method. HOG feature is a feature descriptor used for target detection. It forms features by calculating and counting the histogram of gradient direction in the local area of the image, and describes the image with these features.<br>
This method is similar to the histogram of edge direction and scale-invariant feature transform, but hog’s computation is based on the density matrix of consistent space to improve the accuracy. Navneet Dalal and Bill Triggs first proposed HOG in 2005’s CVPR for pedestrian detection in static images or video.</p>
<a id="more"></a>
<p>The feature of Histogram of Oriented Gradient (HOG) is a descriptor used for object detection in computer vision and image processing. By calculating and statistics the gradient direction histogram of the local area to form the feature. Hog feature combining SVM classifier has been widely used in image recognition, especially in pedestrian detection, which has achieved great success. Nowadays, although many pedestrian detection algorithms are constantly proposed, they are mainly based on HOG + SVM.</p>
<h2 id="Principle-of-HOG-characteristics">Principle of HOG characteristics</h2>
<h3 id="Core-method">Core method</h3>
<p>HOG core method is the detection of local object shape can be the distribution of light intensity gradient or the edge direction described, through the image segmentation into small connection area (called cells), each cell to generate a gradient direction histogram or cell edge pixel in image, the histogram of combination can be expressed by detecting target of the target descriptor.<br>
In order to improve the accuracy, the local histogram can be compared and standardized by calculating the light intensity of a large area in the image (called block) as the measure, and then use this value (measure) to normalize all cells in the block. This normalization process achieves better light/shadow invariance.</p>
<h3 id="The-main-steps">The main steps</h3>
<ol>
<li>Grayscale an image, that is, treat the image as a three-dimensional image of x,y and z, where z is the grayscale value.</li>
<li>Divide into small connected areas called cells (2x2)</li>
<li>Calculate the gradient or edge orientation histogram of each pixel in each cells</li>
<li>Count the gradient histogram of each cell (the number of different gradients) to form the feature descriptor of each cell.</li>
</ol>
<h3 id="The-differences-and-applications-between-HOG-SIFT-PCA-SIFT">The differences and applications between HOG/SIFT/ PCA-SIFT</h3>
<ol>
<li>The HOG feature has no rotation and scale invariance, so the computation is small</li>
<li>Each feature in SIFT needs to be described by 128-dimensional vectors, so the computation is relatively large<br>
3  Since SIFT cannot be used for pedestrian detection due to its huge computation, the pca-sift method filters out a lot of dimensional information and only retains 20 principal components, so it is only applicable for object detection with little change in behavior.</li>
</ol>
<p><img src="/01/HURF/HURF.jpg" alt></p>
<h2 id="HOG-feature-extraction-is-realized-with-python-opencv">HOG feature extraction is realized with python+opencv</h2>
<ol>
<li>Read in the required detection target, i.e. the input image</li>
<li>Grayscale the image (convert the r,g and b values of the input color image into grayscale values through a specific formula)</li>
<li>Use Gamma correction method to normalize the color space of the input image (normalization)</li>
<li>Calculate the gradient (including size and direction) of each pixel of the image, and capture the contour information</li>
<li>Count the gradient histogram (number of different gradients) of each cell to form the descriptor of each cell</li>
<li>Every few cells are grouped into a block (take 3*3 as an example), and all cell features in a block are strung together to get the HOG feature descriptor of the block</li>
<li>HOG feature descriptor of all blocks in the image is concatenated to obtain the HOG feature descriptor of the image (detection target), which is the final classification feature vector</li>
</ol>
<p><em>(HOG parameter setting is: 22 cells/interval, 88 pixels/cell, 8 histogram channels, step size is 1)</em></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Algorithm</category>
        <category>Models</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>HOG</tag>
        <tag>Image Process</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 7</title>
    <url>/2019/05/08/Leetcocde-7/</url>
    <content><![CDATA[<p>昨天刚开始上Udemy的The Web Developer Bootcamp，全栈开发挺有挑战性。<br>
做这个博客的时候没学那么深，希望这门课结束后能完成一个拿得出手的实际应用网站。好了，继续刷题打卡！</p>
<h2 id="561-Array-Partition-I">561. Array Partition I</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">arraypart</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums.length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">			res+=nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>纯数学题，将2n数组分成n对，分别求n对里最小值的和。很简单，先sort排序，然后累加奇数位置的数就可以。</p>
<h2 id="700-Search-in-a-Binary-Search-Tree">700. Search in a Binary Search Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">		<span class="keyword">if</span>(root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">				<span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>简单的BST，注意null时的返回值也是root。</p>
<h2 id="590-N-ary-Tree-Postorder-Traversal">590. N-ary Tree Postorder Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list = <span class="function">newe <span class="title">LinkedList</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line"><span class="comment">//创建堆栈来存贮当前节点</span></span><br><span class="line">		Stack(Node) s = <span class="keyword">new</span> Stack()</span><br><span class="line">		s.push(root);</span><br><span class="line">		<span class="keyword">while</span>(!isEmpty(s))&#123;</span><br><span class="line">			Node temp = s.pop();</span><br><span class="line">			<span class="comment">//使用AddFirst将节点加到list前面，避免使用reverse</span></span><br><span class="line">			list.AddFirst(temp.val);</span><br><span class="line">			<span class="keyword">for</span>(Node n :temp.children)&#123;</span><br><span class="line">				s.push(n);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>类似倒序输出节点，与层次遍历顺序不同。<br>
层次遍历是将节点pop出来即可，此题需要逆序输出，所以很好的一个点就是将list设置为链表，然后将新元素一直加到头部就可以，最后输出list。</p>
<h2 id="589-N-ary-Tree-Preorder-Traversal">589. N-ary Tree Preorder Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _children)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        children = _children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; list = <span class="function">newe <span class="title">LinkedList</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">		Stck&lt;Node&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">		stack.add(root);</span><br><span class="line">		<span class="keyword">while</span> (!isEmpty)&#123;</span><br><span class="line">			root=stack.pop();</span><br><span class="line">			list.add(root.val);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =root.children.size()-;i&gt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">				stack.add(root.childre.get(i));</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>是上一题的简化版，遍历完该支全部节点后才转到下一支，不需要逆转list，注意root.children.get的方法。</p>
<h2 id="965-Univalued-Binary-Tree">965. Univalued Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">UnivalTree</span><span class="params">(Treenode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!isUnivalTree(root.left))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(root.left.val!=root.val)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!isUnivalTree(root.right))</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(root.right.val!=root.val)</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v5">思路</h3>
<p>自身递归的BST,注意递归和判断val的前后顺序。和leetcode 5 里面一道题很相似，需要自己加一个private函数</p>
<h2 id="1030-Matrix-Cells-in-Distance-Order">1030. Matrix Cells in Distance Order</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] allcellsindis(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)&#123;</span><br><span class="line">		<span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">		<span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[R*C][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">		Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">		queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r0,c0&#125;);</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span>[] cell = queue.poll();</span><br><span class="line">			<span class="keyword">int</span> r = cell[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> c = cell[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( r &lt; <span class="number">0</span> || r &gt;= R || c &lt; <span class="number">0</span> ||c &gt;= C)&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(visited[r][c])&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			res[i] = cell;</span><br><span class="line">			i++;</span><br><span class="line">			visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">			queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">			queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">			queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">			queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v6">思路</h3>
<p>某个矩阵，给定一个坐标，让输出其他位置和这个位置的距离差，给定r0c0，x位置与该位置的距离差就是nx-n0，cx-c0<br>
当随便画几个矩阵出来之后发现，输出的结果其实就是从该指定位置bfs搜索的结果（恩，就是这么巧这么神奇）<br>
所以就可以按照bfs的思路来设计code，用queue来实现，设置visited变量来记录是否访问过该节点。<br>
注意poll() 和 offer() ，与pop() 和push()类似，但是效果更好，出错时自动停止。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 6</title>
    <url>/2019/05/07/Leetcode-6/</url>
    <content><![CDATA[<h2 id="写在开头">写在开头</h2>
<p>以后尽量多用java做coding吧，昨晚才知道Amazon的onsite没有python这个选项…orz，所以开始啃java吧~</p>
<h2 id="797-All-Paths-From-Source-to-Target">797. All Paths From Source to Target</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPassSourceTarget(<span class="keyword">int</span>[][] graph)&#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		path.add(<span class="number">0</span>);</span><br><span class="line">		dfsSearch(graph,<span class="number">0</span>,res,path);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsSearch</span><span class="params">(<span class="keyword">int</span> [][] graph, <span class="keyword">int</span> node,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path )</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( node == graph.length -<span class="number">1</span>)&#123;</span><br><span class="line">			res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> nextNode:graph[node])&#123;</span><br><span class="line">			path.add(nextNode);</span><br><span class="line">			dfsSearch(graph,nextNode,res,path);</span><br><span class="line">			path.remove(path.size()-<span class="number">1</span>);<span class="comment">// 很重要的一步，backstrack回去</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>一道dfs思路的路径题，输入结构如下：graph [[1,2],[3],[3],[]] graph[i]中存放的是节点i能够到达的节点集合，比如graph[0]中存放的是1和2，意思就是0能够到达1和2，以此类推，1 和 2 均各自能到达3 。 所以创建一个private函数，用来递归dfs。注意的是在nextnode调用dfs之后，要backstrack回去，将path的size()-1,以保证其他路径dfs时不会受影响。</p>
<h2 id="942-DI-String-Match">942. DI String Match</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] distringmatch(String S)&#123;</span><br><span class="line">		<span class="keyword">int</span> n = S.length(),left=<span class="number">0</span>,right = n;</span><br><span class="line">		<span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]</span><br><span class="line">	    <span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">	    	res[i] = S.charAt(i) == <span class="string">'I'</span> ? left++:right--;</span><br><span class="line">	    &#125;</span><br><span class="line">	    res[n] = left;</span><br><span class="line">	    <span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>一道easy题，outside-in的方法，判断如果为I，将left赋值给res[i]， 否则赋值right，之后将left或者right进行++ 或–，最后退出循环的时候，最后一位肯定是当前的left的值。</p>
<h2 id="763-Partition-Labels">763. Partition Labels</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionlabels</span><span class="params">(String S)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (S is <span class="keyword">null</span>||S.length() == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">			map[S.charAt(I)-<span class="string">'a'</span>] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length;i++)&#123;</span><br><span class="line">			last = Math.max(last,map[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">			<span class="keyword">if</span> (last == i):&#123;</span><br><span class="line">				list.add(last-start+<span class="number">1</span>);</span><br><span class="line">				start = last + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>用map存住每一个字母出现的最后一个位置，不错的小技巧map[S.charAt(i)-‘a’] = i，可以不断更新某字母最后出现的位置。<br>
重新遍历一遍S，比较当前字母的最后位置，将最大存为last，当last== i 即该字母重合时，将该字段长度存入list，更新start。</p>
<h2 id="617-Merge-Two-Binary-Trees">617. Merge Two Binary Trees</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergetree</span><span class="params">(TreeNode t1, TreeNode t2)</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"> 			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		elif (t1 == <span class="keyword">null</span>)&#123;</span><br><span class="line"> 			<span class="keyword">return</span> t2;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		elif (t2 == <span class="keyword">null</span>)&#123;</span><br><span class="line"> 			<span class="keyword">return</span> t1;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		TreeNode n = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line"> 		n.left = mergetree(t1.left,t2.left);</span><br><span class="line"> 		n.right = mergetree(t1.right, t2.right);</span><br><span class="line"> 		<span class="keyword">return</span> n;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>简单的融合两个二叉树的题，判断各自是否为空后，自身简单递归即可，注意定义n时要先说明类别，与python不同，还需要多多练习~</p>
<h2 id="861-Score-After-Flipping-Matrix">861. Score After Flipping Matrix</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> M = A.length, N = A[<span class="number">0</span>].length, res = (<span class="number">1</span>&lt;&lt;(N-<span class="number">1</span>))*M;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;N;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; M;i++)&#123;</span><br><span class="line">				cur + = A[i][<span class="number">0</span>]==A[i][j] ? <span class="number">1</span> :<span class="number">0</span>;</span><br><span class="line">				res + = Math.max(cur,M-cur) * (<span class="number">1</span>&lt;&lt;(N-<span class="number">1</span>-j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v5">思路</h3>
<p>虽然行数不多，但是是比较烧脑的一道题。为了二进制达到最大值，肯定要把第一列的所有数全部设为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&lt;&lt;(N-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>将1的二进制左移N-1位，二进制表示为10000（n-1个0），符合本题的输入结构数组。<br>
设置完的第一列作为对比列，所以j从1开始。然后将每一列的每行元素和每行第一个元素比较，如果相同，cur+1，比较cur和M-cur，判断每列最多可以得到1的个数，进而设置1&lt;&lt;(N-1-j)的左移二进制，跟在第一列的后面。<br>
cur 记录和A[i][0]相同的元素个数，因为一开始将答案第一列设为1，所以不管原始第一列是1还是0，A[i][j]如果相同，由于非0即1，则代表该位置可以是1.不管原来就是还是更改为1，所以cur可以记录该列能够存放1的最大个数<br>
其实每一列1的位置并不重要，因为开头都是1，所以只有个数才能决定最终和的大小，此题要反复琢磨，emmm，挺绕的。</p>
<h2 id="921-Minimum-Add-to-Make-Parentheses-Valid">921. Minimum Add to Make Parentheses Valid</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minaddtomamkeparentheses</span><span class="params">(String S)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>,<span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> i : S.toCharArray())&#123;</span><br><span class="line">			<span class="keyword">if</span> (right == <span class="number">0</span> &amp;&amp; i ==<span class="string">')'</span>)&#123;</span><br><span class="line">				left++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> right += i ==<span class="string">'('</span> ? <span class="number">1</span>: -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> left + right</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v6">思路</h3>
<p>判断需要加多少个括号才能使string变成完整的括号群，())))就需要三个左括号才能变完整。</p>
<h2 id="728-Self-Dividing-Numbers">728. Self Dividing Numbers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfdividingnum</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;()</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i = left; i&lt;=right;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(valid(i))&#123;</span><br><span class="line">				res.add(i)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = num;</span><br><span class="line">		<span class="keyword">while</span>( cur!=<span class="number">0</span>)&#123;</span><br><span class="line">			digit = cur%<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (digit == <span class="number">0</span> || num % digit != <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v7">思路</h3>
<p>一道数学题，输出从left到right里，能够整除其所有digit的数，例如 128 能够整除1 2 8。<br>
在valid函数中，先%10 取个位数，判断能否整除，若可以，再接着将cur/10抛去个位数，再重复之前的步骤即可<br>
举例128： 首先128%10=8，能够整除，则128/10=12， 12%10 = 2，可以整除，再看12/10=1,1%10=1，可整除，再进行1/10=0，退出循环，输出true</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 5</title>
    <url>/2019/05/06/Leetcode-5/</url>
    <content><![CDATA[<h2 id="1038-Binary-Search-Tree-to-Greater-Sum-Tree">1038. Binary Search Tree to Greater Sum Tree</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	val = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">		    self.bstToGst(root.right)</span><br><span class="line">		root.val = self.val = root.val + self.val</span><br><span class="line">		<span class="keyword">if</span> root.left:</span><br><span class="line">			self.bstToGst(root.left)</span><br><span class="line">		<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>一道中等的倒序遍历sum的题，之后顺序输出即可。<br>
由于tree的右孩子永远大于左孩子，所以可以设置一个临时变量val来记录当前的和，从最右端的根节点开始向上循环，并更新root.val</p>
<a id="more"></a>
<h2 id="980-Unique-Paths-III">980. Unique Paths III</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsIII</span><span class="params">(self, A: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">    	self.res = <span class="number">0</span></span><br><span class="line">    	m,n,empty = len(A),len(A[<span class="number">0</span>]),<span class="number">1</span></span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    		<span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">    			<span class="keyword">if</span> A[i][j] == <span class="number">1</span>: x,y = (i,j)</span><br><span class="line">    		    <span class="keyword">elif</span> A[i][j] == <span class="number">2</span>: end =(i,j)</span><br><span class="line">    		    <span class="keyword">elif</span> A[i][j] == <span class="number">0</span>: empty +=<span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x,y,empty)</span>:</span></span><br><span class="line">        	<span class="keyword">if</span>  <span class="keyword">not</span> ( <span class="number">0</span>&lt;=x&lt;=m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;=n <span class="keyword">and</span> A[x][y] &gt;=<span class="number">0</span> ):<span class="keyword">return</span></span><br><span class="line">        	<span class="keyword">if</span> (x,y) == end:</span><br><span class="line">        		self.res += empty == <span class="number">0</span></span><br><span class="line">        		<span class="keyword">return</span></span><br><span class="line">        	A[i][j] = <span class="number">-2</span></span><br><span class="line">        	dfs(x+<span class="number">1</span>,y,empty<span class="number">-1</span>)</span><br><span class="line">        	dfs(x<span class="number">-1</span>,y,empty<span class="number">-1</span>)</span><br><span class="line">        	dfs(x,y+<span class="number">1</span>,empty<span class="number">-1</span>)</span><br><span class="line">        	dfs(x,y<span class="number">-1</span>,empty<span class="number">-1</span>)</span><br><span class="line">        	A[i][j] = <span class="number">0</span></span><br><span class="line">        dfs(x,y,empty)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>一道类似bfs和dp的题，采用Brute Force Backstracking 方法。<br>
首先找到start和end的坐标，计算出empty的数量，然后向四周扩散，<br>
在每一次bfs过程开始，先将该位置设置为-2，避免再次访问；当该次bfs结束后，一定要记得backstracking回去，将该位置重新设置为0，避免其他bfs遇到该点出错。时间复杂度和dp一样，但是空间复杂度要少许多。</p>
<h2 id="1028-Recover-a-Tree-From-Preorder-Traversal">1028. Recover a Tree From Preorder Traversal</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverFromPreorder</span><span class="params">(self, S: str)</span> -&gt; TreeNode:</span></span><br><span class="line">    	stack,i = [],<span class="number">0</span></span><br><span class="line">    	<span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">    		level, val = <span class="number">0</span>,<span class="string">''</span></span><br><span class="line">    		<span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> S[i] ==<span class="string">'-'</span>:</span><br><span class="line">    			level,i = level + <span class="number">1</span>,i+<span class="number">1</span></span><br><span class="line">    		<span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> S[i] !=<span class="string">'-'</span>:</span><br><span class="line">    			val,i = val + S[i], i+<span class="number">1</span></span><br><span class="line">    		<span class="keyword">while</span> len(stack) &gt; len(level):</span><br><span class="line">    			stack.pop()</span><br><span class="line">    		node = TreeNode(val)</span><br><span class="line">    		<span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    			stack[<span class="number">-1</span>].left = node</span><br><span class="line">    		<span class="keyword">elif</span> stack:</span><br><span class="line">    			stack[<span class="number">-1</span>].right = node</span><br><span class="line">    		stack.append(node)</span><br><span class="line">    	<span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>由于题干输入是先序结构，用stack前序存储当前的根节点，之后层次输出，用level记录当前节点深度，stack元素个数超出level时，pop第一个元素，每次循环开始将level初始为0，当i&gt;输入数字的长度时，退出第一个while循环，由于此时stack只剩下一个元素，最后再返回stack[0]即可。</p>
<h2 id="961-N-Repeated-Element-in-Size-2N-Array">961. N-Repeated Element in Size 2N Array</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">2</span> ;i &lt; A.length;i++)</span><br><span class="line">    		<span class="keyword">if</span> (A[i] == A [i-<span class="number">1</span>] || A[i] == A[i-<span class="number">2</span>])</span><br><span class="line">    			<span class="keyword">return</span> A[i];</span><br><span class="line">    		<span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>恩，最近也在学java，于是干脆就用java写一道题吧。<br>
算是一道数学题吧，给定2N大小的数组，找出重复N次的数字，最分散的情况无非就是abacadaeaf，a重复了5次，所以只需要判断该元素和他前面两个元素是否相等即可，如满足任意一个条件，则该数就是所求数。</p>
<h2 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal">1008. Construct Binary Search Tree from Preorder Traversal</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstFromPreorder</span><span class="params">(self, A: List[int],bound = float<span class="params">(<span class="string">'inf'</span>)</span>)</span> -&gt; TreeNode:</span></span><br><span class="line">    	<span class="keyword">if</span> self.i == <span class="number">0</span> <span class="keyword">or</span> A[self.i]&gt; bound:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    	root = TreeNode(A[self.i])</span><br><span class="line">    	self.i + =<span class="number">1</span></span><br><span class="line">    	root.left = self.bstFromPreorder(A,root.val)</span><br><span class="line">    	root.right = self.bstFromPreorder(A,bound)</span><br><span class="line">    	<span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="思路-v5">思路</h3>
<p>又是一道遍历树的问题，设置一个bound无限大边界，递归右子树时方便用，递归前将self.i 加一即可。</p>
<h2 id="Sort-Array-By-Parity">Sort Array By Parity</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Even first</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[j] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Both odd</span></span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Odd, Even</span></span><br><span class="line">                    swap(A, i, j);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v6">思路</h3>
<p>一道简单的奇偶排序问题，将偶数全部提至前面输出，单独定义了swap函数，比较基本，java版本</p>
<h2 id="814-Binary-Tree-Pruning">814. Binary Tree Pruning</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pruneTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left = self.pruneTree(root.left)</span><br><span class="line">        root.right = self.pruneTree(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="keyword">not</span> root.val: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="思路-v7">思路</h3>
<p>简单的一道二叉树的题，休息休息脑子233333。节点只有0和1，将节点为0的而且没有左右子树的节点变为null，依次递归调用。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 3</title>
    <url>/2019/03/30/Leetcode3/</url>
    <content><![CDATA[<h2 id="Problem-1-Sort-List">Problem 1 Sort List</h2>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>Example 1:<br>
Input: 4-&gt;2-&gt;1-&gt;3<br>
Output: 1-&gt;2-&gt;3-&gt;4</p>
<p>Example 2:<br>
Input: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<a id="more"></a>
<p>Hint: Due to the topic of time complexity and space complexity is higher, so looked at various solutions, the best solution is to merge sort, because the list in the merge operation does not need to be like an array of merge operation assigned a temporary array space, space complexity, so it is constant, of course, there is no consideration of recursive system call stack.<br>
This involves a linked list commonly used operation, that is, fast and slow pointer skills.Set slow and fast Pointers, both of which start at the top of the table, fast takes two steps at a time, slow takes one step at a time, fast goes to the end of the list, slow goes right to the middle, and that cuts the list in two.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sortlist</span><span class="params">(self,head:ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">			<span class="keyword">return</span> head</span><br><span class="line">		pre,slow,fast = <span class="literal">None</span>,head,head</span><br><span class="line">		<span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">			pre,slow,fast = slow,slow.next,fast.next.next</span><br><span class="line">		pre.next = <span class="literal">None</span></span><br><span class="line">		<span class="keyword">return</span> self.merge(self.sortlist(head),self.sortlist(slow))<span class="comment"># </span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self,h1,h2)</span>:</span></span><br><span class="line">		dummy = tail = ListNode(<span class="literal">None</span>)</span><br><span class="line">		<span class="keyword">while</span> h1 <span class="keyword">and</span> h2:</span><br><span class="line">			<span class="keyword">if</span> h1.val &lt; h2.val:</span><br><span class="line">				tail.next,h1 = h1,h1.next</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				tail.next,h2 = h2,h2.next</span><br><span class="line">			tail = tail.next</span><br><span class="line">		tail.next = h1 <span class="keyword">or</span> h2</span><br><span class="line">	<span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h2 id="Problem-2-Course-Schedule-II">Problem 2 Course Schedule II</h2>
<p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:</p>
<p>Input: 2, [[1,0]]<br>
Output: [0,1]<br>
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished<br>
course 0. So the correct course order is [0,1] .<br>
Example 2:</p>
<p>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>
Output: [0,1,2,3] or [0,2,1,3]<br>
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>
courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]</p>
<p>Hint: Topological sorting application.The topological order is like the backward order of every small project completed in a project, and our task is to find out the sequence of successful completion.<br>
The method is to delete a node whose entry degree is 0 at a time, and subtract the entry degree of the node it points to by one.And each time the degree of entry is 0 node saved, and finally return it.That’s pretty much the same thing.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    	dic = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">    	neigh = collections.defaultdict(set)</span><br><span class="line">    	<span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">    		dic[i]+=<span class="number">1</span></span><br><span class="line">    		neigh[j].add(i)</span><br><span class="line">    	stack = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses) <span class="keyword">if</span> dic[i]==<span class="number">0</span>]</span><br><span class="line">    	res = []</span><br><span class="line">    	<span class="keyword">while</span> stack:</span><br><span class="line">    		node = stack.pop()</span><br><span class="line">    		res.append(node)</span><br><span class="line">    		<span class="keyword">for</span> i <span class="keyword">in</span> neigh[node]:</span><br><span class="line">    			dic[i]-=<span class="number">1</span></span><br><span class="line">    			<span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">    				stack.append(i)</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">    		<span class="keyword">if</span> dic[i] &gt; <span class="number">0</span>:</span><br><span class="line">    			<span class="keyword">return</span> []</span><br><span class="line">    	<span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 1</title>
    <url>/2019/03/06/Leetcode1/</url>
    <content><![CDATA[<h2 id="Problem-1-Two-Sum">Problem 1 : Two Sum</h2>
<h3 id="Description">Description</h3>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>
You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>
Given nums = [2, 7, 11, 15], target = 9,<br>
Because nums[0] + nums[1] = 2 + 7 = 9,<br>
return [0, 1].</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">		r = &#123;&#125; <span class="comment">#create dict</span></span><br><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">			n = target - nums(x) <span class="comment">#find the other number</span></span><br><span class="line">			<span class="keyword">if</span> n <span class="keyword">in</span> r: <span class="comment">#</span></span><br><span class="line">				<span class="keyword">return</span> [r[n],x] <span class="comment">#return the addresses of matched numbers</span></span><br><span class="line">			r[nums[x]] = x <span class="comment">#input the address of number to r&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Problem-2-Add-two-numbers">Problem 2 : Add two numbers</h2>
<h3 id="Description-v2">Description</h3>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.<br>
You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:<br>
Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
Output: 7 -&gt; 0 -&gt; 8<br>
Explanation: 342 + 465 = 807.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">    	carry = <span class="number">0</span></span><br><span class="line">    	root = n = ListNode(<span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">    		v1 = v2 = <span class="number">0</span></span><br><span class="line">    		<span class="keyword">if</span> l1:</span><br><span class="line">    			v1 = l1.val</span><br><span class="line">    			l1 = l1.next</span><br><span class="line">    		<span class="keyword">if</span> l2:</span><br><span class="line">    			v2 = l2.val</span><br><span class="line">    			l2 = l2.next</span><br><span class="line">    			carry, val = divmod(v1+v2+carry,<span class="number">10</span>)</span><br><span class="line">    			n.next = ListNode(val)</span><br><span class="line">    			n = n.next</span><br><span class="line">    	<span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>
<h2 id="Problems-3-Longest-Substring-Without-Repeating-Characters">Problems 3 : Longest Substring Without Repeating Characters</h2>
<h3 id="Description-v3">Description</h3>
<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br>
Input: “abcabcbb”<br>
Output: 3<br>
Explanation: The answer is “abc”, with the length of 3.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    	usedchar = &#123;&#125;</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">    		<span class="keyword">if</span> s[i] <span class="keyword">in</span> usedchar <span class="keyword">and</span> start&lt;= usedchar(s[i]):</span><br><span class="line">    			start = usedchar(s[i])+<span class="number">1</span></span><br><span class="line">    		<span class="keyword">else</span>:</span><br><span class="line">    			maxlength = max(maxlength, i-start+<span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span> maxlength</span><br></pre></td></tr></table></figure>
<h2 id="Problems-4-Longest-Palindromic-Substring">Problems 4 : Longest Palindromic Substring</h2>
<h3 id="Description-v4">Description</h3>
<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>
Input: “babad”<br>
Output: “bab”<br>
Note: “aba” is also a valid answer.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">helper</span><span class="params">(object)</span>:</span></span><br><span class="line">		<span class="keyword">while</span> i &gt;=<span class="number">0</span> <span class="keyword">and</span> r&lt;len(s) <span class="keyword">and</span> s[l]==s[r]:</span><br><span class="line">			l-=<span class="number">1</span>;r+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">    	res = <span class="string">""</span></span><br><span class="line">    	tem = self.helper(s,i,i)</span><br><span class="line">    	<span class="keyword">if</span> len(tem)&gt;len(res):</span><br><span class="line">    		res = tem</span><br><span class="line">    	tem = self.helper(s,i,i+<span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">if</span> len(tem) &gt; len(res):</span><br><span class="line">    		res = tem</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 8</title>
    <url>/2019/05/10/Leetcode-8/</url>
    <content><![CDATA[<h2 id="979-Distribute-Coins-in-Binary-Tree">979. Distribute Coins in Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distribute</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		dfs(root);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> left = dfs(root.left), right = dfs(root.right);</span><br><span class="line">		res+=Math.abs(left) + Math.abs(right);</span><br><span class="line">		<span class="keyword">return</span> root.val + left + right - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>有点绕的一道dfs题。要求将每个位置都变为1，求变动次数，其实反过来想，如果一个最后节点原来为x,要变为1，那么变动的数值就是x-1的绝对值，也就是想父节点传送的值或者向父节点索要的值，即变动次数，所以只需要递归的将每个节点的x-1累加起来即可。多看。</p>
<a id="more"></a>
<p>##968. Binary Tree Cameras</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">camera</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> state = dfs(root);</span><br><span class="line">		<span class="keyword">return</span> (dfs(root) &lt; <span class="number">1</span>? <span class="number">1</span>:<span class="number">0</span>) + res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> needcamera = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> covered = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 状态为0的叶节点</span></span><br><span class="line">		<span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> state = dfs(root.left);</span><br><span class="line">			<span class="keyword">if</span> (state==<span class="number">0</span>)&#123;<span class="comment">//孩子为叶节点，则该位置设为camera，并被cover</span></span><br><span class="line">				needcamera = <span class="number">1</span>;</span><br><span class="line">				covered = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(state ==<span class="number">1</span>)&#123;<span class="comment">//孩子为camera，被cover</span></span><br><span class="line">				covered =<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;<span class="comment">//与左子树相同</span></span><br><span class="line">			<span class="keyword">int</span> state = dfs(root.right);</span><br><span class="line">			<span class="keyword">if</span> (state==<span class="number">0</span>)&#123;</span><br><span class="line">				needcamera = <span class="number">1</span>;</span><br><span class="line">				covered = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(state ==<span class="number">1</span>)&#123;</span><br><span class="line">				covered =<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (needcamera&gt;<span class="number">0</span>)&#123;<span class="comment">//这里往下开始返回state的值，设为camera的点</span></span><br><span class="line">			res++;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(covered&gt;<span class="number">0</span>)&#123;<span class="comment">//不是camera点并且被cover过，则是camera的父节点，所以返回状态2</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//则变为0状态，筛掉被访问过的节点后的起始节点，可以看成新的叶节点。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>第一次自己做出来的hard题，不太好做。</p>
<p>从上至下比较麻烦，所以干脆从下至上递归。首先分三种状态：</p>
<ol>
<li>没有左右孩子的叶节点，状态为0；</li>
<li>左右孩子为叶节点的子节点，也就是要设为camera的节点，状态为1；</li>
<li>设为camera节点的父节点，即被covered的非camera节点；</li>
</ol>
<p>注意state是该节点的孩子节点，并非本节点的状态，所以当state为0，即孩子节点为叶节点是，本节点就应为1，设为camera；当state=1时，表明其孩子节点为camera，则该节点状态为2，camera的父节点。 最后剩下的则是未被cover的节点，可以重新寻找适合的camera节点。</p>
<p>递归的时候先判断root孩子节点的状态，然后改变当前root的camera和cover，最后返回该root的状态值（0,1,2），以供下次递归使用。</p>
<p>递归一般根据孩子节点状态判断当前节点的问题值，最后再返回当前节点的状态。<br>
多练类似的题。</p>
<h2 id="419-Battleships-in-a-Board">419. Battleships in a Board</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countbattleship</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = board.length;</span><br><span class="line">		<span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;m;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; board[i][j-<span class="number">1</span>] == <span class="string">'x'</span>) <span class="keyword">continue</span>;<span class="comment">//纵列间有没有adjacent</span></span><br><span class="line">				<span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; board[i-<span class="number">1</span>][j] == <span class="string">'X'</span>) <span class="keyword">continue</span>;<span class="comment">//行间有没有adjacent</span></span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-v3">思路</h2>
<p>注意列.行的判断方法。</p>
<h2 id="559-Maximum-Depth-of-N-ary-Tree">559. Maximum Depth of N-ary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">maxDepth</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxDepth=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">			maxDepth = Math.max(maxDepth,maxDepth(child))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxDepth+<span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>没什么好说的，简单的递归，上面是用的node链表，queue队列也可以解决，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		queue.offer(root);</span><br><span class="line">		<span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">int</span> size = queue.size();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;size;i++)&#123;</span><br><span class="line">				Node curr = queue.poll();</span><br><span class="line">				<span class="keyword">for</span>(Node child:root.children)&#123;</span><br><span class="line">					queue.offer(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			depth++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> depth;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 2</title>
    <url>/2019/03/14/Leetcode2/</url>
    <content><![CDATA[<h2 id="Problem1-Group-Anagrams">Problem1: Group Anagrams</h2>
<p>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>
Output:<br>
[<br>
[“ate”,“eat”,“tea”],<br>
[“nat”,“tan”],<br>
[“bat”]<br>
]</p>
<h3 id="代码如下">代码如下</h3>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        d = &#123;&#125; </span><br><span class="line">        <span class="comment">#建立空的字典</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> strs: </span><br><span class="line">        <span class="comment">#遍历str中所有的字符串</span></span><br><span class="line">            key = tuple(sorted(w)) </span><br><span class="line">            <span class="comment">#将字符串去重，利用sort()函数</span></span><br><span class="line">            d[key] = d.get(key,[]) + [str(w)] </span><br><span class="line">            <span class="comment"># 将d中的key指向包含该key的值 并且在for中循环直至全部遍历完成</span></span><br><span class="line">        <span class="keyword">return</span> list(d.values())</span><br><span class="line">         <span class="comment">#将字典d中的values以list的形式返回</span></span><br></pre></td></tr></table></figure>
<h2 id="Problem2-Climbing-Stairs">Problem2 :Climbing Stairs</h2>
<p>You are climbing a stair case. It takes n steps to reach to the top.<br>
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Example 1:</p>
<p>Input: 2<br>
Output: 2<br>
Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps</li>
</ol>
<h3 id="代码如下：">代码如下：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">climbStairs1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="comment">#设置走一步的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>: <span class="comment"># 设置走两步的情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>)+self.climbStairs(n<span class="number">-2</span>)</span><br><span class="line">    <span class="comment"># 函数内引用自身函数，进行迭代，完整遍历一遍</span></span><br></pre></td></tr></table></figure>
<p>在leetcode云服务器上运行后，出现了TLE错误，原因是时间复杂度为 O(2^n)，不合题意<br>
后来在 leet大神 @sfdye 帮助下，学到了一个新trick，利用装饰器@lru_cache()进行补救<br>
装饰器将使用相同的方法调用参数自动缓存结果<br>
其中，()内填写你想设置的范围，None表示无限制，所以时间TLE问题就得到了解决！<br>
新代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @lru_cache(None)</span></span><br><span class="line">    <span class="comment">#插入装饰器ru_cache.()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.climbStairs(n<span class="number">-1</span>) + self.climbStairs(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Problems3-Unique-Paths-DP动态规划问题">Problems3:Unique Paths(DP动态规划问题)</h2>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p>Example 1:</p>
<p>Input: m = 3, n = 2<br>
Output: 3<br>
Explanation:<br>
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down</li>
<li>Right -&gt; Down -&gt; Right</li>
<li>Down -&gt; Right -&gt; Right</li>
</ol>
<p>其实画图后发现，在第一行或者最左列，由于是只能向上或者向下移动，所以无论哪个位置上都只能有一种路径，因此可以先将全部的格子内的步数设为1，然后从第二行第二列开始迭代(由于程序中默认从0开始，所以代码中用1来表示第二行第二列)</p>
<p>根据动态规划来思考，只要我们求出了到达每一个点的最大路径数，由于只能向下向右走，则最后一个点的最大路径数不就是前两个的最大路径之和想加么,即得出状态转移方程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p[i][j] = p[i][j<span class="number">-1</span>]+p[i<span class="number">-1</span>][j]</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">    	<span class="comment"># 首先排除只有一行一列的情况，此时只有一种路径</span></span><br><span class="line">    	<span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">or</span> m == <span class="number">1</span>:</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    	<span class="comment"># 将整个数组均设置为1，初始化</span></span><br><span class="line">    	dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]]</span><br><span class="line">    	<span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,m):</span><br><span class="line">    		<span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">1</span>,n):</span><br><span class="line">    			<span class="comment"># 针对每一个坐标(i,j)下的位置进行状态转移，</span></span><br><span class="line">    			<span class="comment">#其值为该位置上方和左方的路径数之和</span></span><br><span class="line">    			dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">    	<span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]<span class="comment"># 返回dp中的最后一个元素</span></span><br></pre></td></tr></table></figure>
<h2 id="Problems-4-Pascal’s-Triangle-DP动态规划问题">Problems 4 : Pascal’s Triangle(DP动态规划问题)</h2>
<p>Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle.<br>
给出一定的行数，输出接下来的每一行元素个数<br>
Example:</p>
<p>Input: 5<br>
Output:<br>
[<br>
[1],<br>
[1,1],<br>
[1,2,1],<br>
[1,3,3,1],<br>
[1,4,6,4,1]<br>
]<br>
仔细寻找规律后，发现每一行除了1以外，每个元素都是其上一行对应位置和前一个位置的和<br>
代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">    	<span class="comment"># 初始化一个全为1的三角形，每一行元素个数是行数加一(代码中0为第一行)</span></span><br><span class="line">        tree = [[<span class="number">1</span>]* (i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i):</span><br><span class="line">            	<span class="comment"># 进行状态转移</span></span><br><span class="line">                tree[i][j]=tree[i<span class="number">-1</span>][j<span class="number">-1</span>] + tree[i<span class="number">-1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 4</title>
    <url>/2019/05/05/Leetcode4/</url>
    <content><![CDATA[<p>很久没有更新leetcode笔记了，之前只刷题没有写Blog记录心得。不过也好，最近刚刷完top interview 100 题，借此机会复习巩固+写bolg~<br>
今后每日一篇吧，每篇4-6题，上不封顶。</p>
<h2 id="Max-Increase-to-Keep-City-Skyline">Max Increase to Keep City Skyline</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        row, col = list(map(max,grid)), list(map(max,zip(*grid)))</span><br><span class="line">        <span class="keyword">return</span> sum(min(i,j) <span class="keyword">for</span> i <span class="keyword">in</span> row <span class="keyword">for</span> j <span class="keyword">in</span> col ) - sum(map(max,grid))</span><br></pre></td></tr></table></figure>
<p>row里存放每行最大值，col存放每列最大值，增加后的每个位置的元素都不能超过该行or该列的最大值，所以要取min(row,col),循环遍历后取sum,再减去原始矩阵的元素和就是所求的Max increase。</p>
<a id="more"></a>
<h2 id="Range-Sum-of-BST">Range Sum of BST</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root: TreeNode, L: int, R: int)</span> -&gt; int:</span></span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    	l = self.rangeSumBST(root.left,L,R)</span><br><span class="line">    	r = self.rangeSumBST(root.right, L,R)</span><br><span class="line">    	temp = <span class="number">0</span> </span><br><span class="line">    	<span class="keyword">if</span> L &lt;= temp &lt;= R:</span><br><span class="line">    		temp+= root.val</span><br><span class="line">    	<span class="keyword">return</span> l + r + temp</span><br></pre></td></tr></table></figure>
<p>嗯，又遇到一道BST，话不多说，上来直接自身递归调用函数，判断根节点值是否在L,R区间内，从最底下的节点开始向上循环返回值，最后输出结果。</p>
<h2 id="Encode-and-Decode-TinyURL">Encode and Decode TinyURL</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">	sample = string.acsii_letters + <span class="string">'1234567890'</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.url2code = &#123;&#125;</span><br><span class="line">		self.code2url = &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self,longUrl)</span>:</span></span><br><span class="line">		<span class="keyword">while</span> longUrl <span class="keyword">not</span> <span class="keyword">in</span> self.url2code:</span><br><span class="line">			code = <span class="string">''</span>.join(random.choice(Codec.sample) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">6</span>))</span><br><span class="line">			<span class="keyword">if</span> code <span class="keyword">not</span> <span class="keyword">in</span> self.code2url:</span><br><span class="line">				self.code2url[longUrl] = code</span><br><span class="line">				self.url2code[code] - longUrl</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'http://tinyurl.com/'</span> + self.url2code[longUrl]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(self,shortUrl)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.code2url[shortUrl[<span class="number">-6</span>:]]</span><br></pre></td></tr></table></figure>
<p>罕见的一道design题，设计encode和decode两个功能模块，将url加密和解码，核心部分是sample的设置，将sample库设置为ascii码和数字的组合，然后encode时random抽取六位加在原链接的后面，顺便将双方各自作为key加入字典中，在decode中方便直接调用encode后六位所对应的的原链接即可。</p>
<h2 id="Maximum-Binary-Tree">Maximum Binary Tree</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">    		<span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    	i = nums.index(max(nums))</span><br><span class="line">    	node = TreeNode(nums[i])</span><br><span class="line">    	node.left = constructMaximumBinaryTree(nums[:i])</span><br><span class="line">    	node.right = constructMaximumBinaryTree(nums[i+<span class="number">1</span>:])</span><br><span class="line">    	<span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<p>一道基本的遍历树问题，输入样本是中序遍历的顺序，所以直接选取当前nums中最大的数作为node就可以了，然后老样子，递归赋值node.left和node.right，最后返回node即可。</p>
<h2 id="Divide-Two-Integers">Divide Two Integers</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">    	pos = (divisor &lt; <span class="number">0</span>) <span class="keyword">is</span> (dividend &lt; <span class="number">0</span>)</span><br><span class="line">    	dividend = abs(dividend)</span><br><span class="line">    	divisor = abs(divisor)</span><br><span class="line">    	res = <span class="number">0</span></span><br><span class="line">    	<span class="keyword">while</span> divisor &lt;= dividend:</span><br><span class="line">    		temp,i = divisor,<span class="number">1</span></span><br><span class="line">    		<span class="keyword">while</span> dividend&gt;= temp:</span><br><span class="line">    			temp&lt;&lt;=<span class="number">1</span></span><br><span class="line">    			i&lt;&lt;=<span class="number">1</span></span><br><span class="line">    			res+=i</span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> pos:</span><br><span class="line">    		res = -res</span><br><span class="line">    	<span class="keyword">return</span> min(max(<span class="number">-2147483648</span>,res),<span class="number">2147483647</span>)</span><br></pre></td></tr></table></figure>
<p>emmm纯数学题…除数和被除数的关系，其中有几个我个人比较喜欢的小cheat方法。<br>
1.(a &lt;0) is (b&lt;0) 可以同时判断a和b的某种共同特性关系，尤其是正负<br>
2.a&lt;&lt;=1 超级prefer的cheat，另外一种表示乘以二的方式，原理是采用二进制左移1的方法，速度很快<br>
3.如果题目存在输出值范围的问题，可以采用最后一行的min(max(a,answer),b)的方法，其中a是最小值，b是最大值，answer是所求值。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow Learning Notes (1)</title>
    <url>/2019/03/01/Tensorflow/</url>
    <content><![CDATA[<h2 id="Tensorflow-graphs">Tensorflow graphs</h2>
<p>Tensorflow is a graph based parallel computing model (refer to the official document)<br>
Circular or square nodes are called nodes, and the streams of data that flow through them are called tensors.<br>
More about tensor in the official documentation.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">The zero order tensor == scalar</span><br><span class="line"><span class="number">1</span> order tensor == Vector (one-dimensional array)</span><br><span class="line"><span class="number">2</span> order tensor == <span class="number">2</span> d array</span><br><span class="line">…</span><br><span class="line">n order tensor == n d array</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="The-relationship-between-tensor-and-node">The relationship between tensor and node:</h3>
<p>If the dimension of the input tensor is 5,000 by 64, 5000 x 64 means there are 5000 training samples, each sample has 64 characteristics, so the input layer must have 64 nodes to accept these characteristics.</p>
<p>The three layers of the network shown in the figure above include the input layer (input in the figure), the hidden layer (named ReLU layer here to indicate that its activation function is ReLU), and the output layer (Logit layer in the figure).<br>
As you can see, each of these layers have their associated tensor Gradient nodes flowing into them to compute the Gradient, and then the Gradient tensor will go into the SGD Trainer node to do network optimization (which is to say, update the network parameters).</p>
<p>It is through graph that Tensorflow represents the neural network to realize the parallel computation of the network and improve the efficiency. We will introduce the basic syntax of TensorFlow with a simple example.</p>
<h2 id="Examples">Examples</h2>
<p>A = calculated using Tensorflow (b + c) ∗ (c + 2)<br>
A = (b + c) ∗ (c + 2),</p>
<h3 id="Define-data">Define data:</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># First, create a TensorFlow constant =&gt;2=&gt;2</span></span><br><span class="line">const = tf.constant(<span class="number">2.0</span>, name=<span class="string">'const'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the TensorFlow variables b and c</span></span><br><span class="line">b = tf.Variable(<span class="number">2.0</span>, name=<span class="string">'b'</span>)</span><br><span class="line">c = tf.Variable(<span class="number">1.0</span>, dtype=tf.float32, name=<span class="string">'c'</span>)</span><br></pre></td></tr></table></figure>
<p>As mentioned above, in TensorFlow, constant is defined with tf.constant() and Variable is defined with tf.variable (). Tensorflow can perform data type detection automatically, for example: assignment 2.0 defaults to tf.float32, but is best defined explicitly.For more information on the TensorFlow data type, see the official documentation.</p>
<h3 id="Define-operation-also-known-as-TensorFlow-operation">Define operation (also known as TensorFlow operation) :</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create operation</span></span><br><span class="line">d = tf.add(b, c, name=<span class="string">'d'</span>)</span><br><span class="line">e = tf.add(c, const, name=<span class="string">'e'</span>)</span><br><span class="line">a = tf.multiply(d, e, name=<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<p>In TensorFlow, + has its own special function representation.<br>
In fact, TensorFlow defines enough functions to represent all of the math, and of course overloads some of the math, but to be on the safe side, it is recommended to use functions instead of operators.<br>
<em>All variables in TensorFlow must be initialized before they can be used.</em></p>
<h2 id="Initialization-consists-of-two-steps">Initialization consists of two steps:</h2>
<ol>
<li>Define initialization operation</li>
<li>Run initialization operation</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. define init operation</span></span><br><span class="line">init_op = tf.global_variables_initializer()</span><br></pre></td></tr></table></figure>
<p>The construction of TensorFlow graph has been completed above.<br>
The next step is to calculate and output.<br>
To run graph, we need to call the tf.session () function to create a Session.The session is the handle that interacts with the graph.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># session</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">	<span class="comment"># 2. init operation</span></span><br><span class="line">	sess.run(init_op)</span><br><span class="line">	<span class="comment"># caculate</span></span><br><span class="line">	a_out = sess.run(a)</span><br><span class="line">	print(<span class="string">"Variable a is &#123;&#125;"</span>.format(a_out))</span><br></pre></td></tr></table></figure>
<p>TensorFlow has an excellent visualization tool called TensorBoard(see the official documentation)<br>
An improvement to the above example: make the variable b accept any value.Values are received in TensorFlow as placeholders, created through tf.placeholder().</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create placeholder</span></span><br><span class="line">b = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
<p>The value of the second parameter is [None, 1], where None indicates uncertainty, namely the size of the first dimension, which can be any <a href="http://size.In" target="_blank" rel="noopener">size.In</a> particular, the number of tensor inputs (or the number of samples) will be 32, 64…<br>
Now, if you get the result of the calculation, you need the value of feed placeholder b during the run by changing a_out = sess.run(a) to:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_out = sess.run(a, feed_dict=&#123;b: np.arange(<span class="number">0</span>, <span class="number">10</span>)[:, np.newaxis]&#125;)</span><br></pre></td></tr></table></figure>
<p>Output：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Variable a <span class="keyword">is</span> [[  <span class="number">3.</span>]</span><br><span class="line"> [  <span class="number">6.</span>]</span><br><span class="line"> [  <span class="number">9.</span>]</span><br><span class="line"> [ <span class="number">12.</span>]</span><br><span class="line"> [ <span class="number">15.</span>]</span><br><span class="line"> [ <span class="number">18.</span>]</span><br><span class="line"> [ <span class="number">21.</span>]</span><br><span class="line"> [ <span class="number">24.</span>]</span><br><span class="line"> [ <span class="number">27.</span>]</span><br><span class="line"> [ <span class="number">30.</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Deep-Learning</category>
      </categories>
      <tags>
        <tag>Image Process</tag>
        <tag>CV</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCv Learning Notes (1)</title>
    <url>/2019/03/06/OpenCv/</url>
    <content><![CDATA[<h2 id="Representation-of-image">Representation of image</h2>
<p>As a computer, an image is just a bunch of dots of varying brightness.<br>
An M by N image can be represented by an M by N matrix. The value of the matrix element indicates the brightness of the pixel at this position. Generally, the larger the pixel value is, the brighter the point will be.</p>
<p>In general, grayscale images are represented by a 2-dimensional matrix, and color (multi-channel) images are represented by a 3-dimensional matrix (M by N by 3).For image display, most devices currently use unsigned 8-bit integer<br>
The number (of type CV_8U) represents the pixel brightness.The order in which image data is stored in the computer memory starts at the top left (or possibly bottom left) of the image, as shown in the figure</p>
<a id="more"></a>
<p>Iij represents the pixel value of row I, column j.If it is a multi-channel image, such as an RGB image, each pixel is represented by three <a href="http://bytes.In" target="_blank" rel="noopener">bytes.In</a> OpenCV, the channel order of RGB image is BGR, as stored<br>
As shown in figure.</p>
<h2 id="Mat">Mat</h2>
<p>In the early OpenCV, IplImage and CvMat data structures were used to represent images.<br>
In the new version of OpenCV, Mat class is introduced, which can manage memory automatically.<br>
With Mat, you no longer have to spend a lot of effort on memory management, and your code becomes cleaner and fewer lines of code.<br>
IplImage and CvMat are still available in the new version of OpenCV, but some of the new functions only provide Mat interfaces.<br>
The Mat class is defined as follows, and the key properties are as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS</span> <span class="title">Mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// A series of functions</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">/* The flag parameter contains a lot of information about matrices, such as:</span></span><br><span class="line"><span class="comment">- logo Mat</span></span><br><span class="line"><span class="comment">- whether the data is continuous</span></span><br><span class="line"><span class="comment">- depth </span></span><br><span class="line"><span class="comment">- number of channels</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">int</span> flags;</span><br><span class="line"> <span class="comment">// The dimension of the matrix should be greater than or equal to 2</span></span><br><span class="line"> <span class="keyword">int</span> dims;</span><br><span class="line"> <span class="comment">// The number of rows and columns in the matrix, if the matrix exceeds 2 dimensions, both of these variables have a value of 1</span></span><br><span class="line"> <span class="keyword">int</span> rows, cols;</span><br><span class="line"> <span class="comment">// A pointer to data</span></span><br><span class="line"> uchar* data;</span><br><span class="line"> <span class="comment">// A pointer to a reference count</span></span><br><span class="line"> <span class="comment">// NULL if the data is assigned by the user</span></span><br><span class="line"> <span class="keyword">int</span>* refcount;</span><br><span class="line"><span class="number">24</span></span><br><span class="line"> <span class="comment">// Other member variables and member functions</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Create-Mat-object">Create Mat object</h2>
<h3 id="Constructor-method">Constructor method</h3>
<p>The Mat class provides a series of constructors that make it easy to create Mat objects as needed.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>, CV_8UC3, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span></span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"M = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; M &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>The first line of code creates an image with 3 rows (height) and 2 columns (width), and the image element is an 8-bit unsigned integer type with three channels.All pixel values of the image are initialized to (0, 0,<br>
255).Since the default color order in OpenCV is BGR, this is an all-red image.The second line outputs all the pixel values of an instance M of the Mat class.Mat redefines the &lt;&lt; operator,<br>
With this operator, you can easily output all pixel values without having to use a for loop to output each pixel individually.<br>
The output of the code is shown in the figure</p>
<p>Common constructors are:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat::Mat ()</span><br></pre></td></tr></table></figure>
<p>Parameterless construction method;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat::Mat(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type)</span><br></pre></td></tr></table></figure>
<p>Create an image with rows, col and type rows.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat::Mat (Size Size, <span class="keyword">int</span> type)</span><br></pre></td></tr></table></figure>
<p>Create an image of size and type.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat::Mat(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> type, <span class="keyword">const</span> Scalar&amp; s)</span><br></pre></td></tr></table></figure>
<p>Create an image with rows, col and type, and initialize all elements with the value s<br>
…</p>
<p>If more channels are needed, use the macro CV_8UC(n), for example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">3</span>,<span class="number">2</span>, CV_8UC(<span class="number">5</span>))</span></span>;<span class="comment">// Create images with rows 3, columns 2, and channels 5</span></span><br></pre></td></tr></table></figure>
<h3 id="Create-the-object-with-the-create-function">Create the object with the create() function</h3>
<p>In addition to creating images in the constructor, you can also create images using the create() function of the Mat class. If the create() function specifies the same parameters as before the image, no real memory is used.Application for operation; If the parameters are different, the index of the original data memory is reduced and the memory is reapplied.The use method is as follows:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>, CV_8UC3)</span></span>;<span class="comment">// The constructor creates the image</span></span><br><span class="line">M.create(<span class="number">3</span>,<span class="number">2</span>, CV_8UC2);<span class="comment">// Free up memory to recreate the image</span></span><br></pre></td></tr></table></figure>
<p>Note that the initial value of the image pixel cannot be set using the create() function.</p>
<h3 id="Create-objects-using-Matlab">Create objects using Matlab</h3>
<p>Matlab style functions such as zeros(), ones() and eyes() are provided in OpenCV <a href="http://2.It" target="_blank" rel="noopener">2.It</a> makes the code very simple and easy to use.Using these functions requires specifying the size and type of the image.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat Z = Mat::zeros(<span class="number">2</span>,<span class="number">3</span>, CV_8UC1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Z = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; Z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Mat O = Mat::ones(<span class="number">2</span>, <span class="number">3</span>, CV_32F); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"O = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; O &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Mat E = Mat::eye(<span class="number">2</span>, <span class="number">3</span>, CV_64F); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"E = "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; E &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>In this code, some type parameters do not indicate the number of channels, in which case it represents a single channel.The output of the above code is shown in the figure</p>
]]></content>
      <categories>
        <category>Image Recognition</category>
      </categories>
      <tags>
        <tag>Image Process</tag>
        <tag>OpenCv</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 95 / Array(1) ðŸ’ª</title>
    <url>/2020/06/03/array01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-42-Trapping-Rain-Water-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">42. Trapping Rain Water</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br>
<img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmost = Integer.MIN_VALUE; <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">int</span> rightmost = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftmost = Math.max(leftmost,height[left]);</span><br><span class="line">            rightmost = Math.max(rightmost,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(leftmost &lt; rightmost)&#123;</span><br><span class="line">                area+=leftmost-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                area+=rightmost-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1.</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-238-Product-of-Array-Except-Self-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">238. Product of Array Except Self</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples-v2">Examples</h3>
<p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br><span class="line">Constraint: It&apos;s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                left = left * nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length-<span class="number">1</span>; j&gt;=<span class="number">0</span> ;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                right = right * nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = res[j] * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First from left to get the left multiply num, then from right to left to get the final result.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-152-Maximum-Product-Subarray-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">152. Maximum Product Subarray</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples-v3">Examples</h3>
<p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)max = sum;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.length ;j++)&#123;</span><br><span class="line">                sum = sum * nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; max)max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Simple two side for loops solution.</p>
<hr>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-121-Best-Time-to-Buy-and-Sell-Stock-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">121. Best Time to Buy and Sell Stock</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples-v4">Examples</h3>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>
<h3 id="Soluiton">Soluiton</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; min)&#123;</span><br><span class="line">                max = Math.max(prices[i]-min,max);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set first day’s value to be min which is like the price to buy in. Max is the value that to sell.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-56-Merge-Intervals-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">56. Merge Intervals</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples-v5">Examples</h3>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals)&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span> )<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] item : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= item[<span class="number">0</span>])&#123; <span class="comment">// [0,4][1,3]</span></span><br><span class="line">                end = Math.max(end,item[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">                start = item[<span class="number">0</span>];</span><br><span class="line">                end = item[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Classic merge intervals questions. Using start and end to decide whether merge a new interval or add current interval into answer.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-560-Subarray-Sum-Equals-K-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">560. Subarray Sum Equals K</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<h3 id="Examples-v6">Examples</h3>
<p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v5">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum = sum + num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">                count+=map.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using presum to precaculate the sum with different length of nums in array.</p>
<p>Eg:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array : 1 1 1 1 1</span><br><span class="line">       0:1</span><br><span class="line">       1:1</span><br><span class="line"> map -&gt;2:1</span><br><span class="line">       3:1</span><br><span class="line">       4:1</span><br><span class="line">       5:1</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 96 / Array(2) 💪</title>
    <url>/2020/06/06/array02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-31-Next-Permutation-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">31. Next Permutation</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span> ;i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                val = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == -<span class="number">1</span>)&#123; <span class="comment">// already sort in descending order like 321 then we return 123</span></span><br><span class="line">            reverse(nums,<span class="number">0</span>,len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len ;i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; val)&#123;</span><br><span class="line">                swap(nums,pos,i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,pos+<span class="number">1</span>,len);<span class="comment">// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            swap(nums,start,end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
<p>From end to start we need to find the first num target which cause drop and keep record ot it’s pos and value. Then we start from end again to find the first num that is bigger than than target’s value. Then we swap this num with the target num , then reverse the array from pos+1 to len.</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-54-Spiral-Matrix-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">54. Spiral Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.size() &lt; m*n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left ;i &lt;= right &amp;&amp; res.size() &lt; n * m ;i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span> ; i&lt;= down-<span class="number">1</span> &amp;&amp; res.size() &lt; m * n ;i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right ;i&gt;= left &amp;&amp; res.size() &lt; m*n;i--)&#123;</span><br><span class="line">                res.add(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = down-<span class="number">1</span> ;i&gt;=top+<span class="number">1</span> &amp;&amp; res.size() &lt; m * n;i--)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)<br>
Simple idea. Just loop the matrix from left-&gt; right, top-&gt;down, right-&gt;left, down-&gt;top. Then minus each value by 1.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-289-Game-of-Life-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">289. Game of Life</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v2">Examples</h3>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>
Any live cell with two or three live neighbors lives on to the next generation.<br>
Any live cell with more than three live neighbors dies, as if by over-population…<br>
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</p>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dir =&#123;&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dir)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[<span class="number">0</span>]+i&lt;<span class="number">0</span> || d[<span class="number">0</span>]+i&gt;=board.length || d[<span class="number">1</span>]+j&lt;<span class="number">0</span> || d[<span class="number">1</span>]+j&gt;=board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">1</span> || board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">2</span>) live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">0</span> &amp;&amp; live==<span class="number">3</span>) board[i][j]=<span class="number">3</span>;<span class="comment">// dead to live</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live&lt;<span class="number">2</span> || live&gt;<span class="number">3</span>)) board[i][j]=<span class="number">2</span>; <span class="comment">// live to dead</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live ==<span class="number">2</span> || live ==<span class="number">3</span>))board[i][j]=<span class="number">1</span>; <span class="comment">// continue live;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                board[i][j]%=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(mn) S:O(1)</p>
<p>Tricky point is that we can use three state to keep record of the next generation.</p>
<p>1-&gt; live cell continue to live</p>
<p>2-&gt; live cell died due to lives &lt;2 or lives&gt;3</p>
<p>3-&gt; dead cell become live due to lives ==2 or lives ==3</p>
<p>After that we can use %2 to caculate whether it’s 0 or 1.</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-128-Longest-Consecutive-Sequence-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">128. Longest Consecutive Sequence</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v3">Examples</h3>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//corner case</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> left = map.getOrDefault(num-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> right = map.getOrDefault(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                sum += left + right + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(max,sum);</span><br><span class="line">                map.put(num,sum);</span><br><span class="line">                map.put(num-left,sum);</span><br><span class="line">                map.put(num+right,sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<p>Everytime we just to find max continus length of num-1 and num+1, then we mix them up to form a new sum of current num. Then we update max , and also update the num-left, num+right with new sum value, it works because left and right is the length of continus length.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1054-Distant-Barcodes-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1054. Distant Barcodes</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/distant-barcodes/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v4">Examples</h3>
<p>n a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].</p>
<p>Rearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,1,1,2,2,2]</span><br><span class="line">Output: [2,1,2,1,2,1]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,1,1,1,2,2,3,3]</span><br><span class="line">Output: [1,3,1,3,2,1,2,1]</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v5">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rearrangeBarcodes(<span class="keyword">int</span>[] barcodes) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[barcodes.length];</span><br><span class="line">        <span class="keyword">if</span>(barcodes.length == <span class="number">0</span> || barcodes == <span class="keyword">null</span>)<span class="keyword">return</span> res;<span class="comment">//corner case</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b : barcodes)&#123;</span><br><span class="line">            map.put(b,map.getOrDefault(b,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key: map.keySet())&#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;key,map.get(key)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = pq.poll();</span><br><span class="line">            <span class="keyword">while</span>(temp[<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res[idx] = temp[<span class="number">0</span>];</span><br><span class="line">                temp[<span class="number">1</span>]--;</span><br><span class="line">                idx+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(idx&gt;=barcodes.length)idx=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(nlogn) S:O(n)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>New App Deployed 🎉</title>
    <url>/2020/05/31/app1/</url>
    <content><![CDATA[<h1>Covid-19 Tracker App now available online ! 💊</h1>
<p><a href="https://leeemask.com/covid-track/" target="_blank" rel="noopener"><font size="4"> 🔗 COVID-19 tracker </font></a></p>
<p>Brief content of the application.</p>
<img src="https://s1.ax1x.com/2020/06/01/t3OiWj.md.png">
<p>Skill included:</p>
<ul>
<li>React, JavaScript, Chart.js, axios, MongoDB, ElementUI…</li>
</ul>
]]></content>
      <categories>
        <category>Depolyed Web App</category>
      </categories>
      <tags>
        <tag>Web Application</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 103 / Array(3) 💪</title>
    <url>/2020/07/02/array03/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-643-Maximum-Average-Subarray-I-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">643. Maximum Average Subarray I</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/maximum-average-subarray-i/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,12,-5,-6,50,3], k = 4</span><br><span class="line">Output: 12.75</span><br><span class="line">Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line">1 &lt;= k &lt;= n &lt;= 30,000.</span><br><span class="line">Elements of the given array will be in the range [-10,000, 10,000].</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> max = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i&lt;nums.length; i++)&#123;</span><br><span class="line">            sum+=nums[i] - nums[i-k];</span><br><span class="line">            max = Math.max(max,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max/<span class="number">1.0</span>/k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using sliding window to caculate each k continous array’s average. Remember to change max to double first using /1.0.</p>
<p>T:O(N) S:O(1)</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-299-Bulls-and-Cows-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">299. Bulls and Cows</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/bulls-and-cows/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>You are playing the following <a href="https://en.wikipedia.org/wiki/Bulls_and_Cows" target="_blank"> <code>Bulls and Cows</code> </a>game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows.</p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;</span><br><span class="line">Output: &quot;1A3B&quot;</span><br><span class="line">Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;</span><br><span class="line">Output: &quot;1A1B&quot;</span><br><span class="line">Explanation: The 1st 1 in friend&apos;s guess is a bull, the 2nd or 3rd 1 is a cow.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(secret == <span class="keyword">null</span> || guess == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] secarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span>[] guessarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; secret.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(guess.charAt(i) == secret.charAt(i))&#123;</span><br><span class="line">                bulls++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                secarr[secret.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">                guessarr[guess.charAt(i)-<span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">9</span>; i++)&#123;</span><br><span class="line">            cows+=Math.min(secarr[i],guessarr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> + bulls +<span class="string">"A"</span>+ cows +<span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using bucket to store each number’s frequency. When the same position of secret and guess are same then we increase bulls. Ohterwise we increase both positions in two arrays by 1.</p>
<p>After the first loop of the array, we then loop the number from 0 - 9. We only add min frequency one to the cows.</p>
<p>Finally we return the constructed string.</p>
<p>T:O(N) S:O(N)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-658-Find-K-Closest-Elements-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">658. Find K Closest Elements</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/find-k-closest-elements/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given a sorted array arr, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: arr = [1,2,3,4,5], k = 4, x = 3</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: arr = [1,2,3,4,5], k = 4, x = -1</span><br><span class="line">Output: [1,2,3,4]</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findClosestElements</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right-left&gt;=k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(arr[left]-x) &gt; Math.abs(arr[right]-x))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            res.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using two pointers to keep track of the left and right position. Cacualting the abs value of difference between current num and x. We increase by 1 on the large side. Finally we just loop from the left to right and add each number in this range to the res.</p>
<p>T:O(N) S:O(N)</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-719-Find-K-th-Smallest-Pair-Distance-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">719. Find K-th Smallest Pair Distance</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">nums = [1,3,1]</span><br><span class="line">k = 1</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = a[n - <span class="number">1</span>] - a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (count(a, mid) &lt; k)</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= max) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j - i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First idea we can come up with is generating all the possible pairs and the using customed Max/Min PriorityQueue /sort function to get the top k smallest pairs, but it will cause TLE error.</p>
<p>So we only have to using binary searching to reduce the time complexity.</p>
<p>If we sort the array, then we can easily count the numbers of pairs whose distance is smaller than a number. (Only takes O(n))</p>
<p>The number of valid pairs and max distance hava a monotonic relationship.</p>
<p>If distance max is small, the valid pairs will be small. If distance max is large, all pairs will be valid.</p>
<p>Then we could use binary search!</p>
<p>For a given max, count the number of valid pairs.</p>
<p>If num &gt;= k, we could decrease max value. If num &lt; k , we must increase max value.</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 63</title>
    <url>/2020/01/20/chin-up-01/</url>
    <content><![CDATA[<h2 id="前言｜Say-something…">前言｜Say something…</h2>
<p>Hi，很久没有更新blog了，这期间经历了许多，也对自己有了新的认识，刷题也有了新的方法。<br><br>
虽然很久没有更新blog了，但是每天都有在做题，前一月初的时候达成了刷题430道，算是一个小成就吧，接下来也不打算做新题了，主要复习总结之前做过的题目。<br>
<br><br>
最近也陆陆续续收到别的公司的oa和面试，希望自己好好准备。<br>
Keep head on and Chin up !<br>
<br></p>
<h2 id="table-tr-td-bgcolor-orange-199-Binary-Tree-Right-Side-View-td-tr-table"><table><tr><td bgcolor="orange">199. Binary Tree Right Side View</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=size-<span class="number">1</span>)res.add(root.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型tree+bfs+queue的level traversal，唯一difference是当size到达改层最后一个元素时才加入res。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-orange-863-All-Nodes-Distance-K-in-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">863. All Nodes Distance K in Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root,TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.right,dist+<span class="number">1</span>,K,res)l</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find函数将taregt上方所有节点 与target的dist 存进map。dfs函数里首先判断该节点是否存进map，如果有则把dist更新为map里的值，如果没有则不变，dfs每进行一次dist+1。</p>
<h2 id="table-tr-td-bgcolor-orange-207-Course-Schedule-td-tr-table"><table><tr><td bgcolor="orange">207. Course Schedule </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[] prerequisites)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;indegree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] ==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            numCourse--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourse == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型拓扑排序。用indegree存每个课的入度。然后将入度为0，即可以优先上的课加入queue。bfs更新indegree，如果再发现indegree为零，则在加入queue。最后判断剩下的课是否为0。如果可以上则应该没有剩课。否则返回false。</p>
<h2 id="table-tr-td-bgcolor-orange-210-Course-Schedule-II-td-tr-table"><table><tr><td bgcolor="orange">210. Course Schedule II </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;indegree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                res[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]]==<span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                        res[index]=pair[<span class="number">0</span>];</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses ? res : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路和上一题一样，只不过需要维护一个大小为课程数的数组，按序存入课程即可。</p>
<h2 id="table-tr-td-bgcolor-orange-529-Minesweeper-td-tr-table"><table><tr><td bgcolor="orange">529. Minesweeper</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minesweeper/" target="_blank" rel="noopener"> <font size="4">🔗Question Link </font> </a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[][] updateBoard(<span class="keyword">char</span>[][] board, <span class="keyword">int</span>[] click) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(click);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> row = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> col = temp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(board[row][col] == <span class="string">'M'</span>)&#123;</span><br><span class="line">                board[row][col] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=-<span class="number">1</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i;</span><br><span class="line">                        <span class="keyword">int</span> c = col + j;</span><br><span class="line">                        <span class="keyword">if</span>(r&gt;=<span class="number">0</span> &amp;&amp; r&lt;m &amp;&amp; c&gt;=<span class="number">0</span> &amp;&amp; c&lt;n &amp;&amp; (board[r][c] == <span class="string">'M'</span> || board[r][c] ==<span class="string">'X'</span>) )&#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    board[row][col] = (<span class="keyword">char</span>)(count+<span class="string">'0'</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    board[row][col] = <span class="string">'B'</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=-<span class="number">1</span> ;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> j=-<span class="number">1</span> ;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> r = row + i;</span><br><span class="line">                            <span class="keyword">int</span> c = col + j;</span><br><span class="line">                            <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i ==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || c &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">if</span>(board[r][c] == <span class="string">'E'</span>)&#123;</span><br><span class="line">                                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c&#125;);</span><br><span class="line">                                board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典bfs。首先判断是否是雷，如果是则变为x。然后数周围雷或者x的个数。如果个数不为零，则说明该位置周围有雷，将该位置变为雷的个数。如果个数为零，说明为边界，则继续bfs扩大边界。</p>
<h2 id="table-tr-td-bgcolor-orange-133-Clone-Graph-td-tr-table"><table><tr><td bgcolor="orange">133. Clone Graph </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        Queue&lt;Node&gt;queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        map.put(node,dummy);</span><br><span class="line">        queue.add(node);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(Node nb:cur.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(nb))&#123;</span><br><span class="line">                    map.put(nb,<span class="keyword">new</span> Node(nb.val));</span><br><span class="line">                    queue.add(nb);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(cur).neighbors.add(map.get(nb));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用map存原node和克隆的新node，对原node的邻居进行遍历，如果map里没有则把该邻居节点克隆，然后put进map，加入queue。如果存在了就把当前node的邻居节点的克隆节点存入当前node的克隆节点的邻居节点里。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 64</title>
    <url>/2020/01/22/chin-up-02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-orange-font-color-white-5-Longest-Palindromic-Substring-font-td-tr-table"><table><tr><td bgcolor="orange"><font color="white">5. Longest Palindromic Substring </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start, maxlen;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length(); i++)&#123;</span><br><span class="line">            check(s,i,i);</span><br><span class="line">            check(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left &gt; maxlen)&#123;</span><br><span class="line">            maxlen = right - left-<span class="number">1</span>;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查一位 or 两位的回文情况。check自己本身以及自己和后一位。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-green-20-Valid-Parentheses-td-tr-table"><table><tr><td bgcolor="green">20. Valid Parentheses </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">// to store the other part of parenthese</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) ==<span class="string">' '</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'['</span>)&#123; </span><br><span class="line">                stack.push(<span class="string">']'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">')'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.pop() != s.charAt(i))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用stack来保持一对合格的括号。遇到开口就向stack存闭口。如果不是开口就判断pop出来的和当前是否相同。</p>
<h2 id="table-tr-td-bgcolor-orange-3-Longest-Substring-Without-Repeating-Characters-td-tr-table"><table><tr><td bgcolor="orange">3. Longest Substring Without Repeating Characters </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                res = Math.max(res,set.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针。set存唯一的字符。如果遇到重复的，则从头开始移出set。保持res为set的最大size。</p>
<h2 id="table-tr-td-bgcolor-orange-22-Generate-Parentheses-td-tr-table"><table><tr><td bgcolor="orange">22. Generate Parentheses </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        help(<span class="string">""</span>,res,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(String cur, List&lt;String&gt; res, <span class="keyword">int</span> open ,<span class="keyword">int</span> close, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.length() == num *<span class="number">2</span>)&#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open &lt; num)&#123;</span><br><span class="line">            help(cur+<span class="string">"("</span>,res,open+<span class="number">1</span>,close,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close &lt; open)&#123;</span><br><span class="line">            help(cur + <span class="string">")"</span>,res,open,close+<span class="number">1</span>,num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open 和 close用来记录左右括号数，然后分情况recursive调用。最后cur长度达到num*2就可以返回了。</p>
<h2 id="table-tr-td-bgcolor-orange-49-Group-Anagrams-td-tr-table"><table><tr><td bgcolor="orange">49. Group Anagrams </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt; str.length();i++)&#123;</span><br><span class="line">                arr[str.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = Arrays.toString(arr);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">                map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            res.add(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的arr[26]方法。将arr[]转成key存入map，用其来对应组成字母相同的word。最后返回相同字母的word集合。</p>
<h2 id="table-tr-td-bgcolor-orange-91-Decode-Ways-td-tr-table"><table><tr><td bgcolor="orange">91. Decode Ways </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span> ;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> first = Integer.valueOf(s.substring(i-<span class="number">1</span>,i));</span><br><span class="line">            <span class="keyword">int</span> second = Integer.valueOf(s.substring(i-<span class="number">2</span>,i));</span><br><span class="line">            <span class="keyword">if</span>(first &gt;=<span class="number">1</span> &amp;&amp; first&lt;=<span class="number">9</span>)&#123;</span><br><span class="line">                dp[i]+=dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second&gt;=<span class="number">10</span> &amp;&amp; second &lt;=<span class="number">26</span>)&#123;</span><br><span class="line">                dp[i]+=dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遇到返回所有情况而且存在不连续的情况，基本用dp解决。分1位数和2位数来解决。如果1位数在1-9之间，可以对应A-I,如果2位数在10-26之间，可以对应J-Z。dp不断更新可构成的最多情况，最后返回最后一位dp值即可。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-32-Longest-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">32. Longest Valid Parentheses</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">                open++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) ==<span class="string">')'</span> &amp;&amp; open &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-dp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i-dp[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                open--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp思路。open记录开口数，只有当open&gt;0才对close和dp操作。首先更新dp=dp[i-1]+2，加上一对合格对括号。之后如果i-dp[i]&gt;0说明i之前还是有合格括号对存在，把这些也加上。最后用max记录最大，返回max。</p>
<h2 id="table-tr-td-bgcolor-green-125-Valid-Palindrome-td-tr-table"><table><tr><td bgcolor="green">125. Valid Palindrome </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(l))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(r))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(l) != Character.toLowerCase(r))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two pointers。前后各自扫描为字母的位置。如果两个不相同直接false，如果相同则继续往里收缩。</p>
<h2 id="table-tr-td-bgcolor-green-819-Most-Common-Word-td-tr-table"><table><tr><td bgcolor="green">819. Most Common Word </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/most-common-word/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; banset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String[] words = paragraph.toLowerCase().split(<span class="string">"\\W++"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String ban : banned)&#123;</span><br><span class="line">            banset.add(ban);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!banset.contains(word))&#123;</span><br><span class="line">                map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) &gt; max)&#123;</span><br><span class="line">                max = map.get(key);</span><br><span class="line">                res = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>banned单词加入set，map存不在banned里的单词的次数，然后找到最多次数的单词返回。</p>
<h2 id="table-tr-td-bgcolor-orange-227-Basic-Calculator-II-td-tr-table"><table><tr><td bgcolor="orange">227. Basic Calculator II </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i)!=<span class="string">' '</span>) || i == len-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() * num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = s.charAt(i);</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> nums : stack)&#123;</span><br><span class="line">            res+=nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆波兰式子的应用。stack存数字，然后初始化运算符为+号。更新完value后再把符号更新为当前的符号。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 65</title>
    <url>/2020/01/26/chin-up-03/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(sb,root);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(StringBuilder sb, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)sb.append(<span class="string">"n"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(sb,root.left);</span><br><span class="line">            serial(sb,root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = data.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String val = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(val.equals(<span class="string">"n"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(val));</span><br><span class="line">        root.left=buildTree(queue);</span><br><span class="line">        root.right = buildTree(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preorder遍历转为string，用空格隔开，建树的时候split空格，然后preorder建树。用queue存下preorder的string结果。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-orange-1130-Minimum-Cost-Tree-From-Leaf-Values-td-tr-table"><table><tr><td bgcolor="orange">1130. Minimum Cost Tree From Leaf Values</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> product = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;list.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(product &gt; list.get(i) * list.get(i+<span class="number">1</span>))&#123;</span><br><span class="line">                    product = list.get(i) * list.get(i+<span class="number">1</span>);</span><br><span class="line">                    index = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.set(index,Math.max(list.get(index),list.get(index+<span class="number">1</span>)));</span><br><span class="line">            list.remove(index+<span class="number">1</span>);</span><br><span class="line">            res += product;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实质是数组题。遍历找product最小的两数，并且记录第一个数的坐标。然后更换该位置的数。</p>
<h2 id="table-tr-td-bgcolor-orange-124-Binary-Tree-Maximum-Path-Sum-td-tr-table"><table><tr><td bgcolor="orange">124. Binary Tree Maximum Path Sum</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,help(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,help(root.right));</span><br><span class="line">        max = Math.max(max,left+right+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>max记录当前最大的sum。但是recursive返回的是left和right最大值加上当前root值。</p>
<h2 id="table-tr-td-bgcolor-orange-199-Binary-Tree-Right-Side-View-td-tr-table"><table><tr><td bgcolor="orange">199. Binary Tree Right Side View</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>( i&gt;= size-<span class="number">1</span>)res.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典tree bfs。唯一不同是判断当前是否是第size-1个，加入res。这样就保证是tree最right side view了。</p>
<h2 id="table-tr-td-bgcolor-orange-98-Validate-Binary-Search-Tree-td-tr-table"><table><tr><td bgcolor="orange">98. Validate Binary Search Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;= min || root.val &gt;=max)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left,min,root.val) &amp;&amp; check(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设两个范围，保证bst每个节点都在min 和max之间就可以。</p>
<h2 id="table-tr-td-bgcolor-orange-236-Lowest-Common-Ancestor-of-a-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">236. Lowest Common Ancestor of a Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lca的题。递归前先判断该root是否和p or q相同。如果相同则直接返回改值。如果没有则左右递归。若左没有则代表都在右边。若右没有则代表在左边。如果两面都有则返回当前root。因为左右都有肯定当前root为lca。</p>
<h2 id="table-tr-td-bgcolor-green-543-Diameter-of-Binary-Tree-td-tr-table"><table><tr><td bgcolor="green">543. Diameter of Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = help(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = help(root.right)+<span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左右各自找最长depth，更新ans，最后递归返回left和right的最大值。</p>
<h2 id="table-tr-td-bgcolor-orange-173-Binary-Search-Tree-Iterator-td-tr-table"><table><tr><td bgcolor="orange">173. Binary Search Tree Iterator</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        pushall(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pushall(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushall</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义pushall函数，将所有left节点存入stack。最后栈顶则是当前的min值。next时候先pop出peek元素，然后对peek元素pushall，更新min值，然后返回pop值。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 67</title>
    <url>/2020/01/31/chin-up-05/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-orange-909-Snakes-and-Ladders-td-tr-table"><table><tr><td bgcolor="orange">909. Snakes and Ladders</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/snakes-and-ladders/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m*m+<span class="number">1</span>];</span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> next = temp + j;</span><br><span class="line">                    <span class="keyword">int</span>[] pos = getpos(next,m);</span><br><span class="line">                    <span class="keyword">if</span>(board[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        next = board[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(next == m*m)<span class="keyword">return</span> steps;</span><br><span class="line">                    <span class="keyword">if</span>(!seen[next])&#123;</span><br><span class="line">                        seen[next] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.add(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getpos(<span class="keyword">int</span> next, <span class="keyword">int</span> m)&#123;</span><br><span class="line">        <span class="keyword">int</span> row = (next-<span class="number">1</span>)/m;</span><br><span class="line">        <span class="keyword">int</span> col = (next-<span class="number">1</span>)%m;</span><br><span class="line">        <span class="keyword">int</span> x = m-row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = row%<span class="number">2</span> == <span class="number">0</span>?col : m-col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queue存number，通过getpos获得num对应坐标。经典bfs模版。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-orange-1091-Shortest-Path-in-Binary-Matrix-td-tr-table"><table><tr><td bgcolor="orange">1091. Shortest Path in Binary Matrix</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp[<span class="number">0</span>] == m-<span class="number">1</span> &amp;&amp; temp[<span class="number">1</span>] == n-<span class="number">1</span>)<span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] move : moves)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = temp[<span class="number">0</span>]+move[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = temp[<span class="number">1</span>]+move[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp;y&lt;n &amp;&amp; grid[x][y] == <span class="number">0</span> &amp;&amp; !seen[x][y])&#123;</span><br><span class="line">                        seen[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典bfs模版。创建move数组。遇到1就停止。遇到0则加入queue继续bfs。</p>
<h2 id="table-tr-td-bgcolor-orange-130-Surrounded-Region-td-tr-table"><table><tr><td bgcolor="orange">130. Surrounded Region </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) helper(board, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">'O'</span>) helper(board, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) helper(board, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">'O'</span>) helper(board, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'1'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt;= board.length - <span class="number">1</span> &amp;&amp; c &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; board[r][c] == <span class="string">'O'</span>)&#123;</span><br><span class="line">        board[r][c] = <span class="string">'1'</span>;</span><br><span class="line">        helper(board, r + <span class="number">1</span>, c);</span><br><span class="line">        helper(board, r - <span class="number">1</span>, c);</span><br><span class="line">        helper(board, r, c + <span class="number">1</span>);</span><br><span class="line">        helper(board, r, c - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有和边界0相连的0才不会变成x，所以第一步就是将和边缘0相连的0变成*，然后再扫描整个graph，把没有连上的0变成x，*变回0。</p>
<h2 id="table-tr-td-bgcolor-green-111-Minimum-Depth-of-Binary-Tree-td-tr-table"><table><tr><td bgcolor="green">111. Minimum Depth of Binary Tree </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)<span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="keyword">null</span>)<span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive找depth，维护min即可。</p>
<h2 id="table-tr-td-bgcolor-green-559-Maximum-Depth-of-N-ary-Tree-td-tr-table"><table><tr><td bgcolor="green">559. Maximum Depth of N-ary Tree </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                Node temp=queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node child : temp.children)&#123;</span><br><span class="line">                    queue.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterative思路。level order 遍历tree。维护depth，最后返回depth即为maxdepth。</p>
<h2 id="table-tr-td-bgcolor-orange-1319-Number-of-Operations-to-Make-Network-Connected-td-tr-table"><table><tr><td bgcolor="orange">1319. Number of Operations to Make Network Connected</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parents[n] == n)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">return</span> parents[n] = find(parents,parents[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = connections.length;</span><br><span class="line">        <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> extra = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(parents,connections[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(parents,connections[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(root1 == root2)extra++;</span><br><span class="line">            <span class="keyword">else</span> parents[root1] = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] == i) components++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (extra &gt;= components -<span class="number">1</span>) ? components - <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化版union find。基本的uf操作，将union的过程放在了主函数。最后找component的个数，独立的部分个数，则需要链接的link个数就是component-1个。所以只需要判断多余的extra是否大于component-1即可。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>BFS</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 70 💪</title>
    <url>/2020/02/03/chin-up-08/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-437-Path-Sum-III-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">437. Path Sum III</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        help(root,<span class="number">0</span>,sum,map);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">int</span> cursum, <span class="keyword">int</span> target,Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        cursum+=root.val;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(cursum - target))&#123;</span><br><span class="line">            total+=map.get(cursum - target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(cursum,map.getOrDefault(cursum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        help(root.left,cursum,target,map);</span><br><span class="line">        help(root.right,cursum,target,map);</span><br><span class="line">        map.put(cursum,map.get(cursum)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>presum + backtracking。一定要记住最后backtrack减1。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-95-Unique-Binary-Search-Trees-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">95. Unique Binary Search Trees II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> help(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">help</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)res.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start ;i&lt;=end;i++)&#123;</span><br><span class="line">            List&lt;TreeNode&gt; leftset = help(start,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; rightset = help(i+<span class="number">1</span>,end);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode left : leftset)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode right : rightset)&#123;</span><br><span class="line">                    TreeNode node = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    res.add(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从1-&gt;n是节点1到n的任何BST的in-order遍历。因此，如果选择第i个节点作为根，则左子树将包含元素1至（i-1），而右子树将包含元素（i + 1）至n。使用递归调用来获取左右子树的所有可能树，并将所有可能的方式将与根组合。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-114-Flatten-Binary-Tree-to-Linked-List-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">114. Flatten Binary Tree to Linked List</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre;</span><br><span class="line">        root.left=<span class="keyword">null</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先递归到最右节点，依次连接节点，然后在从左子树开始继续向右递归，pre保存到是上一次递归结束时的node，把node连到当前root到right，然后left变null，继续递归。视频讲解⬇️</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/LfKRZ_qCmYQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-116-Populating-Next-Right-Pointers-in-Each-Node-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">116. Populating Next Right Pointers in Each Node </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                node.next = i&lt;size-<span class="number">1</span> ? queue.peek() : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三遍。常规level traversal写法，只在当前层最后一个node时把next给到null，其他的next都是queue里的下一个元素，即横向右边的node。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>BackTracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 66</title>
    <url>/2020/01/30/chin-up-04/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-orange-987-Vertical-Order-Traversal-of-a-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">987. Vertical Order Traversal of a Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        pair(TreeNode n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            node = n;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(root,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.remove();</span><br><span class="line">            min = Math.min(temp.x,min);</span><br><span class="line">            max = Math.max(temp.x,max);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.node.left,temp.x-<span class="number">1</span>,temp.y+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.node.right,temp.x+<span class="number">1</span>,temp.y+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; i &lt;= max; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i),<span class="keyword">new</span> Comparator&lt;pair&gt;()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(pair a, pair b)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a.y == b.y)<span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j &lt; map.get(i).size();j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>定义pair类，包含横向位置x。map存x位置对应的node节点，queue + bfs，遍历所有node并且存入map。<br></li>
<li>在bfs中更新min和max值，找到tree最左和最右边界。</li>
<li>重写sort，将同一位置的node按小-大排序。</li>
<li>针对每一个位置x新建templist，最后将templist加入res中。</li>
</ol>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-orange-863-All-Nodes-Distance-K-in-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">863. All Nodes Distance K in Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)res.add(root.val);</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.right,dist+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先定义find函数，用map存target上方节点距离target的距离，target下方不存。<br><br>
再dfs遍历所有节点，将距离为k的存入res。如果map中有该点，则为target上方的点。直接将dist更新为map对应的value即可。如果没有则一步一步向下深入 dist+1.</p>
<h2 id="table-tr-td-bgcolor-orange-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-td-tr-table"><table><tr><td bgcolor="orange">105. Construct Binary Tree from Preorder and Inorder Traversal</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder == <span class="keyword">null</span> || inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// store index of inorder</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[]inorder,<span class="keyword">int</span> istart, <span class="keyword">int</span> iend, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pstart, <span class="keyword">int</span> pend, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(istart &gt;iend || pstart &gt; pend)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[pstart]);</span><br><span class="line">        <span class="keyword">int</span> inidx = map.get(preorder[pstart]);</span><br><span class="line">        <span class="keyword">int</span> remains = inidx - istart;</span><br><span class="line">        node.left = build(inorder,istart,inidx-<span class="number">1</span>,preorder,pstart+<span class="number">1</span>,pstart + remains,map);</span><br><span class="line">        node.right = build(inorder,inidx+<span class="number">1</span>,iend,preorder,pstart + remains + <span class="number">1</span>,pend,map);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用preorder找到根节点，然后去inorder里找到左右part的index，利用不同的index对左右子树进行build。</p>
<h2 id="table-tr-td-bgcolor-orange-449-Serialize-and-Deserialize-BST-td-tr-table"><table><tr><td bgcolor="orange">449. Serialize and Deserialize BST</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<p>这道题不论BST或者BT都是一样的写法。都是preorder转成string，然后split空格，再用preorder方式进行建树。<br><br>
这道题是BST，<br>
<a href="http://leeemask.com/%2F2020%2F01%2F26%2Fchin-up-03%2F#297-Serialize-and-Deserialize-Binary-Tree>" target="_blank" rel="noopener">另外一道BT的题目链接在这里⬇️</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, st);</span><br><span class="line">        <span class="keyword">return</span> st.toString();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder st)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) st.append(<span class="string">"n"</span> + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st.append(root.val + <span class="string">" "</span>);</span><br><span class="line">            serialize(root.left, st);</span><br><span class="line">            serialize(root.right, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.addAll(Arrays.asList(data.split(<span class="string">" "</span>)));</span><br><span class="line">        <span class="keyword">return</span> deseralize(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deseralize</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(<span class="string">"n"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        root.left = deseralize(queue);</span><br><span class="line">        root.right = deseralize(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路&amp;code 和297一模一样。</p>
<h2 id="table-tr-td-bgcolor-orange-103-Binary-Tree-Zigzag-Level-Order-Traversal-td-tr-table"><table><tr><td bgcolor="orange">103. Binary Tree Zigzag Level Order Traversal</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> zig = <span class="keyword">false</span>;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zig)&#123;</span><br><span class="line">                    templist.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    templist.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">            zig=!zig;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>level traversal。加一个zig判断添加顺序。zig的逆序，不断add(0,val)。</p>
<h2 id="table-tr-td-bgcolor-orange-102-Binary-Tree-Level-Order-Traversal-td-tr-table"><table><tr><td bgcolor="orange">102. Binary Tree Level Order Traversal</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                templist.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典tree level traversal模版。和103一个思路。只不过103需要考虑zig，这道题单纯的traversal就可以。</p>
<h2 id="table-tr-td-bgcolor-orange-96-Unique-Binary-Search-Trees-td-tr-table"><table><tr><td bgcolor="orange">96. Unique Binary Search Trees</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt;=i ; j ++)&#123;</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp思路。数学思路比较费时间。youtbe视频讲解⬇️。</p>
<iframe width="600" height="315" src="https://www.youtube.com/embed/GgP75HAvrlY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h2 id="table-tr-td-bgcolor-orange-366-Find-Leaves-of-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">366. Find Leaves of Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-leaves-of-binary-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span> + Math.max(help(root.left,res),help(root.right,res));</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level + <span class="number">1</span>)res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找tree的深度level，res大小和level一样。然后通过get（level）找到对应的位置，添加root.val。</p>
<h2 id="table-tr-td-bgcolor-orange-545-Boundary-of-Binary-Tree-td-tr-table"><table><tr><td bgcolor="orange">545. Boundary of Binary Tree</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/boundary-of-binary-tree/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        findleft(root.left,res);</span><br><span class="line">        leaf(root.left,res);</span><br><span class="line">        leaf(root.right,res);</span><br><span class="line">        findright(root.right,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findleft</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)findleft(root.right,res);</span><br><span class="line">        <span class="keyword">else</span> findleft(root.left,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaf</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)res.add(root.val);</span><br><span class="line">        leaf(root.left,res);</span><br><span class="line">        leaf(root.right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findright</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left==<span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)findright(root.left,res);</span><br><span class="line">        <span class="keyword">else</span> findright(root.right,res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左-叶子-右 的顺序。定义三个函数各自找左叶右。注意左右函数里，当root左右都为空时要返回停止。只有找叶子结点时才res.add。<br><br>
注意找右时，res.add顺序在递归之后。</p>
<h2 id="table-tr-td-bgcolor-orange-222-Count-Complete-Tree-Nodes-td-tr-table"><table><tr><td bgcolor="orange">222. Count Complete Tree Nodes</td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = countleft(root);</span><br><span class="line">        <span class="keyword">int</span> right = countright(root);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span>&lt;&lt;left) -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countleft</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            dep++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countright</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            dep++;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a herf="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Complete Tree Wiki 定义</a> <br><br>
所以如果最左或者最右有一个空缺就不是complete tree。所以找最左最右的深度。<br><br>
如果相同，则直接返回树 1&lt;&lt;深度 -1就是node的个数。&lt;&lt;相当于对深度取2的对数。<br><br>
如果左右深度不相同则递归继续找各自左右子树并且加1（当前node）。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 68 💪</title>
    <url>/2020/02/01/chin-up-06/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-56-Merge-Intervals-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">56. Merge Intervals</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals)&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= time[<span class="number">0</span>])&#123;</span><br><span class="line">                end = Math.max(end,time[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">                start = time[<span class="number">0</span>];</span><br><span class="line">                end = time[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照start sort一下。只有end大于当前time的start时，两个interval才存在overlap。更新end为最大的。否则将当前start，end加入res。更新start和end为time[0] 和time[1]。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-253-Meeting-Rooms-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">253. Meeting Rooms II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">        <span class="keyword">int</span> rooms = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(start);</span><br><span class="line">        Arrays.sort(end);</span><br><span class="line">        <span class="keyword">int</span> endidx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;start.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start[i] &lt; end[endidx])rooms++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                endidx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rooms;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start 和 end 全部sort。遍历start，遇到小于end[]endidx]的start则+1，否则更新endidx。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-973-K-Closest-Points-to-Origin-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">973. K Closest Points to Origin</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;getdist(a)-getdist(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] point : points)&#123;</span><br><span class="line">            queue.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;K;i++)&#123;</span><br><span class="line">            res[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getdist</span><span class="params">(<span class="keyword">int</span>[] point)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>]*point[<span class="number">0</span>] + point[<span class="number">1</span>]*point[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般top k的题都用pq + 重写sort，然后维护k大的pq，最后要么返回peek要么poll k次就可以。这道题写法没有维护k大。最后poll k次即可。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-57-Insert-Interval-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">57. Insert Interval</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">1</span>] &lt; interval[<span class="number">0</span>])&#123;</span><br><span class="line">                res.add(newInterval);</span><br><span class="line">                newInterval = interval;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newInterval[<span class="number">0</span>] &gt; interval[<span class="number">1</span>])&#123;</span><br><span class="line">                res.add(interval);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = Math.min(interval[<span class="number">0</span>],newInterval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(interval[<span class="number">1</span>],newInterval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和56相似的思路。三种情况：<br></p>
<ol>
<li>interval完全 &lt; newInterval</li>
<li>newInterval完全&lt; interval 此时interval变为newinterval继续循环。</li>
<li>二者有overlap。</li>
</ol>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-242-Valid-Anagram-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">242. Valid Anagram</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;t.length() ; i++)&#123;</span><br><span class="line">            arr[t.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            arr[s.charAt(i)-<span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个26的arr，遍历s++，遍历t–，如果两个相同则最后arr里应该都是0，否则为false。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-75-Sort-Colors-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">75. Sort Colors</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">Question Link &gt;&gt;&gt;</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            bucket[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;bucket.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> count = <span class="number">0</span>;count &lt; bucket[i] ; count++)&#123;</span><br><span class="line">                nums[pos] = i;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bucket sort + inplace change nums数组。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Sort</tag>
        <tag>Interval</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 69 💪</title>
    <url>/2020/02/02/chin-up-07/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-163-Missing-Ranges-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">163. Missing Ranges</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/missing-ranges/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> next = lower;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == nums[i]) &#123;</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;next)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(range(next, nums[i] - <span class="number">1</span>));</span><br><span class="line">                next = nums[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (next == Integer.MIN_VALUE)<span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next &lt;= upper) res.add(range(next, upper));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">range</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> low == high ? String.valueOf(low) : (low + <span class="string">"-&gt;"</span> + high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历nums，更新next，如果next &lt; &gt;nums[i]则存在gap，加入res，之后更新next为当前nums[i]+1继续遍历。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-168-Excel-Sheet-Column-Title-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">168. Excel Sheet Column Title</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/excel-sheet-column-title/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + n%<span class="number">26</span>));</span><br><span class="line">            n = n/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从后往前找，先取余数再取摸，最后reverse一下就是正确顺序的res。<br><br>
Time Complexity : O(N)</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-93-Restore-IP-Addresses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">93. Restore IP Addresses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span> &amp;&amp; i&lt;len-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+<span class="number">4</span> &amp;&amp; j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;j+<span class="number">4</span> &amp;&amp; k&lt;len;k++)&#123;</span><br><span class="line">                    String s1 = s.substring(<span class="number">0</span>,i);</span><br><span class="line">                    String s2 = s.substring(i,j);</span><br><span class="line">                    String s3 = s.substring(j,k);</span><br><span class="line">                    String s4 = s.substring(k,len);</span><br><span class="line">                    <span class="keyword">if</span>(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123;</span><br><span class="line">                        res.add(s1+<span class="string">"."</span>+s2+<span class="string">"."</span>+s3+<span class="string">"."</span>+s4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length()&gt;<span class="number">3</span>||a.length()==<span class="number">0</span>||(a.charAt(<span class="number">0</span>)==<span class="string">'0'</span> &amp;&amp; a.length()&gt;<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(a) &gt; <span class="number">255</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>合格IP地址 ：最多3位，最大255，如果是0只有一位。三层循环把s分成四部分，依次循环比较。<br>
Time Complexity：O(N)</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-32-Longest-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">32. Longest Valid Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)open++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(open &gt;<span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-dp[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i-dp[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                open--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp。open&gt;0时才对 ）操作。注意题目要求最长连续valid，所以要检查一下i-dp[i]，即：在当前合格的括号长度之前，有无合格的长度存在，有的话加起来，没有则继续dp。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-125-Valid-Palindrome-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">125. Valid Palindrome </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(l))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(r))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(l) != Character.toLowerCase(r))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针。注意isLetterOrDigit和toLowerCase的用法。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-819-Most-Common-Word-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">819. Most Common Word</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/most-common-word/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(paragraph == <span class="keyword">null</span> || paragraph.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; ban = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String[] strs = paragraph.toLowerCase().split(<span class="string">"\\W++"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : banned)&#123;</span><br><span class="line">            ban.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ban.contains(str))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> map.put(str,map.getOrDefault(str,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) &gt; max)&#123;</span><br><span class="line">                max = map.get(key);</span><br><span class="line">                res = key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。set存banned word， map存不在set里的word次数。维护max和res不断遍历map的keyset。最后返回res。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-72-Edit-Distance-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">72. Edit Distance</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] edit = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;=len1 ;i++)&#123;</span><br><span class="line">            edit[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;=len2 ;i++)&#123;</span><br><span class="line">            edit[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;len1 ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;len2 ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i) == word2.charAt(j))&#123;</span><br><span class="line">                    edit[i+<span class="number">1</span>][j+<span class="number">1</span>] = edit[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> replace = edit[i][j];</span><br><span class="line">                    <span class="keyword">int</span> delete = edit[i+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">int</span> insert = edit[i][j+<span class="number">1</span>];</span><br><span class="line">                    edit[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.min(replace,Math.min(delete,insert))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edit[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。先初始化edit两个边缘的值。然后一一遍历。除了相同以外，有三种操作，所以当前操作次数为三种最小值+1。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-13-Roman-to-Integer-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">13. Roman to Integer </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        roman = &#123;<span class="string">'I'</span>:<span class="number">1</span>,<span class="string">'V'</span>:<span class="number">5</span>,<span class="string">'X'</span>:<span class="number">10</span>,<span class="string">'L'</span>:<span class="number">50</span>,<span class="string">'C'</span>:<span class="number">100</span>,<span class="string">'D'</span>:<span class="number">500</span>,<span class="string">'M'</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> roman[s[i]] &lt; roman[s[i+<span class="number">1</span>]]:</span><br><span class="line">                z-=roman[s[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                z+=roman[s[i]]</span><br><span class="line">        <span class="keyword">return</span> z + roman[s[<span class="number">-1</span>]]</span><br></pre></td></tr></table></figure>
<p>python。建map存对应值。IV 这种情况减法操作，VI这种情况加法操作。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-97-Interleaving-String-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">97. Interleaving String</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((s1.length() + s2.length())!= s3.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">boolean</span>[s2.length()+<span class="number">1</span>][s1.length()+<span class="number">1</span>];</span><br><span class="line">        matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            matrix[<span class="number">0</span>][i] = matrix[<span class="number">0</span>][i-<span class="number">1</span>] &amp;&amp; (s1.charAt(i-<span class="number">1</span>) == s3.charAt(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = matrix[i-<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; (s2.charAt(i-<span class="number">1</span>) == s3.charAt(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                matrix[i][j] = (matrix[i-<span class="number">1</span>][j] &amp;&amp; (s2.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>))) || (matrix[i][j-<span class="number">1</span>] &amp;&amp; (s1.charAt(j-<span class="number">1</span>)== s3.charAt(i+j-<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[s2.length()][s1.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP表表示当s1在第i个位置并且s2在第j个位置时，s3是否在第（i + j）个位置交织。第0位表示空字符串。</p>
<p>因此，如果s1和s2当前都为空，则s3也为空，并且被认为是交织的。如果只有s1为空，则如果先前的s2位置正在交织并且当前s2位置char等于s3当前位置char，则认为是交织。类似的想法也适用于s2为空的情况。当s1和s2都不为空时，如果我们从i-1，j到达i，j，则如果i-1，j已经交织并且i和当前s3位置相等，则为交织。如果我们从i，j-1到达i，j，则如果i，j-1已经交织并且j和当前s3位置相等。它是交错的。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>String</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 71 💪</title>
    <url>/2020/02/04/chin-up-09/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-11-Container-With-Most-Water-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">11. Container With Most Water </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max = Math.max(max,Math.min(height[left],height[right]) * (right - left ));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针。取当前height[left] height[right]的最小值为高，right和left的差为长，相乘为当前area，与max比较。如果left的height小于right，则left++，否则right–。目的是保证一侧为最大高度。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-42-Trapping-Rain-Water-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">42. Trapping Rain Water</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmost = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> rightmost = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftmost = Math.max(leftmost,height[left]);</span><br><span class="line">            rightmost = Math.max(rightmost,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(leftmost &lt; rightmost)&#123;</span><br><span class="line">                area+=leftmost-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                area+=rightmost-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。双指针。维护最左和最右边的最大高度，如果最左边最高小于最右边最高，通过短板木桶原理，可知当前最大存水只能在最左边，所以用height[left]和leftmost比较，他俩的差就是左边区域可以存的水量。右边同理。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-986-Interval-List-Intersections-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">986. Interval List Intersections</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a= <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a &lt; A.length &amp;&amp; b &lt; B.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = Math.max( A[a][<span class="number">0</span>] , B[b][<span class="number">0</span>] );</span><br><span class="line">            <span class="keyword">int</span> end = Math.min( A[a][<span class="number">1</span>] , B[b][<span class="number">1</span>] );</span><br><span class="line">            <span class="keyword">if</span>(start &lt;= end)res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">            <span class="keyword">if</span>( A[a][<span class="number">1</span>] &lt; B[b][<span class="number">1</span>] ) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] num : res)&#123;</span><br><span class="line">            ans[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two pointer。只有当两个interval的开头最大值 小于 结束最小值时，才会有overlap。接着，不论有没有overlap，如果第一个的结尾小于第二个的结尾，将第一个向后移动，否则第二个向后移动，继续遍历。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-209-Minimum-Size-Subarray-Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">209. Minimum Size Subarray Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, sum = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length ;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                min = Math.min(min,i-start+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two pointer。当sum &gt; s的时候，从start开始减。维护一个min最后返回。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-75-Sort-Color-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">75. Sort Color </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            bucket[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; bucket[i] ;count++)&#123;</span><br><span class="line">                nums[pos] = i;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bucket sort.</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-349-Intersection-of-Two-Arrays-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">349. Intersection of Two Arrays</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            set1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(num))&#123;</span><br><span class="line">                set2.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[set2.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : set2)&#123;</span><br><span class="line">            res[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个set检查重复元素，最后返回set2.</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-350-Intersection-of-Two-Arrays-II-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">350. Intersection of Two Arrays II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                temp.add(num);</span><br><span class="line">                map.put(num,map.get(num)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;temp.size();i++)&#123;</span><br><span class="line">            ans[i] = temp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一道题不同点在于要返回所有重复部分的数字，不单单是一个代表了。所以要用到map来存出现次数。次数为零 or 次数不为零但是不再出现该数字时，找下一个数字。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BackTracking</tag>
        <tag>TwoPointers</tag>
        <tag>BucketSort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 74 💪</title>
    <url>/2020/02/07/chin-up-12/</url>
    <content><![CDATA[<h1>BFS 题目</h1>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-675-Cut-Off-Trees-for-Golf-Event-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">675. Cut Off Trees for Golf Event</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(forest == <span class="keyword">null</span> || forest.get(<span class="number">0</span>).size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//corner case</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = forest.size();</span><br><span class="line">        <span class="keyword">int</span> n = forest.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span> ;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(forest.get(i).get(j) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j,forest.get(i).get(j)&#125;);<span class="comment">//add all num that &gt; 1 to pq.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;<span class="comment">// iterate for each num</span></span><br><span class="line">            <span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> step = getmin(forest,start,tree,m,n,moves);<span class="comment">// start bfs iterate to find minstep to get to the tree.</span></span><br><span class="line">            <span class="keyword">if</span>(step == -<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            sum+=step;</span><br><span class="line">            start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">            start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmin</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span>[][]moves)</span></span>&#123;</span><br><span class="line">        <span class="comment">// normal bfs to find the min step.</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        seen[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; temp[<span class="number">1</span>] == tree[<span class="number">1</span>])<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] move : moves)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = temp[<span class="number">0</span>]+move[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = temp[<span class="number">1</span>]+move[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                        seen[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pq存每个位置的大小，并且按照从小到大poll出。把大于1的点存进pq，poll出第一个点是要到达的tree，一开始默认start为0，0 。bfs写法虽然熟练但是细节还是要注意。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-127-Word-Ladder-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">127. Word Ladder</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/word-ladder/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">       Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">       Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queue.add(beginWord);</span><br><span class="line">       <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">int</span> size = queue.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">               String temp = queue.poll();</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j &lt;endWord.length();j++)&#123;</span><br><span class="line">                   <span class="keyword">char</span>[] chs = temp.toCharArray();</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span> ; c&lt;=<span class="string">'z'</span> ;c++)&#123;</span><br><span class="line">                       chs[j] = c;</span><br><span class="line">                       String newone = <span class="keyword">new</span> String(chs);</span><br><span class="line">                       <span class="keyword">if</span>(set.contains(newone))&#123;</span><br><span class="line">                           <span class="keyword">if</span>(endWord.equals(newone))<span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                           set.remove(newone);</span><br><span class="line">                           queue.add(newone);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           step++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS。每个char改变后记得new一个string来检查。如果存在set里，则要remove掉，避免重复用。</p>
<h1>Partition 题目</h1>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-698-Partition-to-K-Equal-Sum-Subsets-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">698. Partition to K Equal Sum Subsets</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)sum+=num;</span><br><span class="line">        <span class="keyword">if</span>( sum % k != <span class="number">0</span>  || k&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> check(nums,seen,<span class="number">0</span>,k,<span class="number">0</span>,sum/k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[]seen, <span class="keyword">int</span> start, <span class="keyword">int</span> k, <span class="keyword">int</span> cursum,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cursum == target)<span class="keyword">return</span> check(nums,seen,<span class="number">0</span>,k-<span class="number">1</span>,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen[i])&#123;</span><br><span class="line">                seen[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(check(nums,seen,i+<span class="number">1</span>, k ,cursum + nums[i], target))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                seen[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs。k个sum相同的substet，即每个的sum都为nums的和/k。递归寻找，如果当前cursum等于目标值target，返回上一层递归，找剩下的k-1个。否则对每个没遇到的数进行dfs+backtracking，之后把该数变为未见过。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-93-Restore-IP-Addresses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">93. Restore IP Addresses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span> &amp;&amp; i&lt;len-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;i+<span class="number">4</span> &amp;&amp; j&lt;len-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;j+<span class="number">4</span> &amp;&amp; k&lt;len;k++)&#123;</span><br><span class="line">                    String s1 = s.substring(<span class="number">0</span>,i);</span><br><span class="line">                    String s2 = s.substring(i,j);</span><br><span class="line">                    String s3 = s.substring(j,k);</span><br><span class="line">                    String s4 = s.substring(k,len);</span><br><span class="line">                    <span class="keyword">if</span>(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123;</span><br><span class="line">                        res.add(s1+<span class="string">"."</span>+s2+<span class="string">"."</span>+s3+<span class="string">"."</span>+s4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length()&gt;<span class="number">3</span>||a.length()==<span class="number">0</span>||(a.charAt(<span class="number">0</span>)==<span class="string">'0'</span> &amp;&amp; a.length()&gt;<span class="number">1</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(a) &gt; <span class="number">255</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分part讨论。具体解析之前的<a href="http://leeemask.com/2020/02/02/chin-up-07/#table-tr-td-bgcolor-F5B041-font-color-white-93-Restore-IP-Addresses-font-td-tr-table" target="_blank" rel="noopener">每日笔记</a>写过。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-131-Palindrome-Partitioning-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">131. Palindrome Partitioning</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(res,templist,<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; templist, <span class="keyword">int</span> start, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start ;i &lt; s.length() ; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid(s,start,i))&#123;</span><br><span class="line">                    templist.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">                    help(res,templist,i+<span class="number">1</span>,s);</span><br><span class="line">                    templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>dfs + backtracking.</li>
<li>Add one function to check whether the string is Palindrome.</li>
<li>Remember we start from the left most and right most, it’s different from the previous questions which start from the center to two sides.</li>
</ol>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-241-Different-Ways-to-Add-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">241. Different Ways to Add Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;input.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span> || c== <span class="string">'-'</span> || c==<span class="string">'*'</span>)&#123;</span><br><span class="line">                String part1 = input.substring(<span class="number">0</span>,i);</span><br><span class="line">                String part2 = input.substring(i+<span class="number">1</span>);</span><br><span class="line">                List&lt;Integer&gt; list1 = map.getOrDefault(part1,diffWaysToCompute(part1));</span><br><span class="line">                List&lt;Integer&gt; list2 = map.getOrDefault(part2,diffWaysToCompute(part2));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num1 : list1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> num2 : list2)&#123;</span><br><span class="line">                        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                                cursum = num1 + num2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                                cursum = num1 - num2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                                cursum = num1 * num2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        res.add(cursum);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>)res.add(Integer.valueOf(input));</span><br><span class="line">        map.put(input,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Recursive + Memo.</li>
<li>Using map to store the correspond total possible answers to the current part of string. This way can help reduce the total time because we have already store the key-value of them.</li>
<li>In terms of different operation symbol, we have to add different number to the res。</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>Partition</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 72 💪</title>
    <url>/2020/02/05/chin-up-10/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-752-Open-the-Lock-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">752. Open the Lock </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/open-the-lock/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; deads = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str: deadends)&#123;</span><br><span class="line">            deads.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="string">"0000"</span>);</span><br><span class="line">        seen.add(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                String temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(deads.contains(temp))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(temp.equals(target))<span class="keyword">return</span> steps;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">char</span> c = temp.charAt(j);</span><br><span class="line">                    String s1 = temp.substring(<span class="number">0</span>,j) + ( c ==<span class="string">'9'</span> ? <span class="number">0</span>:c-<span class="string">'0'</span>+<span class="number">1</span> ) + temp.substring(j+<span class="number">1</span>);</span><br><span class="line">                    String s2 = temp.substring(<span class="number">0</span>,j) + ( c ==<span class="string">'0'</span> ? <span class="number">9</span>:c-<span class="string">'0'</span>-<span class="number">1</span> ) + temp.substring(j+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(!seen.contains(s1) &amp;&amp;!deads.contains(s1))&#123;</span><br><span class="line">                        queue.add(s1);</span><br><span class="line">                        seen.add(s1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!seen.contains(s2) &amp;&amp;!deads.contains(s2))&#123;</span><br><span class="line">                        queue.add(s2);</span><br><span class="line">                        seen.add(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典BFS。注意对四位分别进行顺时针+1和 逆时针+1操作，并且判断新的string是否在deads和seen里，然后加入queue。注意两个string只能equals比较是否相同，==没用，会一直不成功。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-33-Search-in-Rotated-Sorted-Array-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">33. Search in Rotated Sorted Array</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target&lt;= nums[mid] &amp;&amp; target &gt;= nums[left])&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[len])&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] == target)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[right] == target)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sort的数组被rotate后肯定有两部分递增的区域。mid&gt;left说明mid在较大的递增一侧，否则是在较小的递增区。针对每个区，进行正常的binary search操作，对left和right操作。<br><br>
由于用的是while left + 1 &lt; right的写法，所以最后要先检查left是否等于target，然后再检查right。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-79-Word-Search-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">79. Word Search </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/word-search/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(find(board,i,j,word,<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j,String word, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == word.length())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=board.length || j&lt;<span class="number">0</span> || j&gt;=board[<span class="number">0</span>].length || board[i][j] != word.charAt(index))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = find(board,i+<span class="number">1</span>,j,word,index+<span class="number">1</span>) ||</span><br><span class="line">                      find(board,i,j+<span class="number">1</span>,word,index+<span class="number">1</span>) ||</span><br><span class="line">                      find(board,i,j-<span class="number">1</span>,word,index+<span class="number">1</span>) ||</span><br><span class="line">                      find(board,i-<span class="number">1</span>,j,word,index+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + backtracking. 注意dfs之前把改为值的字符变为*，dfs之后再恢复。本质就是在搜索树的所有情况里找是否存在word这个排列组合。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-784-Letter-Case-Permutation-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">784. Letter Case Permutation</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/letter-case-permutation/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="BFS-Solution">BFS Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(S);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(S.charAt(i)))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;size;j++)&#123;</span><br><span class="line">                String str = queue.poll();</span><br><span class="line">                <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                <span class="comment">// upper case</span></span><br><span class="line">                ch[i] = Character.toUpperCase(ch[i]);</span><br><span class="line">                queue.add(String.valueOf(ch));</span><br><span class="line">                <span class="comment">//lower case</span></span><br><span class="line">                ch[i] = Character.toLowerCase(ch[i]);</span><br><span class="line">                queue.add(String.valueOf(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : queue)&#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把每个字母大小写情况全加进queue，然后依次往后循环遍历，最后把S中每个字母大小写的所有情况全部加入了queue。注意跳过为数字的char。最后queue中的个数应该是S字母长度的阶乘。</p>
<h3 id="DFS-Solution">DFS Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = S.toCharArray();</span><br><span class="line">        help(s,res,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">char</span>[] s, List&lt;String&gt; res, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == s.length)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(s));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ignore digit case</span></span><br><span class="line">        <span class="keyword">if</span>(s[pos]&gt;=<span class="string">'0'</span> &amp;&amp; s[pos]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            help(s,res,pos+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//upper case</span></span><br><span class="line">        s[pos] = Character.toUpperCase(s[pos]);</span><br><span class="line">        help(s,res,pos+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// lower case</span></span><br><span class="line">        s[pos] = Character.toLowerCase(s[pos]);</span><br><span class="line">        help(s,res,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upper 和 lower的情况都要各自进行dfs。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-560-Subarray-Sum-Equals-K-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">560. Subarray Sum Equals K</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">                count += map.get(sum- k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三遍。Presum方法。sum一直累加，map存各个sum值的次数。count加上sum-k就是目前的subarray数量。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-55-Jump-Game-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">55. Jump Game</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;dist)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            dist = Math.max(dist,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>greedy。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-45-Jump-Game-II-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">45. Jump Game II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/jump-game-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curend = <span class="number">0</span>, fast = <span class="number">0</span>, steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = Math.max(fast,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == curend)&#123;</span><br><span class="line">                curend = fast;</span><br><span class="line">                steps++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>curend是上一步最远距离，如果到达了curend，则step++，说明上一步的起跳已经结束。将下一个curend更新为fast。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1306-Jump-Game-III-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1306. Jump Game III</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/jump-game-iii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="Recursive-Soluiton">Recursive Soluiton</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;= <span class="number">0</span> &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;=<span class="number">0</span> &amp;&amp; arr[start] &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> jumpto = arr[start];</span><br><span class="line">            arr[start] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(jumpto == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> canReach(arr,start + jumpto) || canReach(arr,start - jumpto);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jump是当前能跳的步数，然后将其变为-1。如果jumpto是0，则直接返回true。否则递归调用向左或向右跳的情况。</p>
<h3 id="Iterative-Solution">Iterative Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canReach</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        HashSet&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(arr[idx] == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(seen.contains(idx))<span class="keyword">continue</span>;</span><br><span class="line">            seen.add(idx);</span><br><span class="line">            <span class="keyword">if</span>(idx + arr[idx]&lt;arr.length)&#123;</span><br><span class="line">                queue.add(idx + arr[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(idx - arr[idx] &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(idx - arr[idx]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queue bfs。 seen判断是否走过。保证当前坐标加上最大步数小于arr.length 以及 &gt;=0。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>BinarySearch</tag>
        <tag>Presum</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 73 💪</title>
    <url>/2020/02/06/chin-up-11/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-451-N-Queens-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">451. N-Queens</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] chess = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                chess[i][j] = <span class="string">'.'</span>; <span class="comment">// used to created new chess board.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(chess,<span class="number">0</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] chess, <span class="keyword">int</span> row, List&lt;List&lt;String&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == chess.length)&#123;</span><br><span class="line">            res.add(build(chess));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chess.length;col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(row,col,chess))&#123;</span><br><span class="line">                chess[row][col] = <span class="string">'Q'</span>; <span class="comment">// 改成Q</span></span><br><span class="line">                dfs(chess,row+<span class="number">1</span>,res); <span class="comment">// dfs到下一行</span></span><br><span class="line">                chess[row][col] = <span class="string">'.'</span>; <span class="comment">//改回 ’.'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span> row ,<span class="keyword">int</span> col, <span class="keyword">char</span>[][]chess)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row; i++)&#123; <span class="comment">// 检查同一列有无Q，行不用检查因为根据行遍历。</span></span><br><span class="line">            <span class="keyword">if</span>(chess[i][col] == <span class="string">'Q'</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row-<span class="number">1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp;j&lt;chess.length;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] == <span class="string">'Q'</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//检查正对角线有无Q</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>,j=col-<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> ;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i][j] ==<span class="string">'Q'</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="comment">//检查逆对角线有无Q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">build</span><span class="params">(<span class="keyword">char</span>[][] chess)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//最后把chess根据每一行加入res。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;chess.length;i++)&#123;</span><br><span class="line">            path.add(<span class="keyword">new</span> String(chess[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS。queen游戏规则是同一列/同一行/正对角/斜对角不能有Q存在，由于我们根据行数来遍历dfs，所以检查valid函数要考虑（列/正对角/斜对角）三种情况。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-52-N-Queens-II-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">52. N-Queens II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-queens-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        solve(<span class="number">0</span>,n,col,diag1,diag2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[] col, <span class="keyword">boolean</span>[] diag1, <span class="keyword">boolean</span>[]diag2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[j] &amp;&amp; !diag1[j + row] &amp;&amp; !diag2[j-row+n-<span class="number">1</span>])&#123;</span><br><span class="line">                col[j] = diag1[j+row] = diag2[j-row+n-<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                solve(row+<span class="number">1</span>,n,col,diag1,diag2);</span><br><span class="line">                col[j] = diag1[j+row] = diag2[j-row+n-<span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS。和I不同之处是要返回可能的情况个数，但是不用像I一样麻烦。思路一样，对三个方向检查，true表明有Q，false表明没有Q，创建三个方向的boolean数组，这里要注意正/斜对角的个数以及index和row，col的关系，画个图就能明白。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-37-Sudoku-Solver-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">37. Sudoku Solver</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;board[<span class="number">0</span>].length ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] ==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span> ; c&lt;=<span class="string">'9'</span> ;c++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(valid(board,i,j,c))&#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">9</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// check each col;</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check each row;</span></span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span>*(row /<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]!=<span class="string">'.'</span>&amp;&amp;board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]==c)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS。类似queen的题。遍历图，对‘.‘的点进行dfs。从1-9进行选择，然后检查当前选择的数是否可以放，如果可以则调用solve函数继续dfs。如果不行则把当前位置变回’.’。<br><br>
难点在valid函数里对每一个3x3方格的检查。行用/ 列用%。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-22-Generate-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">22. Generate Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        dfs(<span class="string">""</span>,res,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String cur, List&lt;String&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)res.add(cur);</span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            dfs(cur+<span class="string">"("</span>,res,left+<span class="number">1</span>,right,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; left)&#123;</span><br><span class="line">            dfs(cur+<span class="string">")"</span>,res,left,right+<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs。left和right都为n个，则把list加入res。只有当right&lt;left时才递归加入右括号。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-542-01-Matrix-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">542. 01 Matrix </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/01-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] move : moves)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cur[<span class="number">0</span>] + move[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = cur[<span class="number">1</span>] + move[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">0</span> || y&lt;<span class="number">0</span> || x&gt;=m ||y&gt;=n || matrix[x][y] !=-<span class="number">1</span> )<span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                matrix[x][y] = matrix[cur[<span class="number">0</span>]][cur[<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs。先把0的坐标加进queue，把不为零的位置值变为-1。从外围往里扫描，如果更新后的位置不为-1，说明没有找到不为零的位置，继续扫描。如果更新后的位置为-1，说明当前位置是0，所以把更新后位置的值变为当前位置+1，依次类推。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-934-Shortest-Bridge-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">934. Shortest Bridge </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/shortest-bridge/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.length, n = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// dfs to find the whole index of first island.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (found) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dfs(A, visited, q, i, j, dirs);</span><br><span class="line">                    found = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// using bfs to find the step to connect another island</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> j = cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step;</span><br><span class="line">                        &#125;</span><br><span class="line">                        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">boolean</span>[][] visited, Queue&lt;<span class="keyword">int</span>[]&gt; q, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] dirs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= A.length || j &gt;= A[<span class="number">0</span>].length || visited[i][j] || A[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            dfs(A, visited, q, i + dir[<span class="number">0</span>], j + dir[<span class="number">1</span>], dirs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + bfs。 dfs来找任意一个1所属的island的所有1的坐标。bfs则用来根据当前找到的island所有坐标，来找能连接到另外一个岛的1所需要的steps。dfs过程中需定义一个boolean值来判断是否找到全部的岛，如果true则直接进入bfs。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 77 💪</title>
    <url>/2020/02/10/chin-up-15/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1267-Count-Servers-that-Communicate-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1267. Count Servers that Communicate</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    row[i]+=<span class="number">1</span>;</span><br><span class="line">                    col[j]+=<span class="number">1</span>;</span><br><span class="line">                    total++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[i] == <span class="number">1</span> &amp;&amp; col[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        total--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>col 和 row用来记录这一行有多少个电脑，如果最后某个位置为电脑并且所在的行和列都只有1个，那么就是没有连接的，要从total里减去。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-207-Course-Schedule-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">207. Course Schedule</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;indegree.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toplogical sort.按照课程顺序增加indegree。然后从indegree0的开始遍历。判断最后课程是否为零。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-210-Course-Schedule-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">210. Course Schedule II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;indegree.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                res[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                        res[index] = pair[<span class="number">0</span>];</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses ? res : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和course schedule 一样的思路。只不过这道题要求按顺序输出课程顺序，只需要维护一个res并且更新index，不断加入indegree为0的课程即可。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">802. Find Eventual Safe States</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,i,state))res.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> num, <span class="keyword">int</span>[] state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[num] != <span class="number">0</span>)<span class="keyword">return</span> state[num] == <span class="number">1</span>;</span><br><span class="line">        state[num] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : graph[num])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,n,state))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state[num] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs. 目的是找到一个num，它不能跳转到别的数字。方法是找数组里的cycle。每个数有三种state，1-unvisited, 2- safe, 3-unsafe. 如果当前的num存在cycle或者num能到达的数里存在cycle，则该数不安全，状态为2. 如果没有cycle，则是安全的。dfs递归做就可以。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
        <tag>DFS</tag>
        <tag>Topological</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 78 💪</title>
    <url>/2020/02/11/chin-up-16/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-990-Satisfiability-of-Equality-Equations-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">990. Satisfiability of Equality Equations</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] UF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(equations.length == <span class="number">0</span> || equations == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">26</span> ;i++)&#123;</span><br><span class="line">            UF[i] = i; <span class="comment">// initialiaze uf array</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123; <span class="comment">// == case, the same as link between the two 字母</span></span><br><span class="line">                UF[find(str.charAt(<span class="number">0</span>)-<span class="string">'a'</span>)] = find(str.charAt(<span class="number">3</span>)-<span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>( str.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123; <span class="comment">// != case, means cut off the link between two 字母</span></span><br><span class="line">                <span class="keyword">if</span> ( find(str.charAt(<span class="number">0</span>)-<span class="string">'a'</span>) == find( str.charAt(<span class="number">3</span>) -<span class="string">'a'</span>)) &#123;</span><br><span class="line">                    <span class="comment">// only if the two char has been linked before but it is in != case then we can return false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">// classic find function</span></span><br><span class="line">        <span class="keyword">if</span>( a!= UF[a]) UF[a] = find(UF[a]);</span><br><span class="line">        <span class="keyword">return</span> UF[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uf把==的两个字母连起来。然后去判断！=的情况里，如果两个字母已经是union的了，但是处在！=情况里，则返回false，表明这个方程组无解。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-98-Validate-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">98. Validate Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root,Long.MIN_VALUE,Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive. BST 经常要用设置上下界来解决。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-530-Minimum-Absolute-Difference-in-BST-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">530. Minimum Absolute Difference in BST</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="Recursive">Recursive</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root,Integer.MIN_VALUE,Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root , <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(min != Integer.MIN_VALUE)res=Math.min(res,root.val - min);</span><br><span class="line">        <span class="keyword">if</span>(max != Integer.MAX_VALUE)res=Math.min(res,max - root.val);</span><br><span class="line">        help(root.left,min,root.val);</span><br><span class="line">        help(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一题一样，设置两个边界，更新res为最小值即可。</p>
<h3 id="Stack-Iteraive">Stack Iteraive</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt;stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(prev!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    min = Math.min(min,cur.val - prev.val);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deep in-order traversal。 BST则深度中序遍历就可以解决。记住stack traversal模版。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-700-Search-in-a-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">700. Search in a Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)<span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)<span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>simple recursive with different cases with val and root.val.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-701-Insert-into-a-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">701. Insert into a Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive. BST经常用两个up / down的boundary来判断操作条件。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-230-Kth-Smallest-Element-in-a-BST-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">230. Kth Smallest Element in a BST</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> cur.val;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一道BST深度in-order的思路。Kth smallest的题。从最左开始，处理到第k个就是第k小。如果改成kth largest，则就是处理到第number of nodes -k个。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 75 💪</title>
    <url>/2020/02/07/chin-up-13/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-133-Clone-Graph-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">133. Clone Graph</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        map.put(node,dummy);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(Node nb : temp.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(nb))&#123;</span><br><span class="line">                    map.put(nb, <span class="keyword">new</span> Node(nb.val));</span><br><span class="line">                    queue.add(nb);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(temp).neighbors.add(map.get(nb));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using map to store the node and its copy. Creating dummy node to keep track of the head. Using queue to make bfs of each node in the graph.</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-138-Copy-List-with-Random-Pointer-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">138. Copy List with Random Pointer</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(node,<span class="keyword">new</span> Node(node.val));</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(node).next = map.get(node.next);</span><br><span class="line">            map.get(node).random = map.get(node.random);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using map to store node and its copy, then we iteratively arrange the correct next node and random node to its copy.Loop the map for two times, one for store, another for arrangement.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-200-Number-of-Islands-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">200. Number of Islands</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/number-of-islands/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j,m,n); <span class="comment">//dfs</span></span><br><span class="line">                    sum++;<span class="comment">// if dfs end, it means we find an island.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;m &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp;grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">            grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">// try for different directions.</span></span><br><span class="line">            dfs(grid,i+<span class="number">1</span>,j,m,n);</span><br><span class="line">            dfs(grid,i,j+<span class="number">1</span>,m,n);</span><br><span class="line">            dfs(grid,i-<span class="number">1</span>,j,m,n);</span><br><span class="line">            dfs(grid,i,j-<span class="number">1</span>,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using DFS . When we meet 1, we using dfs to find 1 in four directions. If it stop, it means we find an island and we can not move to the other 1. So we increase sum. THen we try the other position of 1 in the grid.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-547-Friend-Circles-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">547. Friend Circles</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M == <span class="keyword">null</span> || M.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> person = <span class="number">0</span> ; person&lt;M.length ;person++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen[person])&#123;</span><br><span class="line">                dfs(M,person,seen);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> person ,<span class="keyword">boolean</span>[] seen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;M[<span class="number">0</span>].length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[person][i] == <span class="number">1</span> &amp;&amp; !seen[i])&#123;</span><br><span class="line">                seen[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(M,i,seen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似island的题，由于是每个坐标代表一个人，这次只需要一行一行dfs就可以。seen检查是否访问过该人。对坐标值为1的地方一层层递归dfs即可。注意嵌套内dfs的 新person 值是当前 person 的 friend。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-695-Max-Area-of-Island-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">695. Max Area of Island</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/max-area-of-island/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> area = dfs(grid,i,j,m,n,<span class="number">0</span>);</span><br><span class="line">                    max = Math.max(max,area);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n,<span class="keyword">int</span> area)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> ||j&gt;=n || grid[i][j] == <span class="number">0</span>)<span class="keyword">return</span> area;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        area++;</span><br><span class="line">        area = dfs(grid,i+<span class="number">1</span>,j,m,n,area);</span><br><span class="line">        area = dfs(grid,i,j+<span class="number">1</span>,m,n,area);</span><br><span class="line">        area = dfs(grid,i-<span class="number">1</span>,j,m,n,area);</span><br><span class="line">        area = dfs(grid,i,j-<span class="number">1</span>,m,n,area);</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和200题一样的思路。dfs更新area，保持一个max记录最大值。dfs中如果遇到0或者边界问题直接返回area。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-733-Flood-Fill-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">733. Flood Fill</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/flood-fill/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image == <span class="keyword">null</span> || image.length == <span class="number">0</span>)<span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)<span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span> m = image.length;</span><br><span class="line">        <span class="keyword">int</span> n = image[<span class="number">0</span>].length;</span><br><span class="line">        dfs(image,sr,sc,newColor,m,n,image[sr][sc]);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor,<span class="keyword">int</span> m ,<span class="keyword">int</span> n,<span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sr &gt;=<span class="number">0</span> &amp;&amp; sc &gt;=<span class="number">0</span> &amp;&amp; sr&lt;m &amp;&amp; sc&lt;n &amp;&amp; image[sr][sc] == color)&#123;</span><br><span class="line">            image[sr][sc] = newColor;</span><br><span class="line">            dfs(image,sr+<span class="number">1</span>,sc,newColor,m,n,color);</span><br><span class="line">            dfs(image,sr,sc+<span class="number">1</span>,newColor,m,n,color);</span><br><span class="line">            dfs(image,sr-<span class="number">1</span>,sc,newColor,m,n,color);</span><br><span class="line">            dfs(image,sr,sc-<span class="number">1</span>,newColor,m,n,color);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs。注意检查一开始sr sc位置的color是否已经和newcolor相同，如果是直接返回image，就不会stack overflow。不是直接从sr sc开始扩散dfs。只对当前不是newcolor的进行变色。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-827-Making-A-Large-Island-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">827. Making A Large Island</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/making-a-large-island/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max,dfs(i,j,grid,<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n]));</span><br><span class="line">                    <span class="keyword">if</span>(max == m*n)<span class="keyword">return</span> max;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max == Integer.MIN_VALUE ? m*n : max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] seen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span> &amp;&amp; i&lt;grid.length &amp;&amp;j&lt;grid[<span class="number">0</span>].length &amp;&amp;!seen[i][j] &amp;&amp; grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">            seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">1</span> + dfs(i+<span class="number">1</span>,j,grid,seen) + dfs(i,j+<span class="number">1</span>,grid,seen) + dfs(i-<span class="number">1</span>,j,grid,seen) + dfs(i,j-<span class="number">1</span>,grid,seen);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + backtracking. 思路类似island 200. 找0并且backtracking回1。注意boolwean数组一定要在dfs中定义，因为每次dfs保证需要只见到一次的位置不同。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 76 💪</title>
    <url>/2020/02/09/chin-up-14/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1162-As-Far-from-Land-as-Possible-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1162. As Far from Land as Possible</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    seen[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> steps = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt; size ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] move : moves)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = temp[<span class="number">0</span>] + move[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = temp[<span class="number">1</span>] + move[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; x&lt;m &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                        seen[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps&lt;=<span class="number">0</span>?-<span class="number">1</span>:steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS.Store all 1 in to queue. Then try to explore out to 0, then level by level. When the iteration stop, we can find the max distacne.</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-841-Keys-and-Rooms-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">841. Keys and Rooms</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="Iterative-Solution">Iterative Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(rooms == <span class="keyword">null</span> || rooms.size() == <span class="number">9</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> key : rooms.get(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(key))&#123;</span><br><span class="line">                    set.add(key);</span><br><span class="line">                    stack.push(key);</span><br><span class="line">                    <span class="keyword">if</span>(set.size() == rooms.size())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size() == rooms.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using set to store all rooms we can visit, and then iterative to visit every key that current rooms has. We only need to check whether the size of seen is equal to the total rooms.</p>
<h3 id="Recursive-Solution">Recursive Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; <span class="comment">//recursive solution</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        help(<span class="number">0</span>,rooms,seen);</span><br><span class="line">        <span class="keyword">return</span> rooms.size() == seen.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> room, List&lt;List&lt;Integer&gt;&gt; rooms, Set&lt;Integer&gt; seen)</span></span>&#123;</span><br><span class="line">        seen.add(room);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : rooms.get(room))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.contains(key))help(key,rooms,seen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Change the iterative solution to recursive. The idea is the same.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1202-Smallest-String-With-Swaps-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1202. Smallest String With Swaps</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestStringWithSwaps</span><span class="params">(String s, List&lt;List&lt;Integer&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            parent[i]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; pair : pairs)&#123;</span><br><span class="line">            union(pair.get(<span class="number">0</span>),pair.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,PriorityQueue&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> root = find(i);</span><br><span class="line">            <span class="keyword">if</span>(map.get(root) == <span class="keyword">null</span>)map.put(root, <span class="keyword">new</span> PriorityQueue&lt;&gt;());</span><br><span class="line">            map.get(root).add(chs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;chs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = map.get(parent[i]).poll();</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[i]!=i)&#123;</span><br><span class="line">            parent[i] = parent[parent[i]];</span><br><span class="line">            i = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = find(a);</span><br><span class="line">        <span class="keyword">int</span> root2 = find(b);</span><br><span class="line">        <span class="keyword">if</span>(root1 &lt; root2)&#123;</span><br><span class="line">            parent[root2] = root1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[root1] = root2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次遇到string的union find题。由于可以swap很多次，所以直接对swap的两个index建立parent graph，保证每个连通pard的root最小，各个部分从小到大。然后针对每个最小的开始root建立pq，用来对char排序。保证连通图里root都是从小到大链接，并且char也是从小到大。用map存各个char和各自起始点对应的char pq。最后直接按顺序append返回。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-842-Split-Array-into-Fibonacci-Sequence-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">842. Split Array into Fibonacci Sequence</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(S,res,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, List&lt;Integer&gt; res, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length() &amp;&amp; res.size() &gt; <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start)== <span class="string">'0'</span> &amp;&amp; i&gt;start)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> num = Long.parseLong(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(num &gt; Integer.MAX_VALUE)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line">            <span class="keyword">if</span>(size &gt;= <span class="number">2</span> &amp;&amp; num&gt;res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>))<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(size&lt;=<span class="number">1</span> || num == res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>))&#123;</span><br><span class="line">                res.add((<span class="keyword">int</span>)num);</span><br><span class="line">                <span class="keyword">if</span>(dfs(s,res,i+<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典dfs。要求斐波那契数列，所以res的大小至少为2的时候，待加入的num必须为前两个之和。并且0只能作为0单独使用，如果s charat start是0，那必须只能该位置可以用，后面的位置都不能用0。注意隐藏条件，num还不能大于Integer.MAX_VALUE。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>Tricky</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 80 💪</title>
    <url>/2020/02/14/chin-up-18/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-872-Leaf-Similar-Trees-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">872. Leaf-Similar Trees</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/leaf-similar-trees/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack1.push(root1);</span><br><span class="line">        stack2.push(root2);</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(getleaf(stack1) != getleaf(stack2))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getleaf</span><span class="params">(Stack&lt;TreeNode&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)<span class="keyword">return</span> node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png"></p>
<p>两个stack dfs找叶节点，由于同时找所以比较的也是同一个位置的叶节点。注意while(true)的写法。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-669-Trim-a-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">669. Trim a Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; L)<span class="keyword">return</span> trimBST(root.right,L,R);</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; R)<span class="keyword">return</span> trimBST(root.left,L,R);</span><br><span class="line">        root.left = trimBST(root.left,L,R);</span><br><span class="line">        root.right = trimBST(root.right,L,R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删掉超出L，R范围内的节点。递归就可以了。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1325-Delete-Leaves-With-a-Given-Value-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1325. Delete Leaves With a Given Value</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/delete-leaves-with-a-given-value/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">removeLeafNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)root.left = removeLeafNodes(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)root.right = removeLeafNodes(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == target)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive。 注意最后返回值，如果当前是leaf并且val等于target，要返回null，否则返回原node。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-814-Binary-Tree-Pruning-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">814. Binary Tree Pruning </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-pruning/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">pruneTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)root.left = pruneTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!= <span class="keyword">null</span>)root.right = pruneTre(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码其实和1325一样。1325是去掉指定值的所有target，这道题是要删掉所有0的subtree，其实性质是一样的，collect node之后删掉。从叶节点向上剥洋葱。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-684-Redundant-Connection-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">684. Redundant Connection </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;edges.length ;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(parents,link[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(parents,link[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(root1 == root2)&#123;</span><br><span class="line">                <span class="keyword">return</span> link;</span><br><span class="line">            &#125;</span><br><span class="line">            parents[root1] = root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == parents[i])<span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> parents[i] = find(parents,parents[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>union find 。 如果找到两个点root一样，则说明之前已经link过，是多余的，直接返回。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1319-Number-of-Operations-to-Make-Network-Connected-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1319. Number of Operations to Make Network Connected</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/number-of-operations-to-make-network-connected/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">makeConnected</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(connections.length == <span class="number">0</span> || connections == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(connections.length &lt; n-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;parents.length ;i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> remain = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link : connections)&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(parents,link[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(parents, link[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>( root1 != root2)&#123;</span><br><span class="line">                remain--;</span><br><span class="line">                parents[root1] = root2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> remain -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parents[a] == a)<span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> parents[a] = find(parents, parents[a]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>union find。记录remains剩下没连接的个数，所以最后最少数量是剩下的个数-。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>UnionFind</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 79 💪</title>
    <url>/2020/02/12/chin-up-17/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-99-Recover-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">99. Recover Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode first = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode second = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pre.val &gt; temp.val)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">                        first = pre;</span><br><span class="line">                    &#125;</span><br><span class="line">                    second = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = temp;</span><br><span class="line">            <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                temp = temp.right;</span><br><span class="line">                <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    stack.push(temp);</span><br><span class="line">                    temp = temp.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = first.val;</span><br><span class="line">        first.val = second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in-order深度遍历。然后依次pop，找到第一个pre大于cur的，则pre是第一个错误的地方，紧接着找第二个，如果之前first不为空，说明找到了，则把当前的给second。最后swap一下就可以了。</p>
<!--mode-->
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-450-Delete-Node-in-a-BST-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">450. Delete Node in a BST</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)root.left = deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key)root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)<span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)<span class="keyword">return</span> root.left;</span><br><span class="line">            TreeNode smallest = root.right;</span><br><span class="line">            <span class="keyword">while</span>(smallest.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                smallest = smallest.left;</span><br><span class="line">            &#125;</span><br><span class="line">            smallest.left = root.left;</span><br><span class="line">            <span class="keyword">return</span> root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive.找到key后，判断左右是否为空，如果都不为空，则去右子树找最小值，找到后把当前root左树给到最小值的左树，返回最小值的右树。<br>
Time : O(h) -&gt; h is the height of tree.</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-501-Find-Mode-in-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">501. Find Mode in Binary Search Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    map.put(temp.val,map.getOrDefault(temp.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                    max = Math.max(max,map.get(temp.val));</span><br><span class="line">                    <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                    <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == max)&#123;</span><br><span class="line">                res.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : res)&#123;</span><br><span class="line">            ans[i] = a;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>level traversal + map。 keep max to store the max frequency.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1302-Deepest-Leaves-Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1302. Deepest Leaves Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                res += temp.val;</span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型level traversal里加一个res来计算当前pop出的所有节点的和，但是每次要归零，最后返回的才是最后一层的node的和。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-429-N-ary-Tree-Level-Order-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">429. N-ary Tree Level Order Traversal</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                Node temp = queue.poll();</span><br><span class="line">                templist.add(temp.val);</span><br><span class="line">                <span class="keyword">for</span>(Node child : temp.children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(child!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        queue.add(child);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型层次遍历，只不过判断左右孩子的时候变成了对children的遍历。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-589-N-ary-Tree-Preorder-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">589. N-ary Tree Preorder Traversal</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(Node root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            help(child,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preorder顺序。根 - 左 -右。先对根加入res，再对左右孩子操作。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-590-N-ary-Tree-Postorder-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">590. N-ary Tree Postorder Traversal</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(Node root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node child : root.children)&#123;</span><br><span class="line">            help(child,res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postorder顺序。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-987-Vertical-Order-Traversal-of-a-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">987. Vertical Order Traversal of a Binary Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            node = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;Integer,List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(<span class="number">0</span>,<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.poll();</span><br><span class="line">            min = Math.min(min,temp.x);</span><br><span class="line">            max = Math.max(max,temp.x);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(<span class="keyword">new</span> pair(temp.x,temp.y,temp.node));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x-<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.left));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x+<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= min ;i&lt;= max; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : <span class="number">0</span>);</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;map.get(i).size() ;j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new 一个class 存 x,y,node。 map存相对应x的node，然后从左到右，从min-max对map里对node进行排序，如果同一列的node y坐标也相同，则按小到大排，如果不是则不改变顺序。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 82 💪</title>
    <url>/2020/02/18/chin-up-20/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span> <span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)sb.append(<span class="string">"n"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(root.left,sb);</span><br><span class="line">            serial(root.right,sb); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = data.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserial(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserial</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.equals(<span class="string">"n"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        node.left = deserial(queue);</span><br><span class="line">        node.right = deserial(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preorder方式serial。split之后再preorder deserial。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-449-Serialize-and-Deserialize-BST-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">449. Serialize and Deserialize BST</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        sb.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">        serial(root.left, sb);</span><br><span class="line">        serial(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.isEmpty())<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = data.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserial(queue,Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserial</span><span class="params">(Queue&lt;String&gt; queue,<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty())<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String s = queue.peek();</span><br><span class="line">        <span class="keyword">int</span> val = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(val &lt; min || val &gt; max)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        queue.poll();</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        node.left = deserial(queue, min, val);</span><br><span class="line">        node.right = deserial(queue,val,max);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是BST，可以设置上下界来在deserial的时候判定是否为null。其余的和上一道BT的一样。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-508-Most-Frequent-Subtree-Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">508. Most Frequent Subtree Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/most-frequent-subtree-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findFrequentTreeSum(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        dfs(root);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key) == max)&#123;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; list.size();i++)&#123;</span><br><span class="line">            res[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s = dfs(root.left) + dfs(root.right) + root.val;</span><br><span class="line">        map.put(s,map.getOrDefault(s,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        max = Math.max(max,map.get(s));</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map + dfs。<br>map存sum和次数，dfs遍历所有root得到所有的sum情况。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-124-Binary-Tree-Maximum-Path-Sum-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">124. Binary Tree Maximum Path Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,help(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,help(root.right));</span><br><span class="line">        max = Math.max(max,left+right+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。注意left和right在dfs的时候要考虑负数情况，所以要和0取max。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-543-Diameter-of-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">543. Diameter of Binary Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = help(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = help(root.right) + <span class="number">1</span>;</span><br><span class="line">        max = Math.max(max,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。题目的意思就是要求找左右子树最大深度和。max要和左右和比较，然后返回左右的最大值。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-687-Longest-Univalue-Path-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">687. Longest Univalue Path</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root,root.val);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = help(root.left,root.val);</span><br><span class="line">        <span class="keyword">int</span> right = help(root.right,root.val);</span><br><span class="line">        max = Math.max(left+right,max);  <span class="comment">// we need find the max edges instead of node, so we dont have to +1.</span></span><br><span class="line">        <span class="keyword">if</span>(val == root.val)<span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的不一样，这道题是找相同的node之间最大的edge，所以在更新max的时候left+right不需要再+1了。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 81 💪</title>
    <url>/2020/02/15/chin-up-19/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-128-Longest-Consecutive-Sequence-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">128. Longest Consecutive Sequence</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// corner case</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">// num --&gt; 连续长度</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> left = map.containsKey(num-<span class="number">1</span>) ? map.get(num-<span class="number">1</span>) : <span class="number">0</span>;<span class="comment">//左边连续长度</span></span><br><span class="line">                <span class="keyword">int</span> right = map.containsKey(num + <span class="number">1</span>) ? map.get(num + <span class="number">1</span>) : <span class="number">0</span>;<span class="comment">//右边连续长度</span></span><br><span class="line">                sum+= left + right + <span class="number">1</span>; <span class="comment">//更新总长度</span></span><br><span class="line">                <span class="comment">// change the current num's maxlen 连续长度</span></span><br><span class="line">                map.put(num,sum);</span><br><span class="line">                max = Math.max(max,sum);<span class="comment">//更新max</span></span><br><span class="line"></span><br><span class="line">                map.put(num - left, sum);<span class="comment">//更新最左边num的长度</span></span><br><span class="line">                map.put(num + right, sum);<span class="comment">//更新最右边num长度</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// duplicate case</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写在注释里。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-112-Path-Sum-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">112. Path Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常递归。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-113-Path-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">113. Path Sum II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res,sum,templist);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> sum, List&lt;Integer&gt; templist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        templist.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            help(root.left,res,sum - root.val, templist);</span><br><span class="line">            help(root.right,res,sum - root.val, templist);</span><br><span class="line">        &#125;</span><br><span class="line">        templist.remove(templist.size() -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + backtracking。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-437-Path-Sum-III-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">437. Path Sum III</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        help(root,sum,<span class="number">0</span>,map);</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span> cursum, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        cursum+=root.val;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(cursum - sum))&#123;</span><br><span class="line">            total+=map.get(cursum - sum);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(cursum,map.getOrDefault(cursum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        help(root.left,sum,cursum,map);</span><br><span class="line">        help(root.right,sum,cursum,map);</span><br><span class="line">        map.put(cursum,map.get(cursum)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + backtracking + presum。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-129-Sum-Root-to-Leaf-Numbers-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">129. Sum Root to Leaf Numbers</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = help(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum*<span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">int</span> leftsum = help(root.left,sum);</span><br><span class="line">        <span class="keyword">int</span> rightsum = help(root.right,sum);</span><br><span class="line">        <span class="keyword">return</span> leftsum + rightsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursion里计算sum并且传下去。一开始用dfs+backtracking+转num和麻烦了，这个简单。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-257-Binary-Tree-Paths-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">257. Binary Tree Paths</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        help(root,sb,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, StringBuilder sb, List&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = sb.length();</span><br><span class="line">        sb.append(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        help(root.left,sb,res);</span><br><span class="line">        help(root.right,sb,res);</span><br><span class="line">        sb.setLength(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + backtracking.注意sb append的顺序。一般都是先加入list之后在判断是否为叶节点。否则容易漏掉。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-437-Path-Sum-III-font-td-tr-table-v2"><table><tr><td bgcolor="#28B463"><font color="white">437. Path Sum III</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是BST，所以只需要通过大小判断就可以选择左右子树。如果当前root全部小于p,q则说明lca在右边的tree。若全小于p，q则在左边。如果大于p小于q则他自己本身就是，如果小于p大于q则是不可能事件，返回root。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-257-Binary-Tree-Paths-font-td-tr-table-v2"><table><tr><td bgcolor="#F5B041"><font color="white">257. Binary Tree Paths</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不是BST，只是单纯的二叉树了。不能用大小边界来判断了。要分情况递归讨论。</p>
<ol>
<li>root为空或者 root只为pq中的一者，那么直接返回当前root。</li>
<li>递归找左右子树中pq的lca，如果left为空，说明只能在right，返回right。</li>
<li>反之返回left。</li>
<li>如果left和right1都不为null，说明p q 二者各自分布在左右中，所以返回当前root。</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 83 💪</title>
    <url>/2020/02/21/chin-up-21/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-968-Binary-Tree-Cameras-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">968. Binary Tree Cameras</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/binary-tree-cameras/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (dfs(root) == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>) + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span> || right == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0 : 叶节点。<br>
1 ： camera的位置。<br>
2 ： 左右子树中有camera，这个位置被cover了。<br>
如果左右中有2，则表明该node的孩子中已经被cover了，则该node变为新的叶节点。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-337-House-Robber-III-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">337. House Robber III</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/house-robber-iii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> help(root,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root, Map&lt;TreeNode,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))<span class="keyword">return</span> map.get(root); <span class="comment">// memo剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            val= val + help(root.left.left,map) + help(root.left.right,map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            val = val + help(root.right.left,map) + help(root.right.right,map);</span><br><span class="line">        &#125;</span><br><span class="line">        val = Math.max(root.val + val,help(root.left,map) + help(root.right,map));</span><br><span class="line">        map.put(root,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs + memo。对当前root分两种情况讨论。</p>
<ol>
<li>已经被robed ，则跳过左右直接孩子，去grand node， root.left.left,root.left.right,root.right.left,root.right.right。</li>
<li>未被robed，则左右直接孩子可以用。直接操作root.left  root.right即可。</li>
<li>最后比较两种情况返回的val值和，取较大存入map。</li>
<li>加入memo剪枝。</li>
</ol>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-979-Distribute-Coins-in-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">979. Distribute Coins in Binary Tree</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right =dfs(root.right);</span><br><span class="line">        res += Math.abs(left) + Math.abs(right);</span><br><span class="line">        <span class="keyword">return</span> root.val + left + right - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求将每个位置都变为1，并且每次变动只能传1个硬币，求变动次数。其实反过来想，如果某个节点原来为x,要变为1，那么变动的数值就是x-1的绝对值，也就是向父节点传送的值或者向父节点索要的值，即变动次数，最后还要保证该节点剩下一个硬币，所以要把左右孩子可以利用的硬币数全部相加然后-1，这些就是该node的父节点能够用到的硬币总数。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-221-Maximal-Square-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">221. Maximal Square</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span> ; j&lt;=n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>],Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp存右下角为1的位置里，最大的正方形边长。从1开始循环，上左下三个方位找最小的边长，因为如果三个方位不是1则最小的为0，也就够不成更大的正方形。最后更新max。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1277-Count-Square-Submatrices-with-All-Ones-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1277. Count Square Submatrices with All Ones</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        matrix[i][j] = Math.min(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(matrix[i][j-<span class="number">1</span>],matrix[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res+=matrix[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和221类似的思路。这里从0开始遍历，in place改变matrix。matrix[i][j]存最大的正方形边长，同时也是以该位置为右下角的正方形个数。<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p>此时右下角的matrix值为2，而于此同时以右下角的1为正方形的个数也是2：一个单独的右下角1，自己构成小正方形；一个边长为2的square。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-70-Climbing-Stairs-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">70. Climbing Stairs</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span> ; i&lt;= n ;i++)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典费纳波切数列dp。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-746-Min-Cost-Climbing-Stairs-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">746. Min Cost Climbing Stairs</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = cost[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> second = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;cost.length ;i++)&#123;</span><br><span class="line">            cost[i] = Math.min(first, second) + cost[i];</span><br><span class="line">            first = second;</span><br><span class="line">            second = cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(first,second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于每次只能走1or2个，所以从第三个开始，选前面两个中最少的一个，更新first和second的值，最后返回二者中的min。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1137-N-th-Tribonacci-Number-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1137. N-th Tribonacci Number</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tribonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span> , third = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> next = first + second + third;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">            third = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路和上一道题很像，都是只能走固定步数。然后不断迭代更新值，最后返回first。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 84 💪</title>
    <url>/2020/02/28/chin-up-22/</url>
    <content><![CDATA[<br>
<font size="3"> 📌煎熬的midterm周过去了，又可以开心的刷题了(并没有)
</font>
<br>
<br>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-784-Letter-Case-Permutation-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">784. Letter Case Permutation</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/letter-case-permutation/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(S);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(S.charAt(i)))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;size;j++)&#123;</span><br><span class="line">                String str = queue.poll();</span><br><span class="line">                <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">                <span class="comment">// upper case</span></span><br><span class="line">                ch[i] = Character.toUpperCase(ch[i]);</span><br><span class="line">                queue.add(String.valueOf(ch));</span><br><span class="line">                <span class="comment">//lower case</span></span><br><span class="line">                ch[i] = Character.toLowerCase(ch[i]);</span><br><span class="line">                queue.add(String.valueOf(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : queue)&#123;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回溯，每次改完一个字母要把原来但变会小写加回queue。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-301-Remove-Invalid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">301. Remove Invalid Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res  = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        queue.add(s);</span><br><span class="line">        seen.add(s);</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            String str = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(isvalid(str))&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                found = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(found)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i) != <span class="string">')'</span> &amp;&amp; str.charAt(i) != <span class="string">'('</span>)<span class="keyword">continue</span>;</span><br><span class="line">                String temp = str.substring(<span class="number">0</span>,i) + str.substring(i);</span><br><span class="line">                <span class="keyword">if</span>(!seen.contains(temp))&#123;</span><br><span class="line">                    queue.add(temp);</span><br><span class="line">                    seen.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isvalid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) count++;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; count-- == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS思路。注意isvalid的判断条件。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-35-Search-Insert-Position-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">35. Search Insert Position</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span>&lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &gt;= target)<span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[end] &gt;= target)<span class="keyword">return</span> end;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> end + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典二分模版。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">34. Find First and Last Position of Element in Sorted Array</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span>&lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + ( end - start )/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)end = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)end = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] == target)res[<span class="number">0</span>] = start;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[end] == target)res[<span class="number">0</span>] = end;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span>&lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + ( end - start )/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)start = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)end = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)start = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[end] == target)res[<span class="number">1</span>] = end;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[start] == target)res[<span class="number">1</span>] = start;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两次二分，找两个位置。注意二分新写法最后判断start和end的顺序。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-981-Time-Based-Key-Value-Store-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">981. Time Based Key-Value Store</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/time-based-key-value-store/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> </span>&#123;</span><br><span class="line">    Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key))&#123;</span><br><span class="line">            map.put(key,<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(key).put(timestamp,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer,String&gt; treemap = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(treemap == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Integer floor = treemap.floorKey(timestamp);</span><br><span class="line">        <span class="keyword">if</span>(floor == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> treemap.get(floor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map + treemap。map用key做keyvalue，treemap里用timestamp作为keyvalue。<br><br>
treemap里floorKey返回&lt;=当前值的key。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
        <tag>BFS</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 86 💪</title>
    <url>/2020/03/05/chin-up-24/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-4-Median-of-Two-Sorted-Arrays-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">4. Median of Two Sorted Arrays</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            arr[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">            arr[m+j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> k = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span> != <span class="number">0</span>)<span class="keyword">return</span> (<span class="keyword">double</span>)arr[k/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> ((<span class="keyword">double</span>)(arr[(k/<span class="number">2</span>) - <span class="number">1</span>] + arr[(k/<span class="number">2</span>)])/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two array 加到一起sort。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-378-Kth-Smallest-Element-in-a-Sorted-Matrix-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">378. Kth Smallest Element in a Sorted Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n ;j++)&#123;</span><br><span class="line">                pq.add(matrix[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(pq.size() &gt; k)pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典kth问题。维护大小为k的max/min heap即可。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-668-Kth-Smallest-Number-in-Multiplication-Table-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">668. Kth Smallest Number in Multiplication Table</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">1</span>, hi=m*n;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid= (lo+hi)/<span class="number">2</span>, cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=n; i&lt;=m; i++)&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; i*j&gt;mid) j--;</span><br><span class="line">                cnt+=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt&gt;=k) hi=mid;</span><br><span class="line">            <span class="keyword">else</span> lo=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binary search把num分成两部分来找。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-917-Reverse-Only-Letters-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">917. Reverse Only Letters</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/reverse-only-letters/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseOnlyLetters</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;S.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetter(S.charAt(i)))&#123;</span><br><span class="line">                stack.push(S.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetter(S.charAt(i)))&#123;</span><br><span class="line">                sb.append(S.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack逆序输出。注意标点符号不只有‘-’。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-925-Long-Pressed-Name-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">925. Long Pressed Name</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/long-pressed-name/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLongPressedName</span><span class="params">(String name, String typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = name.length();</span><br><span class="line">        <span class="keyword">int</span> n = typed.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;m &amp;&amp; name.charAt(i) == typed.charAt(j))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span> || typed.charAt(j) != typed.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two pointer.只需要对typed自身检查有无相同重复即可。如果两个位置元素相同，则name 的index++，如果不同并且typed的前一个和该元素不一样，则直接返回false。<br><br>
abc-aabc-true<br><br>
abc-adbc-false</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-986-Interval-List-Intersections-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">986. Interval List Intersections</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a&lt;A.length &amp; b&lt;B.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = Math.max(A[a][<span class="number">0</span>],B[b][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> end = Math.min(A[a][<span class="number">1</span>],B[b][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(start &lt;= end)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A[a][<span class="number">1</span>] &gt; B[b][<span class="number">1</span>])b++;</span><br><span class="line">            <span class="keyword">else</span> a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] num : res)&#123;</span><br><span class="line">            ans[i] = num;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interval的题。start取最大，end取最小，如果start&lt;end 说明有有交集，加入res。如果没有，A的结尾比B的大，则b往后遍历一个，相反，A往后循环一个。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-855-Exam-Room-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">855. Exam Room</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/exam-room/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    List&lt;Integer&gt; L;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExamRoom</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        L = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        n = N;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            L.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// empty we set seat at 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> d = Math.max(L.get(<span class="number">0</span>), n - <span class="number">1</span> - L.get(L.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.size() - <span class="number">1</span>; ++i) d = Math.max(d, (L.get(i + <span class="number">1</span>) - L.get(i)) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (L.get(<span class="number">0</span>) == d) &#123;<span class="comment">//d == 0 we also set seat at 0</span></span><br><span class="line">            L.add(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.size() - <span class="number">1</span>; ++i)<span class="comment">//try to find the minimum index that match d.</span></span><br><span class="line">            <span class="keyword">if</span> ((L.get(i + <span class="number">1</span>) - L.get(i)) / <span class="number">2</span> == d) &#123;</span><br><span class="line">                L.add(i + <span class="number">1</span>, (L.get(i + <span class="number">1</span>) + L.get(i)) / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> L.get(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        L.add(n- <span class="number">1</span>); <span class="comment">// no match we add at last position</span></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leave</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">// find the p and remove it</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.size(); ++i) <span class="keyword">if</span> (L.get(i) == p) L.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有意思的design题。用list存seat的位置，然后每次遍历找最大的dist，然后再重头开始找最小能够匹配dist的index，把seat插入该index。<br>
否则直接安排在最后面。leave的时候只需要remove p所在的list index即可。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BinarySearch</tag>
        <tag>TwoPointer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 88 💪</title>
    <url>/2020/03/10/chin-up-26/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-304-Range-Sum-Query-2D-Immutable-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">304. Range Sum Query 2D - Immutable</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j&lt;=n ;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>] - dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iMin = Math.min(row1, row2);</span><br><span class="line">        <span class="keyword">int</span> iMax = Math.max(row1, row2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> jMin = Math.min(col1, col2);</span><br><span class="line">        <span class="keyword">int</span> jMax = Math.max(col1, col2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[iMax + <span class="number">1</span>][jMax + <span class="number">1</span>] - dp[iMax + <span class="number">1</span>][jMin] - dp[iMin][jMax + <span class="number">1</span>] + dp[iMin][jMin];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp存当前位置构成的方形内所有的和，在计算时由于dp[i-1][j-1]加了两次，要减去一次，然后加上当前的值matrix[i][j]。<br>
在计算sum的时候，最右下位置的和减去最小行、最小列对应的和值，由于左上的值被减了两次，要加回来一次。<br>
<img src="https://i.imgur.com/gQ2jkLB.jpg"></p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-221-Maximal-Square-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">221. Maximal Square</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max*max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp[i][j]表示位于右下角(i, j)的正方形的边长长度。<br>
如果此单元格的值也是1，则正方形最小长度其上方的值，左侧和对角线左上值中的最小值+1。因为如果一侧短或缺失，则不会形成正方形。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1277-Count-Square-Submatrices-with-All-One-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1277. Count Square Submatrices with All One</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        matrix[i][j] = Math.min(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(matrix[i][j-<span class="number">1</span>],matrix[i-<span class="number">1</span>][j]))+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    res+=matrix[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>matrix保存每个位置能够组成正方形的最小边长，其实把所有情况的最小边长加起来就是正方形的个数。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">309. Best Time to Buy and Sell Stock with Cooldown</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prevsell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> prevbuy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price : prices)&#123;</span><br><span class="line">            prevbuy = buy;</span><br><span class="line">            buy = Math.max(prevsell - price, prevbuy);</span><br><span class="line">            prevsell = sell;</span><br><span class="line">            sell = Math.max(prevbuy + price, prevsell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>buy–目前买完之后最大剩余值，sell–目前卖完最大剩余值，prevbuy–上次操作之后剩余值，prevsell–上次操作之后剩余值。<br>
更新buy，要求最大剩余值，所以要和prevsell-price比较。更新sell，要求最大卖出值，所以 prevbuy + price比较。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 87 💪</title>
    <url>/2020/03/06/chin-up-25/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-992-Subarrays-with-K-Different-Integers-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">992. Subarrays with K Different Integers</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(A,K) - help(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(A[j], <span class="number">0</span>) == <span class="number">0</span>) K--;</span><br><span class="line">            map.put(A[j],map.getOrDefault(A[j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                map.put(A[i],map.get(A[i])-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(A[i]) == <span class="number">0</span>)K++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正好有K个 = 最多K个的情况减去最多K-1的情况。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-15-3Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">15. 3Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i&gt;<span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> low = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high = nums.length -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[low] + nums[high] == target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[low],nums[high],nums[i]));</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low]==nums[low + <span class="number">1</span>])low++;</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high ] == nums[high-<span class="number">1</span>])high--;</span><br><span class="line">                        low++;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[low] + nums[high] &lt; target)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] == nums[low]+<span class="number">1</span>)low++;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] == nums[high-<span class="number">1</span>])high--;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。two pointers基本思路。注意判断有重复数字的情况。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-167-Two-Sum-II-Input-array-is-sorted-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">167. Two Sum II - Input array is sorted</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length&lt;<span class="number">2</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(temp == target)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = left+<span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = right+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two pointers。注意最后返回index要+1.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-16-3Sum-Closest-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">16. 3Sum Closest</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> closetsum = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;nums.length-<span class="number">2</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i&gt;<span class="number">0</span> &amp;&amp; nums[i] != nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.length -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])right--;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(Math.abs(target - closetsum) &gt; Math.abs(target-sum))&#123;</span><br><span class="line">                        closetsum = sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closetsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 sum变种。只需要多维护一个临时的sum值，和closetsum比较更新就可以了。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>TwoPointer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 85 💪</title>
    <url>/2020/02/29/chin-up-23/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-875-Koko-Eating-Bananas-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">875. Koko Eating Bananas</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(piles == <span class="keyword">null</span> || piles.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = getmax(piles);</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + ( end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(caneatall(piles,H,mid))end = mid;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(caneatall(piles,H,start))<span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">caneatall</span><span class="params">(<span class="keyword">int</span>[] piles, <span class="keyword">int</span> H, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            count+=pile/start;</span><br><span class="line">            <span class="keyword">if</span>(pile%start!=<span class="number">0</span>)count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count&lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span>[]piles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pile : piles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pile &gt; max)&#123;</span><br><span class="line">                max = pile;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分发找per hour的消耗量。先找到piles里最大值作为消耗速率，判断当前rate能否在给定小时内消耗完所有piles。如果可以则将rate降低1，如此循环找到最小值。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1011-Capacity-To-Ship-Packages-Within-D-Days-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1011. Capacity To Ship Packages Within D Days</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(weights == <span class="keyword">null</span> || weights.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : weights)&#123;</span><br><span class="line">            left = Math.max(left,w);</span><br><span class="line">            right+=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> need = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> w : weights)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur+w &gt; mid)&#123;</span><br><span class="line">                    need++;</span><br><span class="line">                    cur = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur+=w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(need &gt; D)left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有趣的一道题。right上限为货物总重，然后二分找在给定天数内搬完所有的最小日均量。首先定义cur来存暂时的总搬运量，如果大于了假定的mid值，则需要多一天，并且重新归零cur值，进行下一次，否则cur一直增加。最后判断需要的天数和D的关系即可。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-33-Search-in-Rotated-Sorted-Array-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">33. Search in Rotated Sorted Array</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= nums[left])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] == target)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四遍。用新二分模版写一下。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-81-Search-in-Rotated-Sorted-Array-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">81. Search in Rotated Sorted Array II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[left])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==nums[mid])&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[right] == nums[mid])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] == target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[right] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多了重复的数字，要检查mid和left right。其他不变。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-153-Find-Minimum-in-Rotated-Sorted-Array-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">153. Find Minimum in Rotated Sorted Array</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[start] &lt; nums[end])<span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[end];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次到更小的一部分继续二分。</p>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-154-Find-Minimum-in-Rotated-Sorted-Array-II-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">154. Find Minimum in Rotated Sorted Array II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] &lt; nums[right])<span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>duplicate存在。由于sorted，所以每次只对nums[right]检查。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-162-Find-Peak-Element-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">162. Find Peak Element</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-852-Peak-Index-in-a-Mountain-Array-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">852. Peak Index in a Mountain Array</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span>&lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;nums[right])<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两道题一样的solution。放一起了。<br><br>
每次对mid和mid+1比较。更新左右边界即可。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-74-Search-a-2D-Matrix-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">74. Search a 2D Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = row*col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span>&lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/col][mid%col] == target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[mid/col][mid%col] &lt; target)start = mid;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(matrix[start/col][start%col] == target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[end/col][end%col] == target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五遍。当成一个数组二分查找。注意col和数组index的关系。都用col来比较。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 89 💪</title>
    <url>/2020/03/12/chin-up-27/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-734-Sentence-Similarity-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">734. Sentence Similarity</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sentence-similarity/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilar</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words1.length != words2.length)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map&lt;String,Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; str : pairs)&#123;</span><br><span class="line">            map.putIfAbsent(str.get(<span class="number">0</span>),<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            map.putIfAbsent(str.get(<span class="number">1</span>),<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            map.get(str.get(<span class="number">0</span>)).add(str.get(<span class="number">1</span>));</span><br><span class="line">            map.get(str.get(<span class="number">1</span>)).add(str.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words1.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words1[i].equals(words2[i]))<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(words1[i]))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!map.get(words1[i]).contains(words2[i]))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using map to store the key-value of each string in the pairs. Then we loop the word1 and words2, only when two stirng is equal or map contains each other then we can continue to loop. Other wise we return fasle.</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-737-Sentence-Similarity-II-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">737. Sentence Similarity II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sentence-similarity-ii/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">areSentencesSimilarTwo</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words1.length != words2.length)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// corner case</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; str : pairs)&#123;<span class="comment">// initialize union find hashmap</span></span><br><span class="line">            String parent1 = find(map,str.get(<span class="number">0</span>));</span><br><span class="line">            String parent2 = find(map,str.get(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(!parent1.equals(parent2))map.put(parent1,parent2); <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words1.length ;i++)&#123; <span class="comment">// return false if two string are not equal and both of them are not from the same root string</span></span><br><span class="line">            <span class="keyword">if</span>(!words1[i].equals(words2[i]) &amp;&amp; !find(map,words1[i]).equals(find(map,words2[i])))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(Map&lt;String,String&gt; map, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(s))map.put(s,s);</span><br><span class="line">        <span class="keyword">return</span> s.equals(map.get(s)) ? s : find(map,map.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using Union-Find. Using map to create unionfind graph. First we initialize each string with the root of itself. Then we update the root with parent2 if they are not the same. Then loop the word1, if we meet two string are not equal and are not from the same root string , we return false. Otherwise we continue until we return true in the final.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-277-Find-the-Celebrity-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">277. Find the Celebrity</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-the-celebrity/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The knows API is defined in the parent class Relation.</span></span><br><span class="line"><span class="comment">      boolean knows(int a, int b); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> person = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(knows(person,i))&#123;</span><br><span class="line">                person = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;n ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != person &amp;&amp; (!knows(i,person) || knows(person,i)))<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>we first loop the perosn and change the candidate if the first know the second one. Because we have to make sure that candidate know nobody. Then we for loop again, only when the person is not candidate and he don’t know the candidate or the candidate know the person, we return -1. Other wise we just return the candidate that we found.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-139-Word-Break-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white"> 139. Word Break </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : wordDict)&#123;</span><br><span class="line">            set.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;i ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j,i)))&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dpć´ć°0-ĺ˝ĺindexććsubstringćŻĺŚĺşç°čżă</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-399-Evaluate-Division-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">399. Evaluate Division</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; eq, <span class="keyword">double</span>[] vals, List&lt;List&lt;String&gt;&gt; q) &#123;</span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vals.length; i++) &#123;</span><br><span class="line">            m.putIfAbsent(eq.get(i).get(<span class="number">0</span>), <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            m.putIfAbsent(eq.get(i).get(<span class="number">1</span>), <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            m.get(eq.get(i).get(<span class="number">0</span>)).put(eq.get(i).get(<span class="number">1</span>), vals[i]);</span><br><span class="line">            m.get(eq.get(i).get(<span class="number">1</span>)).put(eq.get(i).get(<span class="number">0</span>), <span class="number">1</span> / vals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] r = <span class="keyword">new</span> <span class="keyword">double</span>[q.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q.size(); i++)</span><br><span class="line">            r[i] = dfs(q.get(i).get(<span class="number">0</span>), q.get(i).get(<span class="number">1</span>), <span class="number">1</span>, m, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(String s, String t, <span class="keyword">double</span> r, Map&lt;String, Map&lt;String, Double&gt;&gt; m, Set&lt;String&gt; seen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.containsKey(s) || !seen.add(s)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(t)) <span class="keyword">return</span> r;</span><br><span class="line">        Map&lt;String, Double&gt; next = m.get(s);</span><br><span class="line">        <span class="keyword">for</span> (String c : next.keySet()) &#123;</span><br><span class="line">            <span class="keyword">double</span> result = dfs(c, t, r * next.get(c), m, seen);</span><br><span class="line">            <span class="keyword">if</span> (result != -<span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç°ććŻä¸Şĺ­ćŻĺŻšĺşçĺłçłťĺ­čżmăĺDFSćžqueryéç¸ĺŻšĺşçä¸¤ä¸Şäšé´çĺźă</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-990-Satisfiability-of-Equality-Equations-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">990. Satisfiability of Equality Equations</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener"><font size="4">đQuestion Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] UF = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(equations.length == <span class="number">0</span> || equations == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            UF[i] = i;<span class="comment">//initialize UF array.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">'='</span>)&#123;</span><br><span class="line">                UF[find(str.charAt(<span class="number">0</span>)-<span class="string">'a'</span>)] = find(str.charAt(<span class="number">3</span>)-<span class="string">'a'</span>);<span class="comment">// link the two == chars</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">'!'</span>)&#123; <span class="comment">//check whether two chars in != case have the same root</span></span><br><span class="line">                <span class="keyword">if</span>(UF[find(str.charAt(<span class="number">0</span>)-<span class="string">'a'</span>)] == find(str.charAt(<span class="number">3</span>)-<span class="string">'a'</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">// create find function.</span></span><br><span class="line">        <span class="keyword">if</span>(a != UF[a])UF[a] = find(UF[a]);</span><br><span class="line">        <span class="keyword">return</span> UF[a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnionFindăCreate a UF graph to store the first and second char in equations. In ‘==’ case, we update the UF of first char. In ‘!=’ case, if we find that the two char has the same root, then return false.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DP</tag>
        <tag>Union-Find</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 92 💪</title>
    <url>/2020/05/24/code02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-130-Surrounded-Regions-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">130. Surrounded Regions</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener"><font size="4">ðŸ”—Question Link </font></a></p>
<ul>
<li>BFS Solution :</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (i==<span class="number">0</span> || i==row-<span class="number">1</span> || j==<span class="number">0</span> || j==col-<span class="number">1</span> ) &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    board[i][j] = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; board[x][y] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    board[x][y] = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'a'</span>)board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DFS Solution :</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (i==<span class="number">0</span> || i==row-<span class="number">1</span> || j==<span class="number">0</span> || j==col-<span class="number">1</span> ) &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    helper(i,j,board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'a'</span>)board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span>[][]board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt;= board.length - <span class="number">1</span> &amp;&amp; c &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; board[r][c] == <span class="string">'O'</span>)&#123;</span><br><span class="line">            board[r][c] = <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">                helper(x,y,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into ‘a’. After that, we make a loop of the whole board to change ‘a’ into O and all other Os into ‘X’.</p>
<a id="more"></a>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 90 💪</title>
    <url>/2020/03/15/chin-up-28/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-567-Permutation-in-String-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">567. Permutation in String</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;len1 ;i++)&#123;</span><br><span class="line">            arr[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            arr[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(allzero(arr))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = len1; j&lt;len2 ;j++)&#123;</span><br><span class="line">            arr[s2.charAt(j)-<span class="string">'a'</span>]--;</span><br><span class="line">            arr[s2.charAt(j-len1)-<span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(allzero(arr))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allzero</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典26大小arr方法。检查各个字母出现的次数。维护一个len1大小的窗口</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>SilidingWindow</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 174 🏆</title>
    <url>/2020/02/01/contest01/</url>
    <content><![CDATA[<br>
<font size="3"> 📌  今天起每周的lc contest也总结一下。自己的答案和优秀答案写在一起。
</font>
<br>
<br>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-5328-The-K-Weakest-Rows-in-a-Matrix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">5328. The K Weakest Rows in a Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Solution">First Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] kWeakestRows(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mat == <span class="keyword">null</span> || mat.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> m = mat.length;</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;num,i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;k;i++)&#123;</span><br><span class="line">            res[i] = arr[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时思路：二维数组存1的个数以及行的index。然后用num对arr进行sort，最后按序将固定k个i存入res。</p>
<h3 id="Optimized-Solution">Optimized Solution</h3>
<p>看了一圈disscuss基本思路和我一样。只不过有人用priorityqueue 重写sort，核心没变。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-5329-Reduce-Array-Size-to-The-Half-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">5329. Reduce Array Size to The Half</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/reduce-array-size-to-the-half/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Solution-v2">First Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSetSize</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;map.get(b)-map.get(a));</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> halflen = len/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(a))&#123;</span><br><span class="line">                queue.add(a);</span><br><span class="line">                set.add(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> templen = map.get(temp);</span><br><span class="line">            res++;</span><br><span class="line">            len-=templen;</span><br><span class="line">            <span class="keyword">if</span>(len &lt;= halflen)<span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map存元素个数，pq从大到小排序，set保证加入queue的是唯一数字。每次poll出次数最多的数字，更新len，和halflen比较，如果小于则直接返回res。否则继续poll。<br>
<br><br>
PS: 当时一直报错因为存在queue会加入重复数字的情况，加入set之后完美Accepted。</p>
<h3 id="Optimized-Solution-v2">Optimized Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSetSize</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((e1, e2) -&gt; (e2.getValue() - e1.getValue()));</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(arr[i], map.getOrDefault(arr[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.addAll(map.entrySet());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count += pq.poll().getValue();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路一摸一样。写法简洁了许多。以后的code尽量一行多operation。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1343-Maximum-Product-of-Splitted-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1343. Maximum Product of Splitted Binary Tree </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="Optimized-Solution-v3">Optimized Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum;</span><br><span class="line">    <span class="keyword">long</span> max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        check(root);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(max%((<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,<span class="number">9</span>)+<span class="number">7</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> l = check(root.left);</span><br><span class="line">        <span class="keyword">long</span> r = check(root.right);</span><br><span class="line">        max = Math.max(max,(l+r+root.val) * (sum - l - r - root.val));</span><br><span class="line">        <span class="keyword">return</span> l + r + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先dfs得到tree的total sum</li>
<li>递归找maxproduct。check里返回的是左右子树的sum和，更新max时注意把total sum分成两部分乘积即可。</li>
</ol>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 175 🏆</title>
    <url>/2020/02/08/contest02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1346-Check-If-N-and-Its-Double-Exist-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1346. Check If N and Its Double Exist </font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/check-if-n-and-its-double-exist/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Solution">First Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfExist</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;arr.length;i++)&#123;</span><br><span class="line">            set.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(set.size() == <span class="number">1</span> &amp;&amp; !set.add(<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(set.size() == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num %<span class="number">2</span> != <span class="number">0</span> || num == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(set.contains(num/<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时思路： 用set存每个num。然后遍历arr，找是否有当前num二倍数的存在。注意零的存在。</p>
<h3 id="Optimized-Solution">Optimized Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfExist</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num * <span class="number">2</span> ) || num % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; set.contains(num/<span class="number">2</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tricky。直接在加入num之前先判断set里有无它的二倍数或者它的1/2数。如果没有则加入，有则直接返回true。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1347. Minimum Number of Steps to Make Two Strings Anagram</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Solution-v2">First Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            arr[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) <span class="keyword">if</span>(arr[i] &gt; <span class="number">0</span>) sum += arr[i];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时思路：arr存每个字母的个数，第一个++，第二个–，遍历arr，只要把&gt;0的全部加起来就是结果。当第二个去–的时候，相同的个数肯定从arr中减去，剩下的是差缺的。</p>
<h3 id="Optimized-Solution-v2">Optimized Solution</h3>
<p>discuss高票答案和我差不多思路。</p>
<h2 id="剩下待更新">剩下待更新</h2>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 91 💪</title>
    <url>/2020/05/16/code01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-289-Game-of-Life-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">289. Game of Life</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dir =&#123;&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dir)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[<span class="number">0</span>]+i&lt;<span class="number">0</span> || d[<span class="number">0</span>]+i&gt;=board.length || d[<span class="number">1</span>]+j&lt;<span class="number">0</span> || d[<span class="number">1</span>]+j&gt;=board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">1</span> || board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">2</span>) live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">0</span> &amp;&amp; live==<span class="number">3</span>) board[i][j]=<span class="number">3</span>;<span class="comment">// dead to live</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live&lt;<span class="number">2</span> || live&gt;<span class="number">3</span>)) board[i][j]=<span class="number">2</span>; <span class="comment">// live to dead</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live ==<span class="number">2</span> || live ==<span class="number">3</span>))board[i][j]=<span class="number">1</span>; <span class="comment">// continue live;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                board[i][j]%=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state:</p>
<ul>
<li>1 means keep living</li>
<li>2 means live to dead*</li>
<li>3 means dead to live.</li>
</ul>
<p>Finally we just use the number to %2 to get the final result.</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1249-Minimum-Remove-to-Make-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1249. Minimum Remove to Make Valid Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)stack.push(i); <span class="comment">// add idnex of ( to stack</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123; <span class="comment">// stack not empty then add index of ) to stack</span></span><br><span class="line">                    check[i] = <span class="keyword">true</span>;</span><br><span class="line">                    check[stack.pop()] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                check[i] = <span class="keyword">true</span>; <span class="comment">// any character in s should be true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; check.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we add index of open / close parenthes to stack. Then we check for pair. If there is a pair of them we change the index of these in check to be true. All other chars should be true in check array except for ( and ). Finally we loop the check array to form the final res string.</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-415-Add-Strings-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">415. Add Strings</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(len1 &gt;=<span class="number">0</span> || len2 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(len1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                n1  = num1.charAt(len1)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                n2 = num2.charAt(len2)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sb.append(sum%<span class="number">10</span>);</span><br><span class="line">            len1--;</span><br><span class="line">            len2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Normal solution. Using carry and sum/10 and sum%10. Remeber to reverse the ans in the final.</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-953-Verifying-an-Alien-Dictionary-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">953. Verifying an Alien Dictionary</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dict = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;order.length() ;i++)&#123;</span><br><span class="line">            dict[order.charAt(i)-<span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j&lt;words.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkbig(words[j-<span class="number">1</span>],words[j]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkbig</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = word1.length();</span><br><span class="line">        <span class="keyword">int</span> b = word2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;a &amp;&amp; i&lt;b;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(dict[word1.charAt(i)-<span class="string">'a'</span>] &lt; dict[word2.charAt(i)-<span class="string">'a'</span>])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dict[word1.charAt(i)-<span class="string">'a'</span>] &gt; dict[word2.charAt(i)-<span class="string">'a'</span>])<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word1.length() &gt; word2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we use int[26] to store the new order of letters. Then we use it as a new dictionary to compare.</p>
<p>After we make it, we loop the given string array, then check them one by one.</p>
<p>Make a new function checkbig to check whether the later word is bigger than the former. If yes then return false. Otherwise we continue.<br>
In the checkbig function, we check the value of each char in the dictionary. If word1’s char is little than the word2 then we return true. So back to the main function it will return false.</p>
<p>In final we also need check the length of them. eg ( ‘word’, ‘wordl’).</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-339-Nested-List-Weight-Sum-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">339. Nested List Weight Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"> * <span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line"> *     <span class="comment">// Constructor initializes an empty nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Constructor initializes a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a nested list</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NestedInteger ni)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a single integer</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())sum+=temp.getInteger()*level;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using BFS to loop the whole array like a binary tree. In the queue loop, we only need to check whether current is an integer or a nestedarray. If is an integer, we add its value * level to the sum. After each level loop, we increase level by 1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 27</span><br><span class="line">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.</span><br></pre></td></tr></table></figure>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-364-Nested-List-Weight-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">364. Nested List Weight Sum II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"> * <span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line"> *     <span class="comment">// Constructor initializes an empty nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Constructor initializes a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a nested list</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NestedInteger ni)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a single integer</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prevsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> levelsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())levelsum+=temp.getInteger();</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prevsum+=levelsum;</span><br><span class="line">            total+=prevsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Different to the former question, in this question we have to loop from the leaf. So we have to keep a prevsum to keep track of.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 176 🏆</title>
    <url>/2020/02/15/contest03/</url>
    <content><![CDATA[<br>
<font size="3"> 📌  今天做出来三题，但是最后一题正好卡在时间点上，没有算进去，不过无所谓了，继续努力。
</font>
<br>
<br>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1354-Construct-Target-Array-With-Multiple-Sums-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1354. Construct Target Array With Multiple Sums</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/construct-target-array-with-multiple-sums/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<p>这道题我写的题解vote数量在discuss区排前三<br><br>
My Discuss Link<a href="https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss?currentPage=1&orderBy=most_votes&query=" target="_blank" rel="noopener"><font size="3">🔗[Java] Think the problem from the end to start.<br>
</font></a></p>
<p>感觉还是挺有收获的，思路挺有趣。</p>
<h3 id="My-solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; target.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i] &gt; max)&#123;</span><br><span class="line">                max = target[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt; target.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == index)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(target[i] &gt; max)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            max = max - target[i];</span><br><span class="line">        &#125;</span><br><span class="line">        target[index] = max;</span><br><span class="line">        <span class="keyword">return</span> isPossible(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体思路就是逆向思考。每次找array里最大的一个数，用它减去剩下的所有num，得到的值就是上一轮该位置被更改前的值。接着我们把这个位置的替换掉，继续循环。在第二个循环里，需要跳过最大值的index，并且要检查剩下的所有num是否都小于最大值，如果不是则直接返回false。详细解析在<a href="https://leetcode.com/problems/construct-target-array-with-multiple-sums/discuss/510317/Java-Think-the-problem-reversely-!!!" target="_blank" rel="noopener">discuss</a>。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1351-Count-Negative-Numbers-in-a-Sorted-Matrix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1351. Count Negative Numbers in a Sorted Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Solution">First Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i&lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>;j&lt;n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &lt; <span class="number">0</span>)sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的遍历graph。O(N^2)复杂度。</p>
<h3 id="Optimized-Solution">Optimized Solution</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++++++</span><br><span class="line">++++--</span><br><span class="line">++++--</span><br><span class="line">+++---</span><br><span class="line">+-----</span><br><span class="line">+-----</span><br></pre></td></tr></table></figure>
<p>graph正负情况如上图，其实很像<a herf="https://leetcode.com/problems/search-a-2d-matrix-ii/">search 2D matrix II</a>这道题，从左上或者右上扫描，保证是O(N)的复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length, r = m - <span class="number">1</span>, c = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[r][c] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                --r;</span><br><span class="line">                cnt += n - c; <span class="comment">// there are n - c negative numbers in current row.</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ++c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1352-Product-of-the-Last-K-Numbers-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1352. Product of the Last K Numbers </font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/product-of-the-last-k-numbers/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductOfNumbers</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductOfNumbers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        list.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProduct</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            sum = sum * list.get(len-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using list to store the nums. Then we make k loops from the tail.</p>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 180 🏆</title>
    <url>/2020/03/15/contest06/</url>
    <content><![CDATA[<p>由于比赛时间延后没赶上，所以这次赛后做的，本次三题。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1380-Lucky-Numbers-in-a-Matrix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1380. Lucky Numbers in a Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">luckyNumbers</span> <span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; minvalues = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;matrix.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = matrix[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt; matrix[<span class="number">0</span>].length ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] &lt; min)&#123;</span><br><span class="line">                    min = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minvalues.add(min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt; matrix[<span class="number">0</span>].length ;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max = matrix[<span class="number">0</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i&lt;matrix.length ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] &gt; max)&#123;</span><br><span class="line">                    max = matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minvalues.contains(max))&#123;</span><br><span class="line">                res.add(max);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观。行的min同时也是col的max才是lucky number。 所以一个set先存出现过的min值，再扫描col找到所有的max，如果max在set里出现过，则加入res。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1381-Design-a-Stack-With-Increment-Operation-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1381. Design a Stack With Increment Operation</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="First-Soluiton">First Soluiton</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        max = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.size() &lt; max)&#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size() == <span class="number">0</span> ? -<span class="number">1</span> : stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; temp = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) temp.push(stack.pop());</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span> &amp;&amp; !temp.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = temp.pop() + val;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())</span><br><span class="line">            stack.push(temp.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Simply using extra stack to reverse the original stack, and to add some operations on it.</p>
<h3 id="Optimized-Soluiton">Optimized Soluiton</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; arr;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        size = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() &lt; size)&#123;</span><br><span class="line">            arr.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr.size() == <span class="number">0</span> ? -<span class="number">1</span> : arr.remove(arr.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; i&lt;arr.size() ; i++)&#123;</span><br><span class="line">            arr.set(i,arr.get(i)+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using extra arr to simulate a stack. Pay attention to the ‘remove’, it can remove the specified index num and return it’s value.</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1382-Balance-a-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1382. Balance a Binary Search Tree</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; sortedarr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">balanceBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> buildtree(<span class="number">0</span>,sortedarr.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        sortedarr.add(root.val);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildtree</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ( end - start)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(sortedarr.get(mid));</span><br><span class="line">        root.left = buildtree(start,mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildtree(mid+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Classic template : inorder traverse + preorder buildtree.</p>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 179 🏆</title>
    <url>/2020/03/07/contest05/</url>
    <content><![CDATA[<p>本次三题。</p>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1374-Generate-a-String-With-Characters-That-Have-Odd-Counts-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1374. Generate a String With Characters That Have Odd Counts</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> )<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ;i++)&#123;</span><br><span class="line">                sb.append(<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"b"</span>);</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;n ;i++)&#123;</span><br><span class="line">                sb.append(<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是判断n的奇偶性，如果奇数全部加a，如果偶数则在最后一位加b就行了。题目描述不清。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1375-Bulb-Switcher-III-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1375. Bulb Switcher III</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTimesAllBlue</span><span class="params">(<span class="keyword">int</span>[] light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = light.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            right = Math.max(right,light[i]);</span><br><span class="line">            <span class="keyword">if</span>(right == i+<span class="number">1</span>)res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>维护最右的灯泡编号，如果当前index+1等于最右的灯泡编号，则说明左边全部点亮，res++。因为index反映了点亮了多少灯泡，而灯泡不可能重复，所以在最右编号不变的情况下，如果index+1等于最右编号(编号从1开始所以要+1)，说明左边全部点过，res++。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1376-Time-Needed-to-Inform-All-Employees-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1376. Time Needed to Inform All Employees</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/time-needed-to-inform-all-employees/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, <span class="keyword">int</span>[] manager, <span class="keyword">int</span>[] informTime)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;manager.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(manager[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(manager[i]))&#123;</span><br><span class="line">                    map.put(manager[i],<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(manager[i]).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(headID);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;size ; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(manager[temp]!=-<span class="number">1</span>)&#123; <span class="comment">// 避开head的位置，从不是head的time开始累加。</span></span><br><span class="line">                    informTime[temp]+=informTime[manager[temp]];</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,informTime[temp]);</span><br><span class="line">                <span class="keyword">if</span>(map.get(temp)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> num : map.get(temp))&#123;</span><br><span class="line">                        queue.add(num);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接裸BFS。更新informTime的值，使其成为累计和。最后返回其中的max。</p>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 102 / DFS(1) 💪</title>
    <url>/2020/06/14/dfs01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-332-Reconstruct-Itinerary-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">332. Reconstruct Itinerary</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:</p>
<p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>
All airports are represented by three capital letters (IATA code).<br>
You may assume all tickets form at least one valid itinerary.<br>
One must use all the tickets once and only once.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].</span><br><span class="line">But it is larger in lexical order.</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();;</span><br><span class="line">    Map&lt;String,PriorityQueue&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets == <span class="keyword">null</span> || tickets.size() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; ticket : tickets)&#123;</span><br><span class="line">            map.putIfAbsent(ticket.get(<span class="number">0</span>),<span class="keyword">new</span> PriorityQueue&lt;&gt;());</span><br><span class="line">            map.get(ticket.get(<span class="number">0</span>)).add(ticket.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);<span class="comment">//类似tree的postorder遍历，</span></span><br><span class="line">        Collections.reverse(res);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String start)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; ends = map.get(start);</span><br><span class="line">        <span class="keyword">while</span>(ends != <span class="keyword">null</span> &amp;&amp; !ends.isEmpty())&#123;</span><br><span class="line">            dfs(ends.poll());<span class="comment">//不断遍历children，也就是当前map里start对应的ends里lexi最小的那个。</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using pq to make sure that every polled element is the smallest leximal one. DFS is just like tree postorder traversal, we need to find the minmum leximal city as start, which is same as traversing children treenode at first. Then we add the root value to the res in the last.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4udFSOWQpdg?start=278" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-339-Nested-List-Weight-Sum-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">339. Nested List Weight Sum</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Four 1&apos;s at depth 2, one 2 at depth 1.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 27</span><br><span class="line">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<ol>
<li>
<p>In dfs we only recursively to call the function in NestedInteger.</p>
</li>
<li>
<p>In bfs we can regard the nums like tree level traversal. The Integer one is root node, and nestedinteger is like the next levels’s nodes.</p>
</li>
</ol>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger nest : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nest.isInteger()) &#123;</span><br><span class="line">                sum += depth * nest.getInteger();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += helper(nest.getList(), depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())sum+=temp.getInteger()*level;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-364-Nested-List-Weight-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">364. Nested List Weight Sum II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: 8 </span><br><span class="line">Explanation: Four 1&apos;s at depth 1, one 2 at depth 2.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 17 </span><br><span class="line">Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<p>It is a little different from the 339. In this question the nestedinteger has the lower depth and single integer has higher depth.</p>
<ol>
<li>
<p>DFS: First we find the total depth of the nestedlist,then we loop each element in the nestedlist,if it is integer then we multiply it by the layer, else we recursevely call the getSum function.</p>
</li>
<li>
<p>BFS: We use presum to store the temp sum of each layer.</p>
</li>
</ol>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span> || nestedList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = helper(nestedList);</span><br><span class="line">        <span class="keyword">int</span> res = getSum(nestedList, h);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(List&lt;NestedInteger&gt; l, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || l.size() == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger n : l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.isInteger()) sum += n.getInteger() * layer;</span><br><span class="line">            <span class="keyword">else</span> sum += getSum(n.getList(), layer - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || l.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger n : l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.isInteger()) max = Math.max(max, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> max = Math.max(max, helper(n.getList()) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prevsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> levelsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())levelsum+=temp.getInteger();</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prevsum+=levelsum;</span><br><span class="line">            total+=prevsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-472-Concatenated-Words-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">472. Concatenated Words</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/concatenated-words/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.<br>
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; </span><br><span class="line"> &quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; </span><br><span class="line">&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.sort(words,(a,b)-&gt;a.length() - b.length());<span class="comment">//sort the words with its length</span></span><br><span class="line">        <span class="keyword">for</span>(String str : words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.length() &gt; <span class="number">0</span> &amp;&amp; check(set,str))&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Set&lt;String&gt; set, String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(str))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            String temp = str.substring(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(set,str.substring(i)))&#123;</span><br><span class="line">                    set.add(str);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We first sort the str array from min length to max length. Then we add each string to set. Before add it to the set, we check it with the current set to see whether current word can be made up by any words in the set. We loop each part of the string, if one part exist in the set, then we recursively call the check function to see the other part.</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Weekly Contest 178 🏆</title>
    <url>/2020/02/29/contest04/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-1351-Count-Negative-Numbers-in-a-Sorted-Matrix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">1351. Count Negative Numbers in a Sorted Matrix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<h3 id="My-solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>brute force。</p>
<a id="more"></a>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1366-Rank-Teams-by-Votes-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1366. Rank Teams by Votes</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">rankTeams</span><span class="params">(String[] votes)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = votes[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span>(String vote : votes)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(vote.charAt(i)))&#123;</span><br><span class="line">                    map.put(vote.charAt(i), <span class="keyword">new</span> <span class="keyword">int</span>[len]);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(vote.charAt(i))[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;len ;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.get(a)[i] != map.get(b)[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> map.get(b)[i] - map.get(a)[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Character ch : map.keySet())&#123;</span><br><span class="line">            pq.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            sb.append(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每个char建一个长度为vote.length()的数组，用来存该char在每个position的freq。然后用pq来match最合适的，放到最前，然后依次poll加入stringbuilder返回。</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1367-Linked-List-in-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1367. Linked List in Binary Tree</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root,head) || isSubPath(head,root.left) || isSubPath(head,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode root, ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> &amp;&amp; root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.val != root.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left,head.next) || check(root.right,head.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和542一样的思路。只有当head和root都为null时可以为true，先检查当前root和head或者对left和right分别进行递归调用。在check函数里也是要对left和right两种情况都考虑，返回｜｜值就可以了。</p>
]]></content>
      <categories>
        <category>Weekly Contest</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 5 💪</title>
    <url>/2020/04/26/front-end-interview2/</url>
    <content><![CDATA[<h1>HTML</h1>
<h2 id="DOCTYPE-作用">&lt;!DOCTYPE&gt;作用</h2>
<p>一般在html文档第一行声明。用来告知浏览器用什么文档解析标准来解析当前文档。解析模式分为标准模式和兼容模式。</p>
<h2 id="标准模式-兼容模式">标准模式 &amp;&amp; 兼容模式</h2>
<ul>
<li>标准模式：标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。</li>
<li>兼容模式：页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
<h2 id="link-和-import区别">link 和 @import区别</h2>
<ul>
<li>从属关系：link是基于html的语法，而@import是基于css的，css2.1之后才出现。</li>
<li>加载顺序：link中的内容可以随页面其他内容一起加载，而@import中引入的css必须等其他全部加载完成后再开始加载。</li>
<li>兼容性区别：link是基于html的，不存在兼容性问题。@import是css2.1之后才出现的，会存在部分IE5+之前的浏览器在不兼容的问题。</li>
<li>DOM可操作性： 可以通过JS操作DOM改变link中的内容来改变样式；而DOM是基于文档的，无法使用@import来改变。</li>
</ul>
<h2 id="浏览器渲染原理">浏览器渲染原理</h2>
<ol>
<li>首先解析收到HTML的文件，构造DOM树。</li>
<li>对CSS文件进行解析，构造CSSOM规则树。</li>
<li>根据DOM和CSSOM规则树构造渲染树。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也叫做回流/重排）.</li>
<li>布局阶段结束后是绘制阶段（重绘），遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ol>
<h2 id="async-和-defer-的作用和区别">async 和 defer 的作用和区别</h2>
<ol>
<li>如果script中没有async和defer，则浏览器会自动加载和执行指定对脚本文件，并暂停其他资源的加载和执行，知道script中的资源加载执行完毕。</li>
<li><strong>defer</strong>：表示延迟执行引入的JS。JS加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</li>
<li><strong>async</strong>：表示异步执行引入JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</li>
</ol>
<img src="https://segmentfault.com/img/bVWhRl?w=801&h=814">
<h2 id="DOMContentLoaded-事件和-Load-事件的区别">DOMContentLoaded 事件和 Load 事件的区别</h2>
<p>DOMContentLoaded在HTML文件全部加载完成后触发，并不需要等待css样式、图片图表等文件的加载。</p>
<p>Load必须等到所有文件全部加载完成后才会触发。</p>
<h2 id="HTML离线缓存">HTML离线缓存</h2>
<p>原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p>
<p>离线的情况下，浏览器就直接使用离线存储的资源。</p>
<h2 id="attibute和property区别">attibute和property区别</h2>
<p>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；<br>
property 就是 dom 元素在 js 中作为对象拥有的属性。</p>
<p>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。</p>
<h1>CSS</h1>
<h2 id></h2>
]]></content>
      <categories>
        <category>Interview</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>📖 前端问题杂烩-Vue篇(1)</title>
    <url>/2020/04/08/front-end-interview-vue/</url>
    <content><![CDATA[<h3 id="讲一讲MVVM？（⭐️⭐️⭐️⭐️）">讲一讲MVVM？（⭐️⭐️⭐️⭐️）</h3>
<p>MVVM是Model-View-ViewModel的缩写，也就是把后端概念里MVC的controller换成了viewmodel。<br></p>
<p>Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。</p>
<h3 id="讲一下Vue2-x响应式数据的原理（⭐️⭐️⭐️）">讲一下Vue2.x响应式数据的原理（⭐️⭐️⭐️）</h3>
<p>Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性。当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p>
<a id="more"></a>
<h3 id="讲一下Vue3-x响应式数据原理（⭐️⭐️⭐️⭐️）">讲一下Vue3.x响应式数据原理（⭐️⭐️⭐️⭐️）</h3>
<p>Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</p>
<h3 id="Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？（⭐️⭐️⭐️）">Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？（⭐️⭐️⭐️）</h3>
<p>判断当前Reflect.get的返回值是否为Object。如果是则再通过reactive方法做代理，这样就实现了深度观测。</p>
<h3 id="监测数组的时候可能触发多次get-set，如何防止触发多次呢？（⭐️⭐️⭐️）">监测数组的时候可能触发多次get/set，如何防止触发多次呢？（⭐️⭐️⭐️）</h3>
<p>可以通过判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p>
<h3 id="vue2-x中如何监测数组变化（⭐️⭐️）">vue2.x中如何监测数组变化（⭐️⭐️）</h3>
<p>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。<br><br>
（这里要多看vue源码和js原型链的概念。)</p>
<h3 id="nextTick是什么？它的实现原理？（⭐️⭐️）">nextTick是什么？它的实现原理？（⭐️⭐️）</h3>
<p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>setImmediate</li>
</ul>
<p>如果以上都不行则采用setTimeout<br>
定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<p>(其实问框架最终还是考验原生JavaScript的功底)</p>
<h3 id="Vue的生命周期（⭐️⭐️⭐️⭐️⭐️）">Vue的生命周期（⭐️⭐️⭐️⭐️⭐️）</h3>
<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载DOM、渲染➡️更新➡️渲染、销毁等一系列过程，这就是Vue生命周期的定义。通俗讲就是Vue实例从创建到销毁到全过程。</p>
<p><strong>beforeCreate</strong>：是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。</p>
<p><strong>created</strong>：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。</p>
<p><strong>beforeMount</strong>：  发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。</p>
<p><strong>mounted</strong>： 在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。</p>
<p><strong>beforeUpdate</strong>： 发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p>
<p><strong>updated</strong>： 发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p>
<p><strong>beforeDestroy</strong>： 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p>
<p><strong>destroyed</strong>： 发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 6 💪</title>
    <url>/2020/06/24/frontend-interview-06/</url>
    <content><![CDATA[<h1>JS</h1>
<p>这几天复习了一下JS的知识，发现有些知识点变模糊了，于是打算写一篇JS常见问题的总结帖巩固一下。</p>
<h2 id="JS里的深浅拷贝">JS里的深浅拷贝</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">letet a a = &#123;</span><br><span class="line">    age     : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 输出为2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上述例子可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</li>
<li>通常在开发中并不希望出现这样的问题，于是浅拷贝就可以来解决这个问题</li>
</ul>
<h3 id="浅拷贝">浅拷贝</h3>
<blockquote>
<p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以通过展开运算符<code>（…）</code>来解决</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常浅拷贝就能解决大部分问题了，但是当遇到如下情况就需要使用到深拷贝了</p>
</blockquote>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>浅拷贝只能解决一层数据的问题，如果接下去的值中还有对象的话，那么就又回到原来的问题了，两者享有相同的引用。要解决这个问题，需要使用深拷贝。</p>
</blockquote>
<h3 id="深拷贝">深拷贝</h3>
<blockquote>
<p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>将对象所有的内容变成JSON格式，再解析JSON出来即可。但是该方法也是有局限性的：</p>
</blockquote>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果有一个循环引用对象，会发现并不能通过该方法深拷贝</p>
</blockquote>
<ul>
<li>在遇到函数或者 <code>undefined</code> 的时候，该对象也不能正常的序列化</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    name: <span class="string">'poetries'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "poetries"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在上述情况中，该方法会忽略掉<code>函数</code>和<code>undefined</code>。</li>
<li>但是在通常情况下，复杂数据都是可以序列化的，所以<code>JSON.parse</code>和<code>JSON.stringify</code>函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。如果数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数。</li>
</ul>
<h2 id="原型问题">原型问题</h2>
<p><img src="https://camo.githubusercontent.com/71cab2efcf6fb8401a2f0ef49443dd94bffc1373/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f31332f313632316538613962636230383732643f773d34383826683d35393026663d706e6726733d313531373232" alt></p>
<ul>
<li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li>
<li>每个对象都有 <code>__proto__ </code>属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</li>
<li>对象可以通过<code> __proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li>
</ul>
<h2 id="instanceof-和-typeof-的区别">instanceof 和 typeof 的区别</h2>
<h3 id="typeof">typeof</h3>
<blockquote>
<p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>null </code>来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 <code>bug</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof null // &apos;object&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原因：因为在 <code>JS </code>的最初版本中，使用的是 <code>32</code> 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null </code>表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个<code>bug</code>却是一直流传下来。</p>
</blockquote>
<ul>
<li>如果想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call(xxxx)</code>。这样就可以获得类似 <code>[object Type]</code> 的字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( a ) );</span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( b ) );</span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( c ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[object <span class="built_in">String</span>];</span><br><span class="line">[object <span class="built_in">Array</span>];</span><br><span class="line">[object <span class="built_in">Function</span>];</span><br><span class="line"></span><br><span class="line">因此,想要得到具体的类型可以字符串截取：</span><br><span class="line"> <span class="built_in">console</span>.log( object.prototype.toString.call( a ).slice( <span class="number">8</span>, <span class="number">-1</span>) );</span><br><span class="line">结果: <span class="built_in">String</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="comment">// 也可以这样判断 undefined</span></span><br><span class="line">a === <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="instanceof">instanceof</h3>
<blockquote>
<p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span></span><br><span class="line">Bar.prototype = Foo;</span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2>
<blockquote>
<p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么函数 <code>A </code>已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A </code>中的变量？ 因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS </code>引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
</blockquote>
<p>经典中的经典面试题，循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出会是一堆6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code>。</li>
<li>解决办法两种，第一种使用闭包和<code>immediately-invoked function expression (IIFE)</code>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二种就是使用 <code>setTimeout</code> 的第三个参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( j );</span><br><span class="line">	&#125;, i*<span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( i );</span><br><span class="line">	&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 形成块级作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 2 💪</title>
    <url>/2020/03/04/front-end-interview-css/</url>
    <content><![CDATA[<h1>CSS 篇</h1>
<h3 id="盒模型">盒模型</h3>
<p>CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。<br>
box-sizing(有3个值哦)：border-box,padding-box,content-box.<br>
标准的盒子模型：width指content部分的宽度<br>
在IE盒子模型中：width表示content+padding+border<br>
标准盒子模型的盒子宽度：左右border+左右padding+width<br>
IE盒子模型的盒子宽度：width</p>
<h3 id="flex">flex</h3>
<p>Flex是Flexible Box的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。<br>
布局的传统解决方案，基于盒状模型，依赖display属性 + position属性 + float属性。<br>
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="css选择器">css选择器</h3>
<p>id 选择器，class 选择器，标签选择器，伪元素选择器，伪类选择器等<br>
同一元素引用了多个样式时，排在后面的样式属性的优先级高；<br>
样式选择器的类型不同时，优先级顺序为：id 选择器 &gt; class 选择器 &gt; 标签选择器；<br>
标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低；<br>
带有!important 标记的样式属性的优先级最高；<br>
样式表的来源不同时，优先级顺序为：内联样式&gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式</p>
<a id="more"></a>
<h3 id="BFC">BFC</h3>
<p>BFC，块级格式化上下文，用于清楚浮动，防止margin重叠等。这是一个独立的渲染区域，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有内部box垂直放置，计算BFC的高度的时候，浮动元素也参与计算，触发BFC的规则有根元素，浮动元素，position为absolute或fixed的元素，display为inline-block，table-cell，table-caption，flex，inline-flex，overflow不为visible的元素</p>
<h3 id="清除浮动：">清除浮动：</h3>
<p>bfc清除浮动<br>
给要清除浮动的元素添加样式clear （ clear的原理是使浮动元素不影响别的元素，而不是消灭浮动）<br>
父元素结束标签钱插入清除浮动的块级元素，给该元素添加样式clear<br>
添加伪元素，在父级元素的最后，添加一个伪元素，通过清除伪元素的浮动，注意该伪元素的display为block，<br>
父元素添加样式overflow清除浮动，overflow设置除visible以外的任何位置</p>
<h3 id="层叠上下文">层叠上下文</h3>
<p>层叠上下文，stacking context， 是HTML中的一个三维的概念。z-index<br>
顺序根据z-index从大到小显示，首先看父类容器的z-index。div的z-index决定了子元素的显示顺序。</p>
<h3 id="CSS-中哪些属性可以继承？">CSS 中哪些属性可以继承？</h3>
<p>每一个属性在定义中都给出了这个属性是否具有继承性，一个具有继承性的属性会在没有指定值的时候，会使用父元素的同属性的值<br>
来作为自己的值。<br>
一般具有继承性的属性有，字体相关的属性，font-size 和 font-weight 等。文本相关的属性，color 和 text-align 等。<br>
表格的一些布局属性、列表属性如 list-style 等。 还有光标属性 cursor、元素可见性 visibility 。<br>
当一个属性不是继承属性的时候，我们也可以通过将它的值设置为 inherit 来使它从父元素那获取同名的属性值来继承。</p>
<h3 id="垂直居中问题：">垂直居中问题：</h3>
<p>对于宽高固定的元素<br>
（1）我们可以利用 margin:0 auto 来实现元素的水平居中。<br>
（2）利用绝对定位，设置四个方向的值都为0，并将 margin 设置为 auto ，由于宽高固定，因此对应方向实现平分，可以实现水<br>
平和垂直方向上的居中。<br>
（3）利用绝对定位，先将元素的左上角通过 top: 50% 和 left: 50% 定位到页面的中心，然后再通过 margin 负值来调整元素<br>
的中心点到页面的中心。<br>
（4）利用绝对定位，先将元素的左上角通过 top: 50% 和 left: 50% 定位到页面的中心，然后再通过 translate 来调整元素<br>
的中心点到页面的中心。<br>
（5）使用 flex 布局，通过 align-items: center 和 justify-content: center 设置容器的垂直和水平方向上为居中对<br>
齐，然后它的子元素也可以实现垂直和水平的居中。<br>
对于宽高不定的元素，上面的后面两种方法，可以实现元素的垂直和水平的居中。</p>
<h3 id="CSS-position种类-属性？">CSS position种类&amp;属性？</h3>
<p>固定定位fixed：元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。<br>
相对定位relative：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。<br>
绝对定位absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。<br>
粘性定位sticky：元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。<br>
默认定位Static：默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。<br>
inherit:规定应该从父元素继承position 属性的值。</html></p>
<h3 id="常见页面布局">常见页面布局</h3>
<p>传统盒模型布局：文档流布局，浮动布局，定位布局<br>
弹性盒子flex布局：<br>
Grid网格布局<br>
圣杯（多列）布局<br>
双飞翼布局</p>
<h3 id="响应式布局">响应式布局</h3>
<p>1.媒体查询：CSS3媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br>
2.百分比布局：通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果<br>
3.rem布局：rem单位都是相对于根元素html的font-size来决定大小的。通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可<br>
4.视口单位<br>
5.图片响应式： 大小自适应 ｜｜ 根据分辨率尽可能选择分辨率高的图片。</p>
<h3 id="css预处理，后处理">css预处理，后处理</h3>
<p>预处理：广义上说，目标格式为 CSS 的 预处理器 是 CSS 预处理器，但本文 特指 以最终生成 CSS 为目的的 领域特定语言。Sass、LESS、Stylus 是目前最主流的 CSS 预处理器。<br>
实现原理：取到 DSL 源代码 的 分析树，将含有 动态生成 相关节点的 分析树 转换为 静态分析树，将 静态分析树 转换为 CSS 的 静态分析树，将 CSS 的 静态分析树 转换为 CSS 代码<br>
后处理：对 CSS 进行处理，并最终生成 CSS 的 预处理器，它属于广义上的 CSS 预处理器。<br>
CSS 压缩工具（如 clean-css）<br>
实现原理：将 源代码 做为 CSS 解析，获得分析树，对CSS的分析树进行后处理，</p>
<h3 id="css3新特性">css3新特性</h3>
<p>Transition:可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用Flash动画或JavaScript<br>
Transform：Transform用来向元素应用各种2D和3D转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等<br>
Animation：Animation让CSS拥有了可以制作动画的功能。使用Animation制作动画可以省去复杂的js代码</p>
<h3 id="display哪些取值">display哪些取值</h3>
<p>none：隐藏，不会占用文档流位置（其他元素会占用他的位置）<br>
inline：行内元素<br>
inline-block：行内块元素，也即有块元素的一些特性，可以设置宽高度边距等等。<br>
block：块元素，独占一行，可以设置宽高边距等等。<br>
table：相关，众所周知table域有一些特定的标签：table、tr、th、td、tfoot等等。那么可以用div等元素的来实现吗？可以，将这些元素的display设置成table-*就行。<br>
inherit：即继承。</p>
<h3 id="相邻的两个inline-block节点为什么会出现间隔，该如何解决">相邻的两个inline-block节点为什么会出现间隔，该如何解决</h3>
<p>两个In line block 节点之间有空隙原因：英文有空格作为词分界，而中文则没有。（这背后延伸出一个中文分词的问题）这个问题的原因可以上述到SGML(标准通用标记语言)和TeX(排版工具)，它实际上是一个行内（inline）的问题，它由空格、换行或回车所产生空白符所致<br>
方法1. 改变书写方式 去掉html中的空格，或者排列在一行，但是可读性差<br>
方法2：font-size<br>
方法3：使用margin负值<br>
方法4：使用word-spacing或letter-spacing</p>
<h3 id="meta-viewport-移动端适配">meta viewport 移动端适配</h3>
<p>所做的适配，就是要调整layout viewport的大小，而用meta标签就可以调整layout viewport的大小。</p>
<h3 id="rem布局的优缺点">rem布局的优缺点</h3>
<p>rem可以让我们的页面更灵活，更健壮，比起到处写死的px值，em似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能<br>
rem是弹性布局的一种，弹性布局是响应式布局的一种，但是响应式布局不是弹性布局。弹性布局强调等比缩放，强调百分百还原，响应式布局强调不同设备有不同的展现。<br>
Rem过于死板，响应式布局可以多设备自适应，</p>
<h3 id="link标签和import标签的区别：">link标签和import标签的区别：</h3>
<p>link属于html标签，而@import是css提供的<br>
页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。<br>
link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。<br>
link方式样式的权重高于@import的。</p>
<h3 id="1像素边框问题：">1像素边框问题：</h3>
<p>1）border-image 图片 实现<br>
缺点是制作图片的圆角时候会出现模糊。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.border-image<span class="number">-1</span>px &#123;</span><br><span class="line">    border-width: <span class="number">1</span>px <span class="number">0</span>px;</span><br><span class="line">    -webkit-border-image: url(<span class="string">"image_url"</span>) <span class="number">2</span> <span class="number">0</span> stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>background-image 渐变实现<br>
除啦用图片，难道纯粹的css就不能实现吗？我的确不想使用图片，感觉制作起来很麻烦，其实百度糯米团首页就是这么做的但是这种方法有个缺点，就是不能实现圆角</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.border &#123;</span><br><span class="line">      background-image:linear-gradient(<span class="number">180</span>deg, red, red <span class="number">50</span>%, transparent <span class="number">50</span>%),</span><br><span class="line">      linear-gradient(<span class="number">270</span>deg, red, red <span class="number">50</span>%, transparent <span class="number">50</span>%),</span><br><span class="line">      linear-gradient(<span class="number">0</span>deg, red, red <span class="number">50</span>%, transparent <span class="number">50</span>%),</span><br><span class="line">      linear-gradient(<span class="number">90</span>deg, red, red <span class="number">50</span>%, transparent <span class="number">50</span>%);</span><br><span class="line">      background-size: <span class="number">100</span>% <span class="number">1</span>px,<span class="number">1</span>px <span class="number">100</span>% ,<span class="number">100</span>% <span class="number">1</span>px, <span class="number">1</span>px <span class="number">100</span>%;</span><br><span class="line">      background-repeat: no-repeat;</span><br><span class="line">      background-position: top, right top,  bottom, left top;</span><br><span class="line">      padding: <span class="number">10</span>px;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>viewport+rem实现<br>
box-shadow 实现<br>
利用阴影我们也可以实现，那么我们来看看阴影，优点是圆角不是问题，缺点是颜色不好控制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    -webkit-box-shadow:<span class="number">0</span> <span class="number">1</span>px <span class="number">1</span>px <span class="number">-1</span>px rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transform: scale(0.5) 实现 推荐相当灵活<br>
其实我们刚才列举了那么多例子，无非就是把1px缩放都0.5px的状态下，而0.5px并不是所有都支持，再根据媒体查询设置不同的缩放比例就可以了，那么我们就开始玩儿缩放吧。<br>
1.用height：1px的div，然后根据媒体查询设置transform: scaleY(0.5);，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    height:<span class="number">1</span>px;</span><br><span class="line">    background:#000;</span><br><span class="line">    -webkit-transform: scaleY(<span class="number">0.5</span>);</span><br><span class="line">    -webkit-transform-origin:<span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div::after&#123;</span><br><span class="line">    content:<span class="string">''</span>;width:<span class="number">100</span>%;</span><br><span class="line">    border-bottom:1px solid #000;</span><br><span class="line">    transform: scaleY(<span class="number">0.5</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>3.用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.div::after &#123;</span><br><span class="line">    content: <span class="string">''</span>;</span><br><span class="line">    width: <span class="number">200</span>%;</span><br><span class="line">    height: <span class="number">200</span>%;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    border: 1px solid #bfbfbf;</span><br><span class="line">    border-radius: <span class="number">4</span>px;</span><br><span class="line">    -webkit-transform: scale(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    transform: scale(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    -webkit-transform-origin: top left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Interview</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 8 💪</title>
    <url>/2020/06/27/frontend-interview-08/</url>
    <content><![CDATA[<h1>React</h1>
<h3 id="React-中-keys-的作用">React 中 keys 的作用</h3>
<blockquote>
<p><code>Keys</code>是 <code>React</code> 用于追踪哪些列表中元素被修改、被添加或者被移除的 <code>辅助标识</code></p>
</blockquote>
<ul>
<li>在开发中，需要保证某个元素的 <code>key</code> 在其同级元素中具有唯一性。在 <code>React Diff</code> 算法中，<code> React</code> 会借助元素的 <code>Key</code> 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 <code>Key</code> 值来判断元素与本地状态的关联关系。</li>
</ul>
<h3 id="传入-setState-函数的第二个参数的作用">传入 setState 函数的第二个参数的作用</h3>
<blockquote>
<p>该函数会在<code>setState</code>函数调用完成并且组件开始重渲染的时候被调用，可以用该函数来监听渲染是否完成。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'tylermcginnis33'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'setState has finished and the component has re-rendered.'</span>)<span class="comment">//渲染完成才会输出log</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="React-中-refs-的作用">React 中 refs 的作用</h3>
<ul>
<li><code>Refs</code> 是 <code>React</code> 提供给的能够安全访问 <code>DOM </code>元素或者某个组件实例的句柄</li>
<li>可以为元素添加<code>ref</code>属性，然后在回调函数中接受该元素在 <code>DOM</code> 树中的句柄，该值会作为回调函数的第一个参数返回</li>
</ul>
<h3 id="在生命周期中的哪一步应该发起-AJAX-请求">在生命周期中的哪一步应该发起 AJAX 请求</h3>
<blockquote>
<p>应将AJAX 请求放到 <code>componentDidMount</code> 函数中执行</p>
</blockquote>
<ul>
<li>
<p><code>React</code> 下一代调和算法 <code>Fiber</code> 会通过开始或停止渲染的方式优化应用性能，会影响到 <code>componentWillMount</code> 的触发次数，会使得<code>componentWillMount</code> 这个生命周期函数的调用次数变得不确定。<code>React</code> 可能会多次频繁调用 <code>componentWillMount</code>。如果将 <code>AJAX</code> 请求放到 <code>componentWillMount</code> 函数中，那么会被触发多次，不采用。</p>
</li>
<li>
<p>如果我们将<code> AJAX</code> 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 <code>componentDidMount</code> 函数中进行 <code>AJAX</code> 请求则能有效避免这个问题。</p>
</li>
</ul>
<hr>
<h3 id="React-中的事件处理逻辑">React 中的事件处理逻辑</h3>
<blockquote>
<p>为了解决跨浏览器兼容性问题，<code>React</code> 将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性；另外，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的。</p>
</blockquote>
<h3 id="redux中间件">redux中间件</h3>
<blockquote>
<p>中间件提供第三方插件的模式，自定义拦截 <code>action</code> -&gt; <code>reducer</code> 的过程。变为 <code>action</code> -&gt; <code>middlewares</code> -&gt; <code>reducer </code>。这种机制可以改变数据流，实现如异步<code> action</code> ，<code>action</code> 过滤，日志输出，异常报告等功能。</p>
</blockquote>
<ul>
<li><code>redux-logger</code>：提供日志输出</li>
<li><code>redux-thunk</code>：处理异步操作</li>
<li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li>
</ul>
<h3 id="为什么虚拟dom会提高性能">为什么虚拟dom会提高性能</h3>
<blockquote>
<p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p>
</blockquote>
<p><strong>具体实现步骤如下</strong></p>
<ul>
<li>用 <code>JavaScript</code> 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中。</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。</li>
<li>把2所记录的差异应用到步骤1所构建的真正的<code>DOM</code>树上，视图就更新。</li>
</ul>
<h3 id="diff算法">diff算法</h3>
<ul>
<li>把树形结构按照层级分解，只比较同级元素。</li>
<li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li>
<li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（<code>class</code>指的是组件的名字）</li>
<li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>。到每一个事件循环结束, <code>React</code> 会检查所有标记 ，仅将标记为<code>dirty </code>的 <code>component </code>进行重新绘制.</li>
<li>选择性地进行子树渲染。可以重写<code>shouldComponentUpdate</code>从而提高<code>diff</code>的性能</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 7 💪</title>
    <url>/2020/06/26/frontend-interview-07/</url>
    <content><![CDATA[<h2 id="跨域">跨域</h2>
<blockquote>
<p>因为浏览器出于安全考虑，有同源策略。同源策略要求协议，域名，端口全部相同，若有一个不同就是跨域，则<code>Ajax</code> 请求会失败。</p>
</blockquote>
<h3 id="JSONP">JSONP</h3>
<blockquote>
<p><code>JSONP</code> 是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞，通过 <code>&lt;script&gt;</code> 标签，当需要通讯时，指向一个需要访问的地址并提供一个回调函数来接收数据</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    	<span class="built_in">console</span>.log(data)</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<ul>
<li><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求</li>
</ul>
<h3 id="CORS">CORS</h3>
<ul>
<li><code>CORS</code>需要浏览器和后端同时支持</li>
<li>浏览器会自动进行 <code>CORS</code> 通信，实现<code>CORS</code>通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li>
<li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li>
</ul>
<h3 id="document-domain">document.domain</h3>
<ul>
<li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li>
<li>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</li>
</ul>
<h3 id="postMessage">postMessage</h3>
<blockquote>
<p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://blog.poetries.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://blog.poetries.com'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Event-loop">Event loop</h2>
<h3 id="JS中的event-loop">JS中的event loop</h3>
<blockquote>
<p><code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p>
</blockquote>
<ul>
<li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p>
</blockquote>
<h3 id="微任务">微任务</h3>
<ul>
<li><code>process.nextTick</code></li>
<li><code>promise</code></li>
<li><code>Object.observe</code></li>
<li><code>MutationObserver</code></li>
</ul>
<h3 id="宏任务">宏任务</h3>
<ul>
<li><code>script </code></li>
<li><code>setTimeout</code></li>
<li><code>setInterval </code></li>
<li><code>setImmediate </code></li>
<li><code>I/O </code></li>
<li><code>UI rendering</code></li>
</ul>
<blockquote>
<p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p>
</blockquote>
<h3 id="正确的Event-loop-顺序">正确的Event loop 顺序</h3>
<ul>
<li>执行同步代码，这属于宏任务</li>
<li>执行栈为空，查询是否有微任务需要执行</li>
<li>执行所有微任务</li>
<li>必要的话渲染 UI</li>
<li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li>
</ul>
<blockquote>
<p>如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，可以把操作 <code>DOM</code> 放入微任务中</p>
</blockquote>
<p><strong>Node 中的 Event loop</strong></p>
<ul>
<li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li>
<li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure>
<p><strong>timer</strong></p>
<ul>
<li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li>
<li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li>
</ul>
<p><strong>I/O</strong></p>
<ul>
<li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li>
</ul>
<p><strong>poll</strong></p>
<ul>
<li>
<p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p>
<ul>
<li>执行到点的定时器</li>
<li>执行 <code>poll</code> 队列中的事件</li>
</ul>
</li>
<li>
<p>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情</p>
<ul>
<li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li>
<li>如果 <code>poll</code> 队列为空，会有两件事发生</li>
<li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li>
<li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li>
<li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li>
</ul>
</li>
</ul>
<p><strong>check</strong></p>
<ul>
<li><code>check</code> 阶段执行 <code>setImmediate</code></li>
</ul>
<p><strong>close callbacks</strong></p>
<ul>
<li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li>
<li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 9 💪</title>
    <url>/2020/06/28/frontend-interview-09/</url>
    <content><![CDATA[<h1>Vue</h1>
<h3 id="生命周期钩子函数">生命周期钩子函数</h3>
<ul>
<li>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</li>
<li>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以看不到。</li>
<li>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 <code>VDOM</code>，最后执行 <code>mounted</code> 钩子，并将 <code>VDOM</code>渲染为真实 <code>DOM</code> 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</li>
<li>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code>，分别在数据更新前和更新后会调用。</li>
<li>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated </code>。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li>
<li>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code>。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数</li>
</ul>
<h3 id="组件通信">组件通信</h3>
<blockquote>
<p>组件通信一般分为以下几种情况：</p>
</blockquote>
<a id="more"></a>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨多层级组件通信</li>
</ul>
<p><strong>1. 父子通信(important)</strong></p>
<ul>
<li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li>
<li>这种父子通信方式也就是典型的<code>单向数据流</code>，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>，而是必须通过发送事件的方式告知父组件修改数据。(这里和react很像)</li>
<li>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 <code>UI</code> 控件上，本质上还是通过事件的方法让父组件修改数据。</li>
<li>可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</li>
<li>Vue 2.3 及以上版本的话可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</li>
<li><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</li>
<li><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.sync</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上写法等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">update:value</span>=<span class="string">"v =&gt; value = v"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">this</span>.$emit(<span class="string">'update:value'</span>, <span class="number">1</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 兄弟组件通信</strong></p>
<blockquote>
<p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
</blockquote>
<p><strong>3. 跨多层次组件通信</strong></p>
<blockquote>
<p>对于这种情况可以使用 <code>Vue 2.2</code> 新增的 <code>API provide / inject</code>。</p>
</blockquote>
<p>假设有父组件 <code>A</code>，然后有一个跨多层级的子组件 <code>B</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>万能办法解决一切通信问题</strong></p>
<blockquote>
<p>使用 <code>Vuex</code> 或者 <code>Event Bus</code> 解决上述所有的通信情况。</p>
</blockquote>
<h3 id="extend-api-作用">extend api 作用</h3>
<blockquote>
<p>这个 <code>API</code> 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;test&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span> Component().$mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">// 除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="computed-和-watch-区别">computed 和 watch 区别</h3>
<ul>
<li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</li>
<li><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li>
<li>一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</li>
<li>另外 <code>computer</code> 和 <code>watch</code> 都支持对象的写法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    <span class="comment">// 深度遍历</span></span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 立即触发</span></span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 执行的函数</span></span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      <span class="comment">// this.aPlus 时触发</span></span><br><span class="line">      <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// this.aPlus = 1 时触发</span></span><br><span class="line">      <span class="keyword">set</span>: function (v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="keep-alive-组件作用">keep-alive 组件作用</h3>
<ul>
<li>在需要组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</li>
<li>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li>
</ul>
<h3 id="v-show-与-v-if-区别">v-show 与 v-if 区别</h3>
<ul>
<li><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 <code>CSS</code>，<code>DOM</code> 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</li>
<li><code>v-if</code> 的话就得说到 <code>Vue</code> 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，在切换时开销更高，更适合不经常切换的场景。</li>
<li>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li>
</ul>
<h3 id="组件中-data-什么时候可以使用对象">组件中 data 什么时候可以使用对象</h3>
<ul>
<li>组件复用时所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</li>
<li>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况。</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 3 💪</title>
    <url>/2020/03/05/frontend-interview-js/</url>
    <content><![CDATA[<h1>JS</h1>
<h3 id="闭包">闭包</h3>
<p>闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。<br>
应用场景？函数防抖，使用闭包设计单例模式，为多个组件独立属性，设置私有变量，取到正确值。</p>
<h3 id="类的创建和继承">类的创建和继承</h3>
<p>创建：new一个function，在这个function的prototype里面增加属性和方法。<br>
1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。<br>
2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，<br>
构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能<br>
3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承<br>
4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）<br>
5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>
6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<h3 id="Javascript-的作用域链？">Javascript 的作用域链？</h3>
<p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>
函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>
端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>
当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p>
<a id="more"></a>
<h3 id="事件流和事件模型">事件流和事件模型</h3>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。<br>
1.DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>
现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。<br>
<a href="http://2.IE" target="_blank" rel="noopener">2.IE</a> 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会<br>
首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点<br>
是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依<br>
次执行。<br>
3.DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，事件捕获阶段。捕获指的是事件从 docu<br>
ment 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型<br>
的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。<br>
事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。事件捕获阶段，处于目标阶段，事件冒泡阶段</p>
<h3 id="如何让事件先冒泡后捕获">如何让事件先冒泡后捕获</h3>
<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。<br>
根据w3c标准，应先捕获再冒泡。若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。</p>
<h3 id="事件委托与冒泡原理">事件委托与冒泡原理</h3>
<p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。<br>
事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到document/window，冒泡过程结束。<br>
举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<h3 id="如何阻止冒泡？">如何阻止冒泡？</h3>
<p>w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true</p>
<h3 id="深拷贝-浅拷贝">深拷贝 浅拷贝</h3>
<p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此<br>
两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</p>
<p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引<br>
用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对<br>
象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p>
<h3 id="懒加载和预加载">懒加载和预加载</h3>
<p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br>
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<h3 id="改变函数内部this指针的指向函数（bind，apply，call的区别）">改变函数内部this指针的指向函数（bind，apply，call的区别）</h3>
<p>Call，apply它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。<br>
bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用</p>
<h3 id="JS节流与防抖">JS节流与防抖</h3>
<ul>
<li>函数节流: 指定时间间隔内只会执行一次任务；</li>
<li>函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</li>
</ul>
<h3 id="iframe-iframe的缺点">iframe &amp;&amp; iframe的缺点</h3>
<p>定义：iframe元素会创建包含另一个文档的内联框架<br>
提示：可以将提示文字放在<iframe></iframe>之间，来提示某些不支持iframe的浏览器<br>
缺点：iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才<br>
会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。<br>
（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。<br>
（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>
（4） 浏览器的后退按钮失效。<br>
（5） 小型的移动设备无法完全显示框架。</p>
<h3 id="JS中的垃圾回收机制">JS中的垃圾回收机制</h3>
<p>垃圾回收有两种实现方式，分别是标记清除和引用计数<br>
标记清除：当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收。<br>
引用计数：统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收。</p>
<h3 id="common-js">common.js</h3>
<p>Commonjs：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载require()引入模块。</p>
<h3 id="数组去重">数组去重</h3>
<p>法一：indexOf循环去重<br>
法二：ES6 Set去重；Array.from(new Set(array))<br>
法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。</p>
<h3 id="判断数据类型（是数组）？">判断数据类型（是数组）？</h3>
<p>Object.prototype.call.toString()<br>
Instanceof</p>
<h3 id="跨域？实现方法">跨域？实现方法</h3>
<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。<br>
JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br>
location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。<br>
<a href="http://window.name" target="_blank" rel="noopener">window.name</a> + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。<br>
postMessage跨域：可以跨域操作的window属性之一。<br>
CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。<br>
代理跨域：起一个代理服务器，实现数据的转发</p>
<h3 id="重排和重绘">重排和重绘</h3>
<p>重绘：当盒子的位置、大小以及其他属性，颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。<br>
重排：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br>
重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p>
<h3 id="虚拟virtual-dom">虚拟virtual dom</h3>
<p>用JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的DOM树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>
<h3 id="webpack？">webpack？</h3>
<p>css文件<br>
webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。</p>
<h3 id="promise">promise</h3>
<p>ES6新语法，Promise是一个对象，保存着未来将要结束的事件，她有两个特征:<br>
1、对象的状态不受外部影响，Promise对象代表一个异步操作，有三种状态，pending进行中，fulfilled已成功，rejected已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是promise名字的由来<br>
2、一旦状态改变，就不会再变，promise对象状态改变只有两种可能，从pending改到fulfilled或者从pending改到rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型resolved,</p>
<h3 id="vue生命周期">vue生命周期</h3>
<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>
<h3 id="es6箭头函数特性">es6箭头函数特性</h3>
<p>1、箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this，<br>
2、箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象<br>
3、不能通过new关键字调用，同样也没有new.target值和原型</p>
<h3 id="es6新特性">es6新特性</h3>
<p>块级作用域：ES5只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题<br>
rest参数：用于获取函数的多余参数，这样就不需要使用arguments对象了，<br>
promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大<br>
模块化：其模块功能主要有两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能</p>
<h3 id="同源策略">同源策略</h3>
<p>如果没有同源策略，不同源的数据和资源（如HTTP头、Cookie、DOM、localStorage等）就能相互随意访问，根本没有隐私和安全可言。为了安全起见和资源的有效管理，浏览器当然要采用这种策略。</p>
<h3 id="PWA">PWA</h3>
<p>PWA全称Progressive Web App，即渐进式WEB应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能</p>
<h3 id="Redux">Redux</h3>
<p>在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux就相当于整个应用的管家。<br>
redux里常用方法<br>
提供 getState() 方法获取 state；<br>
提供 dispatch(action) 方法更新 state；<br>
通过 subscribe(listener) 注册监听器;</p>
<h3 id="vue双向绑定原理：">vue双向绑定原理：</h3>
<p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p>
<h3 id="什么是-DOM-和-BOM？">什么是 DOM 和 BOM？</h3>
<p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。<br>
BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM<br>
的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。</p>
<h3 id="Ajax">Ajax</h3>
<p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，<br>
更新网页的相应部分，而不用刷新整个页面的一种方法。</p>
]]></content>
      <categories>
        <category>Interview</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 1 💪</title>
    <url>/2020/03/04/frontent-interview-html/</url>
    <content><![CDATA[<h1>HTML篇</h1>
<h3 id="语义化">语义化</h3>
<p>HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer等等标签。</p>
<h3 id="移动设备忽略将页面中的数字识别为电话号码的方法">移动设备忽略将页面中的数字识别为电话号码的方法</h3>
<p>如果忽略页面中的数字识别为电话号码, 只要把这个默认行为关闭就行，只要一行代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;meta name = <span class="string">"format-detection"</span> content = <span class="string">"telephone=no"</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="http-vs-https">http vs https :</h3>
<p>定义：<br>
http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>
https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>
区别：<br>
Https协议需要ca证书，费用较高。<br>
http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>
使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443<br>
http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h3 id="websocket">websocket</h3>
<p>WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个</p>
<h3 id="Cookie、sessionStorage、localStorage的区别">Cookie、sessionStorage、localStorage的区别</h3>
<p>共同点：都是保存在浏览器端，并且是同源的<br>
cookie数据始终在同源的http请求中携带(即使不需要)，即cookie在浏览器和服务器间来回传递<br>
cookie数据还有路径（path）的概念，可以限制。cookie只属于某个路径下<br>
存储大小限制也不同–cookie数据不能超过4K，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如回话标识。<br>
webStorage虽然也有存储大小的限制，但是比cookie大得多，可以达到5M或更大<br>
数据的有效期不同 --sessionStorage：仅在当前的浏览器窗口关闭有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭<br>
作用域不同–sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面；localStorage：在所有同源窗口都是共享的；cookie：也是在所有同源窗口中共享的</p>
<a id="more"></a>
<h3 id="cookie-session区别">cookie session区别</h3>
<p>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>
2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。<br>
3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。<br>
4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie</p>
<h3 id="Doctype作用-严格模式与混杂模式如何区分？它们有何意义">Doctype作用?严格模式与混杂模式如何区分？它们有何意义?</h3>
<p>Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。<br>
严格模式的排版和JS 运作模式是 以该浏览器支持的最高标准运行。<br>
混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</p>
<h3 id="浏览器缓存，强-协商缓存">浏览器缓存，强/协商缓存</h3>
<p>浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<br>
缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。<br>
强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。<br>
协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match</p>
<table>
<thead>
<tr>
<th style="text-align:center">缓存类型</th>
<th style="text-align:right">获取资源形式</th>
<th style="text-align:center">状态码</th>
<th style="text-align:center">发送请求到服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">协商缓存</td>
<td style="text-align:right">从缓存取</td>
<td style="text-align:center">200(from cache)</td>
<td style="text-align:center">否，直接从缓存取</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">强缓存</td>
<td style="text-align:right">从缓存取</td>
<td style="text-align:center">304(undefined)</td>
<td style="text-align:center">是，通过服务器来告知缓存是否可用</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:right"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>什么时候用哪个？<br><br>
因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。</p>
<h3 id="304状态码">304状态码</h3>
<p>304：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。</p>
<h3 id="前端优化">前端优化</h3>
<p>降低请求量：合并资源，减少HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。<br><br>
加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。<br><br>
缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。<br><br>
渲染：JS/CSS优化，加载顺序，服务端渲染，pipeline。</p>
<h3 id="GET和POST的区别">GET和POST的区别</h3>
<p>get参数通过url传递，post放在request body中。<br>
get请求在url中传递的参数是有长度限制的，而post没有。<br>
get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。<br>
get请求只能进行url编码，而post支持多种编码方式<br>
get请求会浏览器主动cache，而post支持多种编码方式。<br>
get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。<br>
GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>
GET产生一个TCP数据包；POST产生两个TCP数据包。</p>
<h3 id="浏览器渲染原理？">浏览器渲染原理？</h3>
<p>1）首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。<br>
2）然后对 CSS 进行解析，生成 CSSOM 规则树。<br>
（3）根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩<br>
形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM<br>
元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。<br>
（4）当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也<br>
可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动<br>
重排”。<br>
（5）布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组<br>
件。</p>
<h3 id="输入url会发生什么？">输入url会发生什么？</h3>
<p>DNS解析–TCP连接–发送HTTP请求–服务器处理请求并返回HTTP报文–浏览器解析渲染页面–连接结束</p>
<p>输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部央视，内部央视，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304</p>
<h3 id="描述一下XSS和CRSF攻击？防御方法？">描述一下XSS和CRSF攻击？防御方法？</h3>
<p>XSS, 即为（Cross Site Scripting）, 中文名为跨站脚本, 是发生在目标用户的浏览器层面上的，当渲染DOM树的过程成发生了不在预期内执行的JS代码时，就发生了XSS攻击。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码。实际上是在目标网站的作用域下执行了这段js代码。<br>
CSRF（Cross Site Request Forgery，跨站请求伪造），字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p>
<p>XSS防御的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。也就是对提交的所有内容进行过滤，对url中的参数进行过滤，过滤掉会导致脚本执行的相关内容；然后对动态输出到页面的内容进行html编码，使脚本无法在浏览器中执行。虽然对输入过滤可以被绕过，但是也还是会拦截很大一部分的XSS攻击。</p>
<p>防御CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
]]></content>
      <categories>
        <category>Interview</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Study Go Day 1 🚩</title>
    <url>/2020/02/04/go1/</url>
    <content><![CDATA[<p>今天学习了Go的基本语法和数据结构。感觉和Ruby有点像…<br></p>
<p>以下是和以往学习的语言有很大不同的地方。</p>
<h2 id="声明类型">声明类型</h2>
<p>GO和java的类型声明正好相反，java类型写在变量前面，而Go写在变量后面。var name type = xxx.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = a</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float64</span> = <span class="number">1.3423</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Go语言的基本类型有：-br">Go语言的基本类型有：<br></h3>
<p>bool<br><br>
string<br><br>
int、int8、int16、int32、int64<br><br>
uint、uint8、uint16、uint32、uint64、uintptr<br><br>
byte // uint8 的别名<br><br>
rune // int32 的别名 代表一个 Unicode 码<br><br>
float32、float64<br><br>
complex64、complex128<br></p>
<h2 id="批量格式">批量格式</h2>
<p>每行都用 var 声明变量比较麻烦，所以我们还可以批量定义变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">    c []<span class="keyword">float32</span></span><br><span class="line">    d <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line">    e <span class="keyword">struct</span> &#123;</span><br><span class="line">        x <span class="keyword">int</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>使用关键字 var 和括号，可以将一组变量定义放在一起。</p>
<h2 id="简短格式">简短格式</h2>
<p>除 var 关键字外，还可使用更加简短的变量定义和初始化语法。<br>
名字 := 表达式</p>
<p>需要注意的是，简短模式（short variable declaration）有以下限制：<br>
定义变量，同时显式初始化。<br><br>
不能提供数据类型。只能用在函数内部。</p>
<p>和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">1</span></span><br><span class="line">a := <span class="literal">false</span></span><br><span class="line">b := <span class="string">"ewarwar"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Front-end Interview Note 4 💪</title>
    <url>/2020/04/26/frontend-interview-note/</url>
    <content><![CDATA[<h1>CSS</h1>
<h2 id="before-和-after中单引号和双引号的区别">::before 和:after中单引号和双引号的区别</h2>
<p>单冒号(:)用于css伪类，双冒号(::)用于css伪元素。有些浏览器考虑到兼容问题，部分情况下也可以用单引号(:)表示伪元素。</p>
<p>伪类(😃：一般匹配的是元素的某些特定状态，例如:hover, :link</p>
<ul>
<li>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>
元素时，我们可以通过 :hover 来描述这个元素的状态。</li>
</ul>
<p>伪元素(:😃：一般匹配的是特殊位置，比如::before ::after等。</p>
<ul>
<li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过 ::be<br>
fore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li>
</ul>
<a id="more"></a>
<h2 id="居中问题">居中问题</h2>
<h3 id="1-水平居中">1.水平居中</h3>
<ol>
<li>为div设置宽度，让margin为0 auto。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用text-align实现</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:black;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:pink;<span class="comment">/*和black区分开更清楚*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-水平垂直居中">2.水平垂直居中</h3>
<ol>
<li>容器高宽值给定时,margin设为自身宽高一半</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先将div左上角移到屏幕中心，再设置margin为自身size的一半。</p>
<ol start="2">
<li>容器宽高未知时，使用transform方法。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;<span class="comment">/* 相对定位或绝对定位均可 */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用flex布局</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;<span class="comment">/*看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="position中，不同的值其定位原点各是什么？-relative-absolute-static-fixed-inherit">position中，不同的值其定位原点各是什么？(relative,absolute,static,fixed,inherit)</h2>
<ul>
<li>
<p>absolute:<br>
生成绝对定位的元素，相对于值不为 static 的第一个父元素的 padding box 进行定位，也可以理解为离自己这一级元素最近的<br>
一级 position 设置为 absolute 或者 relative 的父元素的 padding box 的左上角为原点的。</p>
</li>
<li>
<p>fixed :生成绝对定位的元素，相对于浏览器窗口进行定位。</p>
</li>
<li>
<p>relative: 生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</p>
</li>
<li>
<p>static: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right, z-index 声明）。</p>
</li>
<li>
<p>inherit: 规定从父元素继承 position 属性的值。</p>
</li>
</ul>
<h2 id="li-与-li-之间有看不见的空白间隔问题-解决方法">li 与 li 之间有看不见的空白间隔问题 &amp;&amp; 解决方法</h2>
<p>浏览器在渲染inline行内元素的时候，为了美观会将元素间的空白字符渲染成换空格。而我们在写li的时候为了美观会将li放在单独一行，所以li换行后会产生换行符。</p>
<ul>
<li>为li设置 float: left。</li>
<li>将所有 li 写在同一行。</li>
<li>将 ul 内的font-size设为0。</li>
<li>消除 ul 的字符间隔 ，设置letter-spacing: -8px，</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>Interview Questions</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 101 / Graph(2) 💪</title>
    <url>/2020/06/13/graph03/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-37-Sudoku-Solver-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">37. Sudoku Solver</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy all of the following rules:</p>
<p>Each of the digits 1-9 must occur exactly once in each row.<br>
Each of the digits 1-9 must occur exactly once in each column.<br>
Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>
Empty cells are indicated by the character ‘.’.</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="leetcode 37">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="leetcode 37">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The given board contain only digits 1-9 and the character &apos;.&apos;.</span><br><span class="line">You may assume that the given Sudoku puzzle will have a single unique solution.</span><br><span class="line">The given board size is always 9x9.</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)<span class="keyword">return</span>; <span class="comment">//corner case</span></span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;board[<span class="number">0</span>].length ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] ==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span> ; c&lt;=<span class="string">'9'</span> ;c++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(valid(board,i,j,c))&#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;<span class="comment">//used to check every row and col;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">9</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// check each col;</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check each row;</span></span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span>*(row /<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]!=<span class="string">'.'</span>&amp;&amp;board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]==c)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Recursively call the solve function to check the graph. We try to put number 1-9 in each empty cell and then check its col and row to find whether there exist duplicate numbers. If not then we return true.</p>
<p>The tricky part is the last case in valid function. We check each 3x3 grid for a single part in each loop to make sure every number is unique in their 3x3 square area.</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-131-Palindrome-Partitioning-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">131. Palindrome Partitioning</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(res,temp,<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; temp, <span class="keyword">int</span> start, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(s,start,i))&#123;</span><br><span class="line">                temp.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">                help(res,temp,i+<span class="number">1</span>,s);</span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Common backtracking solution. Only difference is that we use a common method ‘valid’ to check whether a string is palindrome or not.</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-980-Unique-Paths-IIIr-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">980. Unique Paths IIIr</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v2">Examples</h3>
<p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p>1 represents the starting square.  There is exactly one starting square.<br>
2 represents the ending square.  There is exactly one ending square.<br>
0 represents empty squares we can walk over.<br>
-1 represents obstacles that we cannot walk over.<br>
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths:</span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, empty = <span class="number">1</span>, startx, starty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) empty++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startx = i;</span><br><span class="line">                    starty = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(grid, startx, starty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.length || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || grid[x][y] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y]==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty == <span class="number">0</span>) res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = -<span class="number">2</span>;</span><br><span class="line">        empty--;</span><br><span class="line">        dfs(grid, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(grid, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(grid, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, x, y - <span class="number">1</span>);</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        empty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we find the start point, then using dfs and backtracking to find the unique path to the end point. Triky point is that the initial empty num is 1 because start point is caculated as empty too.</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
        <tag>BackTracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 98 / Graph(1) 💪</title>
    <url>/2020/06/08/graph01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-207-Course-Schedule-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">207. Course Schedule</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<ol>
<li>DFS (Tarjan’s Algorithm) with two different state</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = pre[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = pre[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,state,i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span>[] state, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[v] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// current node is being tracking in other dfs process</span></span><br><span class="line">        <span class="keyword">if</span>(state[v] == <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// current node have been tracked so no loop here.</span></span><br><span class="line">        </span><br><span class="line">        state[v] = <span class="number">1</span>; <span class="comment">// change current node to be tracking </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,state,w))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        state[v] = <span class="number">2</span>; <span class="comment">// after searching and no loop here then we change state to be tracked</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V+E) S:O(V)</p>
<a id="more"></a>
<ol start="2">
<li>DFS (Tarjan’s Algorithm) with two boolean array</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = pre[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = pre[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] tracking = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(graph,marked,tracking,i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">boolean</span>[] marked, <span class="keyword">boolean</span>[]tracking, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        tracking[v] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(graph,marked,tracking,w))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tracking[w])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tracking[v] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V+E) S:O(V)</p>
<ol start="3">
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = prerequisite[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = prerequisite[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">            indegrees[w]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; start = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                start.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!start.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = start.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph[v]) &#123;</span><br><span class="line">                indegrees[w]--;</span><br><span class="line">                <span class="keyword">if</span> (indegrees[w] == <span class="number">0</span>) &#123;</span><br><span class="line">                    start.add(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(V+E) S:O(V)</p>
<p>DFS solution we use two states / two boolean array to check whether current node is being tracking or have been checked.</p>
<p>Normal BFS Torpological solution. Using queue to check each course’s indegree. Finally if the total courses left is not 0 then we return false.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-210-Course-Schedule-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">210. Course Schedule II</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class="line">             course 0. So the correct course order is [0,1] .</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class="line">             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;indegree.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                res[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                        res[index] = pair[<span class="number">0</span>];</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses ? res : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DFS ( to be added)</p>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-133-Clone-Graph-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">133. Clone Graph</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Example 1:<br>
<img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt="leetcode 133"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val = 1)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).</span><br><span class="line">2nd node (val = 2)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3).</span><br><span class="line">3rd node (val = 3)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).</span><br><span class="line">4th node (val = 4)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3).</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        map.put(node,dummy);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(Node nb : temp.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(nb))&#123;</span><br><span class="line">                    map.put(nb,<span class="keyword">new</span> Node(nb.val));</span><br><span class="line">                    queue.add(nb);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(temp).neighbors.add(map.get(nb));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS thoughts. Clone each node to it’s new node and put them into hashmap. Then using dummy node to keep recode of the new map.</p>
<p>T:O(n) S:O(n)</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Talk is cheap. Show me the code.</title>
    <url>/2019/02/20/hello-world/</url>
    <content><![CDATA[<h2 id="Hi！">Hi！</h2>
<p>Hi, here is my personal website and my first blog. From the beginning of the determination to switch to the code farmers, I have always hoped to have a home in the network world. Because I have been busy studying abroad, I am now on the winter vacation and can finally free up time to build my own blog. Non-technical origin, from the front-end basic language, to the popular front-end framework React, Angular, Spring, Firebase, etc., slowly explored by themselves, relying on interest and perseverance. I hope that when I lose the last line of code, the entire website appears completely in front of me, and I have no hard work. Of course, this is just a simple beginning. There are still many things to learn. Keep hungry and keep learning.</p>
<h2 id="嗨！">嗨！</h2>
<p>嗨，这里是我个人网站，也是我的第一个博客。从下定决心转行码农开始，就一直希望能在网络世界里里有一个属于自己的家。由于之前一直在忙留学的事情，现在放寒假了，终于能空出时间来打造一个自己的Blog。 非科班出身，从前端的基本语言，再到流行前后端框架React,Angular,Spring,Firebase等，自己慢慢摸索，全靠兴趣和毅力支撑。如愿以偿地，当我输完最后一行代码的时候，整个网站完整地出现在我眼前，也算没有白努力吧。当然，这只是一个简单的开始，要学习的还有很多，少说多做。Keep hungry and keep learning。</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode EveryDay 99 / Graph(2) 💪</title>
    <url>/2020/06/09/graph02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1102-Path-With-Maximum-Minimum-Value-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1102. Path With Maximum Minimum Value</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].</p>
<p>The score of a path is the minimum value in that path.  For example, the value of the path 8 →  4 →  5 →  9 is 4.</p>
<p>A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south).</p>
<img src="https://assets.leetcode.com/uploads/2019/04/23/1313_ex1.JPG" alt="leetcode 1102">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[5,4,5],[1,2,6],[7,4,6]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">The path with the maximum score is highlighted in yellow.</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;Integer.compare(b[<span class="number">0</span>],a[<span class="number">0</span>]));</span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> minval = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> i = temp[<span class="number">1</span>], j= temp[<span class="number">2</span>],val = temp[<span class="number">0</span>];</span><br><span class="line">            minval = Math.min(minval,val);</span><br><span class="line">            <span class="keyword">if</span>(i==m-<span class="number">1</span> &amp;&amp; j==n-<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> newx = i+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newy = j+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newx &gt;=<span class="number">0</span> &amp;&amp; newx&lt;m &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;n &amp;&amp; !seen[newx][newy])&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[newx][newy],newx,newy&#125;);</span><br><span class="line">                    seen[newx][newy] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using BFS to keep searching the max value path. Using priorityqueue to keep the max one on the top. And keep the minval to find the minval in the max path.</p>
<p>T:O(n) S:O(n)</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-765-Couples-Holding-Hands-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">765. Couples Holding Hands</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/couples-holding-hands/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p>
<p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p>
<p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ;i++)&#123;</span><br><span class="line">                parents[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[n] == n)<span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">return</span> parents[n] = find(parents[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(a);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(b);</span><br><span class="line">            <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">                parents[root1] = root2;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="keyword">int</span>[] row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = row.length /<span class="number">2</span>;</span><br><span class="line">        UF unionfind = <span class="keyword">new</span> UF(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;N ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a  = row[i*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> b  = row[i*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            unionfind.union(a/<span class="number">2</span>,b/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionfind.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using UF is more efficient. Just regard each couple is a vertex in the graph, what we need to do is to find the number of unconnected components, which is also the times we need to swap.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1267-Count-Servers-that-Communicate-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1267. Count Servers that Communicate</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.</p>
<p>Return the number of servers that communicate with any other server.<br>
<img src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" alt="leetcode 1267"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: grid = [[1,0],[0,1]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: No servers can communicate with others.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    row[i]++;</span><br><span class="line">                    col[j]++;</span><br><span class="line">                    total++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[i]==<span class="number">1</span> &amp;&amp; col[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        total--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we loop each vertex in the graph, if it’s value is 1 we add 1 to total and update the row and col array to count the total computers that are on the same row or col. Then we loop the graph again to remove the single computer, which row and col is only 1.</p>
<p>T:O(m*n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">802. Find Eventual Safe States</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</p>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
<p>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="leetcode 802">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<p>DFS -  Tarjan’s Torpological</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,i,state))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> node, <span class="keyword">int</span>[] state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[node] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(state[node] == <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        state[node] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,num,state))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T: O(V + E) S: O(V)</p>
<p>Using <a target="_blank" href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#:~:text=Tarjan's%20algorithm%20is%20an%20algorithm,path%2Dbased%20strong%20component%20algorithm.">Tarjan’s algo torpological</a> to find SCC. If there is no SCC then we return true which means we can reach final safe state, then we add current node into res. Otherwise we return false.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-684-Redundant-Connection-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">684. Redundant Connection</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v4">Example</h3>
<p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p>
<p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v5">Solution</h3>
<p>Union-Find:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=edges.length; i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(parents,edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(parents,edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(root1 == root2)&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parents[root1] = root2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == parents[i])<span class="keyword">return</span> i;</span><br><span class="line">        parents[i] = find(parents,parents[i]);</span><br><span class="line">        <span class="keyword">return</span> parents[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is clearly that we have to find the edge that cause a loop in the graph. So UF is the best way to do that. Once we find one vertex have the same root with other vertex then we return the edge that current vertex exist in.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-841-Keys-and-Rooms-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">841. Keys and Rooms</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v5">Example</h3>
<p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room.</p>
<p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p>
<p>Initially, all the rooms start locked (except for room 0).</p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return true if and only if you can enter every room.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v6">Solution</h3>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(rooms == <span class="keyword">null</span> || rooms.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> key : rooms.get(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(key))&#123;</span><br><span class="line">                    set.add(key);</span><br><span class="line">                    stack.push(key);</span><br><span class="line">                    <span class="keyword">if</span>(set.size() == rooms.size())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size() == rooms.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<p>Straight forward solution. Using BFS to get each key and store them in set. Using stack to keep track of the rooms that we just opened.<br>
We only need to check whether the size of set and size of rooms are same.</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 18</title>
    <url>/2019/05/29/leeetcode18/</url>
    <content><![CDATA[<h2 id="138-Copy-List-with-Random-Pointer-Hashmap-linkedlist">138. Copy List with Random Pointer (Hashmap &amp;&amp; linkedlist)</h2>
<img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png">
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomlist</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(cur.val, next, <span class="keyword">null</span>);</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next.random = c.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node copyhead = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node curnext = cur.next.next;<span class="comment">//cur链表</span></span><br><span class="line">            Node copy = cur.next;<span class="comment">//copy链表</span></span><br><span class="line">            cur.next = curnext;</span><br><span class="line">            <span class="keyword">if</span>(curnext!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                copy.next = curnext.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = curnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>在原node的后面复制一个node’，然后将random指向对应的位置，最后各自连接链表，共三次循环，第一次复制，第二次random连线，第三次各自成线。<br><br>
大概思路如图：<br>
<img src="https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/138.%20Copy%20List%20with%20Random%20Pointer.jpg"></p>
<h2 id="74-Search-a-2D-Matrix-Binary-Search">74. Search a 2D Matrix (Binary Search)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> end = rows*cols-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[mid/cols][mid%cols] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[mid/cols][mid%cols] &lt; target)&#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>二分查找的题，原题是2D矩阵，但其实不用那么复杂，考虑为一位数组就可以，利用mid/cols可以判断是第几小段，类似横向排布，所以matrix[mid/cols][mid%cols]方法将二维矩阵转换成了一维数组的问题。不错的idea。</p>
<h2 id="81-Search-in-Rotated-Sorted-Array-II-Binary-Search">81. Search in Rotated Sorted Array II(Binary Search)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums ,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//check each num so we will check start == end</span></span><br><span class="line">        <span class="comment">//We always get a sorted part and a half part</span></span><br><span class="line">        <span class="comment">//we can check sorted part to decide where to go next</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">             <span class="comment">//if left part is sorted</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[start])&#123;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; nums[mid] || target &lt; nums[start])&#123;</span><br><span class="line">                    <span class="comment">//target is in rotated part</span></span><br><span class="line">                    start = mid +<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    end = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[start])&#123;</span><br><span class="line">                 <span class="comment">//right part is rotated</span></span><br><span class="line">            <span class="comment">//target is in rotated part</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid] || target &gt; nums[end])&#123;</span><br><span class="line">                    end = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//duplicates, we know nums[mid] != target, so nums[start] != target</span></span><br><span class="line">            <span class="comment">//based on current information, we can only move left pointer to skip one cell</span></span><br><span class="line">            <span class="comment">//thus in the worest case, we would have target: 2, and array like 11111111, then</span></span><br><span class="line">            <span class="comment">//the running time would be O(n)</span></span><br><span class="line">                start++;<span class="comment">//这里用end--也是可以的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>一道比较复杂的二分查找，数组无规律sort，分为高低两区，需要判断哪个区然后再进一步做决定，具体比较繁琐。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 23</title>
    <url>/2019/06/17/leetcode%2023/</url>
    <content><![CDATA[<h2 id="109-Convert-Sorted-List-to-Binary-Search-Tree-linked-list-recursion">109. Convert Sorted List to Binary Search Tree(linked list/recursion)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow = head,fast=head,preslow=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            preslow = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preslow!=<span class="keyword">null</span>)preslow.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(slow == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode n = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="keyword">if</span>(head != slow)&#123;</span><br><span class="line">            n.left = sortedListToBST(head)</span><br><span class="line">            n.right = sortedListToBST(slow.next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>BST的题，原数组是sorted的，所以思路比较好想。直接找到中间数作为root，左右分别找中间数，recursive调用。<br><br>
比较好的两点：<br><br>
1.定义preslow，用来作为左半部分的tail，并且将tail.next=null,切断<br><br>
2.利用slow 和 fast不断循环的思路，fast领先slow两个数，所以当fast next next = null时，slow正好在中间位置。</p>
<h2 id="97-Interleaving-String（DP">97. Interleaving String（DP)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isintervleaing</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((s1.length()+s2.length())!=s3.length())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">boolean</span>[s2.length()+<span class="number">1</span>][s1.length()+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            matrix[<span class="number">0</span>][i] = matix[<span class="number">0</span>][i-<span class="number">1</span>]&amp;&amp;(s1.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = matrix[i-<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; (s2.charAt(i-<span class="number">1</span>)==s3.charAt(i-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                matrix[i][j] = (matrix[i-<span class="number">1</span>][j] &amp;&amp; (s2.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>))) || (matrix[i][j-<span class="number">1</span>] &amp;&amp; (s1.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix[s2.length][s1.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hard的dp题，判断两个字符串是否为交叉的。不论哪个在前，肯定有一个满足分字符串的位置和总字符串的位置相同。先将s1和s2分别检测，存在第一行和第一列里。最后进行全局扫描，注意i+j-1的应用。</p>
<h2 id="77-Combinations-Backtracking">77. Combinations (Backtracking)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        combine(ans,<span class="keyword">new</span> ArrayList&lt;&gt;(),<span class="number">1</span>,n,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; comb,<span class="keyword">int</span> start,<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(comb));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i&lt;=n,i++)&#123;</span><br><span class="line">            comb.add(i);</span><br><span class="line">            combine(ans,comb,i+<span class="number">1</span>,n,k-<span class="number">1</span>);</span><br><span class="line">            comb.remove(comb.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>backtracking思路。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 19</title>
    <url>/2019/05/30/leetcode%2019/</url>
    <content><![CDATA[<h2 id="153-Find-Minimum-in-Rotated-Sorted-Array-Binary-search">153. Find Minimum in Rotated Sorted Array (Binary search)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findmin</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>无重复数字。二分查找的基本思想。稍微难度增加，要求找到最小值，并且数组sort rotated。基本思路和二分差不多，设置mid，判断mid和right的大小。<br>如果mid&lt;right，那么说明mid在顺序sort的数组里，正常缩小right范围即可。<br>如果mid&gt;right时，说明rotate的数组部分在mid右侧，所以更新left为mid+1。最后返回left值。</p>
<h2 id="154-Find-Minimum-in-Rotated-Sorted-Array-II-Binary-search">154. Find Minimum in Rotated Sorted Array II (Binary search)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findmin2</span><span class="params">(<span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end-start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[end])&#123;</span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>上一题的升级版，存在重复的数字。 比第一道题多了一个分析情况，当mid = end时，end要–，依旧是和end的数字比较，比直接和start数字比较方便快捷。</p>
<h2 id="167-Two-Sum-II-Input-array-is-sorted">167. Two Sum II - Input array is sorted</h2>
<p>自己做的binary search 方法，4ms，超过19%，有点慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span>,right = numbers.length -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = target - numbers[i];</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(numbers[mid] == temp)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+ <span class="number">1</span>, mid+ <span class="number">1</span>&#125;;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &lt; temp)&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了discuss，比较好的是two pointer方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">souliton</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] index = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="keyword">null</span> || num.length&lt;<span class="number">2</span>)<span class="keyword">return</span> index;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = num.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">long</span> v = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(v == target)&#123;</span><br><span class="line">                index[<span class="number">0</span>] = left + <span class="number">1</span>;</span><br><span class="line">                index[<span class="number">1</span>] = right + <span class="number">1</span>;</span><br><span class="line">                brerak;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v &gt;target)&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较直观，容易理解的思路，用long v 代替 int v是个很好的方法，为了防止int overflow。</p>
<h2 id="174-Dungeon-Game-dp-programming">174. Dungeon Game (dp programming)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">caculationminHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][]hp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == m-<span class="number">1</span> &amp;&amp; j == n-<span class="number">1</span>)&#123;</span><br><span class="line">                    hp[i][j] = Math.max(<span class="number">1</span>-dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( i == m-<span class="number">1</span>)&#123;</span><br><span class="line">                    hp[i][j] = Math.max(hp[i][j+<span class="number">1</span>] - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( j == n-<span class="number">1</span>)&#123;</span><br><span class="line">                    hp[i][j] = Math.max(hp[i+<span class="number">1</span>][j] - dungeon[i][j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    hp[i][j] = Math.min(Math.max(hp[i][j+<span class="number">1</span>] - dungeon[i][j],<span class="number">1</span> ),Math.max(hp[i+<span class="number">1</span>][j] - dungeon[i][j], <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>非常烧脑的一道题。自下而上的dp思想。当前位置的生命值最少为1，所以要满足当前hp减去地牢损耗值 &gt;=1。<br><br>
四种情况：<br><br>
1.最右下角的位置，终点处生命值判断；<br><br>
2.最后一行，从右至左扫描，上一个hp减去当前的地牢损耗值&gt;1即可<br><br>
3.最后一列，从下至上扫描，上一个hp减去当前的地牢损耗值&gt;1即可<br><br>
4.任意位置，要求这个位置的右方或者下方的值减去相对应的损耗值后都要大于1，并且在符合要求的hp中选取最小的最为最优选。<br><br>
最后返回hp[0][0],也就是起始位置的最小值。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 20</title>
    <url>/2019/06/06/leetcode%2020/</url>
    <content><![CDATA[<h2 id="写在前面">写在前面</h2>
<p>最近事情比较多，办签证，写论文，改格式，没什么时间刷题和看网课了，现在总算是闲下来了，之后大概就是一遍准备答辩ppt一遍刷题吧。加油加油。</p>
<h2 id="209-Minimum-Size-Subarray-Sum-two-pointers">209. Minimum Size Subarray Sum(two pointers)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minsub</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, <span class="keyword">int</span> from = <span class="number">0</span>, mn = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=s)&#123;</span><br><span class="line">                mn = Math.min(mn,i-from+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[from];</span><br><span class="line">                from++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (mn == Integer.MAX_VALUE)? <span class="number">0</span> : mn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针问题，from为起始位置，sliding window思想循环下去，当sum&gt;s时，将from从sum减去，同时from++，滑动检索。</p>
<a id="more"></a>
<h2 id="222-Count-Complete-Tree-Nodes">222. Count Complete Tree Nodes</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftdepth = leftdepth(root);</span><br><span class="line">        <span class="keyword">int</span> rightdepth = rightdepth(root);</span><br><span class="line">        <span class="keyword">if</span>(leftdepth == rightdepth)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftdepth) -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+countNodes(root.left) + countNodes(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftdepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">            dep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightdepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            dep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断节点的个数，节点数N和层数depth对关系：N = 2^depth - 1。然后分左右俩个depth函数来计算深度。</p>
<h2 id="87-Scramble-String">87. Scramble String</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isScramble</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> len = s1.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            letters[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            letters[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(letters[i] !=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(<span class="number">0</span>,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(isScramble(s1.substring(<span class="number">0</span>,i), s2.substring(len-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(<span class="number">0</span>,len-i))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似trie的树字典，但是做法比较简单。判断两个字符串是否是同一个，先判断是否为空，其次判断是否直接相等，在判断长度（这里如果长度不同直接false）<br>
用letter 存住每个字母的值，s1的++，s2的–，如果相同应该仍为0。注意substring的用法。（起始，结束）or(某位置以后的全部元素)。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 24</title>
    <url>/2019/06/20/leetcode%2024/</url>
    <content><![CDATA[<h2 id="99-Recover-Binary-Search-Tree-BST-In-Order-traversal">99. Recover Binary Search Tree(BST In-Order-traversal)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode first;</span><br><span class="line">    <span class="keyword">private</span> TreeNode second;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">        second = <span class="keyword">null</span>;</span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">int</span> temp = first.val;</span><br><span class="line">        first.val = second.val;</span><br><span class="line">        second.val = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(first==<span class="keyword">null</span> &amp;&amp; (pre==<span class="keyword">null</span> ||pre.val&gt;=root.val))&#123;</span><br><span class="line">            first = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first!=<span class="keyword">null</span> &amp;&amp; pre.val&gt;=root.val)&#123;</span><br><span class="line">            second = root;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置两个指针分别指向中序遍历中出现局部降序的节点，设置pre指针指向当前节点的前一个节点，在中序遍历中比较前一节点和当前节点的数值，从而判断是否为局部降序，最后，将两个局部降序指针指(first\second)向的节点的数值交换，即可完成搜索二叉树的恢复.</p>
<a id="more"></a>
<h2 id="135-Candy-two-scan">135. Candy(two scan )</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candies[] = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];        </span><br><span class="line">        Arrays.fill(candies, <span class="number">1</span>);<span class="comment">// Give each child 1 candy </span></span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; candies.length; i++)&#123;<span class="comment">// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child</span></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candies[i] = (candies[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = candies.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child</span></span><br><span class="line">	        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) candies[i] = Math.max(candies[i], (candies[i + <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> candy : candies)  </span><br><span class="line">    	    sum += candy;        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较难的一道题，当相邻的两个数，下一个比当前大时，下一个位置分配的糖果多一个。所以左至右和右至左都扫描一次，解决了连续重复数字的问题。<br><br>
I’ve come up with a simple proof of this algo.<br></p>
<p>init with all 1<br></p>
<p>we only give one more when we see adjacent increase (both from left to right)<br></p>
<p>I want to use some case to illustrate this ((notices we don’t care the exact value of ratings, only their relation)<br></p>
<p>the rating is similar to ‘wave’, increase of decrease<br><br>
let’s look at this case:<br><br>
ratings: [1,3,6,9,4,2]<br><br>
candies: [1,2,3,4,2,1]<br></p>
<p>the highest rating is 9, when scan from left to right, num of candies should be 4, scan right to left, it should be 3, then we choose the larger value.<br></p>
<p>and let’s look at some case containing adjacent-equal<br></p>
<p>when there are adjacent-equal, lets look at some cases:<br></p>
<p>ratings: [1,2,3,3,3,3,4,5]<br><br>
candies: [1,2,3,1,1,1,2,3]<br></p>
<p>ratings: [1,2,8,8,8,8,8,2]<br><br>
candies: [1,2,3,1,1,1,2,1]<br></p>
<p>with these cases it should be easier to understand.<br></p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 11</title>
    <url>/2019/05/16/leetcode11/</url>
    <content><![CDATA[<h2 id="15-3-Sum">15. 3 Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.lenght-<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span> || nums[i]!=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> lo = i+<span class="number">1</span>,hi=nums.length-<span class="number">1</span>,sum=<span class="number">0</span>-nums[i];</span><br><span class="line">				<span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">					<span class="keyword">if</span>(nums[lo] + nums[hi] == sum)&#123;</span><br><span class="line">						res.add(Array.asList(nums[i],nums[lo],nums[hi]));</span><br><span class="line">						<span class="keyword">while</span>(lo&lt;hi &amp;&amp; nums[lo] == nums[lo+<span class="number">1</span>])lo++;</span><br><span class="line">						<span class="keyword">while</span>(lo&lt;hi &amp;&amp; nums[hi] == nums[hi-<span class="number">1</span>])hi--;</span><br><span class="line">						lo++;</span><br><span class="line">						hi--;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[lo] + nums[hi]&lt;sum)lo++;</span><br><span class="line">					<span class="keyword">else</span> hi--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Hint">Hint</h3>
<p>先排序，3 pointer方法，i，lo，hi，sum = 目标值-nums[i],然后开始比较lo和hi的和与sum的大小关系。<br>
注意array.aslist的用法。</p>
<h2 id="16-3-sum-closet">16. 3 sum closet</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="keyword">int</span> sum = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[nums.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> closetnums = sum;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.lenght-<span class="number">2</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">0</span> || nums[i]!=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> left = i+<span class="number">1</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">					sum = nums[left] + nums[right] + nums[i];</span><br><span class="line">					<span class="keyword">if</span> (sum&lt;target)&#123;</span><br><span class="line">						<span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">							left++;</span><br><span class="line">						&#125;</span><br><span class="line">						left ++;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">						<span class="keyword">while</span>(left&lt;right&amp;&amp; nums[right]==nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">							right--;</span><br><span class="line">						&#125;</span><br><span class="line">						right--;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">return</span> sum;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (Math.abs(target-sum)&lt;Math.abs(target - closetnums))&#123;</span><br><span class="line">						closetnums = sum;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> closetnums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hint-v2">Hint</h3>
<p>和3sum一样的思路，3 pointer，i，left，right，将排序后的第一，第二，最后三个数的和暂时存为closetnums,循环里用sum存下临时的和，与target比较，只有相等时返回sum，否则都要进行比较，取差值最小的作为下一个closetnums。</p>
<h2 id="18-4-Sum">18. 4 Sum</h2>
<pre><code class="language-java">public class Solution {
	int len = 0;
	public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {
		len = nums.length;
		Arrays.sort(nums);
		return ksum(nums,target,4,0)
		private ArrayList&lt;List&lt;Integer&gt;&gt; ksum(int[] nums, int target, int k, int index){
			ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
			if (index &gt;= len){
				return res;
			}
			if (k==2){
				int i = index, j = len - 1;
				while(i&lt;j){
					if(target-nums[i] == nums[j]){
						List&lt;List&lt;Integer&gt;&gt; temp = new ArraysList&lt;&gt;();
						temp.add(nums[i]);
						temp.add(target - nums[i]);
						res.add(temp);
						while(i&lt;j&amp;&amp; nums[i]==nums[i+1]) i++;
						while(i&lt;j &amp;&amp; nums[j]==nums[j-1])j--;
						i++;
						j--;
					}else if(target - nums[i]&gt;nums[j]){
						i++;
					}else{
						j--;
					}
				}
			}else{
				for(int i = index; i&lt; len - k + 1;i++){
					ArrayList&lt;List&lt;Integer&gt;&gt; temp = ksum(nums,target - nums[i], k-1,i++);
					if(temp!=null){
						for(List&lt;Integer&gt; t : temp){
							t.add(0,nums[i]);
						}
						res.addAll(temp);
					}
					while(i&lt;len-1 &amp;&amp; nums[i] == nums[i+1]){
						i++;
					}
				}
			}
			return res;
		}
	}
</code></pre>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>IBM 高频 Online Assignments</title>
    <url>/2019/10/16/ibmoa/</url>
    <content><![CDATA[<h2 id="IBM-OA-2020-高频-Two-Strings">IBM | OA 2020 高频 | Two Strings</h2>
<p><img src="https://assets.leetcode.com/users/sunnypatel165/image_1571206298.png"><br>
<img src="https://assets.leetcode.com/users/sunnypatel165/image_1571206020.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String[] a = &#123;<span class="string">"ab"</span>, <span class="string">"cd"</span>, <span class="string">"ef"</span>&#125;;</span><br><span class="line">	    String[] b = &#123;<span class="string">"af"</span>, <span class="string">"ee"</span>, <span class="string">"ef"</span>&#125;;</span><br><span class="line">        String[] res = commonSubstring(a,b);</span><br><span class="line">        <span class="keyword">for</span>(String ans : res)&#123;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commonSubstring</span><span class="params">(String[] a, String[] b)</span></span>&#123;</span><br><span class="line">        String res = <span class="keyword">new</span> String[a.length];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> twobitA = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> twobitB = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;a[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> a = a[i].charAt(j);</span><br><span class="line">                <span class="keyword">char</span> b = b[i].charAt(j);</span><br><span class="line">                twobitA ｜= <span class="number">1</span> &lt;&lt; (a-<span class="string">'a'</span>);</span><br><span class="line">                twobitB ｜= <span class="number">1</span> &lt;&lt; (b-<span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = (twobitA &amp;&amp; twobitB ) &gt; <span class="number">0</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tricky：利用二进制相同返回值大于0否则为00000…的方法。｜= 是二进制里的+=，即将该位置的所有二进制结果相加，最后和b的相比较，若有相同的，则返回的二进制肯定不是0，若没有，则返回的一定是00000…</p>
<a id="more"></a>
<h2 id="IBM-OA-2020-高频-Aladdin-and-his-Carpet">IBM | OA 2020 高频 | Aladdin and his Carpet</h2>
<p><img src="https://assets.leetcode.com/users/sunnypatel165/image_1571205524.png"><br>
<img src="https://assets.leetcode.com/users/sunnypatel165/image_1571205505.png"><br>
<img src="https://assets.leetcode.com/users/sunnypatel165/image_1571205483.png"><br>
<img src="https://assets.leetcode.com/users/sunnypatel165/image_1571205464.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function">pubic <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">optimalpoints</span><span class="params">(List&lt;Integer&gt; magic, List&lt;Integer&gt; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>,cur=<span class="number">0</span>,total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magic.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cost = magic.get(i) - dist.get(i);</span><br><span class="line">            cur+=cost;</span><br><span class="line">            total+=cost;</span><br><span class="line">            <span class="keyword">if</span>(cur&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total &gt; <span class="number">0</span> ? pos+<span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gas station的类型题，判断那个位置可以开始进行循环后最终值不小于零。相同的题目链接<a href="https://leetcode.com/problems/gas-station/" target="_blank" rel="noopener"> leetcode–gasstation </a></p>
]]></content>
      <categories>
        <category>IBM-OA</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>OnlineAssignments</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 12</title>
    <url>/2019/05/17/leetcode12/</url>
    <content><![CDATA[<h2 id="22-Generate-Parentheses">22. Generate Parentheses</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		helper(res,<span class="keyword">new</span> StringBuilder(),<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res, StringBuilder sb, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(open==n&amp;&amp;close==n)&#123;</span><br><span class="line">			res.add(sb.toString());</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(open&lt;n)&#123;</span><br><span class="line">			sb.append(<span class="string">'('</span>);</span><br><span class="line">			helper(res,sb,open+,slose,n);</span><br><span class="line">			sb.setLength(sb.length()-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(close&lt;open)&#123;</span><br><span class="line">			sb.append(<span class="string">')'</span>);</span><br><span class="line">			helper(res,sb,open,close+<span class="number">1</span>,n);</span><br><span class="line">			sb.setLength(sb.length()-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Hint">Hint</h3>
<p>backtrack 和buildstring结合。首先第一个必须是（，下一步（or)都可以，但是打印）的前提是（的数量要大于）的数量，记住每一次要将sb的length backtrack 减1.</p>
<h2 id="25-Reverse-Nodes-in-k-Group">25. Reverse Nodes in k-Group</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseGroup</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		ListNode curr = head;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(curr!=<span class="keyword">null</span>&amp;&amp;count!=k)&#123;</span><br><span class="line">			curr=curr.next;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">			curr = reverseGroup(curr,k);</span><br><span class="line">			<span class="keyword">while</span>(count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				ListNode temp = head.next;</span><br><span class="line">				head.next = curr;</span><br><span class="line">				curr = head;</span><br><span class="line">				head = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			head = curr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hint-v2">Hint</h3>
<p>每遇到k个元素就要翻转一次，每个循环的翻转次数一共是count也就是k次，注意翻转的code表达。</p>
<h2 id="30-Substring-with-Concatenation-of-All-Words">30. Substring with Concatenation of All Words</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">find</span><span class="params">(String s, String[] words)</span></span>&#123;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		<span class="keyword">int</span> wordnum = words.length();</span><br><span class="line">		<span class="keyword">if</span> (wordnum==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> wordlen = words[<span class="number">0</span>].length();</span><br><span class="line">		HashMap&lt;String,Integer&gt; allwords = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String w :words)&#123;</span><br><span class="line">			<span class="keyword">int</span> value = allwords.gerOrDefault(w,<span class="number">0</span>);</span><br><span class="line">			allwords.put(w,value+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length()-wordnum*wordlen+<span class="number">1</span>;i++)&#123;</span><br><span class="line">			HashMap&lt;String,Integer&gt; haswords = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">			<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(num&lt;wordnum)&#123;</span><br><span class="line">				String word = s.substring(i+num*wordlen,i+(num+<span class="number">1</span>)*wordlen);</span><br><span class="line">				<span class="keyword">if</span>(allwords.containKey(word))&#123;</span><br><span class="line">					<span class="keyword">int</span> value = haswords.gerOrDefault(word,<span class="number">0</span>);</span><br><span class="line">					haswords.put(word,value+<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">if</span>(haswords.get(word)&gt;allwords.get(word))&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(num==wordnum)&#123;</span><br><span class="line">				res.add(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hint-v3">Hint</h2>
<p>Hard题，亮点是用到两个HashMap，第一个是将words里面单词的个数存入，hashmap2是用来遍历string的时候，将当前word字段的个数存入hashmap2，在进行比较，若map1里的个数小于map2里的个数，或者有新的字段，则break；否则进行下一个字段，直到当前长度的words全部检查后，没有异常则将i存入res。<br>
具体思路在 <a href="https://leetcode.windliang.cc/leetCode-30-Substring-with-Concatenation-of-All-Words.html" target="_blank" rel="noopener">leetcode 30</a></p>
<h2 id="31-Next-Permutation">31. Next Permutation</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length-<span class="number">1</span>;</span><br><span class="line">		p=-<span class="number">1</span>;</span><br><span class="line">		pv=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">				p=i;</span><br><span class="line">				pv = nums[i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p==-<span class="number">1</span>)&#123;</span><br><span class="line">			reverse(nums,<span class="number">0</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = n; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i]&gt;pv)&#123;</span><br><span class="line">				swap(nums,p,i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(nums,p+<span class="number">1</span>,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(s&lt;e)&#123;</span><br><span class="line">			swap(nums,s,e);</span><br><span class="line">			s++;</span><br><span class="line">			e--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> t = nums[s];</span><br><span class="line">		nums[s] = nums[e];</span><br><span class="line">		nums[e] = t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外定义reverse和swap函数，原理大概就是从右向左扫描，找到第一个不是sort顺序的数，存住，第二次从右扫描找比之前那个元素大的数，交换位置。然后再p+1,n之间继续swap。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 10</title>
    <url>/2019/05/12/leetcode10/</url>
    <content><![CDATA[<h2 id="557-Reverse-Words-in-a-String-III">557. Reverse Words in a String III</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">reversewords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] s1 = s.toCharArray;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s1.length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[j] == <span class="string">' '</span>)&#123;</span><br><span class="line">				reverse(s1,i,j-<span class="number">1</span>);</span><br><span class="line">				i-j+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(s1,i,s.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(s1);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(s1,l,r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span>[] temp=s[l];</span><br><span class="line">		s[l] = s[r];</span><br><span class="line">		s[r] = temp;</span><br><span class="line">		l++;r--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>用空格来分割字符串，遇到space运行一次reverse，注意最后空格之后还有最后一部分字符串，所以要额外运行一次reverse。<br>
reverse基本思想就是swap。</p>
<a id="more"></a>
<h2 id="344-Reverse-String">344. Reverse String</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">reverstring</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">char</span> start;</span><br><span class="line">		<span class="keyword">char</span> end;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;(s.length)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">			start = s[i];</span><br><span class="line">			end=s[(s.length-<span class="number">1</span>)-i];</span><br><span class="line">			s[i] = end;</span><br><span class="line">			s[(s.length-<span class="number">1</span>)-i] = start;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>时间复杂度O(n/2)，空间复杂度O(1),right place 改变顺序，不能用返回新String的方法了。二分法替换。</p>
<h2 id="821-Shortest-Distance-to-a-Character">821. Shortest Distance to a Character</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solutoin</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S. <span class="keyword">char</span> C)&#123;</span><br><span class="line">		<span class="keyword">int</span> n = S.length();</span><br><span class="line">		<span class="keyword">int</span> pos = -n;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(S.charAt(i) == C)&#123;</span><br><span class="line">				pos = i;</span><br><span class="line">			&#125;</span><br><span class="line">			res[i] = i - pos;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>( <span class="keyword">int</span> i =n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(S.charAt(i) == C)&#123;</span><br><span class="line">				pos = i;</span><br><span class="line">			&#125;</span><br><span class="line">			res[i] = Math.min(res[i], Math.abs(i-pos));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>two pass，左右各遍历一遍，找到min值。 将pos=-n纯粹是为了将其设的足够大。Brilliant。</p>
<h2 id="867-Transpose-Matrix">867. Transpose Matrix</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] A)&#123;</span><br><span class="line">		<span class="keyword">int</span> M = A.length;</span><br><span class="line">		<span class="keyword">int</span> N = A[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span>[][] B = <span class="keyword">new</span> <span class="keyword">int</span>[N][M];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;M;i++)&#123;</span><br><span class="line">				B[j][i] = A[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>矩阵转换题，注意新定义矩阵B的行列数和for的顺序，转置矩阵后MxN 变为NxM, 所以先j&lt;N 后 i&lt;M.</p>
<h2 id="912-Sort-an-Array">912. Sort an Array</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sortinarray</span><span class="params">(self,nums:List[int] -&gt; List[int])</span>:</span></span><br><span class="line">		<span class="keyword">if</span> len(nums)&lt;<span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> nums</span><br><span class="line">		pivot = random.choice(nums)</span><br><span class="line">		l=[v <span class="keyword">for</span> v <span class="keyword">in</span> nums <span class="keyword">if</span> v &lt; pivot]</span><br><span class="line">		m=[v <span class="keyword">for</span> v <span class="keyword">in</span> nums <span class="keyword">if</span> v == pivot]</span><br><span class="line">		r=[v <span class="keyword">for</span> v <span class="keyword">in</span> nums <span class="keyword">if</span> v &gt; pivot]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> self.sortinarray(l) + m + self.sortinarray(r)</span><br></pre></td></tr></table></figure>
<h3 id="思路-v5">思路</h3>
<p>比较easy的题，但是要记住quick sort 的排序方法，先random选nums，分成&lt;=&gt;三部分，在各自递归调用，返回时注意加上m，中间值。</p>
<h2 id="876-Middle-of-the-Linked-List">876. Middle of the Linked List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">middlelinked</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">		ListNode slow = head; fast = head;</span><br><span class="line">		<span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">			slow = slow.next;</span><br><span class="line">			fast = fast.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v6">思路</h3>
<p>非常重要的一种思路，fast和slow指针同时扫描，当fast到达结尾时，slow一定在middle(奇偶数定理可以证明).返回slow此时位置的后续指链。</p>
<h2 id="872-Leaf-Similar-Trees">872. Leaf-Similar Trees</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leafSimilar</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">		Stack&lt;TreeNode&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		s1.push(root1);</span><br><span class="line">		s2.push(root2);</span><br><span class="line">		<span class="keyword">while</span>(!s1.empty() &amp;&amp; !s2.empty())&#123;</span><br><span class="line">			<span class="keyword">if</span>(dfs(s1)!=dfs(s2))&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> (s1.empty() &amp;&amp; s2.empty());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Stack&lt;TreeNode&gt; s)</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			TreeNode node = s.pop();</span><br><span class="line">			<span class="keyword">if</span>(node.left !=<span class="keyword">null</span>) s.push(node.left);</span><br><span class="line">			<span class="keyword">if</span>(node.right !=<span class="keyword">null</span>) s.push(node.right);</span><br><span class="line">			<span class="keyword">if</span>(node.left ==<span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) <span class="keyword">return</span> node.val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v7">思路</h3>
<p>判断树最后各个节点是否相同，通常思路是用DFS遍历tree成list,然后比较两个list。但是比较麻烦。<br>
这里将逐个叶节点进行比较，采用stack存储，其实这里遍历的方法类似pre-order，只不过不输出。<br>
定义dfs函数，比较每个节点是否为最后一个节点，若左右不空，将其压入堆栈，若为空，返回最后节点的值，s1和s2的值进行比较。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 15</title>
    <url>/2019/05/26/leetcode15/</url>
    <content><![CDATA[<h2 id="45-Jump-Game-II">45. Jump Game II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> jumps = <span class="number">0</span>, curend = <span class="number">0</span>, <span class="keyword">int</span> curfast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            curfast = Math.max(curfast, i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == curend)&#123;</span><br><span class="line">                jumps ++;</span><br><span class="line">                curend = curfast;</span><br><span class="line">                <span class="keyword">if</span>(curend &gt;= nums.length)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>Greddy 思想的一道题，用curend存住当前位置能够跳到的最远位置，curfast存住从当前节点到curend之间，各个节点能够走到的最远位置，所以当i=curend时，也就是走到当前节点所能够触及的最后一个元素时，jump必定加一，并且将curend更新为curfast。当curend大于整个数列长度时，即检索完成，则提前break退出循环。</p>
<h2 id="55-Jump-Game">55. Jump Game</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis = ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;=dis;i++)&#123;</span><br><span class="line">            dis = Math.max(dis,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dis &gt; = nums.length -<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>和上一题差不多的思路，只不过是换成boolean输出，只要判断循环中有无一个时刻，dis超出或者等于nums.length，如果有则肯定为true，若没有则为false。</p>
<h2 id="47-Permutations-II">47. Permutations II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permutations(<span class="keyword">int</span> [] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(list,<span class="keyword">new</span> ArrayList&lt;&gt;(),nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist , <span class="keyword">int</span>[]nums,<span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(templist.size()==nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i] || i&gt;<span class="number">0</span> &amp;&amp;nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                templist.add(nums[i]);</span><br><span class="line">                backtrack(list,templist,nums,used);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>backtrack的思想，leetcode 13 里有讲，今天算是复习一遍。<br>
最后for里面的if条件：1.该元未使用 2. i》0，该元素在nums里和前面重复且前面的元素未使用过（如果前一个重复的元素使用过的话，是可以用当前元素的）。</p>
<h2 id="51-N-Queens">51. N-Queens</h2>
<img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solvequeens( <span class="keyword">int</span> n)&#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[][] curr = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span>[i][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span> diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span> diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        solve(curr,<span class="number">0</span>,,n,res,col,diag1,diag2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] curr, <span class="keyword">int</span> row, <span class="keyword">int</span> n, List&lt;List&lt;String&gt;&gt; ret, <span class="keyword">boolean</span>[] col, <span class="keyword">boolean</span>[] diag1, <span class="keyword">boolean</span>[] diag2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            List&lt;String&gt; toadd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">                toadd.add(String.valueOf(curr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(toadd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[j] || diag1[row + n -j - <span class="number">1</span>] || diag2[row + j])<span class="keyword">continue</span>;</span><br><span class="line">            col[i]=<span class="keyword">true</span>;</span><br><span class="line">            diag1[row + n -j - <span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            diag2[row + j] = <span class="keyword">true</span>;</span><br><span class="line">            curr[row][j]=<span class="string">'Q'</span>;</span><br><span class="line">            solve(curr,row+<span class="number">1</span>,n,res,col,diag1,diag2);</span><br><span class="line">            curr[row][j]=<span class="string">'.'</span>;</span><br><span class="line">            diag2[row + j] = <span class="keyword">false</span>;</span><br><span class="line">            diag1[row + n -j - <span class="number">1</span>]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>比较难的一道题，基本思想也是backtracking，元素比较多。<br>
皇后棋比较恶心的是对角线也可以走，所以要设置两个diag1 和diag2来存储正反对角线的元素，注意[]内的表达式。由于每一次递归后row都+1，所以不需要考虑每一行的冲突，因为每次每行只会存一个Q。<br>
每次递归后要全部恢复原样！！！backtrack的基本思想。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 13</title>
    <url>/2019/05/24/leetcode13/</url>
    <content><![CDATA[<p>前几天在忙毕设和画图，导致刷题进度一直停滞不前。<br>
今天刚到公司实习，感觉和大佬的差距仍然是以光年为单位。<br>
嗯，努力不能停啊。<br>
废话不多说，继续开始刷题。</p>
<h2 id="Backtracking-类型题">Backtracking 类型题</h2>
<p>backtracking思路，每次recursive后将tamplist的数组大小变回之前，为了方便下一轮递归。并且将remain变为remain-candidates【i】<br>
大概分为两类，一类是可以重复使用，不用担心数字重复出现的情况；另一种是不能重复使用，也不能出现重复数字。</p>
<a id="more"></a>
<h2 id="第一类">第一类</h2>
<h2 id="Combination-Sum">Combination Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort()</span><br><span class="line">		backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">				templist.add(candidates[i]);</span><br><span class="line">				backtrack(list,templist,candidates,remain-candidates[i],i);</span><br><span class="line">				templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Permutations">Permutations</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         backtrack(list, tempList, nums);</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Subsets">Subsets</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort()</span><br><span class="line">		backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">				templist.add(candidates[i]);</span><br><span class="line">				backtrack(list,templist,candidates,remain-candidates[i],i);</span><br><span class="line">				templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二类">第二类</h2>
<p>由于要求不能出现重复数字，而且不能重复使用，所以要判断nums[i]==nums[i+1]的情况下直接跳过，并且递归时i+1。</p>
<h2 id="Combination-Sum-2-一个数只用一次且不能有重复的数字">Combination Sum 2 (一个数只用一次且不能有重复的数字)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort()</span><br><span class="line">		backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;start&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">				templist.add(candidates[i]);</span><br><span class="line">				backtrack(list,templist,candidates,remain-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">				templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Permutations-II-contains-duplicates">Permutations II (contains duplicates)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这道题和其他有略微不同的地方，额外使用boolean值来判断该位置是否使用过，</p>
<h2 id="Subsets-II-contains-duplicates">Subsets II (contains duplicates)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort()</span><br><span class="line">		backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(),candidates,target,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> remain,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(remain&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>)list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i&gt;start&amp;&amp;nums[i]==nums[i+<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">				templist.add(candidates[i]);</span><br><span class="line">				backtrack(list,templist,candidates,remain-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">				templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="43-Multiply-Strings">43. Multiply Strings</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = num1.length(), n = num2.length();</span><br><span class="line">		<span class="keyword">int</span> [] pos = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">int</span> mul = (num1charAt(i)-<span class="string">'0'</span>)*(num2charAt(j)-<span class="string">'0'</span>);</span><br><span class="line">				<span class="keyword">int</span> p1 = i+j, p2 = i+j+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">int</span> sum = mul + pos[p1];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> p : pos) <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; p == <span class="number">0</span>)) sb.append(p);</span><br><span class="line">		<span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">'0'</span>:sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>将乘法过程写出来。 具体解释见 <a href="https://leetcode.com/problems/multiply-strings/discuss/17605/Easiest-JAVA-Solution-with-Graph-Explanation" target="_blank" rel="noopener">leetcode 43 详解</a>,其实基本思想就是将相乘过程写出来，发现每位相乘后向前移动一位，所以可以采用i+j，i+j+1进行pos赋值。<br>
图解如下：<br>
<img src="https://drscdn.500px.org/photo/130178585/m%3D2048/300d71f784f679d5e70fadda8ad7d68f"></p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 16</title>
    <url>/2019/05/27/leetcode16/</url>
    <content><![CDATA[<h2 id="52-N-Queens-II">52. N-Queens II</h2>
<img src="https://assets.leetcode.com/uploads/2018/10/12/8-queens.png">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nqueen2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] col = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] diag1 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] diag2 = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*<span class="number">2</span>-<span class="number">1</span>];</span><br><span class="line">        solve(<span class="number">0</span>,n,col,diag1,diag2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">boolean</span>[] col, <span class="keyword">boolean</span>[] diag1, <span class="keyword">boolean</span>[] diag2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nlj++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!col[j] &amp;&amp; !diag1[row+j] &amp;&amp; ! diag2[row-j+n-<span class="number">1</span>])&#123;</span><br><span class="line">                col[j]=<span class="keyword">true</span>;</span><br><span class="line">                diag1[row + j] = <span class="keyword">true</span>;</span><br><span class="line">                diag2[row-j+n-<span class="number">1</span>]= <span class="keyword">true</span>;</span><br><span class="line">                solve(row+<span class="number">1</span>,n,col,diag1,diag2);</span><br><span class="line">                diag2[row-j+n-<span class="number">1</span>]= <span class="keyword">false</span>;</span><br><span class="line">                diag1[row + j] = <span class="keyword">false</span>;</span><br><span class="line">                col[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>和NQueen思路基本一致，只不过输出的是种类数量而不是Q的排列方式。所以相比于Queen1来说比较简单。backtracking的思想。</p>
<h2 id="57-Insert-Interval">57. Insert Interval</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval)&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> [] interval : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&lt;interval[<span class="number">0</span>])&#123;</span><br><span class="line">                ans.add(newInterval);</span><br><span class="line">                newInterval = interval;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(newInterval[<span class="number">0</span>] &gt; interval[<span class="number">1</span>])&#123;</span><br><span class="line">                ans.add(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = Math.max(newInterval[<span class="number">0</span>],interval[<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.min(newInterval[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(newInterval);</span><br><span class="line">        <span class="keyword">return</span> ans.toArray( <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意取舍的情况，interval的开头结尾和newinterval的开头结尾进行比较。三种情况。new小，将new加入ans，并更新new；interval小，将interval加入ans。；有重合部分，开头取最小，结尾取最大。</p>
<h2 id="58-Length-of-Last-Word">58. Length of Last Word</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> end = s.length() -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end&gt;=<span class="number">0</span> &amp;&amp; s.charAt(end) == <span class="string">' '</span>)&#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(end == -<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = end;</span><br><span class="line">        <span class="keyword">while</span>(start&gt;=<span class="number">0</span> &amp;&amp; s.charAt(start) != <span class="string">' '</span>)&#123;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照空格分隔，end遇到空格减一，而start遇到非空格减一，从后向前检索，最后输出end-start。</p>
<h2 id="59-Spiral-Matrix-II">59. Spiral Matrix II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rowbegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowend = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> colbegin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> colend = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( cur &lt; n*n)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = rowbegin;</span><br><span class="line">            <span class="keyword">int</span> j = colbegin;</span><br><span class="line">            <span class="keyword">for</span>(j = colbegin; j &lt;= colend;j++)&#123;</span><br><span class="line">                res[rowbegin][j] = cur;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rowbegin++;</span><br><span class="line"><span class="comment">// 第一步是从上至下</span></span><br><span class="line">            <span class="keyword">for</span>(i = rowbegin ; i &lt;= rowend ; i++)&#123;</span><br><span class="line">                res[i][colend] = cur;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            colend--;</span><br><span class="line"><span class="comment">//第二步从右至左</span></span><br><span class="line">            <span class="keyword">for</span>(j = colend ; j &gt;= colbegin ; j++)&#123;</span><br><span class="line">                res[rowend][j] = cur;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            rowend--;</span><br><span class="line"><span class="comment">//第三步从下至上</span></span><br><span class="line">            <span class="keyword">for</span>(i = rowend; i&gt;=rowbegin; i++)&#123;</span><br><span class="line">                res[i][colbegin] = cur;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            colbegin ++;</span><br><span class="line"><span class="comment">//最后一步从左至右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>螺旋输出矩阵，分四大步，上至下，右至左，下至上，左至右。</p>
<h2 id="61-Rotate-List">61. Rotate List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotatelinkedlist</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> head;</span><br><span class="line">         &#125;</span><br><span class="line">         ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">         dummy.next = head;</span><br><span class="line">         ListNode fast = dummy, slow = dummy;</span><br><span class="line">         <span class="keyword">int</span> i;</span><br><span class="line">         <span class="keyword">for</span> (i = <span class="number">0</span> ; fast.next!=<span class="keyword">null</span>;i++)&#123;</span><br><span class="line">             fast = fast.next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j = i-k%n;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">             slow = slow.next;</span><br><span class="line">         &#125;</span><br><span class="line">         fast.next = dummy.next;</span><br><span class="line">         dummy.next = slow.next;</span><br><span class="line">         slow.next = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> dummy.next;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>反转链表，关键的问题在于断点slow的选取，具体证明参考<a href="https://leetcode.com/problems/rotate-list/discuss/22715/Share-my-java-solution-with-explanation" target="_blank" rel="noopener">leetcode 61</a>的discuss，很巧妙。在得出断点的位置后，直接进行交换即可。</p>
<h2 id="62-Unique-Paths">62. Unique Paths</h2>
 <img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePath</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Integer[][] map = <span class="keyword">new</span> Integer[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> i&lt; m;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n ; j ++)&#123;</span><br><span class="line">                map[i][j] = map[i-<span class="number">1</span>][j]+map[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> map[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>重新复习一下，先将边缘设为1，然后每个位置的种类是它top和left种类和。然后循环下去。复杂度是O(m*n)。</p>
<h2 id="63-Unique-Paths-II">63. Unique Paths II</h2>
<img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquepath</span><span class="params">(<span class="keyword">int</span> [][] obstaclegrid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = obstaclegrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[width];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> [] row : obstaclegrid)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] += dp[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v5">思路</h3>
<p>新奇的做法。常规思路用2D的dp来存储，这道题采用1D的dp来存储，只考虑j，用j来更新dp值。<br>
dp [ j ] += dp [ j - 1 ] is dp [ j ] = dp [ j ] + dp [j - 1];<br><br>
即 new dp [ j ] = old dp [ j ] + dp [ j-1 ]<br><br>
即 current cell = top cell + left cell。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 21</title>
    <url>/2019/06/10/leetcode21/</url>
    <content><![CDATA[<h2 id="82-Remove-Duplicates-from-Sorted-List-II（two-pointer-linked-list">82. Remove Duplicates from Sorted List II（two pointer / linked list)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deletedupliate</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = head;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode fisrt = dummy;<span class="comment">//新建一个first链表来存储不重复的节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; cur.next!=<span class="keyword">null</span>)&#123;<span class="comment">//判断该节点和后节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val!=cur.next.val&amp;&amp;cur.val!=pre.val)&#123;<span class="comment">//前后都无重复</span></span><br><span class="line">                first = cur;</span><br><span class="line">                first.next = first;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur.val!=pre.val)&#123;<span class="comment">//处理最后一个节点时只考虑pre和cur</span></span><br><span class="line">            first = cur;</span><br><span class="line">            first.next = first;</span><br><span class="line">        &#125;</span><br><span class="line">        first.next = <span class="keyword">null</span>;<span class="comment">//注意，这是为了处理当链表都为重复时，将全部剔除。</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>linked list 和 two pointer 的思路，新建first链表存答案，判断当前后均不为重复时进行操作。</p>
<a id="more"></a>
<h2 id="83-Remove-Duplicates-from-Sorted-List（linked-lilst）">83. Remove Duplicates from Sorted List（linked lilst）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solutoin</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode list = head;</span><br><span class="line">        <span class="keyword">while</span>(list!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.next == <span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(list.val == list.next.val)&#123;</span><br><span class="line">                list.next = list.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.next = list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>easy的82题，要求将重复数字的只留下一个输出，而82是要求将重复的全部剔除，所以83相比82比较简单<br><br>
只需要将重复情况下list.next = list.next.next;循环下去。</p>
<h2 id="86-Partition-List-listed-node-two-pointers">86. Partition List(listed node / two pointers)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partation</span><span class="params">(ListNode head,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        ListNode smallhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>),bighead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode smalltail = smallhead, bigtail = bighead;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val&lt;x)&#123;</span><br><span class="line">                smalltail.next = head;</span><br><span class="line">                smalltail = smalltail.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bigtail.next  = head;</span><br><span class="line">                bigtail = bigtail.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        bigtail.next = <span class="keyword">null</span>;</span><br><span class="line">        smalltail.next = bighead.next;</span><br><span class="line">        <span class="keyword">return</span> smallhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建small和big两个链表，分别用来存小于x和大于x的节点，最后将大的节点合并在小的节点后面即可。注意bigtail.next=null这一步非常关键，避免了链表的循环，防止TLE。</p>
<h2 id="92-Reverse-Linked-List-II-linked-list-two-pointers">92. Reverse Linked List II(linked list / two pointers)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverselinkedlist</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m-<span class="number">1</span>;i++)pre=pre.next;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode then = start.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n-m;i++)&#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针问题。pre，start，then表示前一节点，当前，后节点，循环m-1次找到pre，将pre.next变为start。执行n-m次换位。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 17</title>
    <url>/2019/05/28/leetcode17/</url>
    <content><![CDATA[<h2 id="写在开头">写在开头</h2>
<p>刚才刷一亩三分地，看到有大佬在分享自己的上岸心得，感触挺多。<br>他说刷题是一项长久的工作，像吃饭一样，不能停，要每天刷题，保持手感，多复习多总结。<br></p>
<p>这一点我虽然做到了但是还要坚持下去。刷题的时候要思考，如果面试问到了这道题, 人家为什么要问？帖子的楼主说得有道理，公司实际遇不到的问题怎么会考你呢？<br></p>
<p>所以要把这道题当成目标公司需要解决的问题来思考，多跟hr交流沟通思路，不要闷头解题。<br><br>
<br><br>
毕竟一共一千多道题，一次投入持久性产出（滑稽脸）。<br><br>
言归正传，继续刷题吧。今后主要按tag来刷题，更有针对性了。</p>
<a id="more"></a>
<h2 id="64-Minimum-Path-Sum">64. Minimum Path Sum</h2>
<p>自己做出来的dp题，思路很简单，之前做过许多类似的，直接上代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minpath</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j !=<span class="number">0</span>)&#123;<span class="comment">//第一行</span></span><br><span class="line">                    grid[i][j]+=grid[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i!=<span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;<span class="comment">//第一列</span></span><br><span class="line">                    grid[i][j] += grid[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp; j ==<span class="number">0</span>)&#123;<span class="comment">//左上角原点</span></span><br><span class="line">                    grid[i][j]=grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//正常累加，取最小值</span></span><br><span class="line">                    grid[i][j]+=Math.min(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<p>和之前的unique path 一个思路，之后不过是将每个点的路径数量换成了权值，需要在最后累加时用min来决定最小值的路径。</p>
<h2 id="67-Add-Binary">67. Add Binary</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addbinary</span><span class="params">(String a, String b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = a.length()-<span class="number">1</span>;<span class="comment">//从末尾开始累加</span></span><br><span class="line">        <span class="keyword">int</span> j = b.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>( i &gt;=<span class="number">0</span> || j&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += a.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum += b.charAt(j)-<span class="string">'0'</span>;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(sum%<span class="number">2</span>);<span class="comment">//sum和2的关系，遇到sum=2 加0,1和0则为本身。</span></span><br><span class="line">            carry = sum/<span class="number">2</span>;<span class="comment">// 判断进位，只有遇到2时才为1，其余都为0.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>) sb.append(carry);<span class="comment">//加入最后一个carry</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();<span class="comment">//逆转一下，因为从末尾开始是顺序加入string的，所以要逆序输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>二进制加法题，从末位相加，重要的是sum%2 和 sum/2的思想。最后逆序输出。<br><br>
其实也可以用stack做，最后sb.add(stack.pop())就可以，但是比较麻烦，还是喜欢<br>StringBuilder 的做法。</p>
<h2 id="85-Maximal-Rectangle">85. Maximal Rectangle</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>] == <span class="keyword">null</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length, maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] height = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;<span class="comment">//right 从右至左扫描，找min</span></span><br><span class="line">            <span class="keyword">int</span> rB = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    right[j] = Math.min(right[j], rB);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right[j] = n - <span class="number">1</span>;</span><br><span class="line">                    rB = j - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lB = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//left 从左至右扫描，找max</span></span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    left[j] = Math.max(left[j], lB);</span><br><span class="line">                    height[j]++;</span><br><span class="line">                    maxArea = Math.max(maxArea, height[j] * (right[j] - left[j] + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    height[j] = <span class="number">0</span>;</span><br><span class="line">                    left[j] = <span class="number">0</span>;</span><br><span class="line">                    lB = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v3">思路</h3>
<p>挺难的一道题，找出最大的矩形面积。<br><br>
明显的DP方法，但是具体的思路还是听烧脑的。<br><br>
策略: 把matrix看成多个直方图, 每一行及其上方的数据都构成一个直方图, 需要考察matrix.size()个直方图<br><br>
对于每个点(row, col), 我们最后都计算以这个点上方的连续的’1’往left, right方向延申可以得到的最大的矩形的面积<br><br>
通过这种方法获取的矩形一定会把最大的矩形包含在内<br><br>
height[row][col]记录的是(row, col)这个坐标为底座的直方图柱子的高度, 如果这个点是’0’, 那么高度当然是0了<br><br>
left[row][col]记录的是(row, col)这个坐标点对应的height可以延申到的最左边的位置<br><br>
right[row][col]记录的是(row, col)这个坐标点对应的height可以延申到的最右边的位置+1<br><br>
以上面的matrix为例,<br><br>
对于(row=2, col=1)这个点, left=0, right=5, height=1<br><br>
对于(row=2, col=2)这个点, left=2, right=3, height=3<br><br>
(2,2)这个点与(2,1)紧挨着,left和right却已经变化如此之大了, 这是因为left和right除了受左右两边的’1’影响, 还受到了其上方连续的’1’的制约<br><br>
由于点(2,2)上有height=3个’1’, 这几个’1’的left的最大值作为当前点的left, 这几个’1’的right的最小值作为当前点的right<br><br>
因此, 实际上, 我们是要找以hight对应的这条线段往左右两边移动(只能往全是’1’的地方移动), 可以扫过的最大面积<br><br>
当hight与目标最大矩形区域的最短的height重合时, 最大矩形的面积就找到了, 如上面的例子, 就是点(2,3)或(2,4)对应的height<br></p>
<h2 id="72-Edit-Distance">72. Edit Distance</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mindistance</span><span class="params">(String word1,String word2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=m;i++)<span class="comment">// 最左列情况，word1存在，word2为空</span></span><br><span class="line">            cost[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n;i++)<span class="comment">//最上行情况，word2存在，word1为空</span></span><br><span class="line">            cost[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i) == word2.charAt(j))&#123;<span class="comment">// i 和j 元素相同</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//不同的情况下，三种措施</span></span><br><span class="line">                    <span class="keyword">int</span> replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> delete = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">int</span> insert = dp[i][j-<span class="number">1</span>];</span><br><span class="line">                    cost[i][j] = Math.min(replace,Math.min(delete,insert))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>典型的dp题，字符串的增删替换，用dp思想，一共有四种操作。<br><br>
1.word1 的i元素和word2的j元素相同，无操作，其操作次数为dp[i-1][j-1]即上一个字母的情况。<br>2.这两个元素不相同，可以有三种操作：<br><br>
(1) replace 替换，dp[i-1][j-1]，将上一个字母替换为当前字母，<br><br>
(2) delete 删除，将word1里当前元素删除，dp[i-1][j]，变为其前一个字母<br><br>
(3) insert 插入，向word1里插入word2的前一个元素，dp[i][j-1]，<br><br>
注意取这三者的最小值，然后加1。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 25</title>
    <url>/2019/06/21/leetcode25/</url>
    <content><![CDATA[<h2 id="115-Distinct-Subsequences（DP">115. Distinct Subsequences（DP)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">distinctsu</span><span class="params">(String s, String t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            mem[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t.length();t++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    mem[i+<span class="number">1</span>][j+<span class="number">1</span>]=mem[i][j]+mem[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mem[i+<span class="number">1</span>][j+<span class="number">1</span>]=mem[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mem[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp思路。大神的思路永远都是简单而又震撼→<a href="https://leetcode.com/problems/distinct-subsequences/discuss/37327/Easy-to-understand-DP-in-Java" target="_blank" rel="noopener">leetcode 115</a>.<br><br>
dp题做多了会发现大体上的程序结构基本是一样的。<br><br>
1.新建二/三维数组，并初始化边界。<br><br>
2.循环扫描，一般是i+1\j+1的位置和左上角/上方/左方的位置进行操作。<br><br>
3.返回最后位置的状态。<br></p>
<a id="more"></a>
<h2 id="120-Triangle（DP">120. Triangle（DP)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; nextrow = triangle.get(i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> sum = Math.min(nextrow.get(j),nextrow.get(j+<span class="number">1</span>))+triangle.get(i).get(j);</span><br><span class="line">                triangle.get(i).set(j,sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle.get(<span class="number">0</span>).get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp思路。自下而上循环。亮点是不用单独存储sum，直接将选取的位置存上当前的sum值，节省空间复杂度。最后返回最上面的位置即可，就是最后的sum。</p>
<h2 id="221-Maximal-Square（DP">221. Maximal Square（DP)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalsquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,n=matrix[<span class="number">0</span>].length,res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]==<span class="string">'1'</span>)&#123;</span><br><span class="line">                    ans[i][j] = Math.min(Math.min(ans[i-<span class="number">1</span>][j-<span class="number">1</span>],ans[i-<span class="number">1</span>][j]),ans[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    res = Math.max(ans[i][j],res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp思路。找到最大的1字正方形。用dp存住每个位置当前的最大正方形。只有当左/上/左斜上位置都不为0时，才可能存在正方形。<br><br>
最后更新res，存住最大的正方形边长。最后返回面积，边长**2.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 22</title>
    <url>/2019/06/13/leetcode22/</url>
    <content><![CDATA[<h2 id="241-Different-Ways-to-Add-Parentheses-recursive-HashMap">241. Different Ways to Add Parentheses (recursive / HashMap)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(input))<span class="keyword">return</span> map.get(input);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;input.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i) == <span class="string">'-'</span> ||</span><br><span class="line">            input.charAt(i) == <span class="string">'+'</span> ||</span><br><span class="line">            input.charAt(i) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                String part1 = input.substring(<span class="number">0</span>,i);</span><br><span class="line">                String part2 = input.substring(i+<span class="number">1</span>);</span><br><span class="line">                List&lt;Integer&gt; part1ret = diffWaysToCompute(part1);</span><br><span class="line">                List&lt;Integer&gt; part2ret = diffWaysToCompute(part2);</span><br><span class="line">                <span class="keyword">for</span>(Integer p1 : part1ret)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Integer p2 : part2ret)&#123;</span><br><span class="line">                        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">switch</span>(input.charAt(i))&#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>: c=p1+p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>: c=p1-p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>: c=p1*p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ret.add(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            ret.add(Integer.valueOf(input));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive的思想，并且利用hashmap来避免重复计算的情况，降低时间复杂度，注意switch的用法。</p>
<a id="more"></a>
<h2 id="96-Unique-Binary-Search-Trees">96. Unique Binary Search Trees</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numtrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i] += dp[j-<span class="number">1</span>] *dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是数学思路比较难，需要计算出不同子树结构的所有树的数量。具体思路见<a href="https://leetcode.com/problems/unique-binary-search-trees/discuss/31666/DP-Solution-in-6-lines-with-explanation.-F(i-n)-G(i-1)-*-G(n-i)" target="_blank" rel="noopener">leetcode96</a>.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 26</title>
    <url>/2019/06/25/leetcode26/</url>
    <content><![CDATA[<h2 id="100-Same-Tree">100. Same Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">issameTree</span><span class="params">(TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val == q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> issameTree(q.left,p.left) &amp;&amp; issameTree(q.right,p.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归判断每个节点是否都相同，比较简单。</p>
<a id="more"></a>
<h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Inorder-Postorder-Tree-Transform">106. Construct Binary Tree from Inorder and Postorder Traversal(Inorder/Postorder Tree Transform)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> indexp;</span><br><span class="line">     <span class="keyword">int</span> indexi;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span>[] postorder, TreeNode end)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(indexp&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         TreeNode n = <span class="keyword">new</span> TreeNode(posrorder[indexp]);</span><br><span class="line">         indexp--;</span><br><span class="line">         <span class="keyword">if</span>(inorder[indexi] != n.val)&#123;</span><br><span class="line">             n.left=buildTree(inorder,posrorder,n);</span><br><span class="line">         &#125;</span><br><span class="line">         indexi--;</span><br><span class="line">         <span class="keyword">if</span>((end == <span class="keyword">null</span>) || (inorder[indexi] != end.val))&#123;</span><br><span class="line">             n.right = buildTree(inorder, posrorder, <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> n;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[]postorder)</span></span>&#123;</span><br><span class="line">         indexp = posrorder.length -<span class="number">1</span> ;</span><br><span class="line">         indexi = inorder.length -<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> buildTree(inorder, postorder, <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>给定postorder和inorder的树结构，输出正确的树结构。post中最后一位是root，进而在inorder中找root的位置，判断有无左右子树。<br><br>
若有左子树，则将当前的n作为end来递归；若有右子树，则将end重新设为null。</p>
<h2 id="总结一下常见的三种order-traversal">总结一下常见的三种order traversal</h2>
<h3 id="94-Binary-Tree-Inorder-Traversal">94.  Binary Tree Inorder Traversal</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inorder要遍历完所有的左子树再遍历根节点。</p>
<h3 id="144-Binary-Tree-Preorder-Traversal">144. Binary Tree Preorder Traversal</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preorder 根-左-右，stack先存right再存left，保证pop时先左后右</p>
<h3 id="145-Binary-Tree-Postorder-Traversal">145. Binary Tree Postorder Traversal</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.addFirst(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.left  != <span class="keyword">null</span>) stack.push(root.left );</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>post左-右-根，利用addfirst方法，不断更新linkedlist。这时push的顺序应该先左后右。因为push后要进行addfirst，pop出右。addfirst；再popleft，addfirst后此时left已经到了right前面，符合post要求。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 27</title>
    <url>/2019/08/02/leetcode27/</url>
    <content><![CDATA[<h2 id="6-ZigZag-Conversion">6. ZigZag Conversion</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        StringBuilder[] sb = <span class="keyword">new</span> StringBuilder[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; numRows ; i++)sb[i] = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;numRows &amp;&amp; idx&lt; s.length(); i++)sb[i].append(s.charAt(idx++));<span class="comment">// 竖直方向增加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = numRows - <span class="number">2</span> ; i&gt;<span class="number">0</span> &amp;&amp; idx&lt; s.length(); i-- ) sb[i].append(s.charAt(idx++));<span class="comment">//斜向增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;sb.length; i++)res.append(sb[i]);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zagzig方法实际上就是按照顺序在每一行上增加元素。<br><br>
分情况，竖直方向增加后再斜向增加。循环即可。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345678996       1   5   9      159</span><br><span class="line">numRows=3   ==&gt;   2 4 6 8 9  ==&gt; 24689</span><br><span class="line">                  3   7   6      376</span><br></pre></td></tr></table></figure>
<h2 id="3-Longest-Substring-Without-Repeating-Characters">3. Longest Substring Without Repeating Characters</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                j = Math.max(j,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双指针，i先向前扫描，如果hashmap已经存在当前i元素，j则跳过当前元素到max(j,i+1)的位置。然后存住当前i的元素，更新max。</p>
<h2 id="273-Integer-to-English-Words">273. Integer to English Words</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] belowTen = <span class="keyword">new</span> String[] &#123; <span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] belowTwenty = <span class="keyword">new</span> String[] &#123;<span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] belowHundred = <span class="keyword">new</span> String[] &#123;<span class="string">""</span>, <span class="string">"Ten"</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(num); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">helper</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String result = <span class="keyword">new</span> String();</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) result = belowTen[num];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">20</span>) result = belowTwenty[num -<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">100</span>) result = belowHundred[num/<span class="number">10</span>] + <span class="string">" "</span> + helper(num % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000</span>) result = helper(num/<span class="number">100</span>) + <span class="string">" Hundred "</span> +  helper(num % <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000000</span>) result = helper(num/<span class="number">1000</span>) + <span class="string">" Thousand "</span> +  helper(num % <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">1000000000</span>) result = helper(num/<span class="number">1000000</span>) + <span class="string">" Million "</span> +  helper(num % <span class="number">1000000</span>);</span><br><span class="line">        <span class="keyword">else</span> result = helper(num/<span class="number">1000000000</span>) + <span class="string">" Billion "</span> + helper(num % <span class="number">1000000000</span>);</span><br><span class="line">        <span class="keyword">return</span> result.trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先建立字符表，注意前面有&quot;&quot;。然后各自递归调用helper函数，逐渐缩小数值并找到对应的单位。</p>
<h2 id></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    TrieNode head;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        TrieNode node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch: word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.charToNode.containsKey(ch))&#123;</span><br><span class="line">                node.charToNode.put(ch,<span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.charToNode.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        node.isend = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.charToNode.containsKey(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.charToNode.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prefix == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TrieNode node = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : prefix.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!node.charToNode.containsKey(ch))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.charToNode.get(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        Map&lt;Character, TrieNode&gt; charToNode;</span><br><span class="line">        <span class="keyword">boolean</span> isend = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">            charToNode = <span class="keyword">new</span> HashMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>实现Trie结构，实现四个功能。注意最后的class TrieNode里的定义。<br><br>
1.只有到最后一个字母时才将isend改为true，其余都为false。<br><br>
2.用map存住每个元素，并且利用get和containsKey来更新node和查询是否存在当前字母。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 28</title>
    <url>/2019/08/04/leetcode28/</url>
    <content><![CDATA[<h2 id="38-Count-and-Say">38. Count and Say</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countandsay</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        String res = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            res = build(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">build</span><span class="params">(String res)</span></span>&#123;</span><br><span class="line">        StringBuiler sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;res.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> val = res.charAt(idx);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(idx &lt; res.length &amp;&amp; res.charAt(p) == val )&#123;</span><br><span class="line">                p++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(String.valueOf(count);</span><br><span class="line">            sb.append(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始只有一个1，然后计算相同数字的个数count，然后将count和当前val的值加入res中，继续循环计算。<br>
1 11 21 1211 111221 312211 …<br><br>
1 一个1(11)  两个1(21)   一个2一个1(1211)  一个1一个2两个1(111221) 三个1两个2一个1(312211)…<br></p>
<a id="more"></a>
<h2 id="49-Group-Anagrams">49. Group Anagrams</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupanagrams(String[] strs)&#123;</span><br><span class="line">        Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++)&#123;</span><br><span class="line">                arr[s.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            String key = Arrays.toString(arr);</span><br><span class="line">            List&lt;String&gt; temp = map.getOrDefault(key, <span class="keyword">new</span> LinkedList&lt;String&gt;());</span><br><span class="line">            temp.add(s);</span><br><span class="line">            map.put(key,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;map.values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用hashmap存住26个字母的顺序个数，当做key，再后面循环中只需要对比每个string的字母个数顺序即可。相同的放在同一个temp中，并且更新该key对应的temp组。</p>
<h2 id="151-Reverse-Words-in-a-String">151. Reverse Words in a String</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reversewords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        StingBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">int</span> m = l-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(m) == <span class="string">' '</span>)&#123;</span><br><span class="line">                m--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> n = m-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.charAt(n) != <span class="string">' '</span> )&#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">' '</span>);</span><br><span class="line">            sb.append(s.substring(n+<span class="number">1</span>,m+<span class="number">1</span>));</span><br><span class="line">            m=n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length()&gt;<span class="number">0</span>)sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体思路从后往前扫描，i为第一个不为空格的位置，j为第一个空格的位置，将substring（j+1,i+1）加入sb中；<br><br>
注意在加入substring前先加入’ '，保证后续每个字段和之前都有空格。最后将第一个位置的空格delete即可。</p>
<h2 id="165-Compare-Version-Numbers">165. Compare Version Numbers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String version1, String version2)</span></span>&#123;</span><br><span class="line">        String[] v1 = version1.split(<span class="string">'\\.'</span>);</span><br><span class="line">        String[] v2 = version2.split(<span class="string">'\\.'</span>);</span><br><span class="line">        <span class="keyword">int</span> n = Math.max(v1.length,v2.length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = i&lt;v1.length ? Integer.parseInt(v1[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> num2 = i&lt;v2.length ? Integer.parseInt(v2[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(num1 &gt; num2)<span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num1 &lt; num2) <span class="keyword">return</span><span class="string">'-1'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java中利用\.来分割.  分割后每一项进行对比，注意parseInt用法。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 29</title>
    <url>/2019/08/05/leetcode29/</url>
    <content><![CDATA[<h2 id="Permutations-II-contains-duplicates">Permutations II (contains duplicates)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist, <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(templist.size() == nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="keyword">true</span>;</span><br><span class="line">                templist.add(nums[i]);</span><br><span class="line">                backtrack(list,templist,nums,used);</span><br><span class="line">                used[i] = <span class="keyword">false</span>;</span><br><span class="line">                templist.remove(templist.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟 Permutations的解法一样，就是要考虑“去重”。先对数组进行排序，这样在DFS的时候，可以先判断前面的一个数是否和自己相等，相等的时候则前面的数必须使用了，自己才能使用，这样就不会产生重复的排列了。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 31</title>
    <url>/2019/09/12/leetcode31/</url>
    <content><![CDATA[<h2 id="126-Word-Ladder-II">126. Word Ladder II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Set&lt;String&gt; begin = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        begin.add(beginWord);</span><br><span class="line">        end.add(endWrod);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!begin.isEmpty() &amp;&amp; !end.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(begin.size() &lt; end.size())&#123;</span><br><span class="line">                Set&lt;String&gt; set = beginSet;</span><br><span class="line">                beginSet = endSet;</span><br><span class="line">                endSet = set;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String word : begin)&#123;</span><br><span class="line">                <span class="keyword">char</span>[] chrs = word.charToArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; chrs.length ; i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'a'</span> ; c &lt;= <span class="string">'z'</span>; c++&gt;&#123;</span><br><span class="line">                        <span class="keyword">char</span> old = chrs[i];</span><br><span class="line">                        chrs[i] = c;</span><br><span class="line">                        String target = String.valueOf(chrs);</span><br><span class="line">                        <span class="keyword">if</span>(end.contains(target))&#123;</span><br><span class="line">                            <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!visited.contains(target) &amp;&amp; dict.contains(target))&#123;</span><br><span class="line">                            visited.add(target);</span><br><span class="line">                            temp.add(target);</span><br><span class="line">                        &#125;</span><br><span class="line">                        chrs[i] = old;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            begin = temp;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用双向扫描，begin和end一起扫描，直到某一个set中出现了另外一个单词为止，具体讲解如下视频。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/vWPCm69MSfs?start=1107" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 30</title>
    <url>/2019/08/22/leetcode30/</url>
    <content><![CDATA[<h2 id="560-Subarray-Sum-Equals-K">560. Subarray Sum Equals K</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">soluiton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cur ; nums)&#123;</span><br><span class="line">            sum+=cur;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum-k))res+=map.get(sum-k);</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>presum + hashmap 的方法<br><br>
sum[i, j] = sum[0, j] - sum[0, i - 1]    --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j]<br><br>
k           sum      hashmap的key     --&gt;  hashmap的key  =  sum - k<br><br>
hashmap中存的是&lt;sum,sum出现的次数&gt;；</p>
<a id="more"></a>
<h2 id="547-Friend-Circles">547. Friend Circles</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findfriend</span><span class="params">(<span class="keyword">int</span>[][] M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited =  <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; M.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(M,visited,i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M,<span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> other = <span class="number">0</span>; other &lt; M.length; other++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[person][other] == <span class="number">1</span> &amp;&amp; !visited[other])&#123;</span><br><span class="line">                visited[other] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(M,visited,other);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象成一个矩阵，左边是person，上面是other（相对的），然后先从person开始dfs，dfs中又递归地对person对应的other进行dfs，<br><br>
将这个other看成新的person进行dfs，有点类似回合制，person - other  - person - other 都是相对的。</p>
<h2 id="652-Find-Duplicate-Subtrees">652. Find Duplicate Subtrees</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findduplicate</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        fint(root,<span class="keyword">new</span> HashMap&lt;&gt;(),res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(TreeNode cur, Map&lt;String&gt; map, List&lt;TreeNode&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        String temp = cur.val + <span class="string">","</span> + find(cur.left,map,res) + <span class="string">","</span> + find(cur.right,map,res);</span><br><span class="line">        <span class="keyword">if</span>(map.getOrDefault(temp,<span class="number">0</span>) == <span class="number">1</span>)res.add(cur);</span><br><span class="line">        map.put(temp,map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用hashmap记录每个子树经过哈希后的数量，哈希方法可以用最简单的前序遍历，即 根,左子树,右子树 的方式递归构造。<br><br>
若发现当前子树在哈希表第二次出现，则将该结点记入res列表。</p>
<h2 id="187-Repeated-DNA-Sequences">187. Repeated DNA Sequences</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">find</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Set seen = <span class="keyword">new</span> Hashset();</span><br><span class="line">        Set repeated = <span class="keyword">new</span> Hashset();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i+<span class="number">9</span>&lt;s.length();i++)&#123;</span><br><span class="line">            String ten = s.substring(i,i+<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(ten))&#123;</span><br><span class="line">                repeated.add(ten);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(repeated);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用hashset不能添加重复元素的特征和sliding window结合的方法，从i到i+10的范围内扫描<br><br>
如果seen里面不能添加该10位string，表明已经有过，所以添加到repeated中。</p>
<h2 id="1-Two-Sum">1.Two Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">twosum</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典的two sum，java版本注意定义hashmap的写法。</p>
<h2 id></h2>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 32</title>
    <url>/2019/09/20/leetcode32/</url>
    <content><![CDATA[<h2 id="269-Alien-Dictionary">269. Alien Dictionary</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Set&lt;Character&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;Character,Set&lt;Character&gt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; degree = <span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(String s :words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">                degree.get(C,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words.length ; i ++)&#123;</span><br><span class="line">            String cur = words[i];</span><br><span class="line">            String next = words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> length = Math.min(cur.length(),next.length());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = cur.charAt(j);</span><br><span class="line">                <span class="keyword">char</span> c2 = next.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c1!=c2)&#123;</span><br><span class="line">                    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(c1))set = map.get(c1);</span><br><span class="line">                    <span class="keyword">if</span>(!set.contains(c2))&#123;</span><br><span class="line">                        set.add(c2);</span><br><span class="line">                        map.put(c1,set);</span><br><span class="line">                        degree.put(c2,degree.get(c2)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Character&gt; q=<span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : degree.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree.get(c) q.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> c = q.remove;</span><br><span class="line">            res += c;</span><br><span class="line">            <span class="keyword">if</span>(map.contains(c))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c2 : map.get(C))&#123;</span><br><span class="line">                    degree.put(c2,degree.get(c2)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(degree.get(c2)==<span class="number">0</span>)&#123;</span><br><span class="line">                        q.add(c2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.length != degree.size())<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用map构建graph，degree存每个字母的入度，将每个字母入度设置为0.<br><br>
相邻的单词，第一个不同的字母出现时，前一个在后一个之前，然后对每一个字母的map进行更新.<br><br>
最后用queue来处理结果，将degree为0的输入，然后一个一个remove，并对该字母进行扫描，再将入度为0的存入queue。以此类推。</p>
<h2 id="819-Most-Common-Word">819. Most Common Word</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">mostCommonWord</span><span class="params">(String paragraph, String[] banned)</span> </span>&#123;</span><br><span class="line">        String[] words = paragraph.toLowerCase().split(<span class="string">"\\W++)"</span>);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> Hashset&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(String word :banned)&#123;</span><br><span class="line">            set.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(word))&#123;</span><br><span class="line">                map.put(word,map.getOrDefault(word,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        String res = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str) &gt; max)&#123;</span><br><span class="line">                max = map.get(str);</span><br><span class="line">                res = str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>正则表达式中，\w（小写w） 表示字符,  \W（大写W)表示非字符.  ‘+’ 我们要满足多项。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 34</title>
    <url>/2019/09/26/leetcode34/</url>
    <content><![CDATA[<h2 id="Aamazon-近期高频题-！">Aamazon 近期高频题 ！</h2>
<h2 id="937-Reorder-Data-in-Log-Files">937. Reorder Data in Log Files</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        Comparator&lt;String&gt; comp = <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> s1start=index(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">int</span> s2start=index(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">char</span> s1fc = s1.charAt(s1start+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">char</span> s2fc = s2.charAt(s2start+<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s1fc &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s2fc &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s2fc&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 后面是针对两个位置都是字母的情况，如果都为零，说明该字母后面均为数字或者字母，则需要从0到当前到s1start和s2start进行重新扫描。</span></span><br><span class="line">                <span class="comment">// 用s1start和s2start进行比较</span></span><br><span class="line">                <span class="keyword">int</span> precomp = s1.substring(s1start+<span class="number">1</span>).compareTo(s1.substring(s2start+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(precomp==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> s1.substring(<span class="number">0</span>,s1start).compareTo(s2.substring(<span class="number">0</span>,s2start));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> precomp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一位是被sort到对象，第二位是参考顺序，comparator会将各个元素跟比较结果进行关联。</span></span><br><span class="line">        Array.sort(logs,comp);</span><br><span class="line">        <span class="keyword">return</span> logs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@override 的目的是为了防止在更改父类时出错，不加也可以。利用java内置comparator接口，对每一个log进行主动排序，将排序结果和log对应起来，对数字和字母的情况进行设置。<br><br>
字母和字母之间comparator会自动进行排序，所以我们只需要对数字-数字 / 数字-字母对情况进行讨论。<br><br>
comparator第一位是需要进行关联赋值的对象，后一位是进行比较的参考位。<br><br>
若两者都是数字，则返回0，位置不动，二者priority相同；<br><br>
若第一个是数字，第二个是字母，返回1，后者priority高于前者（要把符合要求的提前，又因为是升序排序，所以要将priority低的关联值设置的大<br><br>
若第一个是字母，第二个是数字，返回-1，前者此时priority最高。<br><br>
若二者都是字母，则进行precomp赋值，如果还是恒等于0，非log单词后面全是数字or都是单词，所以要对0-s1start/s2start的substring再扫描，对s1start和s2start位置进行最后比较。<br><br>
最后对log用comp的参考值进行排序即可。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 36</title>
    <url>/2019/10/04/leetcode36/</url>
    <content><![CDATA[<h2 id="Aamazon-近期高频题-！">Aamazon 近期高频题 ！</h2>
<h2 id="Problem">Problem</h2>
<p>Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 → 4 → 5 → 9 is 4.<br>
You can only move either down or right at any point in time.<br>
Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[5, 1],</span><br><span class="line"> [4, 5]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">Possible paths:</span><br><span class="line">5 → 1 → 5 =&gt; min value is 1</span><br><span class="line">5 → 4 → 5 =&gt; min value is 4</span><br><span class="line">Return the max value among minimum values =&gt; max(4, 1) = 4.</span><br></pre></td></tr></table></figure>
<p>有点类似unique path problemII，这道题要求返回每个路径上最小值中的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!i &amp;&amp; !j)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)dp[j] = Math.min(grid[i][j],dp[j]);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)dp[j] = Math.min(grid[i][j],dp[j-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = Math.max(Math.min(grid[i][j],dp[j]),Math.min(grid[i][j],dp[j-<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一行 则横向比较更新最小值；若第一列，纵向比较；将值存在dp[j]里。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 33</title>
    <url>/2019/09/25/leetcode33/</url>
    <content><![CDATA[<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree">863. All Nodes Distance K in Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    Map&lt;Treenode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    find(root,target);</span><br><span class="line">    search(root,<span class="number">0</span>,K,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root, <span class="keyword">int</span> distance, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            distance=map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis==K)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        search(root.left,distance+<span class="number">1</span>,K,res);</span><br><span class="line">        search(root.right,distance+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用HashMap存住从根root到target 的path上所有节点离target的距离。<br><br>
接着用dfs方法对每个节点进行扫描。如果map有当前的节点，说明在root-target的path上。直接将distance设置为该节点到target的距离。<br><br>
如果当前节点不在map中且距离不是K（在target的子树里）,则下一次dfs将distance值加1。</p>
<a id="more"></a>
<h2 id="957-Prison-Cells-After-N-Days">957. Prison Cells After N Days</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] prison(<span class="keyword">int</span>[] cells, <span class="keyword">int</span> N)&#123;</span><br><span class="line">        <span class="keyword">for</span>( N = (N-<span class="number">1</span>)%<span class="number">14</span> + <span class="number">1</span> ; N &gt; <span class="number">0</span> ; N--)&#123;</span><br><span class="line">            <span class="keyword">int</span>[]cells2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">7</span>;i++)&#123;</span><br><span class="line">                cell2[i] = cells[i1]==cells[i+<span class="number">1</span>]? <span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cells = cell2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键要找到这道题的规律，七次一循环，cell loop7次后会回到原始状态，所以用(N-1)%14+1来判断总的循环次数，只需要找到当前N是7次里面的哪一次。<br><br>
注意不论开头和结尾是什么，第二次开始全部变为0，因为没有adjenct，所以将cell2直接赋值给cells，因为cell2初始时开头和结尾均是0。</p>
<ol start="1000">
<li>Minimum Cost to Merge Stones</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="keyword">int</span>[] stones, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        <span class="keyword">if</span> ((n - <span class="number">1</span>) % (K - <span class="number">1</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prefix = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;  n; i++)</span><br><span class="line">            prefix[i + <span class="number">1</span>] = prefix[i] + stones[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = K; m &lt;= n; ++m)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + m &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + m - <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid = i; mid &lt; j; mid += K - <span class="number">1</span>)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> ((j - i) % (K - <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] += prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断长度能不能被k整除。<br><br>
用prefix存住按顺序相加的和，备用。<br><br>
用dp存住当前两个位置之间的min cost。注意用mid对i，j之间的位置进行min扫描，保证每次都取到最小值。<br><br>
对mid loop完后，将prefix里面i和j的相对位置的值相减并且赋给dp[i][j]。</p>
<ol start="77">
<li>Combinations</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        combine(ans,<span class="keyword">new</span> ArrayList&lt;Integer&gt;(),<span class="number">1</span> ,n,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, <span class="keyword">int</span> start, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)ans.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(comb));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =start; i&lt;=n;i++)&#123;</span><br><span class="line">            comb.add(i);</span><br><span class="line">            combine(ans,comb,i+<span class="number">1</span>,n,k-<span class="number">1</span>);</span><br><span class="line">            comb.remove(comb.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回溯方法，记得最后将comb长度-1；</p>
<h2 id="22-Generate-Parentheses">22. Generate Parentheses</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> StringBuilder(),<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res ,StringBuilder sb, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(open == n &amp;&amp; close==n)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open&lt;n)&#123;</span><br><span class="line">            sb.append(<span class="string">'('</span>);</span><br><span class="line">            helper(res,sb,open+<span class="number">1</span>,close,n);</span><br><span class="line">            sb.setLength(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(close&lt;open)&#123;</span><br><span class="line">            sb.append(<span class="string">')'</span>);</span><br><span class="line">            helper(res,sb,open,close+<span class="number">1</span>,n);</span><br><span class="line">            sb.setLength(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复习。回溯方法，首先判断open和close的值，记得每步最后也要把length-1.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 35</title>
    <url>/2019/10/01/leetcode35/</url>
    <content><![CDATA[<h2 id="Aamazon-近期高频题-！">Aamazon 近期高频题 ！</h2>
<h2 id="1167-Minimum-Cost-to-Connect-Sticks">1167. Minimum Cost to Connect Sticks</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stickscost</span><span class="params">(<span class="keyword">int</span> [] sticks)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : sticks)&#123;</span><br><span class="line">            queue.offer(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.poll() + queue.poll();</span><br><span class="line">            sum += temp;</span><br><span class="line">            queue.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用priority queue的自动从小到大poll的顺序优点，自动升序扫描，最终返回最小的sum。</p>
<a id="more"></a>
<h2 id="Amazon-OA-2019-Find-Pair-With-Given-Sum">Amazon | OA 2019 | Find Pair With Given Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> target1 = <span class="number">90</span>;</span><br><span class="line">	System.out.println(Arrays.toString(Find2Sum(nums1, target1-<span class="number">30</span>)));</span><br><span class="line">	<span class="keyword">int</span>[] nums2 = &#123;<span class="number">20</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">10</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> target2 = <span class="number">90</span>;</span><br><span class="line">	System.out.println(Arrays.toString(Find2Sum(nums2, target2-<span class="number">30</span>)));</span><br><span class="line">	<span class="keyword">int</span>[] nums3 = &#123;<span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">25</span>, <span class="number">30</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> target3 = <span class="number">90</span>;</span><br><span class="line">	System.out.println(Arrays.toString(Find2Sum(nums3, target3-<span class="number">30</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] Find2Sum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">	Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">	<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[i] &gt; mac || nums[map.get(nums[i])] &gt; max)&#123;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                max = Math.max(nums[i],nums[map.get(nums[i])]);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		map.put(target - nums[i], i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two sum的变种题，无相等条件下要返回最接近target的值。所以多一步判断。其余的与two sum一样的思路。</p>
<h2 id="992-Subarrays-with-K-Different-Integers">992. Subarrays with K Different Integers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">substringarray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atmostk(A,K) - atmost(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">atmost</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.lengthj ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(A[j],<span class="number">0</span>) == <span class="number">0</span> )K--;</span><br><span class="line">            map.put(A[j],map.getOrDefault(A[j],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                map.put(A[j],map.get(A[j])-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(A[j])==<span class="number">0</span>)&#123;</span><br><span class="line">                    K++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans + = j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求找出不同元素个数为K的subarray种类数，其实可以看作是F(K)-F(K-1)的结果，最多有K个的个数减去最多有K-1的个数就是只有K个的种类数。<br><br>
但是这里用sliding window 会很麻烦，所以就检查一共有多少个不同的数。当K&lt;0时，说明当前window里已经有两个不同的数了，然后从左边收缩window的大小<br><br>
ans记录从开始到当前j位置，种类最多有K个(&lt;=K)的subarray总数。然后减去F(K-1)的即可。<br>
Youtube视频详细讲解：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/FZPtxuxArLU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 38</title>
    <url>/2019/10/10/leetcode38/</url>
    <content><![CDATA[<h2 id="113-Path-Sum-II">113. Path Sum II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathsum(TreeNode root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        re</span><br><span class="line">        pathsum(root,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathsum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        cur.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(cur));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pathsum(root.left,sum-root.val,cur,res);</span><br><span class="line">            pathsum(root.right,sum-root.val,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前root为leaf时，root val == sum ，那么直接存入cur；如果不等于sum，则继续iterate，将sum=sum-root.val。<br><br>
记得最后backtracking将cur大小减一，保证其他答案不被覆盖。</p>
<a id="more"></a>
<h2 id="114-Flatten-Binary-Tree-to-Linked-List">114. Flatten Binary Tree to Linked List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        flatten(root,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">flatten</span><span class="params">(TreeNode root, TreeNode pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> pre;</span><br><span class="line">        pre=flatten(root.right,pre);</span><br><span class="line">        pre=flatten(root.left,pre);</span><br><span class="line">        root.right = pre;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs的思路，先从right分支找到最后一个root，将其设为pre，然后逐渐递归，依次将root存入pre，并且将当前root设为pre，并且将left设为null。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 40</title>
    <url>/2019/10/12/leetcode40/</url>
    <content><![CDATA[<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal">103. Binary Tree Zigzag Level Order Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> zig = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt;temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queue.size();i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zig)&#123;</span><br><span class="line">                    temp.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            zig=!zig;</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>奇数层zig为false，偶数层zig为true。true加到queue前面，false则在后面按顺序添加。</p>
<a id="more"></a>
<h2 id="297-Serialize-and-Deserialize-Binary-Tree">297. Serialize and Deserialize Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serial(<span class="keyword">new</span> StringBuilder(),root).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">serial</span><span class="params">(StringBuilder str, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> str.append(<span class="string">"null"</span>);</span><br><span class="line">        str.append(root.val).append(<span class="string">','</span>);</span><br><span class="line">        serial(str,root.left).append(<span class="string">","</span>);</span><br><span class="line">        serial(str,root.right);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deserial(<span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">','</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserial</span><span class="params">(Queue&lt;String&gt;q)</span></span>&#123;</span><br><span class="line">        String val = q.poll();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"null"</span>equals(val))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(valueOf(val));</span><br><span class="line">        root.left = deserial(q);</span><br><span class="line">        root.right = deserial(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三次做。有点忘。enocde注意边界条件。serial中间加逗号。进行right时不用加，因为是最后一个位置。<br><br>
decode时注意deserial里面的写法，aslist和split。同样注意边界条件。它是从最后一位往前迭代。直到第一位时答案才会是最全的。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 39</title>
    <url>/2019/10/12/leetcode39/</url>
    <content><![CDATA[<h2 id="144-Binary-Tree-Preorder-Traversal">144. Binary Tree Preorder Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preoeder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedLIst&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>preorder,按照右左顺序放入deque，再按左右顺序pop出。</p>
<h2 id="145-Binary-Tree-Postorder-Traversal">145. Binary Tree Postorder Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt;  stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.addFirst(root);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上一道题类似，不过是逆序输出，只需要将add改为addFrist即可。Deque的特性。</p>
<h2 id="Amazon-高频题">Amazon 高频题</h2>
<p>Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 → 4 → 5 → 9 is 4.</p>
<p>You can only move either down or right at any point in time.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input:</span><br><span class="line">[[<span class="number">5</span>, <span class="number">1</span>],</span><br><span class="line"> [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation:</span><br><span class="line">Possible paths:</span><br><span class="line"><span class="number">5</span> → <span class="number">1</span> → <span class="number">5</span> =&gt; min value is <span class="number">1</span></span><br><span class="line"><span class="number">5</span> → <span class="number">4</span> → <span class="number">5</span> =&gt; min value is <span class="number">4</span></span><br><span class="line">Return the max value among minimum values =&gt; max(<span class="number">4</span>, <span class="number">1</span>) = <span class="number">4</span>.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincvalue</span><span class="params">(<span class="keyword">int</span>[][] mattix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix(<span class="number">0</span>).length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]-matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>&amp;&amp;i!==)&#123;</span><br><span class="line">                    dp[j]=Math.min(matrix[i][j],dp[j]);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j!=<span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[j] = Math.min(matrix[i][j],dp[j-<span class="number">1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]= Math.min(Math.max(dp[j-<span class="number">1</span>],dp[j]),matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一维数组寸住结果。只能向下或者向右扫描。</p>
<h2 id="5-Longest-Palindromic-Substring">5. Longest Palindromic Substring</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lo, maxlength;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> : i &lt; s.length()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            valid(s,i,i);</span><br><span class="line">            valid(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(lo,lo+maxlength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; k&lt;s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123;</span><br><span class="line">            j--;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxlength &lt; k-j-<span class="number">1</span>)&#123;</span><br><span class="line">            lo = j+<span class="number">1</span>;</span><br><span class="line">            maxlength = k-j-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住两种情况 一个字母重复 aba 或者两个字母重复 abba</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 37</title>
    <url>/2019/10/07/leetcode37/</url>
    <content><![CDATA[<h2 id="Aamazon-近期高频题-！">Aamazon 近期高频题 ！</h2>
<h2 id="5-Longest-Palindromic-Substring">5. Longest Palindromic Substring</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> lowpos,maxlength;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longest</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; s.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            valid(s,i,i); <span class="comment">//aba情况</span></span><br><span class="line">            valid(s,i,i+<span class="number">1</span>); <span class="comment">//baab情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(lowpos,lowpos+maxlength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; k &lt; s.length() &amp;&amp; charAt(j) == charAt(k))&#123;</span><br><span class="line">            j--;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxlength&lt;k-j+<span class="number">1</span>)&#123;</span><br><span class="line">            lowpos = j+!;</span><br><span class="line">            maxlength = k-j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又遇到了第五题，基本思路就是分aba和baab的情况分别循环。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 41</title>
    <url>/2019/10/14/leetcode41/</url>
    <content><![CDATA[<h2 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal">105. Construct Binary Tree from Preorder and Inorder Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> prestart, <span class="keyword">int</span> instart, <span class="keyword">int</span> inend, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prestart &gt; preorder.length-<span class="number">1</span> || instart &gt; inend)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[prestart]);</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==root.val)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = helper(prestart+<span class="number">1</span>,instart,idx-<span class="number">1</span>,preorder,inorder);</span><br><span class="line">        root.right = helper(prestart+idx-instart+<span class="number">1</span>,idx+<span class="number">1</span>,inend,preorder,inorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>preorder第一个永远是根结点，根据preorder的根结点在inorder里找到就可以划分左右子树了。左边是从instart到idx-1，右边是从idx+1到inend。 <br><br>
而且preorder中要跳过左子树的部分，为idx-instart.</p>
<a id="more"></a>
<h2 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal">106. Construct Binary Tree from Inorder and Postorder Traversal</h2>
<p>解法1: 1ms</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> indexpost;</span><br><span class="line">    <span class="keyword">int</span> indexinorder;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, TreeNode end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(indexpost &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode n = <span class="keyword">new</span> TreeNode(postorder[indexpost]);</span><br><span class="line">        indexpost--;</span><br><span class="line">        <span class="keyword">if</span>(inorder[indexinorder] != n.val)&#123;</span><br><span class="line">            n.right = buildTree(inorder,postorder,n);</span><br><span class="line">        &#125;</span><br><span class="line">        indexinorder--;</span><br><span class="line">        <span class="keyword">if</span>((end ==<span class="keyword">null</span>) || (inorder[indexinorder]!=end.val))&#123;</span><br><span class="line">            n.left = buildTree(inorder,postorder,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span></span>&#123;</span><br><span class="line">        indexpost = postorder.length -<span class="number">1</span>;</span><br><span class="line">        indexinorder = inorder.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder,postorder,<span class="keyword">null</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>postorder的最后一个元素永远是根节点。当inorder元素和postorder最后一个元素不相同，要继续往下循环，构建right子树。当右子树构建完成/inorder里遇到了postorder的最后一个元素，也就是根结点，开始进行左子树的构建循环。<br>
解法2: 3ms</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length != postorder.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hm = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;++i)</span><br><span class="line">            hm.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> buildTreePostIn(inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>, postorder, <span class="number">0</span>, </span><br><span class="line">                              postorder.length-<span class="number">1</span>,hm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTreePostIn</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span>[] postorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     HashMap&lt;Integer,Integer&gt; hm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ps&gt;pe || is&gt;ie) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[pe]);</span><br><span class="line">        <span class="keyword">int</span> ri = hm.get(postorder[pe]);</span><br><span class="line">        root.left = buildTreePostIn(inorder, is, ri-<span class="number">1</span>, postorder, ps, ps+ri-is-<span class="number">1</span>, hm);</span><br><span class="line">        root.right= buildTreePostIn(inorder,ri+<span class="number">1</span>, ie, postorder, ps+ri-is, pe-<span class="number">1</span>, hm);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用hashmap存节点和对应的位置。然后根据postorder里根结点的位置，进行对应的left和right子树构建。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 42</title>
    <url>/2019/10/15/leetcode42/</url>
    <content><![CDATA[<h2 id="129-Sum-Root-to-Leaf-Numbers">129. Sum Root to Leaf Numbers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumnumbers</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode n, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n.left == <span class="keyword">null</span> &amp;&amp; n.right==<span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> s*<span class="number">10</span> + n.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum(n.left,s*<span class="number">10</span>+n.val) + sum(n.right,s*<span class="number">10</span>+n.val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>将每一条子树链上数字加起来组成多位数。然后将最后结果相加。自身为空时返回0。left或者right为空时则将上一位的的结果乘10再加上自身值。</p>
<h2 id="222-Count-Complete-Tree-Nodes">222. Count Complete Tree Nodes</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countnum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftdepth = leftdepth(root);</span><br><span class="line">        <span class="keyword">int</span> rightdepth = rightdepth(root);</span><br><span class="line">        <span class="keyword">if</span>(leftdepth == rightdepth)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftdepth)-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+countnum(root.left) + countnum(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftdepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightdepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1&lt;&lt; 是log2()的意思，因为总节点数等于2的层数立方-1。left和rightdepth都相等时，可以直接返回left的depth公式。<br><br>
如果不相等，则需要recursive进行计算。记得最后加1，算上root根结点</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 44</title>
    <url>/2019/10/18/leetcode44/</url>
    <content><![CDATA[<h2 id="23-Merge-k-Sorted-Lists">23. Merge k Sorted Lists</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">kmergelist</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(<span class="keyword">new</span> Comparator &lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="meta">@override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode node1, ListNode node2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node1.val &lt; node2.val)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(node1.val == node2.val)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode last = dummy;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty)&#123;</span><br><span class="line">            last.next = queue.poll();</span><br><span class="line">            last = last.next;</span><br><span class="line">            <span class="keyword">if</span>(last.next!=<span class="keyword">null</span>)queue.add(last.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hard。首先要利用优先队列，然后定义comparator，将小的值放在最高优先度。queue第一次加的是每个linkedlist的头节点。类似minheap。</p>
<h2 id="973-K-Closest-Points-to-Origin">973. K Closest Points to Origin</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right)</span></span>&#123;<span class="comment">// Just keep the highest priority to small dist.</span></span><br><span class="line">                <span class="keyword">if</span>( dist(left) &lt; dist(right) ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( dist(left) == dist(right) ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] point : points)&#123;</span><br><span class="line">            queue.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(K&gt;<span class="number">0</span>)&#123;<span class="comment">// Keep in mind that Kth point is in int[K-1] position</span></span><br><span class="line">            K--;</span><br><span class="line">            res[K] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span>[] point)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> point[<span class="number">0</span>]*point[<span class="number">0</span>] + point[<span class="number">1</span>]*point[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Comparator方法。将dist小的point赋给最高的优先度。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 43</title>
    <url>/2019/10/16/leetcode43/</url>
    <content><![CDATA[<h2 id="199-Binary-Tree-Right-Side-View">199. Binary Tree Right Side View</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightsideview</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size -- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;<span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;<span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bfs方法返回最右侧的节点。利用size作为flag来记录当前层是否遍历完。<br><br>
– &gt;是比较之后自身减一。queue.poll从前，stack.pop从后。</p>
<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree">236. Lowest Common Ancestor of a Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == q || root==p || root == <span class="keyword">null</span>)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三遍。自身调用，left就是左子树的最小父节点，right就是右子树的最小父节点。不用想太多，调用后直接用返回值进行比较，很简单，left为null则表示左边没有最小父节点，返回右子树的情况。同理，right为null时返回左子树的情况。如果两边都没有，那么就是root本身了。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 45</title>
    <url>/2019/10/20/leetcode45/</url>
    <content><![CDATA[<h2 id="241-Different-Ways-to-Add-Parentheses">241. Different Ways to Add Parentheses</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>)&#123;</span><br><span class="line">                String part1 = input.substring(<span class="number">0</span>,i);</span><br><span class="line">                String part2 = input.substring(i+<span class="number">1</span>);</span><br><span class="line">                List&lt;Integer&gt; p1 = map.getOrDefault(p1,diffWaysToCompute(part1));</span><br><span class="line">                List&lt;Integer&gt; p2 = map.getOrDefault(p2,diffWaysToCompute(part2));</span><br><span class="line">                <span class="keyword">for</span>(Integer v1 : p1)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(Integer v2 : p2)&#123;</span><br><span class="line">                        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                            <span class="keyword">case</span>(<span class="string">'+'</span>):</span><br><span class="line">                                r = p1+p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span>(<span class="string">'-'</span>):</span><br><span class="line">                                r = p1 - p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span>(<span class="string">'*'</span>):</span><br><span class="line">                                r = p1*p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        res.add(r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(Integer.valueOf(input));</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(input,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用map存住string对应的所有结果和，减少时间。根据符号判断当前运算方法，最后记得将res和当前的input存入map。</p>
<a id="more"></a>
<h2 id="282-Expression-Add-Operators">282. Expression Add Operators</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        find(res,sb,num,<span class="number">0</span>,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(List&lt;Integer&gt; res , StringBuilder sb, String num, <span class="keyword">int</span> pos, <span class="keyword">int</span> target, <span class="keyword">int</span> prev, <span class="keyword">int</span> after)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == num.length() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(target == prev)&#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num.charAt(pos) == <span class="string">'0'</span> &amp;&amp; i!=pos)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">long</span> cur = Long.parseLong(num.substring(pos,i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> len = sb.length();</span><br><span class="line">            <span class="keyword">if</span>(pos == <span class="number">0</span>)&#123;</span><br><span class="line">                find(res,sb.append(curr),num,i+<span class="number">1</span>,target,curr,curr);</span><br><span class="line">                sb.setLength(length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                find(res,sb.append(<span class="string">'+'</span>).append(curr),num,i+<span class="number">1</span>,target,prev + curr, curr);</span><br><span class="line">                sb.setLength(length);</span><br><span class="line">                find(res,sb.append(<span class="string">'-'</span>).append(curr),num,i+<span class="number">1</span>,target,prev - curr, -curr);</span><br><span class="line">                sb.setLength(length);</span><br><span class="line">                find(res,sb.append(<span class="string">'*'</span>).append(curr),num,i+<span class="number">1</span>,target,prev - after + after*curr, after*curr);</span><br><span class="line">                sb.setLength(length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hard。 利用stringbuilde方法比直接用string更快。注意每一次find后要backtracking，将sb的length调整回一开始的值，就是每次find里声明的sb的长度。<br><br>
利用long型避免出错。注意Long.parseLong的用法。第一步的时候将after和prev都设为curr。之后才会细分。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 46</title>
    <url>/2019/10/27/leetcode46/</url>
    <content><![CDATA[<h2 id="123-Best-Time-to-Buy-and-Sell-Stock-III">123. Best Time to Buy and Sell Stock III</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> onebuy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> twobuy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> onebuyonesell = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> twobuytwosell = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = price[i];</span><br><span class="line">            onebuy = Math.min(p,onebuy);</span><br><span class="line">            onebuyonesell = Math.max(p-onebuy,onebuyonesell);</span><br><span class="line">            twobuy = Math.min(twobuy, p - onebuyonesell);</span><br><span class="line">            twobuytwosell = Math.max(twobuytwosell, p - twobuy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> twobuytwusell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>use onebuy and twobuy to store the min cost, and onebuyonesell &amp; twobuytwosell are used to store the max profit.</p>
<a id="more"></a>
<h2 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown">309. Best Time to Buy and Sell Stock with Cooldown</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solitoin</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>,presell = <span class="number">0</span>, buy = Integer.MIN_VALUE,prebuy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> price: prices)&#123;</span><br><span class="line">            prebuy = buy;</span><br><span class="line">            buy = Math.max(presell - price, prebuy);</span><br><span class="line">            presell = sell;</span><br><span class="line">            sell = Math.max(prebuy + price, presell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hard one.<br><br>
buy, sell are both used to store the max profit of the action queue which is ended with ‘buy’ or ‘sell’.<br><br>
When it is ended with buy, we compare the prebuy and presell - price(buying action cause profit to decrease, so minus the price) to choose the larger one.<br><br>
When it is ended with sell, we compare the presell and prebuy + price.<br><br>
Hint: we can not have two same actions like ‘buy’ ‘buy’ or ‘sell’‘sell’. So in the comparision, we use different params instead of both sell or both buy.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 47</title>
    <url>/2019/11/03/leetcode47/</url>
    <content><![CDATA[<h2 id="295-Find-Median-from-Data-Stream">295. Find Median from Data Stream</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()) max;</span><br><span class="line">    PriorityQueue&lt;Integer&gt;() min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        max = PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder());</span><br><span class="line">        min = PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addnum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        min.offer(num);</span><br><span class="line">        max.offer(min.poll());</span><br><span class="line">        <span class="keyword">if</span>(min.size() &lt; max.size())&#123;</span><br><span class="line">            min.offer(max.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findmedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(min.size() == max.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> ((min.peek() + max.peek()) / <span class="number">2.0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> min.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个heap，一个存小的一半，一个存大的一半。find的时候判断两部分长度是否相等。<br><br>
max中较小的部分靠后，优先peek；min正常大pq，大数靠后优先peek。</p>
<a id="more"></a>
<h2 id="561-Array-Partition-I">561. Array Partition I</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">arraypart</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; nums.length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            res+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，sort之后隔2位直接相加就是最终答案。具体算法解析在这里<a href="https://leetcode.com/problems/array-partition-i/discuss/102170/Java-Solution-Sorting.-And-rough-proof-of-algorithm." target="_blank" rel="noopener">leetcode 561</a></p>
<h2 id="167-Two-Sum-II-Input-array-is-sorted">167. Two Sum II - Input array is sorted</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">twosumSorted</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] idx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length &lt;<span class="number">2</span>)<span class="keyword">return</span> idx;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(temp == target)&#123;</span><br><span class="line">                idx[<span class="number">0</span>] = left + <span class="number">1</span>;</span><br><span class="line">                idx[<span class="number">1</span>] = right + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &gt; target)&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变种two sum， 输入的numbers已经sorted，利用双指针前后扫描，大于target就右边收缩，小于target就左边扩大。</p>
<h2 id="27-Remove-Element">27. Remove Element</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=target)&#123;</span><br><span class="line">                nums[m] = nums[i];</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接循环扫描，并用m-index将新的值存如数组，每次循环最后将m++.m++.</p>
<h2 id="472-Concatenated-Words">472. Concatenated Words</h2>
<h3 id="dp解法">dp解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">concatenatedword</span><span class="params">(String[] words)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; prewords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(form(words[i],prewords))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            prewords.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">form</span><span class="params">(String word, Set&lt;String&gt; dict)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dict.isEmpty())<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[word.length()+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; word.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(dict.contains(word.substring(j,i)))&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word.length()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用comparator将word sort。<br><br>
dp存住当前字母之前的word是否已经在dist中存在。如果有则该长word可以用之前的短word构成。</p>
<h3 id="dfs-解法">dfs 解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(words,(a,b)-&gt; a.length()-b.length());</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArraysList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; words.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(words[i].length != <span class="number">0</span> &amp;&amp; valid(set,words[i]))&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(Set&lt;String&gt; set, String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(word))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">            String temp = word.substring(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(valid(set,word.substring(i)))&#123;</span><br><span class="line">                    set.add(word);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs思路。part1和dp思路一致。private方法里注意dfs之后要将目前的word存入set。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 49</title>
    <url>/2019/11/04/leetcode49/</url>
    <content><![CDATA[<h2 id="994-Rotting-Oranges">994. Rotting Oranges</h2>
<h3 id="题干">题干</h3>
<p>In a given grid, each cell can have one of three values:<br></p>
<p>the value 0 representing an empty cell;<br><br>
the value 1 representing a fresh orange;<br><br>
the value 2 representing a rotten orange.<br><br>
Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.<br></p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.<br><br>
<br><br>
<img src="https://assets.leetcode.com/uploads/2019/02/16/oranges.png"></p>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>这道题和博客leetcode48中maxmium minum path score有相似的思路。<br><br>
BFS扫描，只对grid中为1的点进行操作。每次操作完一个点之后将minute+1。<br></p>
<ol>
<li>利用queue来存节点坐标。由于没有min max限制，所以我们直接存入就可以。<br></li>
<li>先遍历一边grid，存下fresh（1）的个数。由于是从坏掉的开始扩散，所以再将坏掉的橙子坐标存入queue。</li>
<li>对queue poll出对点进行bfs，即坏掉位置</li>
<li>建立操作方位的集合，操作是只需要遍历该集合即可。</li>
<li>对更新位置后值为1的坐标(newx,newy)进行操作，将其改为2，存入queue，fresh的数量-1。</li>
<li>最后判断fresh的个数是否为零。应该是0。如果是0则返回minute；如果不是的话就返回-1.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length;</span><br><span class="line">        <span class="keyword">int</span> cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> freshnums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;rows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)freshnums++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(freshnums == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minutes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(freshnums == <span class="number">0</span>)<span class="keyword">return</span> minutes;</span><br><span class="line">            minutes++;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] point = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] move : moves)&#123;</span><br><span class="line">                    <span class="keyword">int</span> newx = point[<span class="number">0</span>] + move[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> newy = point[<span class="number">1</span>] + move[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newx &lt; <span class="number">0</span> || newy &lt; <span class="number">0</span> || newx &gt;= rows || newy &gt;= cols || grid[newx][newy] == <span class="number">0</span> || grid[newx][newy] == <span class="number">2</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    grid[newx][newy] = <span class="number">2</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newx,newy&#125;);</span><br><span class="line">                    freshnums--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freshnums == <span class="number">0</span> ?  minutes: -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="545-Boundary-of-Binary-Tree">545. Boundary of Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        leftBoundary(root.left);</span><br><span class="line">        leaves(root.left);</span><br><span class="line">        leaves(root.right);</span><br><span class="line">        rightBoundary(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftBoundary</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)) <span class="keyword">return</span>;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) leftBoundary(root.right);</span><br><span class="line">        <span class="keyword">else</span> leftBoundary(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightBoundary</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || (root.right == <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)rightBoundary(root.left);</span><br><span class="line">        <span class="keyword">else</span> rightBoundary(root.right);</span><br><span class="line">        nodes.add(root.val); <span class="comment">// add after child visit(reverse)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodes.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        leaves(root.left);</span><br><span class="line">        leaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照左边界，左子节点，右子节点，右边界对顺序。<br><br>
leaves要一致扫描到最后的节点再返回。rightboundary中记得要在访问子节点之后再将root值存入node。<br><br>
因为左边界是自上而下，而右边界是自下而上存入node。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 48</title>
    <url>/2019/11/04/leetcode48/</url>
    <content><![CDATA[<h2 id="209-Minimum-Size-Subarray-Sum">209. Minimum Size Subarray Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">minsizesub</span><span class="params">(<span class="keyword">int</span>[]nums,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>,sum=<span class="number">0</span>,min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                min = Math.min(min,i-from+<span class="number">1</span>);</span><br><span class="line">                sum-=nums[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (min == Integer.MAX_VALUE) ? <span class="number">0</span>:min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>two pointers方法。正序扫描累加，当大于s的时候，减去nums[from],存住当前min的值，直到当前from到i内的和小于s为止，i继续向后遍历。<br></li>
<li>orner case 要判断min是否变化，如果没有则返回0。</li>
</ol>
<a id="more"></a>
<h2 id="1004-Max-Consecutive-Ones-III">1004. Max Consecutive Ones III</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function">pubic <span class="title">maxconsecutive</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,res=<span class="number">0</span>,zeronums=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> end =<span class="number">0</span>;end&lt;A.length;end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] == <span class="number">0</span>)zeronums++;</span><br><span class="line">            <span class="keyword">while</span>(zeronums&gt;K)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[start] == <span class="number">0</span>)zeronums--;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end-start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>sliding window方法。永远保证window里0的个数为K个，如果超过就要再用start开始遍历，保证0的个数始终为K，然后将最长的substring存为res。<br></li>
<li>切记不要被end和start的字面意思迷惑。这道题的关键就是保持window里0的个数为K。</li>
</ol>
<h2 id="1099-Two-Sum-Less-Than-K">1099. Two Sum Less Than K</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">twosumlessthanK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,max=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = A[i]+A[j];</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; K)&#123;</span><br><span class="line">                max = Math.max(max,sum);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>two pointers。<br></li>
<li>先sort，然后两遍各自向中间扫描，大于k就右边缩小一位，小于K就左边扩大一位，只有小于K时更新max，大于的时候直接j–就可以。</li>
</ol>
<h2 id="572-Subtree-of-Another-Tree">572. Subtree of Another Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s,t)|| isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val!= t.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tree的pre-traversal。先判断当前s和t是否isSame,或者s.left/s.right和t是否为isSubTree。<br><br>
isSame里两种情况为true：<br></p>
<ol>
<li>val均相等<br></li>
<li>都为null<br></li>
<li>各自左右子树也为issame。<br></li>
</ol>
<h2 id="1102-Path-With-Maximum-Minimum-Value">1102. Path With Maximum Minimum Value</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M,N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        M = A.length;</span><br><span class="line">        N = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] dx = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dy = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[M][N];</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; b[<span class="number">0</span>] - a[<span class="number">0</span>]);<span class="comment">//以值为参考进行comparre</span></span><br><span class="line"></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur[<span class="number">1</span>] == M-<span class="number">1</span> &amp;&amp; cur[<span class="number">2</span>] == N-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = cur[<span class="number">1</span>] + dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny = cur[<span class="number">2</span>] + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt;M &amp;&amp; ny &gt;=<span class="number">0</span> &amp;&amp; ny &lt; N &amp;&amp; !seen[nx][ny])&#123;</span><br><span class="line">                    seen[nx][ny] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Math.min(cur[<span class="number">0</span>],A[nx][ny]),nx,ny&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>PriorityQueue以大根堆的形式存住各个位置的值。<br></li>
<li>将每个位置以 {值，x坐标，y坐标} 的形式存入priority。以值为参考进行自定义compare。<br></li>
<li>在nx ny移动的部分，将新位置的值和之前cur的值进行比较，依次存入priorityqueue，最根部的则是这些最小值中最大的值。<br></li>
<li>以供下次循环时poll使用。poll出来的均为上一次扫描中最小值中的最大值。在更新位置前要判断是否为最后一个元素，如果是直接返回cur[0]。</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 51</title>
    <url>/2019/11/06/leetcode51/</url>
    <content><![CDATA[<h2 id="Tree-Problems">Tree Problems</h2>
<h2 id="1104-Path-In-Zigzag-Labelled-Binary-Tree">1104. Path In Zigzag Labelled Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">pathInZigZagTree</span><span class="params">(<span class="keyword">int</span> label)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;()l</span><br><span class="line">        <span class="keyword">int</span> parent = label;</span><br><span class="line">        res.addFirst(parent);</span><br><span class="line">        <span class="keyword">while</span>(parent!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> depth = (<span class="keyword">int</span>)Math.log(parent)/Math.log(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> remains = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>,depth+!)-parent-<span class="number">1</span>;</span><br><span class="line">            partne = (<span class="keyword">int</span>)(Math.pow(<span class="number">2</span>,depth) + reamins)/<span class="number">2</span>;</span><br><span class="line">            res.addFirst(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自下而上。在顺序颠倒的一行时，先计算出深度，再由深度计算出当前label距离该行最大值的距离remains，然后通过正常顺序计算出对应的parent。并且addFirst到res中。</p>
<a id="more"></a>
<h2 id="366-Find-Leaves-of-Binary-Tree">366. Find Leaves of Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getheight(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getheight</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        jf(root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span> + Math.max(getheight(root.left,res), getheight(root.right,res));</span><br><span class="line">        <span class="keyword">if</span>(res.size() &lt; level +<span class="number">1</span>)res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        res.get(level).add(root);</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>recursive。 得到每一层距离叶节点的最大距离level，叶节点level为0，存在res[0]，自下而上recursive。将每个level的节点存入res。</p>
<h2 id="897-Increasing-Order-Search-Tree">897. Increasing Order Search Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> increase(root,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increase</span><span class="params">(TreeNode root, TreeNode tail)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> tail;</span><br><span class="line">        TreeNode res = increase(root.left,root);</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = increase(root.right,tail);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tail记录最终结果里root的下一个节点。left分支中，root.left的下一个节点就是root父节点。并且将root.left 设为null。右分支在recursive时，在res赋值中，将当前root当作下一节点存入res。</p>
<h2 id="1123-Lowest-Common-Ancestor-of-Deepest-Leaves">1123. Lowest Common Ancestor of Deepest Leaves</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode lca;</span><br><span class="line">    <span class="keyword">int</span> deepest = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        deep(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lca;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deep</span><span class="params">(TreeNode root, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        deepest = Math.max(deepest,depth);</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">int</span> left = deep(root.left,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = deep(root.right,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(left == deepest &amp;&amp; right == deepest)&#123;</span><br><span class="line">            lcn = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要当某个root的left 和 right 深度都为deepest时 ，说明该位置的subtree对称深度相同。那么直接返将当前的root赋值给lcn。</p>
<h2 id="1110-Delete-Nodes-And-Return-Forest">1110. Delete Nodes And Return Forest</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: to_delete)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(root))&#123;</span><br><span class="line">            res.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        bfs(root,set,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, Set&lt;Integer&gt; set, List&lt;TreeNode&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        root.left = dfs(root.left,set,res);</span><br><span class="line">        root.right = dfs(root.right,set, res);</span><br><span class="line">        <span class="keyword">if</span>(set.contains(root))&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!-<span class="keyword">null</span>)res.add(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)res.add(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dfs recursive。如果当前节点在delete名单里，看它左右节点是否为空，如果有不为null的将其子节点存入res。如果都为null则彻底删除该节点，返回null。<br><br>
如果不含该节点，则返回该节点。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 50</title>
    <url>/2019/11/05/leetcode50/</url>
    <content><![CDATA[<h2 id="866-Prime-Palindrome">866. Prime Palindrome</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">primePalindrome</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="number">8</span> &lt;= N &amp;&amp; N &lt;= <span class="number">11</span>)<span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; <span class="number">100000</span>; x++)&#123;</span><br><span class="line">            String s = Integer.toString(x);</span><br><span class="line">            String news = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(s + news.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>( y &gt;=N &amp;&amp; isPrime(y))<span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &lt; <span class="number">2</span> || y%<span class="number">2</span> == <span class="number">0</span>)<span class="keyword">return</span> y==<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">3</span>; i*i&lt;=y;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(y%i == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，只需要考虑奇数位的string就可以了。注意构建palidrom的方法。reverse之后取第二个位置到最后，加到s中。<br><br>
还有要注意素数到判断。最好全记住。</p>
<a id="more"></a>
<h2 id="456-132-Pattern">456. 132 Pattern</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> two = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> index = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; two) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (index &lt; nums.length &amp;&amp; nums[i] &gt; nums[index]) &#123;</span><br><span class="line">                two = nums[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">            nums[index] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用two来存大小为第二大的数字，但是位置应该是在132中最后的位置。</p>
<h2 id="909-Snakes-and-Ladders">909. Snakes and Ladders</h2>
<h3 id="题目">题目</h3>
<p>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:<br>
<img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png"></p>
<p>You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:</p>
<p>You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.<br>
(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)<br>
If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.</p>
<h3 id="solution">solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">snakesandladders</span><span class="params">(<span class="keyword">int</span>[][]board)</span></span>&#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[n*n+<span class="number">1</span>];</span><br><span class="line">        queue.offer(<span class="number">1</span>);</span><br><span class="line">        seen[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;=<span class="number">6</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> next = cur + k;</span><br><span class="line">                    <span class="keyword">int</span> [] pos = NumToPos(next);</span><br><span class="line">                    <span class="keyword">if</span>(board[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        next = board[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(next == n*n)<span class="keyword">return</span> steps;</span><br><span class="line">                    <span class="keyword">if</span>(!seen[next])&#123;</span><br><span class="line">                        seen[next] = <span class="keyword">true</span>;</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">NumToPos</span><span class="params">(<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = (target-<span class="number">1</span>)/n, col = (target-<span class="number">1</span>)%n;</span><br><span class="line">        <span class="keyword">int</span> x = n-row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = row%<span class="number">2</span> == <span class="number">0</span>? col:n-col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路">思路</h3>
<ol>
<li>不用单独建一个一位数组，直接私有一个helper函数实现num和postion的转换。</li>
<li>这种图路径的问题基本都是queue+操作方向/距离集合，之前的题里方向集合注意new int[]{}的初始化；这道题直接for遍历1-6步。</li>
<li>这种题要加上seen判断是否访问过该点，根据当前点显示数字大小（此题只有目的位置的数字和-1两种），将符合的再存入queue。更新seen为true。</li>
<li>思路大体为num -&gt; pos -&gt; num, 通过NumToPos函数实现num的跳转。</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 52</title>
    <url>/2019/11/06/leetcode52/</url>
    <content><![CDATA[<h2 id="第二遍">第二遍</h2>
<h2 id="98-Validate-Binary-Search-Tree">98. Validate Binary Search Tree</h2>
<h3 id="stack-解法">stack 解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root !=<span class="keyword">null</span> &amp;&amp; root.val &lt;= pre.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>判断BST是否合理，利用stack实现in order的操作。左-根-右的顺序存入stack，判断pre和root的值大小。左支就是下-上，pre在root下面；右支是pre在root上面。</p>
<h3 id="recursive-解法">recursive 解法</h3>
<p>(in-order-traversl实现，先递归left，再访问root，再递归right)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TReeNode root)</span></span>&#123;</span><br><span class="line">        test(root);</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        test(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">            valid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        test(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="101-Symmetric-Tree">101. Symmetric Tree</h2>
<h3 id="iterative解法">iterative解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">symmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode tree1 = stack.pop(), tree2=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(tree1 == <span class="keyword">null</span> &amp;&amp; tree2 == <span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tree1 == <span class="keyword">null</span> || tree2 == <span class="keyword">null</span> || tree1.val !=tree2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            stack.push(tree1.left);</span><br><span class="line">            stack.push(tree2.right);</span><br><span class="line">            stack.push(tree1.right);</span><br><span class="line">            stack.push(tree2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterative。记得把tree node 对称地push进stack。</p>
<h3 id="recursive解法">recursive解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || test(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(TreeNode node1, TreeNode node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>)<span class="keyword">return</span> node1 == node2;</span><br><span class="line">        <span class="keyword">if</span>(node1.val != node2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> test(node1.left,node2.right) %% test(node1.right,node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意最后同时检查对称。 node1或者node2有一个为null时直接返回node1==node2即可。简洁。</p>
<h2 id="94-Binary-Tree-Inorder-Traversal">94. Binary Tree Inorder Traversal</h2>
<h3 id="Iterative-解法">Iterative 解法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root);</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>in-order 将节点加入res。记住stack方法的框架。</p>
<h2 id="102-Binary-Tree-Level-Order-Traversal">102. Binary Tree Level Order Traversal</h2>
<h3 id="Iterative-方法">Iterative 方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; templist= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size; i ++)&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)queue.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)queue.add(cur.right);</span><br><span class="line">                templist.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Queue自上而下存节点。size为当前这一行的元素个数，遍历size遍，将每个节点左右孩子加入queue后，再将其本身加入templist。遍历结束加入res。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 53</title>
    <url>/2019/11/07/leetcode53/</url>
    <content><![CDATA[<h1>亚麻 VO 面经 准备</h1>
<h2 id="560-Subarray-Sum-Equals-K">560. Subarray Sum Equals K</h2>
<h3 id="two-pointer-sliding-window-暴力解">two pointer sliding window + 暴力解</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length ;i++)&#123;</span><br><span class="line">            sum=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum == k)count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.length ; j++)&#123;</span><br><span class="line">                sum+=num[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k)count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力解，两个指针，时间复杂度o(n方)。空间复杂度o(1)</p>
<a id="more"></a>
<h3 id="Presum-HashMap">Presum + HashMap</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; presum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        presum.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(num : nums)&#123;</span><br><span class="line">            sum+=num;</span><br><span class="line">            <span class="keyword">if</span>(presum.containsKey(sum-k))&#123;</span><br><span class="line">                count+= presum.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            presum.put(sum,presum.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路主要是通过 SUM[i, j] = SUM[0, j]-SUM[0, i - 1] 得来。<br><br>
相当于从第一位到最后一位所有的sum存入map。如果map历史中的某个sum正好等于当前的sum - k，表明之前sum截止的idx到当前到sum截止idx中间的元素和正好为k。所以count加一。<br>
<br><br>
we know the key to solve this problem is SUM[i, j]. So if we know SUM[0, i - 1] and SUM[0, j], then we can easily get SUM[i, j]. To achieve this, we just need to go through the array, calculate the current sum and save number of all seen PreSum to a HashMap. Time complexity O(n), Space complexity O(n).<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sum[i, j] = sum[<span class="number">0</span>, j] - sum[<span class="number">0</span>, i - <span class="number">1</span>]    --&gt; sum[<span class="number">0</span>, i - <span class="number">1</span>] = sum[<span class="number">0</span>, j] - sum[i, j]</span><br><span class="line">    k           sum      hashmap-key     --&gt;  hashmap-key  =  sum     -    k</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 54</title>
    <url>/2019/11/07/leetcode54/</url>
    <content><![CDATA[<h2 id="第二遍">第二遍</h2>
<h2 id="80-Remove-Duplicates-from-Sorted-Array-II">80. Remove Duplicates from Sorted Array II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">2</span> || num &gt; nums[index-<span class="number">2</span>])&#123;</span><br><span class="line">                nums[index] = num;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑不难。留出两个位置，因为题目要求最多有两个重复元素。只要当前num和nums[index-2]即可。将当前num存入index的位置。</p>
<a id="more"></a>
<h2 id="相同的逻辑套路。">相同的逻辑套路。</h2>
<h2 id="26-Remove-Duplicates-from-Sorted-Array">26. Remove Duplicates from Sorted Array</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; <span class="number">1</span> || num &gt; nums[index-<span class="number">1</span>])&#123;</span><br><span class="line">                nums[index] = num;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一样的套路。这道题允许重复的个数只有一个。</p>
<h2 id="442-Find-All-Duplicates-in-an-Array">442. Find All Duplicates in an Array</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(Math.abs(index + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            nums[index] = -nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将num对应的index变为负数，如果遍历中遇到了自己对应的index已经为负，说明已经出现过了，存入res。</p>
<h2 id="5-Longest-Palindromic-Substring">5. Longest Palindromic Substring</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start, dist;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            valid(s,i,i);</span><br><span class="line">            valid(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+dist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist &lt; j-i-<span class="number">1</span>)&#123;</span><br><span class="line">            dist = j-i-<span class="number">1</span>;</span><br><span class="line">            start = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三遍遇到。还是要注意两种对称情况。121or1221。</p>
<h2 id="937-Reorder-Data-in-Log-Files">937. Reorder Data in Log Files</h2>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]</span><br><span class="line"></span><br><span class="line">Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        Arrays.sort(logs,(s1,s2)-&gt;&#123;</span><br><span class="line">            String[] split1 = s1.split(<span class="string">" "</span>,<span class="number">2</span>);</span><br><span class="line">            String[] split2 = s2.split(<span class="string">" "</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">boolean</span> isdigit1 = Character.isDigit(split1[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">boolean</span> isdigit2 = Character.isDigit(split2[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(!isdigit1 &amp;&amp; !isdigit2)&#123;</span><br><span class="line">                <span class="keyword">int</span> compare_value = split1[<span class="number">1</span>].compareTo(split2[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(compare_value==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> split1[<span class="number">0</span>].compareTo(split2[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> compare_value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isdigit1 &amp;&amp; isdigit2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isdigit1 &amp;&amp; !isdigit2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> logs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>纯粹的string操作知识点。</p>
<ol>
<li>首先判断第二位是数字还是字符，数字靠后放，字符往前提。自定义sort顺序，当isdigit1/2 均为数字时，保持原顺序，优先度为0；1为digit2不是，优先度最低，为1，1不是digit 2是digit，优先度最高，为-1；<br></li>
<li>当都不是digit时，对两者对字符大小判断，compareTo如果为0，说明第二位开头字母也一样。那就对第一部分对string进行大小排序。</li>
</ol>
<h2 id="60-Permutation-Sequence">60. Permutation Sequence</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum*=i;</span><br><span class="line">            factorial[i] = sum;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        k=k-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = k/factorial[n-i];</span><br><span class="line">            sb.append(String.valueOf(numbers[index]));</span><br><span class="line">            numbers.remove(index);</span><br><span class="line">            k = k-index*factorial[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先建立factorial和numbers，存住n的阶乘值和所有的number。所有的结果应该按各自为开头排列。只有1的全部遍历完了才会到2开头。。。<br><br>
当前第k个结果的第一个数字在numbers里的index可以用index = k/factorial[n-i]来计算。 n-i是除去开头数字剩下所有情况，k则是要求的位置。k/factorial[n-i]则可以找出开头数字的位置。然后去numbers用index求出开头数字。最后要更新k，因为开头数字找到了以后，再求之后的数字时，要用k减去第一个数字所在的轮次，然后以此类推即可。</p>
<h2 id="71-Simplify-Path">71. Simplify Path</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; banset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals<span class="string">".."</span> &amp;&amp; !deque.isEmpty())deque.pop();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!banset.contains(str))deque.push(str);</span><br><span class="line">        &#125;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            res = <span class="string">"/"</span> + deque.pop() + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.isEmptuy() ? <span class="string">"/"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dequeLILO，遇到…且deque中有元素则pop。</p>
<h2 id="675-Cut-Off-Trees-for-Golf-Event-hard">675. Cut Off Trees for Golf Event (hard)</h2>
<h2 id="思路依旧Priority-bfs-操作方向集">思路依旧Priority + bfs + 操作方向集{}</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dir&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> LinkedList&lt;&gt;((a,b)-&gt;a[<span class="number">2</span>]-b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">int</span> m = forest.size(), n=forest.get(<span class="number">0</span>).size();</span><br><span class="line">        <span class="keyword">if</span>(forest == <span class="keyword">null</span> || forest.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(forest.get(i).get(j) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j,forest.get(i).get(j)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> step = getstep(forest,tree,start,m,n);</span><br><span class="line">            <span class="keyword">if</span>(step&lt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            sum+=step;</span><br><span class="line">            start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">            start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getstep</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] tree, <span class="keyword">int</span>[]start, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        seen[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; curr[<span class="number">1</span>] == tree[<span class="number">1</span>])<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] d : dir)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nr = curr[<span class="number">0</span>] + d[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> nc = curr[<span class="number">1</span>] + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nr &lt; <span class="number">0</span> || nr &gt; m || nc &lt;<span class="number">0</span> || nc &gt;n || forest.get(nr).get(nc) == <span class="number">0</span> || seen[nr][nc])<span class="keyword">continue</span>;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr,nc&#125;);</span><br><span class="line">                    seen[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>用priorityqueue按小到大将tree存下。然后从小到大poll出，进行dfs。基本的priority + 操作{} 的dfs。框架要熟记。<br></li>
<li>start给定从0，0开始，当dsf过后记得将start更新为第一个tree的坐标:tree[0],tree[1].</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 55</title>
    <url>/2019/11/07/leetcode55/</url>
    <content><![CDATA[<h2 id="503-Next-Greater-Element-II">503. Next Greater Element II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line">        Arrays.fill(next,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; n*<span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i%n];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)&#123;</span><br><span class="line">                next[stack.pop()] = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>用stack存原nums里元素的index。新建一个等大的next存放结果。</li>
<li>全部初始为-1.进行n*2次遍历，保证原nums中最后的元素也能找到circle中的max。</li>
<li>如果stack peek()的index对应的nums里的元素小于当前的num时，表明index对应的元素下一个最大值就是当前的num。将num赋给 next[stack.pop()]。如果没有最大值的位置永远是-1。</li>
</ol>
<a id="more"></a>
<h2 id="类似的题目">类似的题目</h2>
<h2 id="496-Next-Greater-Element-I">496. Next Greater Element I</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums2.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i])&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nums1.length;i++)&#123;</span><br><span class="line">            num1[i] = map.getOrDefault(nums1[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一样的思路，只不过这道题直接存的是元素本身，因为没有circle的要求。用map存住nums2里元素和next greater的key-value。最后对nums1进行更新。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 56</title>
    <url>/2019/11/09/leetcode56/</url>
    <content><![CDATA[<h2 id="1130-Minimum-Cost-Tree-From-Leaf-Values">1130. Minimum Cost Tree From Leaf Values</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mctFromLeafValues</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack.push(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a: arr)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()&lt;= a)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = stack.pop();</span><br><span class="line">                res+= mid * Math.min(stack.peek(),a);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            res+=stack.pop()*stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很不错的一道stack题。如果当前待存的数大于当前stack堆顶的数，则将堆顶数pop出，pop之后的堆顶数和当前待存a中最大的数乘以pop的数。一直循环直到堆顶的元素大于当前待存数值。<br><br>
tricky的地方在于，当所有元素遍历一边后，会检查当前stack的大小，如果大于2，继续pop并且乘以当前peek，直到&lt;2。返回res；因为如果stack size&lt;2 说明第一轮while循环时，最后一个数值会大于前面所有的数，所以会一直pop并且更新res。</p>
<a id="more"></a>
<h2 id="449-Serialize-and-Deserialize-BST">449. Serialize and Deserialize BST</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEP = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NULL = <span class="string">"null"</span>;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> NULL;</span><br><span class="line">        <span class="comment">//traverse it recursively if you want to, I am doing it iteratively here</span></span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        st.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">            root = st.pop();</span><br><span class="line">            sb.append(root.val).append(SEP);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) st.push(root.right);</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) st.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strs = data.split(SEP);</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String e : strs) &#123;</span><br><span class="line">            q.offer(Integer.parseInt(e));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getNode(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">getNode</span><span class="params">(Queue&lt;Integer&gt; q)</span> </span>&#123; <span class="comment">//q: 5,3,2,6,7</span></span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(q.poll());<span class="comment">//root (5)</span></span><br><span class="line">        Queue&lt;Integer&gt; samllerQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123;</span><br><span class="line">            samllerQueue.offer(q.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//smallerQueue : 3,2   storing elements smaller than 5 (root)</span></span><br><span class="line">        root.left = getNode(samllerQueue);</span><br><span class="line">        <span class="comment">//q: 6,7   storing elements bigger than 5 (root)</span></span><br><span class="line">        root.right = getNode(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack存储顺序为 root left left left 。。。 right right right right<br><br>
建bst时要分大小queue。保证left的值全在smallqueue中取。right的在出除去left值的q中取。</p>
<h2 id="593-Valid-Square">593. Valid Square</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validSquare</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2, <span class="keyword">int</span>[] p3, <span class="keyword">int</span>[] p4)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dist(p1,p2),dist(p1,p3),dist(p1,p4),dist(p2,p3),dist(p2,p4),dist(p3,p4)&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : len)&#123;</span><br><span class="line">            max = Math.max(max,i);</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.size()==<span class="number">2</span>&amp;&amp;map.get(max)==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span>[]point1,<span class="keyword">int</span>[]point2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((point2[<span class="number">0</span>]-point[<span class="number">0</span>])*()point2[<span class="number">0</span>]-point[<span class="number">0</span>]) + (point2[<span class="number">1</span>]-point1[<span class="number">1</span>])*(point2[<span class="number">1</span>]-point1[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断四个点是否为一个square。用map存各个点之间距离。最后只要保证map点大小为2(边长和对角线两种长度)，且最长的(对角线)有且只有两个。</p>
<h2 id="759-Employee-Free-Time">759. Employee Free Time</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Interval&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt; a.start-b.start);</span><br><span class="line">        schedule.forEach(e -&gt; queue.addAll(e));</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.end &lt; queue.peek().start)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> Interval(temp.end,queue.peek().start));</span><br><span class="line">                temp = queue.poll();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.end &lt; queue.peek().end ? queue.peek() : temp;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>priorityqueue 存interval。poll之后判断当前end和peek的start大小关系即可。注意不符合res条件后先跟peek比然后在poll。直接poll会TLE。</p>
<h2 id="1091-Shortest-Path-in-Binary-Matrix">1091. Shortest Path in Binary Matrix</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dir = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span> || grid[m-<span class="number">1</span>][n-<span class="number">1</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] pop = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(pop[<span class="number">0</span>]==m-<span class="number">1</span> &amp;&amp; pop[<span class="number">1</span>]==n-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] d:dir) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nextX = d[<span class="number">0</span>]+pop[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> nextY = d[<span class="number">1</span>]+pop[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(nextX&gt;=<span class="number">0</span> &amp;&amp; nextX&lt;m &amp;&amp; nextY&gt;=<span class="number">0</span> &amp;&amp; nextY&lt;n &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY]==<span class="number">0</span>) &#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextX,nextY&#125;);</span><br><span class="line">                        visited[nextX][nextY]=<span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>queue + dir{}。 注意当遍历到最后一个的时候要返回ans+1；因为ans存的类似于步骤次数，和之前做的题类似，但是这道题是返回的距离，所以要用次数+1.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 57</title>
    <url>/2019/11/11/leetcode57/</url>
    <content><![CDATA[<h2 id="863-All-Nodes-Distance-K-in-Binary-Tree">863. All Nodes Distance K in Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>find将在target之上的node存入map。在target subtree里的不赋值。</li>
<li>dfs中，如果是target之上的节点，将dist更新为map中存的到target的距离，再进行dfs dist+1。</li>
<li>如果是target的subtree，则循环到target自身时，dist会变为0，然后dfs更新，当dist==k时，该节点也就是要存入res的节点。</li>
</ol>
<a id="more"></a>
<h2 id="987-Vertical-Order-Traversal-of-a-Binary-Tree">987. Vertical Order Traversal of a Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        pair(TreeNode n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            node = n;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer,List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(root,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.remove();</span><br><span class="line">            min = Math.min(temp.x,min);</span><br><span class="line">            max = Math.max(temp.x,max);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(temp);</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.node.left,temp.x-<span class="number">1</span>,temp.y+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.node.right,temp.x+<span class="number">1</span>,temp.y+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = min; i &lt;= max; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i),<span class="keyword">new</span> Comparator&lt;pair&gt;()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(pair a, pair b)</span></span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a.y == b.y)<span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j &lt; map.get(i).size();j++)&#123;</span><br><span class="line">                list.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>新建pair 类，用queue存放所有树节点，记录所有树节点x的最小值和最大值，之后遍历要用到。</li>
<li>map 存放x坐标都相同的pai。然后用compare 从小到大sort。</li>
<li>然后通过x顺序遍历map，将相同x的值存进同一个list，再加入res中。</li>
</ol>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 59 / Tree</title>
    <url>/2019/11/14/leetcode59/</url>
    <content><![CDATA[<h2 id="Tree-类题模版">Tree 类题模版</h2>
<ol>
<li>单tree<br>
<img src="https://s2.ax1x.com/2019/11/15/MapoG9.png"></li>
<li>两个tree比较<br>
<img src="https://s2.ax1x.com/2019/11/15/MapIPJ.png"></li>
<li>tree 三种 遍历<br>
<img src="https://s2.ax1x.com/2019/11/15/Map454.png"></li>
</ol>
<h2 id="100-Same-Tree">100. Same Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> left = isSameTree(p.left,q.left);</span><br><span class="line">        <span class="keyword">boolean</span> right = isSameTree(p.right,q.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right &amp;&amp; p.val == q.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单tree模版。</p>
<a id="more"></a>
<h2 id="101-Symmetric-Tree">101. Symmetric Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="keyword">null</span> || help(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode node1, TreeNode node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> left = help(node1.left,node2.right);</span><br><span class="line">        <span class="keyword">boolean</span> right = help(node1.right,node2.left);</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right&amp;&amp;node1.val == node2.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双tree。由于题目给定单function里只有一个tree，要单独写一个private。</p>
<h2 id="951-Flip-Equivalent-Binary-Trees">951. Flip Equivalent Binary Trees</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> left1 = flipEquiv(root1.left,root2.left);<span class="comment">//no change</span></span><br><span class="line">		<span class="keyword">boolean</span> left2 = flipEquiv(root1.left,root2.right); <span class="comment">// flipped</span></span><br><span class="line">		<span class="keyword">boolean</span> right1 = flipEquiv(root1.right,root2.right); <span class="comment">// no change</span></span><br><span class="line">		<span class="keyword">boolean</span> right2 = flipEquiv(root1.right,root2.left);  <span class="comment">// flipped</span></span><br><span class="line">	    <span class="keyword">return</span> root1.val == root2.val &amp;&amp;( ( left1 &amp;&amp; right1) || (left2 &amp;&amp; right2) );<span class="comment">// we have to make sure the correct left and right part is unchanged or flipped.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双tree。要考虑四种情况。 left ： change or flipped 。right一样。</p>
<h2 id="572-Subtree-of-Another-Tree">572. Subtree of Another Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || t==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val!=t.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和100 same tree 一样的思路。只不过subtree一样也可以。所以main 里return中有考虑left / right subtree 一样单情况。</p>
<h2 id="545-Boundary-of-Binary-Tree">545. Boundary of Binary Tree</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solutoin</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        left(root.left);</span><br><span class="line">        leaves(root.left);</span><br><span class="line">        leaves(root.right);</span><br><span class="line">        right(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)left(root.right);</span><br><span class="line">        <span class="keyword">else</span> left(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)right(root.left);</span><br><span class="line">        <span class="keyword">else</span> right(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaves</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)res.add(root.val);</span><br><span class="line">        leaves(root.left);</span><br><span class="line">        leaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左边界 - 左叶子 - 右叶子 - 右边界。<br><br>
注意左右add root的时机不同。左边先add再递归。右边是先递归再add。<br><br>
注意三种情况的函数写法。left /leaves /right</p>
<h2 id="103-Binary-Tree-Zigzag-Level-Order-Traversal">103. Binary Tree Zigzag Level Order Traversal</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">boolean</span> zig = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(zig)&#123;</span><br><span class="line">                    temp.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    temp.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(temp);</span><br><span class="line">            zig = !zig;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用zig来标记该行是否zig输出。如果是zig的一行，则将poll出来的 add(0,temp)到 temp的开头。否则的话就按顺序add到temp中。每个teamp存的是每一行的元素，最后将temp加入res中。</p>
<h2 id="124-Binary-Tree-Maximum-Path-Sum">124. Binary Tree Maximum Path Sum</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        max = Integer.MIN_VALUE;</span><br><span class="line">        maxpath(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxpath</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(maxpath(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(maxpath(root.right),<span class="number">0</span>);</span><br><span class="line">        max = Math.max(max,left+right+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tricky的地方在于：max赋值那里，math里面的max是左右子树遍历后的max，而外面的max还是未更新的max。注意最后return左右中最大的加上root val，返回给上一层继续递归。</p>
<h2 id="653-Two-Sum-IV-Input-is-a-BST">653. Two Sum IV - Input is a BST</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> dfs(root,set,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root, HashSet&lt;Integer&gt; set , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(k-root.val))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left,k) || dfs(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>two sum 变种。依旧用set存下出现过的node值。如果set中有node有等于k-root.val，则返回true。没有就继续左右递归。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 58</title>
    <url>/2019/11/13/leetcode58/</url>
    <content><![CDATA[<h2 id="2-Add-Two-Numbers">2. Add Two Numbers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sum/=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum+=l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum+=l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">10</span> == <span class="number">1</span>)dummy.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum/10j就是计算进位。而sum%10则是计算刨除进位后需要加的数。</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 61 / LinkedList</title>
    <url>/2019/11/17/leetcode61/</url>
    <content><![CDATA[<h2 id="61-Rotate-List">61. Rotate List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">        ListNode fast = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            size++;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size - k%size;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast.next = head;</span><br><span class="line">        head= slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定listnode长度，找到第k-k%size第元素，然后将其后元素全部提前即可。</p>
<a id="more"></a>
<h2 id="82-Remove-Duplicates-from-Sorted-List-II">82. Remove Duplicates from Sorted List II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre.next == cur)&#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cur和pre双指针。首先判断cur和cur next值是否相等。如果相等则跳过，pre针对cur如果有跳跃，则直接将pre next 更新为新cur next， 如果没有跳跃则就为pre next。 因为没有跳跃的话pre始终在cur的前面。</p>
<h2 id="141-Linked-List-Cycle">141. Linked List Cycle</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast=head,slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经典快慢指针。fast走两个，slow走一个，如果两个某个时刻重合，说明有环。否则没有。</p>
<h2 id="21-Merge-Two-Sorted-Lists-1-iterative-2-recursive">21. Merge Two Sorted Lists (1.iterative / 2. recursive)</h2>
<h3 id="1-Iterative-方法">1.Iterative 方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 !=<span class="keyword">null</span> &amp;&amp; l2 !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                res.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.next = l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)res.next = l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)res.next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>straightforward方法。新建一个头节点dummy，分情况讨论l1和l2节点的值大小，分别加入dummy next。最后考虑某个list已经遍历完的情况，则将另外一个list直接加到dummy 后面。</p>
<h3 id="2-Recursive-方法">2.Recursive 方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>)<span class="keyword">return</span> l1 == <span class="keyword">null</span> ? l2:l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本的recursive方法，分别对l1和l2递归。</p>
<h2 id="23-Merge-k-Sorted-Lists-priorityqueue-recursive">23. Merge k Sorted Lists (priorityqueue / recursive )</h2>
<h3 id="priorityqueue">priorityqueue</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode node1, ListNode node2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node1.val &lt; node2.val)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(node1.val == node2.val)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode last = dummy;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            last.next = queue.poll();</span><br><span class="line">            last = last.next;</span><br><span class="line">            <span class="keyword">if</span>(last.next!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(last.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义comparator，将每个list第一个节点存入queue，然后判断poll后的queue头部节点和poll的节点next的值大小。然后依次poll出即可。</p>
<h3 id="recursive-based-on-mergeTwolists-solutions">recursive ( based on mergeTwolists solutions)</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)<span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end)/<span class="number">2</span>;</span><br><span class="line">            ListNode l1 = mergeTwoList(lists,start,mid);</span><br><span class="line">            ListNode l2 = mergeTwoList(lists,mid+<span class="number">1</span>,end);</span><br><span class="line">            <span class="keyword">return</span> merge(l1,l2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next=merge(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next=merge(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于lc 21 mergetwolist 的方法。本题变为k个list，需要多一层对list自身对递归。二分递归。然后再接上mergetwolist的思路，对指定对两个list进行merge。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 60 / LinkedList</title>
    <url>/2019/11/16/leetcode60/</url>
    <content><![CDATA[<h2 id="2-Add-Two-Numbers">2. Add Two Numbers</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sum/=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum+=l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum+=l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            dummy.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">10</span> == <span class="number">1</span>)dummy.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum/10j就是计算进位。而sum%10则是计算刨除进位后需要加的数。</p>
<a id="more"></a>
<h2 id="138-Copy-List-with-Random-Pointer">138. Copy List with Random Pointer</h2>
<img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png">
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">new</span> Node(cur.val, next, <span class="keyword">null</span>);</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        Node copyhead = head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Node curnext = cur.next.next;<span class="comment">//cur链表</span></span><br><span class="line">            Node copy = cur.next;<span class="comment">//copy链表</span></span><br><span class="line">            cur.next = curnext;</span><br><span class="line">            <span class="keyword">if</span>(curnext!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                copy.next = curnext.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = curnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copyhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三次遍历。<br></p>
<ol>
<li>第一次在对应的node后面复制自己成为node’</li>
<li>第二次将node’的random连线</li>
<li>第三次各自成线。<br><br>
大概思路如图：<br>
<img src="https://raw.githubusercontent.com/hot13399/leetcode-graphic-answer/master/138.%20Copy%20List%20with%20Random%20Pointer.jpg"></li>
</ol>
<h2 id="328-Odd-Even-Linked-List">328. Odd Even Linked List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode odd = head, even = head.next, evenhead = even;</span><br><span class="line">            <span class="keyword">while</span>(even !=<span class="keyword">null</span> &amp;&amp; even.next !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                odd.next = odd.next.next;</span><br><span class="line">                even.next = even.next.next;</span><br><span class="line">                odd = odd.next;</span><br><span class="line">                even = even.next;</span><br><span class="line">            &#125;</span><br><span class="line">            odd.next = evenhead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区分odd和even的head之后各自next.next遍历就可以。最后将evenhead加到odd后面。</p>
<h2 id="1019-Next-Greater-Node-In-Linked-List">1019. Next Greater Node In Linked List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(ListNode node = head; node!=<span class="keyword">null</span>;node = node.next)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; list.get(stack.peek())&lt; list.get(i))&#123;</span><br><span class="line">                res[stack.pop()] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listnode存为arraylist。用stack存贮index，然后各自比较。类似next greator 的题，一样的思路。下一题就是next greater。</p>
<h2 id="503-Next-Greater-Element-II-circle">503. Next Greater Element II(circle)</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%size])&#123;</span><br><span class="line">                res[stack.pop()] = nums[i%size];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i%size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Loop once, we can get the Next Greater Number of a <em>normal</em> array.</li>
<li>Loop twice, we can get the Next Greater Number of a <em>circular</em> array</li>
</ol>
<h2 id="496-Next-Greater-Element-I">496. Next Greater Element I</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums2)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() &lt; num)&#123;</span><br><span class="line">                map.put(stack.pop(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            nums1[i]=map.getOrDefault(nums1[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map + stack。</p>
<h2 id="556-Next-Greater-Element-III">556. Next Greater Element III</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] number = (n+<span class="string">""</span>).toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = number.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (number[i-<span class="number">1</span>] &lt; number[i])</span><br><span class="line">               <span class="keyword">break</span>;<span class="comment">//从后向前遍历，找到第一个左边小于右边的index。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//如果没有，也就是整个序列都是降序，本身就是最大值了。</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> x = number[i-<span class="number">1</span>], smallest = i;<span class="comment">// 记住小的数值，记录右边数值的index。</span></span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; number.length; j++)<span class="comment">// 在x到最后一位之间，寻找大于x值并且小于右边值的最小值index</span></span><br><span class="line">            <span class="keyword">if</span> (number[j] &gt; x &amp;&amp; number[j] &lt;= number[smallest])</span><br><span class="line">                smallest = j;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> temp = number[i-<span class="number">1</span>];<span class="comment">//将左边的小数值和右边部分的最小值互换。</span></span><br><span class="line">        number[i-<span class="number">1</span>] = number[smallest];</span><br><span class="line">        number[smallest] = temp;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(number, i, number.length);<span class="comment">//将剩下的右边部分sort</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> val = Long.parseLong(<span class="keyword">new</span> String(number));</span><br><span class="line">        <span class="keyword">return</span> (val &lt;= Integer.MAX_VALUE) ? (<span class="keyword">int</span>) val : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路附在code里。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 14</title>
    <url>/2019/05/25/leeticode14/</url>
    <content><![CDATA[<h2 id="44-Wildcard-Matching">44. Wildcard Matching</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solutoin</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String str, String pattern)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s =<span class="number">0</span>,p=<span class="number">0</span>,startidx=-<span class="number">1</span>,match=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(s&lt;str.length())&#123;</span><br><span class="line">			<span class="keyword">if</span>(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p) == <span class="string">'?'</span> || str.charAt(s)==pattern.charAt(p))&#123;</span><br><span class="line">				p++;</span><br><span class="line">				s++;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == <span class="string">'*'</span>)&#123;</span><br><span class="line">				staridx = p;</span><br><span class="line">				match = s;</span><br><span class="line">				p++;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(staridx !=-<span class="number">1</span>)&#123;</span><br><span class="line">				p = staridx + <span class="number">1</span>;</span><br><span class="line">				match++;</span><br><span class="line">				s=match;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (p&lt;pattern.length()&amp;&amp; pattern.charAt(p) ==<span class="string">'*'</span>)&#123;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p == pattern.length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hint">Hint</h3>
<p>简单的几个if判断，双指针问题。 s指向str-原string，p指向pattern-待检测的string。<br>
重要的是第三个if，当staridx一直不为-1时，p始终为staridx的后一位，保证了前面的星号可以一直顺着s检测下去不中断。</p>
<h2 id="10-Regular-Expression-Matching">10. Regular Expression Matching</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span>[][] state = <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">		state[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j&lt;state[<span class="number">0</span>].length();j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(state[<span class="number">0</span>][j-<span class="number">1</span>] || j&gt;<span class="number">1</span> &amp;&amp; state[<span class="number">0</span>][j-<span class="number">2</span>])&#123;</span><br><span class="line">					state[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;state.legnth();i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; state[<span class="number">0</span>].legnth();j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;</span><br><span class="line">					state[i][j] =state[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)!= p.charAt(j-<span class="number">2</span>) &amp;&amp; p.charAt(j-<span class="number">2</span>)!=<span class="string">'.'</span>)&#123;</span><br><span class="line">						state[i][j] = state[i][j-<span class="number">2</span>];</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						state[i][j] = state[i-<span class="number">1</span>][j]||state[i][j-<span class="number">1</span>]||state[i][j-<span class="number">2</span>];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> state[s.length()][p.legnth()];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hint-v2">Hint</h3>
<p>hard的一道题，也是判断.* 的题，<br>
1, 如果p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];<br>
2, 如果p.charAt(j) == ‘.’ : dp[i][j] = dp[i-1][j-1];<br>
3, 如果p.charAt(j) == '<em>’: (细分三种情况)<br>
1   当p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  // a</em> 表示为空<br>
2   当p.charAt(j-1) == s.charAt(i) or p.charAt(j-1) == ‘.’:（细分三种）<br>
dp[i][j] = dp[i-1][j]    //a* 表示两个a<br>
or dp[i][j] = dp[i][j-1]   // a* 表示一个a<br>
or dp[i][j] = dp[i][j-2]   // a* 表示为空</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 9</title>
    <url>/2019/05/11/leetcode9/</url>
    <content><![CDATA[<h2 id="951-Flip-Equivalent-Binary-Trees">951. Flip Equivalent Binary Trees</h2>
<h3 id="O-n-方案">O(n)方案</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipequv</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root <span class="number">1</span> == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span> || root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span>((root1.left != <span class="keyword">null</span> ? root1.left.val : -<span class="number">1</span>) != (root2.left != <span class="keyword">null</span> ? root2.left.val : -<span class="number">1</span>))&#123;</span><br><span class="line">			TreeNode t = root1.left;</span><br><span class="line">			root1.left = root1.right;</span><br><span class="line">			root1.right = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flipequv(root1.left,root2.left) &amp;&amp; flipequv(root1.right,root2.right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路">思路</h3>
<p>判断两个树经过flip后是否是同一棵树。<br>
首先1.若两个root都为null，为true<br>
2.若其中一个为null而另一个不是，或者两个的val不同，false<br>
3.重点在第三个if，分别判断各自左孩子是否为空，如果左右孩子都相同，则跳过该if，执行递归；<br>
若！=，分三个情况：<br>
a. root1.left = null 而root2.left存在<br>
b. root1.left 存在 而 root2.left = null<br>
c. root1.left.val != root2.left.val<br>
在以上三种情况下，证明和原树不一样，为了验证是否是flip过，用swap思想，将root1.left 和right值互换，再进行判断。</p>
<h2 id="338-Counting-Bits">338. Counting Bits</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] countbits(<span class="keyword">int</span> num)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++)&#123;</span><br><span class="line">			f[i] = f[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v2">思路</h3>
<p>将整数分为两部分，最后一位和前面所有。<br>
最后一位1 or 0，用 i&amp;1 (1%2)表示，判断最后一位1的个数（也就是看是不是1）<br>
其他位数，用f[i&gt;&gt;1]即(i/2)表示，判断前面的所有1的个数<br>
其实细看，偶数的f[i/2]可以调用前面已有的数值，最后的个位肯定为0，奇数最后个位肯定为1，类似dp？</p>
<h2 id="985-Sum-of-Even-Numbers-After-Queries">985. Sum of Even Numbers After Queries</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sumEvenAfterQueries(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">    	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> a : A)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    			sum+=a;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> [] ans = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> [] q:queries)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(A[q[<span class="number">1</span>]] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    			sum-=A[q[<span class="number">1</span>]];</span><br><span class="line">    		&#125;</span><br><span class="line">    		A[q[<span class="number">1</span>]] += q[<span class="number">0</span>];</span><br><span class="line">    		<span class="keyword">if</span> (A[q[<span class="number">1</span>]] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    			sum+=A[q[<span class="number">1</span>]]</span><br><span class="line">    		&#125;</span><br><span class="line">    		ans[i] = sum;</span><br><span class="line">    		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路-v3">思路</h2>
<p>现将当前数组的偶数加起来，开始循环，当q[1]位置为偶数时，保险起见，先从sum里减掉，之后q[0]加上，再次判断是否为偶数，如果是则加进sum，不是的话直接放弃，将当前偶数放进ans[i],i++</p>
<h2 id="885-Spiral-Matrix-III">885. Spiral Matrix III</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">		<span class="keyword">int</span>[][] dirt = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;，&#123;<span class="number">1</span>,<span class="number">0</span>&#125;，&#123;<span class="number">0</span>，-<span class="number">1</span>&#125;，&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;；</span><br><span class="line">		List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>, d =<span class="number">0</span>;</span><br><span class="line">		res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r0,c0&#125;);</span><br><span class="line">		<span class="keyword">while</span> (res.size() &lt; R*C)&#123;</span><br><span class="line">			<span class="keyword">if</span> (d == <span class="number">0</span> || d == <span class="number">2</span>)&#123;</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> =<span class="number">0</span>; i&lt; len;i++)&#123;</span><br><span class="line">				r0+=dirt[d][<span class="number">0</span>];</span><br><span class="line">				c0+=dirt[d][<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C)&#123;</span><br><span class="line">					res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r0,c0&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			d = (d+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[R*C][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路-v4">思路</h3>
<p>顺时针回字形从起点开始扫描，dirt设置每次移动后的坐标，d设置移动的步数，画图后发现，右下各1步，左上各2步，右下各3步，左上各4步…，以此类推，d是移动方向在dirt里的位置，0右1下2左3上，所以当d=0（起点或者经过一轮后） 或者 d=2，每次状态改变的时候，移动步长len要+1。</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Review Problems List 📌</title>
    <url>/9999/12/31/problemslist/</url>
    <content><![CDATA[<br>
<font size="3"> 记录Problems list的完成情况 每日更新。<br>
<a href="https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ6qpA/edit#gid=972946549" target="_blank" rel="noopener"><font size="4">🔗 Problems List  Link </font></a>
<br>
Github Leetcode Summary 同步更新。<br>
<a href="https://github.com/WangHngLeee/LeetcodeSummary" target="_blank" rel="noopener"><font size="4">🔗 Github Summary Link </font></a>
<br>
</font>
<br>
<br>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Problems List</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 62 / LinkedList</title>
    <url>/2019/11/18/leetcode62/</url>
    <content><![CDATA[<h2 id="92-Reverse-Linked-List-II">92. Reverse Linked List II</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m-<span class="number">1</span>;i++)pre=pre.next;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode then = start.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n-m;i++)&#123;</span><br><span class="line">            start.next = then.next;</span><br><span class="line">            then.next = pre.next;</span><br><span class="line">            pre.next = then;</span><br><span class="line">            then = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本的链表操作。注意更新时代码的写法。</p>
<a id="more"></a>
<h2 id="725-Split-Linked-List-in-Parts">725. Split Linked List in Parts</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node = root; node!=<span class="keyword">null</span> ; node =  node.next)&#123;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = size/k,r = size%k;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>, node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; node!=<span class="keyword">null</span> &amp;&amp; i&lt;k ; i++,r--)&#123;</span><br><span class="line">            res[i] = node;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + ( r &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>); j++)&#123;</span><br><span class="line">                prev = node;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先将root存入res[0]，然后根据n和r对数组大小进行确定，然后遍历，记住prev是该数组的尾，而node则是更新为了下一个res的头节点。相当于用prev.next==null 来断链表。</p>
<h2 id="148-Sort-List">148. Sort List</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">            ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            dummy.next = head;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode prev = dummy;</span><br><span class="line">                ListNode cur = dummy.next;</span><br><span class="line">                <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ListNode left = cur;</span><br><span class="line">                    ListNode right = split(left, step);</span><br><span class="line">                    cur = split(right, step);</span><br><span class="line">                    prev = merge(left, right, prev);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">split</span><span class="params">(ListNode head, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; head.next != <span class="keyword">null</span> &amp;&amp; i &lt; step; i++) &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode right = head.next;</span><br><span class="line">            head.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right, ListNode prev)</span> </span>&#123;</span><br><span class="line">            ListNode cur = prev;</span><br><span class="line">            <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">                    cur.next = left;</span><br><span class="line">                    left = left.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.next = right;</span><br><span class="line">                    right = right.next;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span>) cur.next = left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) cur.next = right;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) cur = cur.next;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bottom-up。 将node按个数为1，2，4，8，。。。的顺序分别排序，step&lt;&lt;=1就是将step*2.split是返回断开后右边的listnode，merge就是合并，但要注意返回的是合并后的尾部的node，方便下一次循环链接。</p>
<h2 id></h2>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title>React Review 📓</title>
    <url>/2020/05/19/react1/</url>
    <content><![CDATA[<h2 id="React-复习">React 复习</h2>
<h3 id="生命周期">生命周期</h3>
<p>生命周期就是组件从实例化到渲染再到最终从页面中销毁，整个过程就是生命周期。在生命周期中，有很多可以调用的事件，也称为hook/钩子函数。</p>
<h3 id="生命周期三个状态">生命周期三个状态</h3>
<ul>
<li>Mounting : 将组件插入DOM中</li>
<li>Updating : 将组件更新到DOM中</li>
<li>Unmounting : 将组件移出DOM</li>
</ul>
<h3 id="钩子函数（方法，事件）">钩子函数（方法，事件）</h3>
<ul>
<li>
<p>componentWillMount(): 组件将要渲染,AJAX,添加动画前的类</p>
</li>
<li>
<p>componentDidMount(): 组件渲染完毕，添加动画</p>
</li>
<li>
<p>componentWillReceiveProps(): 组件将要接受props数据</p>
</li>
<li>
<p>shouldComponentUpdate(): 组件接收到新的props/state时判断是否更新，返回boolean值</p>
</li>
<li>
<p>componentWillUpdate(): 组件将要更新</p>
</li>
<li>
<p>componentDidUpdate(): 组件更新完毕</p>
</li>
<li>
<p>compnentWillUnmount(): 组件将要卸载</p>
</li>
</ul>
<a id="more"></a>
<p>尝试以下代码输出情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complife</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            msg:<span class="string">'test msg'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'构造函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'挂载完毕，准备渲染'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'渲染完毕'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件将要接受props'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate()&#123;</span><br><span class="line">        <span class="comment">//如果希望更新返回true，不希望则返回false，不更新就是undefined</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.msg == <span class="string">'test msg'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件将要更新'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件更新完毕'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件卸载'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log（<span class="string">'渲染函数'</span>)</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Complife /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>console结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">组件将要渲染</span><br><span class="line">渲染函数</span><br><span class="line">组件渲染完毕</span><br></pre></td></tr></table></figure>
<p>没有其他event时构造的顺序如上面结果所示。</p>
<p>但如果有clickevent更新状态时，组件的状态顺序又是怎样的呢？</p>
<p>其他不变，在render函数中增加一个ondlick事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">    render()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log（<span class="string">'渲染函数'</span>)</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h1&gt;&#123;<span class="keyword">this</span>.state.msg&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;button onClick=&#123;this.changeMsg&#125;&gt;更新&lt;/</span>button&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        changeMsg=()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">                msg:"changing msg"</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">......</span></span><br></pre></td></tr></table></figure>
<p>点击更新后此时console将会多出以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件将要更新</span><br><span class="line">渲染函数</span><br><span class="line">组件更新完毕</span><br></pre></td></tr></table></figure>
<p>在complife之后增加parent class尝试Unmount函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            isshow:<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.remove&#125;&gt; remove complif组件 &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;complife /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    remove=()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">            isshow:false;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Parent /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此时点击button后会增加一条console</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件卸载</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>Front-end</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Python &amp; Web</title>
    <url>/2019/02/27/pythonEmail/</url>
    <content><![CDATA[<h3 id="Python-network-programming">Python network programming</h3>
<p>Python provides two levels of access to network services:</p>
<ol>
<li>Low-level network services support basic Sockets, which provide the standard BSD Sockets API and access to all methods of the Socket interface of the underlying operating system.</li>
<li>Advanced network service module SocketServer, which provides a server center class, can simplify the development of network server.</li>
</ol>
<a id="more"></a>
<h3 id="Socket">Socket</h3>
<p>Socket also known as the “Socket”, the application usually through the “Socket” to the network to make a request or reply to the network request, so that the host or a computer between the process can communicate.</p>
<h3 id="Socket-function">Socket() function</h3>
<p>In Python, socket () function is used to create socket. The syntax format is as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.socket([family[, type[, proto]]])</span><br></pre></td></tr></table></figure>
<h2 id="Parameters">Parameters:</h2>
<p>Family: the socket family can be AF_UNIX or AF_INET<br>
Type: socket types can be classified as SOCK_STREAM or SOCK_DGRAM depending on whether they are connection-oriented or connection-free<br>
Protocol: don’t use 0 as the default.</p>
<h3 id="The-service-side">The service side</h3>
<p>Use the socket function of the socket module to create a socket object.A socket object can set up a socket service by calling other functions.<br>
Now we can specify the port of the service by calling the bind(hostname, port) function.<br>
Next, call the accept method of the socket object. This method waits for the client to connect and returns a connection object indicating that it is connected to the client.<br>
The complete code is as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># file name：server.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket               <span class="comment"># input socket model</span></span><br><span class="line"></span><br><span class="line">s = socket.socket()         <span class="comment"># create socket object</span></span><br><span class="line">host = socket.gethostname() <span class="comment"># Gets the localhost name</span></span><br><span class="line">port = <span class="number">12345</span>                <span class="comment"># Set port</span></span><br><span class="line">s.bind((host, port))        <span class="comment"># Binding port</span></span><br><span class="line"></span><br><span class="line">s.listen(<span class="number">5</span>)                 <span class="comment"># Wait for client connection</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    c, addr = s.accept()     <span class="comment"># Establish a client connection.</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Address:'</span>, addr</span><br><span class="line">    c.send(<span class="string">'Welcome to the rookie tutorial!'</span>)</span><br><span class="line">    c.close()                <span class="comment"># close the connection</span></span><br></pre></td></tr></table></figure>
<h2 id="The-client">The client</h2>
<p>Next, write a simple client instance that connects to the service created above.The port number is 12345.<br>
The socket.connect(hosname, port) method opens a TCP connection to a service provider that has a hostname of port.After the connection. We can then retrieve the data from the server and remember to close the connection when the operation is complete.<br>
The complete code is as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># file name：client.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket               <span class="comment"># import socket model</span></span><br><span class="line"></span><br><span class="line">s = socket.socket()         <span class="comment"># create socket object</span></span><br><span class="line">host = socket.gethostname() <span class="comment"># Gets the localhost name</span></span><br><span class="line">port = <span class="number">12345</span>                <span class="comment"># Set port</span></span><br><span class="line"></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="keyword">print</span> s.recv(<span class="number">1024</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>Now we open the two terminals. The first terminal executes the <a href="http://server.py" target="_blank" rel="noopener">server.py</a> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python server.py</span><br></pre></td></tr></table></figure>
<p>Second terminal execution <a href="http://client.py" target="_blank" rel="noopener">client.py</a> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python client.py </span><br><span class="line">Welcome to the rookie tutorial!</span><br></pre></td></tr></table></figure>
<p>When we open the first terminal, we will see the following information output:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Address： (<span class="string">'192.168.0.118'</span>, <span class="number">62461</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 93 / String(1) 💪</title>
    <url>/2020/05/30/string01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-14-Longest-Common-Prefix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">14. Longest Common Prefix</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string “”.</p>
<h3 id="Example">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strs.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(pre)!=<span class="number">0</span>)&#123;</span><br><span class="line">                pre = pre.substring(<span class="number">0</span>,pre.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T: O(n) S: O(1)</p>
<p>Using tricky of function of indexOf to get the first positoin of string. We take first string as comparator, then loop all the other strings to check if the first position of comparator in these strings is 0. If not 0, then we shrink the comparator string’s length - 1.</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-10-Regular-Expression-Matching-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">10. Regular Expression Matching</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p>
<p>Given an input string (s) and a pattern §, implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.<br>
‘*’ Matches zero or more of the preceding element.<br>
The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>
p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        state[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; state[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state[<span class="number">0</span>][j - <span class="number">1</span>] || (j &gt; <span class="number">1</span> &amp;&amp; state[<span class="number">0</span>][j - <span class="number">2</span>])) &#123;</span><br><span class="line">                    state[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; state.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; state[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    state[i][j] = state[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != p.charAt(j - <span class="number">2</span>) &amp;&amp; p.charAt(j - <span class="number">2</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        state[i][j] = state[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state[i][j] = state[i - <span class="number">1</span>][j] || state[i][j - <span class="number">1</span>] || state[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP solution.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];</span><br><span class="line">2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];</span><br><span class="line">3, If p.charAt(j) == &apos;*&apos;: </span><br><span class="line">here are two sub conditions:</span><br><span class="line">    1   if p.charAt(j-1) != s.charAt(i) </span><br><span class="line">           dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty</span><br><span class="line">    2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;:</span><br><span class="line">           dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a </span><br><span class="line">        or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a</span><br><span class="line">        or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby learning notes(1)</title>
    <url>/2019/08/27/ruby/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>由于选了CSC517的oop需要用ruby来做project，虽然ruby较为冷门，但是多学一门语言总是好的。<br><br>
环境设置以及一些基本操作就跳过了。</p>
<h3 id="Ruby-语法">Ruby 语法</h3>
<p>ruby中输出用puts</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">puts <span class="string">"Hello Ruby!"</span></span><br></pre></td></tr></table></figure>
<h3 id="Ruby中的行尾">Ruby中的行尾</h3>
<p>ruby中用分号；或者换行符\n来表示行尾。</p>
<h3 id="Ruby中的Here-Document">Ruby中的Here Document</h3>
<p>Here Document&quot; 是指建立多行字符串。<br><br>
在 &lt;&lt; 之后，k可以指定一个字符串或标识符来终止字符串，且当前行之后直到终止符为止的所有行是字符串的值。<br><br>
如果终止符用引号括起，引号的类型决定了面向行的字符串类型。注意&lt;&lt; 和终止符之间必须没有空格.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/ruby -w</span></span><br><span class="line"><span class="comment"># -*- coding : utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line">print &lt;&lt;EOF</span><br><span class="line">    这是第一种方式创建here document 。</span><br><span class="line">    多行字符串。</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">print &lt;&lt;<span class="string">"EOF"</span>;                <span class="comment"># 与上面相同</span></span><br><span class="line">    这是第二种方式创建here document 。</span><br><span class="line">    多行字符串。</span><br><span class="line">EOF</span><br><span class="line"> </span><br><span class="line">print &lt;&lt;<span class="string">`EOC`</span>                 <span class="comment"># 执行命令</span></span><br><span class="line">    echo hi there</span><br><span class="line">    echo lo there</span><br><span class="line">EOC</span><br><span class="line"> </span><br><span class="line">print &lt;&lt;<span class="string">"foo"</span>, &lt;&lt;<span class="string">"bar"</span>          <span class="comment"># 您可以把它们进行堆叠</span></span><br><span class="line">    I said foo.</span><br><span class="line">foo</span><br><span class="line">    I said bar.</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Ruby-中的BEGIN-END-语句">Ruby 中的BEGIN/END 语句</h3>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>&#123;</span><br><span class="line">    cdoe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示code会在程序运行之前调用<br><br>
例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">puts <span class="string">"this is main code"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span>&#123;</span><br><span class="line">    puts <span class="string">"this is begin code"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">this is <span class="keyword">begin</span> code</span><br><span class="line">this is main code</span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">END</span>&#123;</span><br><span class="line">    CODE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表明code会在程序运行之后调用<br>
例子：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">END</span>&#123;</span><br><span class="line">    puts <span class="string">"this is END code"</span></span><br><span class="line">&#125;</span><br><span class="line">puts <span class="string">"this is main code"</span></span><br><span class="line"><span class="keyword">BEGIN</span>&#123;</span><br><span class="line">    puts <span class="string">"this is begin code"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">this is <span class="keyword">begin</span> code</span><br><span class="line">this is main code </span><br><span class="line">this is <span class="keyword">end</span> code</span><br></pre></td></tr></table></figure>
<h3 id="Ruby-中的数组">Ruby 中的数组</h3>
<p>数组字面量通过[]中以逗号分隔定义，且支持range定义。<br></p>
<p>（1）数组通过[]索引访问<br><br>
（2）通过赋值操作插入、删除、替换元素<br><br>
（3）通过+，－号进行合并和删除元素，且集合做为新集合出现<br><br>
（4）通过&lt;&lt;号向原数据追加元素<br><br>
（5）通过*号重复数组元素<br><br>
（6）通过｜和&amp;符号做并集和交集操作（注意顺序）<br><br>
下面例子完成了数组的顺序输出：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">"a"</span>,<span class="string">"bbb"</span>,<span class="string">"123"</span>,<span class="string">"null"</span>,]</span><br><span class="line">arr.each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    puts i</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Ruby的哈希类型">Ruby的哈希类型</h3>
<p>Ruby 哈希是在大括号内放置一系列键/值对，键和值之间使用逗号和序列 =&gt; 分隔。尾部的逗号会被忽略。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">hsh = colors = &#123;<span class="string">"red"</span> =&gt; <span class="number">0xf00</span>, <span class="string">"green"</span> =&gt; <span class="number">0x0f0</span>, <span class="string">"blue"</span> =&gt; <span class="number">0x00f</span>&#125;</span><br><span class="line">hsh.each <span class="keyword">do</span> <span class="params">|key,value|</span></span><br><span class="line">    pring key,<span class="string">"is"</span>,value,<span class="string">"\n"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="Ruby-范围类型">Ruby 范围类型</h3>
<p>一个范围表示一个区间。<br><br>
范围是通过设置一个开始值和一个结束值来表示。范围可使用 s…e 和 s…e 来构造，或者通过 Range.new 来构造。<br>
使用 … 构造的范围从开始值运行到结束值（包含结束值）。使用 … 构造的范围从开始值运行到结束值（不包含结束值）。当作为一个迭代器使用时，范围会返回序列中的每个值。<br><br>
范围 (1…5) 意味着它包含值 1, 2, 3, 4, 5<br><br>
范围 (1…5) 意味着它包含值 1, 2, 3, 4</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>..<span class="number">15</span>).each <span class="keyword">do</span><span class="params">|i|</span></span><br><span class="line">    print i,<span class="string">' '</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ruby</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactive Native (1)</title>
    <url>/2019/06/10/rn1/</url>
    <content><![CDATA[<h3 id="开个贴记录一下RN的学习记录，希望最后能够自己做出比较满意的app吧。">开个贴记录一下RN的学习记录，希望最后能够自己做出比较满意的app吧。</h3>
<h2 id="hello-world">hello world</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Text, View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;View style=&#123;&#123; <span class="attr">flex</span>: <span class="number">1</span>, <span class="attr">justifyContent</span>: <span class="string">"center"</span>, <span class="attr">alignItems</span>: <span class="string">"center"</span> &#125;&#125;&gt;</span><br><span class="line">          &lt;Text&gt;Hello, world!&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React Native 内置了对 ES2015 标准的支持.下面一行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;View&gt;<span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p>叫做 JSX —— 是一种在 JavaScript 中嵌入 XML 结构的语法<br><br>
代码中，使用的是内置的<text>组件，它专门用来显示文本，而<view>就类似 html 中的div或是span这样的容器。</view></text></p>
<a id="more"></a>
<h2 id="Props-属性">Props(属性)</h2>
<p>react native中大多组件可以用参数来修改。可以修改的这些参数就称为props。<br><br>
以插入图片为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Components&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Image&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Bananas</span> <span class="keyword">extends</span> <span class="title">Components</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">let</span> pic = &#123;</span><br><span class="line">            url:<span class="string">'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            &lt;Image source=&#123;pic&#125; style=&#123;&#123;<span class="attr">width</span>:<span class="number">193</span>,<span class="attr">height</span>:<span class="number">150</span>&#125;&#125; /&gt;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个图片时，可以传入一个名为source的 prop 来指定要显示的图片的地址，以及使用名为style的 prop 来控制其尺寸。<br><br>
{pic}外围有一层括号，需要用括号来把pic这个变量嵌入到 JSX 语句中。括号的意思是括号内部为一个 js 变量或表达式，需要执行后取值。因此可以把任意合法的 JavaScript 表达式通过括号嵌入到 JSX 语句中。</p>
<p>自定义的组件也可以使用props。通过在不同的场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。只需在render函数中引用this.props，然后按需处理即可。下面是一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Text, View &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">alignItems</span>: <span class="string">'center'</span>, <span class="attr">marginTop</span>: <span class="number">50</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Text&gt;Hello &#123;<span class="keyword">this</span>.props.name&#125;!&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LotsOfGreetings</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;&#123;<span class="attr">alignItems</span>: <span class="string">'center'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;Greeting name=<span class="string">'Rexxar'</span> /&gt;</span><br><span class="line">        &lt;Greeting name=<span class="string">'Jaina'</span> /&gt;</span><br><span class="line">        &lt;Greeting name=<span class="string">'Valeera'</span> /&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在Greeting组件中将name作为一个属性来定制，这样可以复用这一组件来制作各种不同的“问候语.</p>
<h2 id="State">State</h2>
<p>我们使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用state。</p>
<p>一般来说，你需要在 constructor 中初始化state（译注：这是 ES6 的写法，早期的很多 ES5 的例子使用的是 getInitialState 方法来初始化 state，这一做法会逐渐被淘汰），然后在需要修改时调用setState方法。<br><br>
注意绩几点：<br><br>
1.一切界面变化都是状态state变化<br><br>
2.state的修改必须通过setState()方法<br><br>
3.this.state.likes = 100， 这样的直接赋值修改无效！<br><br>
4.setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性<br><br>
5.setState 是异步操作，修改不会马上生效<br></p>
]]></content>
      <categories>
        <category>web/app开发，框架</category>
      </categories>
      <tags>
        <tag>React-Native</tag>
        <tag>app</tag>
        <tag>webapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 106 / Review 01</title>
    <url>/2020/07/10/review1/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-398-Random-Pick-Index-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">398. Random Pick Index</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/random-pick-index/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>
<p>Note:<br>
The array size can be very large. Solution that uses too much extra space will not pass the judge.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">int[] nums = new int[] &#123;1,2,3,3,3&#125;;</span><br><span class="line">Solution solution = new Solution(nums);</span><br><span class="line"></span><br><span class="line">// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(3);</span><br><span class="line"></span><br><span class="line">// pick(1) should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(1);</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random rand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.rand = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// current num is the target</span></span><br><span class="line">                total++; <span class="comment">// caculate the total</span></span><br><span class="line">                <span class="keyword">if</span>(rand.nextInt(total) == <span class="number">0</span>)&#123;</span><br><span class="line">                res = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Consider the example like</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1,2,3,3,3&#125; with target 3</span><br></pre></td></tr></table></figure>
<p>We want to select 2,3,4 with a probability of <code>1/3</code> each.</p>
<p>2 : It’s probability of selection is 1 * (1/2) * (2/3) = 1/3<br>
3 : It’s probability of selection is (1/2) * (2/3) = 1/3<br>
4 : It’s probability of selection is just 1/3</p>
<p>So they are each randomly selected.</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-394-Decode-String-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">394. Decode String</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/decode-string/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v2">Examples</h3>
<p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = &quot;3[a2[c]]&quot;</span><br><span class="line">Output: &quot;accaccacc&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>; <span class="comment">//corner case</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        Stack&lt;StringBuilder&gt; sbstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; intstack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> tempcount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(c))&#123;</span><br><span class="line">                tempcount = tempcount*<span class="number">10</span> + c -<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>)&#123; <span class="comment">// start</span></span><br><span class="line">                intstack.push(tempcount);</span><br><span class="line">                sbstack.push(sb);</span><br><span class="line">                tempcount = <span class="number">0</span>; <span class="comment">// reset count</span></span><br><span class="line">                sb = <span class="keyword">new</span> StringBuilder(); <span class="comment">//reset stringbuilder</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                StringBuilder swap = sb;</span><br><span class="line">                sb = sbstack.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=intstack.pop(); i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">                    sb.append(swap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Keep two stack of both index and stringbuilder. When we meet <code>[</code> then we add previous stringbuilder and count to the stack, and reset both stringbuider and count. When we meet <code>]</code> we have to add current stringbuilder to the previous stringbuilder in the stack.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-385-Mini-Parser-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">385. Mini Parser</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/mini-parser/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v3">Examples</h3>
<p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Note: You may assume that the string is well-formed:</p>
<p>String is non-empty.<br>
String does not contain white spaces.<br>
String contains only digits 0-9, [, - , ].</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given s = &quot;324&quot;,</span><br><span class="line"></span><br><span class="line">You should return a NestedInteger object which contains a single integer 324.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given s = &quot;[123,[456,[789]]]&quot;,</span><br><span class="line"></span><br><span class="line">Return a NestedInteger object containing a nested list with 2 elements:</span><br><span class="line"></span><br><span class="line">1. An integer containing value 123.</span><br><span class="line">2. A nested list containing two elements:</span><br><span class="line">    i.  An integer containing value 456.</span><br><span class="line">    ii. A nested list with one element:</span><br><span class="line">         a. An integer containing value 789.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> NestedInteger <span class="title">deserialize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.startsWith(<span class="string">"["</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NestedInteger(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;NestedInteger&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        NestedInteger res = <span class="keyword">new</span> NestedInteger();</span><br><span class="line">        stack.push(res);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'['</span>)&#123;</span><br><span class="line">                NestedInteger cur = <span class="keyword">new</span> NestedInteger();</span><br><span class="line">                stack.peek().add(cur);</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                start =i+ <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span> || c ==<span class="string">','</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; start)&#123;</span><br><span class="line">                    Integer val = Integer.valueOf(s.substring(start,i));</span><br><span class="line">                    stack.peek().add(<span class="keyword">new</span> NestedInteger(val));</span><br><span class="line">                &#125;</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( c == <span class="string">']'</span>)&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When we meet <code>[</code> it means we have to add new nestedinteger into the peek one in stack.And then add current into the stack to prepare for the upcoming nestedinteger list. When we meet <code>]</code> it means we get the end of current nestedinteger. So we just pop up the current peek of stack.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-384-Shuffle-an-Array-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">384. Shuffle an Array</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/shuffle-an-array/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v4">Examples</h3>
<p>Shuffle a set of numbers without duplicates.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">// Init an array with set 1, 2, and 3.</span><br><span class="line">int[] nums = &#123;1,2,3&#125;;</span><br><span class="line">Solution solution = new Solution(nums);</span><br><span class="line"></span><br><span class="line">// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line">// Resets the array back to its original configuration [1,2,3].</span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line">// Returns the random shuffling of array [1,2,3].</span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    Random rand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        rand = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] clone = nums.clone();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = rand.nextInt(i+<span class="number">1</span>);</span><br><span class="line">            swap(clone, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] clone, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = clone[i];</span><br><span class="line">        clone[i] = clone[j];</span><br><span class="line">        clone[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s a bit like question 398, both need to use Random to generate a random index in order to make sure the posibility is equal to each num. In this question, when loop each num in the array, we have to get a random index.</p>
<p>Proof: Suppose this algorithm works, i.e. for each position j (starting from 0), the probability of any number in the range[0,j] to be at position j is 1/(1+j).</p>
<p><code>int i = random.nextInt(j + 1):</code></p>
<p>(1) If i == j, <code>nums[j]</code> does not need to change its position, which has probability 1/(1+j).</p>
<p>(2) if i !=j, <code>nums[j]</code> needs to be swapped with nums[i]. The probability of any number x in the range <code>[0,j-1]</code> to be at position <code>j = nums[j]</code> changes its position * x is at position i<br>
= <code>(1-1/(1+j)) * (1/j) = 1/(1+j)</code></p>
<p>Each number has equal probability to be at any position.</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Second-Round</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 94 / String(2) ðŸ’ª</title>
    <url>/2020/06/02/string02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-609-Find-Duplicate-File-in-System-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">609. Find Duplicate File in System</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/find-duplicate-file-in-system/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>
<h3 id="Example">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]</span><br><span class="line">Output:</span><br><span class="line">[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : paths)&#123;</span><br><span class="line">            String[] strs = str.split(<span class="string">"\\s++"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;strs.length ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = strs[i].indexOf(<span class="string">'('</span>);</span><br><span class="line">                String msg = strs[i].substring(idx);</span><br><span class="line">                String totalName = strs[<span class="number">0</span>] + <span class="string">"/"</span> + strs[i].substring(<span class="number">0</span>,idx);</span><br><span class="line">                Set&lt;String&gt; names = map.getOrDefault(msg,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                names.add(totalName);</span><br><span class="line">                map.put(msg,names);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key).size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(map.get(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<p>First we split the string with &quot; &quot; to seprate the string with two parts : paths + file.<br>
Then we go to the file part, and find the message in it using “(”, we split the file with two part: file name + file message.<br>
Using map and set to store the file like &quot; message -&gt; Set <paths of file> &quot;. Then we add the path in the set to final res list.</paths></p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-767-Reorganize-String-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">767. Reorganize String</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/reorganize-string/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<p>Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p>
<p>If possible, output any possible result.  If not possible, return the empty string.</p>
<h3 id="Example-v2">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: S = &quot;aab&quot;</span><br><span class="line">Output: &quot;aba&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: S = &quot;aaab&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S.length() ;i++)&#123;</span><br><span class="line">            arr[S.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, letter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                letter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max &gt; (S.length() + <span class="number">1</span>)/<span class="number">2</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(arr[letter] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res[index] = (<span class="keyword">char</span>)(letter +<span class="string">'a'</span>);</span><br><span class="line">            index+=<span class="number">2</span>;</span><br><span class="line">            arr[letter]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(index &gt;= S.length())&#123;</span><br><span class="line">                    index = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[index] = (<span class="keyword">char</span>)(i + <span class="string">'a'</span>);</span><br><span class="line">                index+=<span class="number">2</span>;</span><br><span class="line">                arr[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(1)</p>
<p>Easy thoughts: We first find the char with max currency and put it on the even positin first like 0,2,4,6… Then we keep to put all other chars in the remained position.</p>
<p>If we get the end of the size of string, we turn back to the position of 1 and keep put char in it.<br>
It easy to understand with the following explain.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a _ a _ a _ _ _ _ // fill in &quot;a&quot; at position 0, 2, 4</span><br><span class="line">a b a _ a _ b _ b // fill in &quot;b&quot; at position 6, 8, 1</span><br><span class="line">a b a c a _ b _ b // fill in &quot;c&quot; at position 3</span><br><span class="line">a b a c a d b d b // fill in &quot;d&quot; at position 5, 7</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-32-Longest-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">32. Longest Valid Parentheses</font></td></tr></table></h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<h3 id="Example-v3">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)open++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(open &gt;<span class="number">0</span> &amp;&amp; s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-dp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i-dp[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                open--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(dp[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DP problem. When we meet ‘)’ and open &gt;0 then we start dp operation.</p>
<p>Tricky point is the line in the bellow:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(i-dp[i] &gt; 0)&#123;</span><br><span class="line">    dp[i]+=dp[i-dp[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We are looking for the longest continuous parentheses, so we have to check the dp value before the current valid length.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">()()() // case 1</span><br><span class="line">((())) // case 2</span><br></pre></td></tr></table></figure>
<p>In case 1, only we meet ) then we can make current dp to 2, but after that we will back to the value of 0. So we have to check whether there is valid length before the current length.</p>
<p>In case 2 it is normal way what we think in the first time.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-43-Multiply-Strings-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">43. Multiply Strings</font> </td></tr></table></h2>
<p><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p>
<p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p>
<h3 id="Example-v4">Example</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length();</span><br><span class="line">        <span class="keyword">int</span> n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i)-<span class="string">'0'</span>) * (num2.charAt(j)-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">int</span> pos1 = i+j,pos2 = i+j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = arr[pos2] + mul;</span><br><span class="line">                arr[pos1] += sum / <span class="number">10</span>;</span><br><span class="line">                arr[pos2] = sum % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; num == <span class="number">0</span>))&#123;</span><br><span class="line">                sb.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n^2) S:O(1)</p>
<p>We simulate the multiply process. Using pos1 and pos2 to store the carry.<br>
For example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1 2 5</span><br><span class="line">    * 3 2</span><br><span class="line">    ------</span><br><span class="line">      1 0 ( 5*2 ) step 1</span><br><span class="line">    0 4   ( 2*2 ) step 2</span><br><span class="line">  0 2     ( 1*2 ) .... 3</span><br><span class="line">    1 5   ( 3*5 ) .... 4</span><br><span class="line">  0 6   ...</span><br><span class="line">0 3   ...</span><br><span class="line">--------------</span><br><span class="line">  4 0 0 0</span><br></pre></td></tr></table></figure>
<p>Like above, cause every time we caculate the two number to get mul, then we have to use the last time’s pos1 value, which is the same as current pos2’s vlaue. Then after caculate that we add them together to get the final value string.</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 97 / Tree(1) 💪</title>
    <url>/2020/06/07/tree01/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-199-Binary-Tree-Right-Side-View-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">199. Binary Tree Right Side View</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/next-permutation/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<ol>
<li>DFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        dfs(root,res,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == res.size())&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,res,depth+<span class="number">1</span>);</span><br><span class="line">        dfs(root.left,res,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res.</p>
<p>T:O(n) S:O(n)</p>
<ol start="2">
<li>BFS</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>( i == size-<span class="number">1</span>)res.add(temp.val); <span class="comment">// only add the last node in every level into res</span></span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node.</p>
<p>T:O(n) S:O(n)</p>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)res.append(<span class="string">"null"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(root.left,res);</span><br><span class="line">            serial(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String source)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = source.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> des(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">des</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.equals(<span class="string">"null"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        node.left = des(queue);</span><br><span class="line">        node.right = des(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In serialize function, we use recursive preorder way to save the tree node’s value into a String. In deserialize function, we use the previous string as source data. Then we recursively to build a new tree using pre-order too.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-124-Binary-Tree-Maximum-Path-Sum-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">124. Binary Tree Maximum Path Sum</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Examples-v2">Examples</h3>
<p>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<h3 id="Solutoin">Solutoin</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,help(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,help(root.right));</span><br><span class="line">        max = Math.max(max,left+right+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using revursive to find the max in right / left branch. Max is updated when current node is seen as the root node, so we sum the value of left+right+node.val . But in return line, we can only choose one branch in left/right branch.</p>
<p>T:O(n) S:O(1)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-236-Lowest-Common-Ancestor-of-a-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">236. Lowest Common Ancestor of a Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]<br>
<img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="leetcode 236"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="keyword">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are three cases:</p>
<ol>
<li>when left and right both have return value, it means that two nodes are displayed in both left and right branch. The current root is their LCA, so we return root.</li>
<li>when left has null, it means two nodes are both in right branch. So we just return right value. Right keep record the first target node we meet.</li>
<li>when right has null, it means two nodes are both in left branch. So we just return left value. Left keep record the first target node we meet.</li>
</ol>
<p>T:O(n) S:O(1)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-98-Validate-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">98. Validate Binary Search Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>
The right subtree of a node contains only nodes with keys greater than the node’s key.<br>
Both the left and right subtrees must also be binary search trees.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&apos;s value is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root,Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using defination of BST:left &lt; root &lt; right. Then we can set up two max / min boundary to check each layer.</p>
<p>Tricky: The test case contains large number which can only be included by Long type number.</p>
<p>T:O(n) S:O(1)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-987-Vertical-Order-Traversal-of-a-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">987. Vertical Order Traversal of a Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v4">Example</h3>
<p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.<br>
<img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v5">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            node = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;Integer,List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(<span class="number">0</span>,<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.poll();</span><br><span class="line">            min = Math.min(min,temp.x);</span><br><span class="line">            max = Math.max(max,temp.x);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(<span class="keyword">new</span> pair(temp.x,temp.y,temp.node));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x-<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.left));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x+<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= min ;i&lt;= max; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y);</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;map.get(i).size() ;j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using HashMap to store each x position’s nodes. And then sort each nodes wiht it’s y’s positon value. If two nodes have same y position, then sort them with node’s value.</p>
<p>T:O(n^2logn) S:O(n)</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Using python-turtle to create images</title>
    <url>/2019/02/21/tree1/</url>
    <content><![CDATA[<p><img src="/21/tree1/tree2.jpg" alt></p>
<h2 id="Turtle">Turtle</h2>
<p>Urzig has created a language for children to learn to program – LOGO language, which features a programming command for a turtle to draw on a screen.<br>
Turtle Graphics were later ported to various high-level languages, and the Python library was built in, essentially 100% duplicating all the functionality of the original Turtle Graphics.</p>
<a id="more"></a>
<p>The first one is the one with the falling leaves effect, which I’ll talk about later.</p>
<p>Let’s start with a simple tree. The code is as follows:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree</span><span class="params">(n, l)</span>:</span></span><br><span class="line">    pd() <span class="comment"># put the pen down</span></span><br><span class="line">    <span class="comment"># shadow effect</span></span><br><span class="line">    t = cos(radians(heading() + <span class="number">45</span>)) / <span class="number">8</span> + <span class="number">0.25</span></span><br><span class="line">    pencolor(t, t, t)</span><br><span class="line">    pensize(n / <span class="number">3</span>)</span><br><span class="line">    forward(l) <span class="comment"># draw the twigs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span>: </span><br><span class="line">    b = random() * <span class="number">15</span> + <span class="number">10</span> <span class="comment"># Right branch deflection Angle</span></span><br><span class="line">    c = random() * <span class="number">15</span> + <span class="number">10</span> <span class="comment"># Left branch deflection Angle</span></span><br><span class="line">    d = l * (random() * <span class="number">0.25</span> + <span class="number">0.7</span>) <span class="comment"># The length of the next branch</span></span><br><span class="line">    <span class="comment"># Turn right at an Angle and draw the right branch</span></span><br><span class="line">    right(b)</span><br><span class="line">    tree(n - <span class="number">1</span>, d)</span><br><span class="line">    <span class="comment"># Turn left at an Angle and draw the left branch</span></span><br><span class="line">    left(b + c)</span><br><span class="line">    tree(n - <span class="number">1</span>, d)</span><br><span class="line">    <span class="comment"># turn back</span></span><br><span class="line">    right(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># draw the leaves</span></span><br><span class="line">    right(<span class="number">90</span>)</span><br><span class="line">    n = cos(radians(heading() - <span class="number">45</span>)) / <span class="number">4</span> + <span class="number">0.5</span></span><br><span class="line">    pencolor(n, n, n)</span><br><span class="line">    circle(<span class="number">3</span>)</span><br><span class="line">    left(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    pu() <span class="comment"># pen up</span></span><br><span class="line">    backward(l) <span class="comment"># backward</span></span><br><span class="line"></span><br><span class="line">bgcolor(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>) <span class="comment"># background</span></span><br><span class="line">ht() <span class="comment"># hide turtle</span></span><br><span class="line">speed(<span class="number">0</span>) <span class="comment"># speed，slow down from 1-10，0 is the fastest</span></span><br><span class="line">tracer(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">left(<span class="number">90</span>) <span class="comment"># turn left for 90 angles</span></span><br><span class="line">pu() <span class="comment"># pen up</span></span><br><span class="line">backward(<span class="number">300</span>) <span class="comment"># backward 300</span></span><br><span class="line">tree(<span class="number">13</span>, <span class="number">100</span>) <span class="comment"># recursive 7 layers</span></span><br><span class="line">done()</span><br></pre></td></tr></table></figure>
<p>Run the code with PythonIDLE：</p>
<p><img src="/21/tree1/tree.jpg" alt></p>
<h3 id="Add-fallen-leaves">Add fallen leaves</h3>
<p>Replace all the codes after drawing the leaves with:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(random()&gt;<span class="number">0.7</span>):</span><br><span class="line">    pu()<span class="comment">#falling</span></span><br><span class="line">    t = heading()</span><br><span class="line">    an = <span class="number">-40</span> +random()*<span class="number">40</span></span><br><span class="line">    setheading(an)</span><br><span class="line">    dis = int(<span class="number">800</span>*random()*<span class="number">0.5</span> + <span class="number">400</span>*random()*<span class="number">0.3</span> + <span class="number">200</span>*random()*<span class="number">0.2</span>) <span class="comment"># set the falling equation</span></span><br><span class="line">    forward(dis)</span><br><span class="line">    setheading(t)</span><br><span class="line">    <span class="comment"># draw leaves</span></span><br><span class="line">    pd() <span class="comment">#pen up</span></span><br><span class="line">    right(<span class="number">90</span>)</span><br><span class="line">    n = cos(radians(heading()<span class="number">-45</span>))/<span class="number">4</span>+<span class="number">0.5</span></span><br><span class="line">    pencolor(n*<span class="number">0.5</span>+<span class="number">0.5</span>,<span class="number">0.4</span>+n*<span class="number">0.4</span>,<span class="number">0.4</span>+n*<span class="number">0.4</span>)</span><br><span class="line">    circle(<span class="number">2</span>)</span><br><span class="line">    left(<span class="number">90</span>)</span><br><span class="line">    pu()</span><br><span class="line">    <span class="comment">#back</span></span><br><span class="line">    t=heading()</span><br><span class="line">    setheading(an)</span><br><span class="line">    backward(dis)</span><br><span class="line">    setheading(t)</span><br><span class="line">    pu()</span><br><span class="line">    backward(l) <span class="comment">#backward</span></span><br><span class="line"></span><br><span class="line">bgcolor(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) <span class="comment">#background</span></span><br><span class="line">ht() <span class="comment">#hide turtle</span></span><br><span class="line">speed(<span class="number">0</span>) <span class="comment">#speed</span></span><br><span class="line">tracer(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">pu() </span><br><span class="line">backward(<span class="number">100</span>)</span><br><span class="line">left(<span class="number">90</span>) </span><br><span class="line">pu() </span><br><span class="line">backward(<span class="number">300</span>) </span><br><span class="line">tree(<span class="number">12</span>,<span class="number">100</span>) </span><br><span class="line">done()</span><br></pre></td></tr></table></figure>
<p>The effect after running:<br>
<img src="/21/tree1/tree2.jpg" alt><br>
At this point, a basic tree is drawn, and the tutrl library still has a lot for me to learn.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Image Process</tag>
        <tag>Turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 105 / String(3) 💪</title>
    <url>/2020/07/04/string03/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1268-Search-Suggestions-Systeme-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1268. Search Suggestions Systeme</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/search-suggestions-system/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array of strings <code>products</code> and a string <code>searchWord</code>. We want to design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested <code>products</code> should have common prefix with the <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimums <code>products</code>.</p>
<p>Return list of lists of the suggested <code>products</code> after each character of <code>searchWord</code> is typed.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;</span><br><span class="line">Output: [</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class="line">]</span><br><span class="line">Explanation: products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class="line">After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]</span><br><span class="line">After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<h4 id="1-Trie">1. Trie</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">        Trie[] children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">        Arrays.sort(products);</span><br><span class="line">        Trie root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String p : products)&#123;</span><br><span class="line">            insert(p,root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> search(searchWord,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String p, Trie root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : p.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.children[c-<span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            root = root.children[c-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(root.list.size()&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                root.list.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; search(String str, Trie root)&#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = root.children[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root == <span class="keyword">null</span> ? Arrays.asList() : root.list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It’s clearly that it’s trie problem at first. So we can define a new class called Trie and initialize a new Trie structure. First we sort the products list. Then we insert 3 produsts to each character node. Then we search from the start of  <code>searchWord</code> . If no trie exist then we just add a blank array to res.</p>
<img src="https://i.ibb.co/PZYKX4d/Capture.jpg">
<p>T: O(m * n + L)</p>
<p>Sorting cost time O(m * n), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n).</p>
<p>S: O(m * n + L * m)</p>
<p>Including return list ans, where m = average length of products, n = products.length, L = searchWord.length().</p>
<h4 id="2-Binary-Search">2. Binary Search</h4>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(products);</span><br><span class="line">        List&lt;String&gt; productsList = Arrays.asList(products);</span><br><span class="line">        TreeMap&lt;String,Integer&gt; treemap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// adding products into treemap</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;products.length; i++)&#123;</span><br><span class="line">            treemap.put(products[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// start binary search</span></span><br><span class="line">        String key = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : searchWord.toCharArray())&#123;</span><br><span class="line">            key+=c;</span><br><span class="line">            String lowerbound = treemap.ceilingKey(key);</span><br><span class="line">            String upperbound = treemap.floorKey(key+<span class="string">"~"</span>);</span><br><span class="line">            <span class="keyword">if</span>(lowerbound == <span class="keyword">null</span> || upperbound == <span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">            res.add(productsList.subList( treemap.get(lowerbound), Math.min(treemap.get(lowerbound)+<span class="number">3</span>, treemap.get(upperbound)+<span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.size() &lt; searchWord.length())&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, if A[i] is a prefix of A[j],<br>
A[i] must be the prefix of A[i + 1], A[i + 2], …, A[j].</p>
<p>We can utilize the advantage of TreeMap like auto-sorting and cellingKey / floorKey functions. After the strings are sorted in treemap, then we can using ceilingKey to find the max one that is less than current string and floorKey to find the min one that is larget than current string.</p>
<p>Then we can add the strings that between the upperbound and lowerbound to the res.</p>
<p>T:O(NlogN) for sorting</p>
<p>S:O(logN) for quick sort.</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-539-Minimum-Time-Difference-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">539. Minimum Time Difference</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/minimum-time-difference/"><font size="4">🔗Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line">The number of time points in the given list is at least 2 and won&apos;t exceed 20000.</span><br><span class="line">The input time is legal and ranges from 00:00 to 23:59.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timePoints == <span class="keyword">null</span> || timePoints.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">24</span>*<span class="number">60</span>];</span><br><span class="line">        <span class="keyword">for</span>(String str: timePoints)&#123;</span><br><span class="line">            String[] temp = str.split(<span class="string">":"</span>);</span><br><span class="line">            <span class="keyword">int</span> hour = Integer.valueOf(temp[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> minute = Integer.valueOf(temp[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(bucket[hour*<span class="number">60</span>+minute] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min,hour*<span class="number">60</span>+minute);</span><br><span class="line">            max = Math.max(max,hour*<span class="number">60</span>+minute);</span><br><span class="line">            bucket[hour*<span class="number">60</span>+minute] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_diff = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=min; i&lt;=max; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>( i == min)&#123;</span><br><span class="line">                    min_diff = Math.min(min_diff, Math.min(max-min, <span class="number">1440</span>-max+min));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    min_diff = Math.min(min_diff,i-prev);</span><br><span class="line">                &#125;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The idea is simple. There is 24*60=1440 minutes per day, so we can create an array with size of 1440 to store the each timepoint to check whether they have appeared before. If so then we just return 0 beause the difference is 0 between two same time points. Otherwise we need to find the min and max points in the given list. And using prev to store the previous timepoints.</p>
<p>The graph of the timeline is like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 - - - min - - - max - - -1440 -</span><br><span class="line">⬆️ - - - - - - - - - - - - - - - ⬇️ // actually 1440 and 0 are the same point</span><br></pre></td></tr></table></figure>
<p>And there is two situations:</p>
<ul>
<li>Current timepoint is min:</li>
</ul>
<p>So we only have two part to compare:<br>
<code>max - min</code>, <code>1440-(max-min)</code>, which is the parts that the timepoints of <code>0 -&gt; min</code> and <code>max -&gt;1440</code></p>
<ul>
<li>Current timepoint is not min :</li>
</ul>
<p>Just using <code>curr-prev</code> to get the temp time difference and compare it with <code>min_diff</code>.</p>
<p>T:O(N) S:O(1)</p>
<hr>
<h2 id="table-tr-td-bgcolor-28B463-font-color-white-443-String-Compression-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">443. String Compression</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/string-compression/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>Given an array of characters, compress it in-place.</p>
<p>The length after compression must always be smaller than or equal to the original array.</p>
<p>Every element of the array should be a character (not int) of length 1.</p>
<p>After you are done modifying the input array in-place, return the new length of the array.</p>
<p>Follow up:</p>
<p>Could you solve it using only O(1) extra space?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<p>At first we can easily come up with the <code>HashMap</code> solution. But it doesn’t meet the O(1) space requirement.</p>
<p>So here is the standard solution.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars == <span class="keyword">null</span> || chars.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">char</span> currchar = chars[index];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; chars.length &amp;&amp; currchar == chars[index] )&#123;</span><br><span class="line">                index++;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            chars[resindex] = currchar;</span><br><span class="line">            resindex++;</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : Integer.toString(count).toCharArray())&#123;</span><br><span class="line">                    chars[resindex] = c;</span><br><span class="line">                    resindex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resindex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kind of brute force. Keep track of current index and the final index. Then add the count of each char to array after itself. Finally return the final <code>resindex</code> which is the length of new array.</p>
<p>T:O(N) S:O(1)</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode EveryDay 100 / Tree(2) 💪</title>
    <url>/2020/06/11/tree02/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-96-Unique-Binary-Search-Trees-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">96. Unique Binary Search Trees</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/unique-binary-search-trees/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<p>DP + Math</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt;=i ; j ++)&#123;</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<p>Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST.</p>
<p>Take 1,2,3 for example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    G(3)</span><br><span class="line">            /         |             \</span><br><span class="line">     F(1,3)    +    F(2,3)   +    F(3,3)</span><br><span class="line">  (1 as root)     (2 as root)    (3 as root)</span><br><span class="line">     /  \            /  \           /  \</span><br><span class="line">  G(0)  G(1)      G(1) G(1)     G(2)  G(1)</span><br><span class="line">According to defination of BST, so different root have different subtrees.</span><br></pre></td></tr></table></figure>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GgP75HAvrlY?start=438" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">105. Construct Binary Tree from Preorder and Inorder Traversal</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>
You may assume that duplicates do not exist in the tree.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, given</span><br><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>|| inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[]inorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is &gt; ie || ps &gt; pe)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> inidx = map.get(preorder[ps]); <span class="comment">// 在inorder里得到node的位置</span></span><br><span class="line">        <span class="keyword">int</span> remains = inidx - is; <span class="comment">// 得到左半部分的剩余</span></span><br><span class="line">        node.left = build(inorder,is,inidx-<span class="number">1</span>,preorder,ps+<span class="number">1</span>,ps+remains,map);</span><br><span class="line">        node.right = build(inorder,inidx+<span class="number">1</span>,ie,preorder,ps+remains+<span class="number">1</span>,pe,map);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Recursively building a tree from preorder and inorder array. Root is the first element in preorder, and use that element to find the index in inorder to caculate the left and right part’s length. Using map to store the index and element in the map.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-863-All-Nodes-Distance-K-in-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">863. All Nodes Distance K in Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>We are given a binary tree (with root node root), a target node, and an integer value K.</p>
<p>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="leetcode 863">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line"></span><br><span class="line">Output: [7,4,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)res.add(root.val);</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.right,dist+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using map to store different node’s distance to the target node.(Only sublayer node). Then using dfs to scan each node to caculate the distance. If it is not in the map, it means that node is uplayer of the target, so we using default 0 from root to scan, each step we add 1. If we meet a node that stored in the map, the we use the distance stored in the map to justify the distance.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-366-Find-Leaves-of-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">366. Find Leaves of Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/find-leaves-of-binary-tree/"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example-v4">Example</h3>
<p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line"></span><br><span class="line">Output: [[4,5,3],[2],[1]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1. Removing the leaves [4,5,3] would result in this tree:</span><br><span class="line">          1</span><br><span class="line">         / </span><br><span class="line">        2          </span><br><span class="line">2. Now removing the leaf [2] would result in this tree:</span><br><span class="line">          1          </span><br><span class="line">3. Now removing the leaf [1] would result in the empty tree:</span><br><span class="line">          []</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<p>Recursive</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,res);</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,res);</span><br><span class="line">        <span class="keyword">int</span> level = Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level+<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using every node’s level to determine whether current node is leaf or not. Leaf node’s level return -1+1=0. Then we add the nodes to res by the order of it’s level. -&gt; 0: 4,5,3  -&gt; 1:2 -&gt; 2:1</p>
<p>T:O(n) S:O(n)</p>
<hr>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>F-1 VISA Approved！</title>
    <url>/2019/06/04/%C7%A9%D6%A4/</url>
    <content><![CDATA[<p>今天去北京安家楼面签，人超多，没想到vo只要了我的cv和study plan 就给approved了，比较幸运。<br>
接下来继续努力吧~<br>
好几天没刷题了，事情比较多，加油加油。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>F-1 VISA</tag>
      </tags>
  </entry>
  <entry>
    <title>📖 Vue学习笔记(2)</title>
    <url>/2020/04/05/vue2/</url>
    <content><![CDATA[<h1>vue指令–事件修饰符</h1>
<h2 id="stop阻止冒泡">.stop阻止冒泡</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span> = <span class="string">"divclicker"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">value</span>=<span class="string">'clickme'</span> @<span class="attr">click.stop</span> =<span class="string">"btnclicker"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                divclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'div clicked'</span>)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                btnclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'btn clicked'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">btn clicked</span><br></pre></td></tr></table></figure>
<p>stop让冒泡停在了btn这个地方，不会继续向上延伸到div父类。<br><br>
如果没有stop阻止冒泡的话，正常冒泡行为输出应该为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">btn clicked</span><br><span class="line">div clicked</span><br></pre></td></tr></table></figure>
<ul>
<li>xxx.stop: 自身修饰符,可以阻止冒泡行为。</li>
</ul>
<a id="more"></a>
<h2 id="prevent-阻止默认事件">.prevent 阻止默认事件</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://google.com"</span> @<span class="attr">click.prevent</span>=<span class="string">"linkclicked"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                linkclicked()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'link clicked'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码最终将会console出‘link clicked’的结果但是并不会跳转，因为prevent阻止了跳转的默认行为。<br></p>
<ul>
<li>.prevent: 可以阻止默认的js行为。</li>
</ul>
<h2 id="capture-捕获行为">.capture 捕获行为</h2>
<p>利用之前.stop中的代码来看：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.capture</span> = <span class="string">"divclicker"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">value</span>=<span class="string">'clickme'</span> @<span class="attr">click</span> =<span class="string">"btnclicker"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                divclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'div clicked'</span>)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                btnclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'btn clicked'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时控制台输出的顺序则将会是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div clicked</span><br><span class="line">btn clicked</span><br></pre></td></tr></table></figure>
<p>capture改变了web的默认冒泡行为，变成了捕获行为。<br></p>
<ul>
<li>冒泡：渲染之后，当用户产生交互时，先从父节点向下寻找触发行为的component，然后由下至上冒泡地依次触发sub父类。</li>
<li>捕获：与冒泡相反，直接由上到下触发。</li>
</ul>
<h2 id="self-自身触发">.self 自身触发</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span> = <span class="string">"divclicker"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">value</span>=<span class="string">'clickme'</span> @<span class="attr">click</span> =<span class="string">"btnclicker"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                divclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'div clicked'</span>)</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                btnclicker()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'btn clicked'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时只点击button时控制台只会输出：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">btn clicked</span><br></pre></td></tr></table></figure>
<p>并没有div的消息出现，这是因为self定义了只有点击该元素本身的时候才会触发行为。所以当点击div范围内的空白处时会输出‘div clicked’.</p>
<h2 id="once-只执行一次">.once 只执行一次</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://google.com"</span> @<span class="attr">click.prevent.self</span> =<span class="string">"linkclicked"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el:<span class="string">'#app'</span>,</span></span><br><span class="line">            data:&#123;&#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                linkclicked()&#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">'link clicked'</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码只会阻止该a标签跳转一次，点击第二次则会正常跳转，因为self限制了prevent只起作用一次。</p>
<ul>
<li>事件修饰符可以串联。</li>
<li>once只触发一次，且只有一次有效。</li>
</ul>
<h2 id="stop-和-self-阻止冒泡的原理区别">.stop 和 .self 阻止冒泡的原理区别</h2>
<p>.stop 和 .self 都可以产生阻止冒泡的行为发生，但是二者原理不同。<br></p>
<ul>
<li>.stop 阻止了该元素之上的所有父元素的冒泡行为</li>
<li>.self 只阻止了自身的冒泡行为。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// self机制</span><br><span class="line">div1</span><br><span class="line">    div2</span><br><span class="line">        div3 @click.self</span><br><span class="line">            btn @click</span><br></pre></td></tr></table></figure>
<p>点击btn后，除了div3不会冒泡，btn，div1和div2均会正常冒泡。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// stop机制</span><br><span class="line">div1</span><br><span class="line">    div2</span><br><span class="line">        div3 @click.stop</span><br><span class="line">            btn @click</span><br></pre></td></tr></table></figure>
<p>此时点击btn，只有btn和div3会冒泡，而div1和div2均不会冒泡。</p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>📖 Vue学习笔记(1)</title>
    <url>/2020/04/04/vue1/</url>
    <content><![CDATA[<h2 id="MVC-MVVM">MVC &amp; MVVM</h2>
<h4 id="MVC">MVC</h4>
<ul>
<li>MVC是后端中的分层概念。M-Model，V-View，C-Controller。</li>
</ul>
<h4 id="MVVM">MVVM</h4>
<ul>
<li>MVVC只是针对前端分层。M-Model，V-View，VM-View Model。其中M和V要通过VM来进行数据链接。</li>
</ul>
<h2 id="Vue基本代码">Vue基本代码</h2>
<p>分两大部分。html和js。</p>
<h4 id="html部分">html部分</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">//js中new的vue实例将会控制该div中的所有元素。</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="js部分">js部分</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新的vue实例</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">'#app'</span>, <span class="comment">// 选择控制某个div</span></span><br><span class="line">    data:&#123;</span><br><span class="line">        title:<span class="string">'test'</span><span class="comment">//存放data</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method:&#123;</span><br><span class="line">        func1()&#123;</span><br><span class="line">            <span class="comment">// 实现函数内容</span></span><br><span class="line">        &#125;,</span><br><span class="line">        func2()&#123;</span><br><span class="line">            <span class="comment">//实现函数内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>不难看出，html中的部分是V-view，js中的部分是VM-ViewModel，负责数据链接，另外model部分也在js中，具体是data体现了model的功能。</li>
<li>vue中不需要用data.title来引用，直接用即可。</li>
</ul>
<a id="more"></a>
<h2 id="v-cloak-v-text-v-html">v-cloak / v-text / v-html</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>aaa &#123;&#123; msg &#125;&#125; aaa<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-text</span>=<span class="string">"msg1"</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-html</span>=<span class="string">"msg2"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            msg1:<span class="string">'test'</span>，</span></span><br><span class="line"><span class="xml">            msg2:'<span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is h1 text<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用v-cloak能够解决插值表达式在网速不稳定下文本的闪烁问题。</li>
<li>v-text能够覆盖原本的文本，而v-cloak只会替代本身的占字符。</li>
<li>v-html可以自动识别html文本语句并转成html渲染。</li>
</ul>
<h2 id="v-bind-属性绑定">v-bind 属性绑定</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"btn"</span> <span class="attr">v-bind:title</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            title:<span class="string">'this is title'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>v-bind会将目标target绑定到该元素上，如果不用v-bind则会显示title字样而不是data中自定义的title值。</li>
<li>另外由于v-bind:是js语法，所以后面可以跟自定义的lambda，例如v-bind:title=“title + ‘123’”.</li>
<li>v-bind:也可以直接简写为:</li>
</ul>
<h2 id="v-on-事件绑定">v-on 事件绑定</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"btn"</span> <span class="attr">v-on:click</span>=<span class="string">"alert"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            title:<span class="string">'this is title'</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"><span class="javascript">            alert:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                alert(<span class="string">'test'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>v-on用于事件绑定。后面一般跟自己定义的函数。类似js中的onclick.</li>
<li>可以简写为@click，@mouseover。。。</li>
<li>js中定义methods时，有两种写法，一种是function，一种是函数名直接跟().</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods&#123;</span><br><span class="line">    alert()&#123;</span><br><span class="line">        alert(<span class="string">'test'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    alert1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'test1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="demo1-跑马灯文字循环">demo1 : 跑马灯文字循环</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">value</span>=<span class="string">'开始'</span> @<span class="attr">click</span>=<span class="string">"begin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'button'</span> <span class="attr">value</span>=<span class="string">'停止'</span> @<span class="attr">click</span>=<span class="string">"stop"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el:<span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            msg:<span class="string">'测试跑马灯文字流！测试！'</span>，</span></span><br><span class="line"><span class="javascript">            intervalId:<span class="literal">null</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:</span><br><span class="line">            begin()&#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">if</span>(intervalId != <span class="literal">null</span>)<span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.intervalId = setInterval( <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 保证能够自动刷新加入interval</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> start = msg.substring(<span class="number">0</span>,<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> end = msg.substring(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">this</span>.msg = start + end;<span class="comment">//重新拼接string</span></span></span><br><span class="line">                &#125;,400);</span><br><span class="line">            &#125;,</span><br><span class="line">            stop()&#123;</span><br><span class="line"><span class="javascript">                clearInterval(<span class="keyword">this</span>.intervalId);</span></span><br><span class="line"><span class="javascript">                intervalId = <span class="literal">null</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>每次把第一位char移到最后</li>
<li>为了保证连续滚动，设定interval</li>
<li>利用intervalId来保证开始和停止按钮正常工作。利用intervalId是否为null来判断之前是否移动过。</li>
</ul>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>📖 Vue学习笔记(3)</title>
    <url>/2020/04/13/vue3/</url>
    <content><![CDATA[<h1>vue v-model 和 数据双向绑定</h1>
<h2 id="v-model">v-model</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span> &#123;&#123; msg &#125;&#125; <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-bind:value</span> = <span class="string">"msg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-model</span> = <span class="string">"msg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            msg: <span class="string">'This is new data '</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码很清楚的展示了v-bind 单向数据绑定和 v-model 双向数据绑定的区别。<br><br>
第一个input框内的文字只会和h4内同步一次，当对input做出改变时，h4内容不会随之改变。<br><br>
相反，使用了v-model的input发生改变时，h4显示的内容会随之一起改变。</p>
<p>待更新</p>
]]></content>
      <categories>
        <category>前端框架</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 844. Backspace String Compare</title>
    <url>/2020/07/29/844.%20Backspace%20String%20Compare/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-844-Backspace-String-Compare-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">844. Backspace String Compare</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/backspace-string-compare/"><font size="4">🔗 LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Note that after backspacing an empty text, the text will continue empty.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Navie">Navie</h4>
<p>We can using stack to simulate backspacing option. When we meet <code>#</code> we just pop up the top element in the stack. Finally we only need to compare the two stacks.</p>
<h4 id="Backforward">Backforward</h4>
<p>Starting from the last element, keep count of the <code>#</code>. If current is <code>#</code>, we increase by 1. Otherwise, if count is larger than 0, it means current char is before # and need to be deleted. If count is equal to 0, we add current char to the res.</p>
<h4 id="Optimized-Two-pointers-with-O-1-space">Optimized - Two pointers with O(1) space</h4>
<p>Follow up : Can you make up only O(1) space ?</p>
<p>Apparently we can only using two pointers to achieve O(1) spce without any other space.</p>
<p>Start from both tails, keep record the number of ‘#’.</p>
<p>It will eventually stop at the final char of res. Then we can check the rest of chars to see whether they are the same.</p>
<p>If not, we have to check whether they both have been cleaned up with index of -1.</p>
<h3 id="Code">Code</h3>
<h4 id="Navie-v2">Navie</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(S).equals(help(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Stack&lt;Character&gt; <span class="title">help</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) != <span class="string">'#'</span>)stack.push(str.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
<h4 id="Backforward-v2">Backforward</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(S).equals(help(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">help</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'#'</span>)count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)count--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
<h4 id="Two-pointers">Two pointers</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="keyword">null</span> || T == <span class="keyword">null</span>)<span class="keyword">return</span> S == T;</span><br><span class="line">        <span class="keyword">int</span> m = S.length();</span><br><span class="line">        <span class="keyword">int</span> n = T.length();</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; (S.charAt(i) == <span class="string">'#'</span> || cnt1 &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)cnt1++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt1--;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; (T.charAt(j) == <span class="string">'#'</span> || cnt2 &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)cnt2++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j&gt;=<span class="number">0</span> &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; S.charAt(i) == T.charAt(j))&#123;</span><br><span class="line">                j--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i == -<span class="number">1</span> &amp;&amp; j == -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(1)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 359. Logger Rate Limiter</title>
    <url>/2020/08/02/359.%20Logger%20Rate%20Limiter/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-359-Logger-Rate-Limiter-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">359. Logger Rate Limiter</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/logger-rate-limiter/"><font size="4">LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.</p>
<p>Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.</p>
<p>It is possible that several messages arrive roughly at the same time.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logger logger = new Logger();</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 1</span><br><span class="line">logger.shouldPrintMessage(1, &quot;foo&quot;); returns true;</span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 2</span><br><span class="line">logger.shouldPrintMessage(2,&quot;bar&quot;); returns true;</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 3</span><br><span class="line">logger.shouldPrintMessage(3,&quot;foo&quot;); returns false;</span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 8</span><br><span class="line">logger.shouldPrintMessage(8,&quot;bar&quot;); returns false;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Navie">Navie</h4>
<p>It’s obvious that we can use a <code>HashMap</code> to store each message’s timestamp. Each time we meet a previous existed message, we only need check whether <code>current timestamp - map.get(message) &gt; 10</code>, if not return false. Otherwise update the message’s timestamp and return true.</p>
<p>However, using hashmap in some huge date stream can cause memory usage keeps growing, which is a waste of performance. So we have to think a better solution to save memory.</p>
<h4 id="Cicular-buffer">Cicular buffer</h4>
<p>Using Set and bucket array to store at most 10 seconds before. After that we clear the set. Give each <code>timestamp % 10</code> a new set to store message.</p>
<h4 id="Two-HashMap">Two HashMap</h4>
<p><code>starttime</code> record the start time of the <code>newmap</code>.</p>
<p><code>newmap</code> keeps the messages of <code>[starttime, starttime +10)</code>;</p>
<p><code>oldmap</code> keeps messages at most <code>20</code> seconds before.</p>
<h3 id="Code">Code</h3>
<h4 id="Navie-v2">Navie</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(message))&#123;</span><br><span class="line">            map.put(message,timestamp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(timestamp - map.get(message) &lt; <span class="number">10</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            map.put(message,timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(1) S:O(N)</p>
<h4 id="Circular-buffer">Circular buffer</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bucket;</span><br><span class="line">    Set[] sets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sets = <span class="keyword">new</span> Set[<span class="number">10</span>];</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sets.length;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = timestamp % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(timestamp != bucket[index])&#123;</span><br><span class="line">            sets[index].clear();</span><br><span class="line">            bucket[index] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bucket.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timestamp - bucket[i] &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sets[i].contains(message))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[index].add(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(1) S:O(N)</p>
<h4 id="Two-HashMaps">Two HashMaps</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; oldmap;</span><br><span class="line">    Map&lt;String, Integer&gt; newmap;</span><br><span class="line">    <span class="keyword">int</span> startime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        oldmap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        newmap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        starttime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timestamp &gt;= latest + <span class="number">20</span>)&#123; <span class="comment">// both map need refresh</span></span><br><span class="line">            oldmap.clear();</span><br><span class="line">            newmap.clear();</span><br><span class="line">            starttime = timestamp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timestamp &gt;= latest + <span class="number">10</span>)&#123; <span class="comment">// refresh new map and assign old map with the value of new map</span></span><br><span class="line">            oldmap = <span class="keyword">new</span> HashMap&lt;&gt;(newmap);</span><br><span class="line">            newmap.clear();</span><br><span class="line">            starttime = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newmap.containsKey(message)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(oldmap.containsKey(message))&#123;</span><br><span class="line">            <span class="keyword">int</span> last = oldmap.get(message);</span><br><span class="line">            <span class="keyword">if</span>(last + <span class="number">10</span> &gt; timestamp) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newmap.put(message, timestamp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(1) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 125. Valid Palindrome</title>
    <url>/2020/08/03/125.%20Valid%20Palindrome/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-125-Valid-Palindrome-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">125. Valid Palindrome</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/valid-palindrome/"><font size="4">LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using two pointers to scan the string from start and end. Skip all <code>unletterOrDigit</code> character like ’ ’ and ‘.’ and other signs. Then check two characters is same or not.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(l))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(r))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(l) != Character.toLowerCase(r))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(1)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 4. Median of Two Sorted Arrays</title>
    <url>/2020/08/03/4.%20Median%20of%20Two%20Sorted%20Arrays/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-4-Median-of-Two-Sorted-Arrays-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">4. Median of Two Sorted Arrays</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/median-of-two-sorted-arrays/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Brute-force">Brute force</h4>
<p>The first solution we can come up with is getting two arrays into one and sort the final array, then try to get the middle index number. But it will cost <code>O(nlogn)</code>, which doesn’t meet the time complexity requirement of <code>log(m+n)</code>.</p>
<p>Apparently, the <code>O(log(n+m))</code> can be approached only by <code>Binary Search</code>.</p>
<h4 id="Binary-Search">Binary Search</h4>
<p>Idea copied from <a href="https://leetcode.com/yaokaiyang" target="_blank" rel="noopener">@YaokaiYang<br>
</a></p>
<p>In order to solve this question, we need to first understand what a median is. A median is the middle value of a dataset.</p>
<p>Since we have 2 seperately sorted array in this question, to find the middle value is somewhat complicated. However, keep in mind that we do not care about the actual value of the numbers, what we want is the middle point from the combination of 2 arrays. In other words, we are looking for the middle index of the 2 arrays. Thus approach like binary search could be employed.</p>
<p>Based on the fact that the 2 arrays are sorted seperatedly, we could try to get the submedian of the 2 arrays in each round. Than compare them. And the basic idea is that the left half of the array with a smaller submedian can never contains the common median.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (mid1 &lt; mid2) keep nums1.right + nums2</span><br><span class="line">else keep nums1 + nums2.right</span><br></pre></td></tr></table></figure>
<h3 id="Code">Code</h3>
<h4 id="Navie-Brute-Force">Navie Brute Force</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            arr[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">            arr[m+j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> k = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span> != <span class="number">0</span>)<span class="keyword">return</span> (<span class="keyword">double</span>)arr[k/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> ((<span class="keyword">double</span>)(arr[(k/<span class="number">2</span>) - <span class="number">1</span>] + arr[(k/<span class="number">2</span>)])/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(NlogN) S:O(N)</p>
<h4 id="Binary-Search-v2">Binary Search</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (m + n + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (m + n + <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (help(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left) + help(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> s1, <span class="keyword">int</span>[]nums2, <span class="keyword">int</span> s2, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s1 &gt; nums1.length-<span class="number">1</span>)<span class="keyword">return</span> nums2[s2 + position - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>( s2 &gt; nums2.length-<span class="number">1</span>)<span class="keyword">return</span> nums1[s1 + position - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[s1], nums2[s2]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> mid2 = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1 + position/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.length)mid1 = nums1[s1 + position/<span class="number">2</span> -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s2 + position/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.length)mid2 = nums2[s2 + position/<span class="number">2</span> -<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mid1 &lt; mid2)&#123;</span><br><span class="line">            <span class="keyword">return</span> help(nums1,s1 + position/<span class="number">2</span>, nums2, s2, position - position/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> help(nums1,s1,nums2,s2 + position/<span class="number">2</span>, position - position/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(log(M+N)) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 23. Merge k Sorted Lists</title>
    <url>/2020/08/03/23.%20Merge%20k%20Sorted%20Lists/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-23-Merge-k-Sorted-Lists-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">23. Merge k Sorted Lists</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/merge-k-sorted-lists/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using self-design <code>PriorityQueue</code> to store each head of <code>list</code> in the <code>lists</code>. Then loop each head and add their next listnode into the priorityqueue. Finally we can get a sorted linkedlist.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt; a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span>(ListNode list : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            head.next = pq.poll();</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(head.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 516. Longest Palindromic Subsequence</title>
    <url>/2020/08/06/516.%20Longest%20Palindromic%20Subsequence/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-516-Longest-Palindromic-Subsequence-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">516. Longest Palindromic Subsequence</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-subsequence/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Exapmles">Exapmles</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s, find the longest palindromic subsequence&apos;s length in s. You may assume that the maximum length of s is 1000.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line">One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br><span class="line"> </span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line">One possible longest palindromic subsequence is &quot;bb&quot;.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s a typical palindromic string problem. When we see subsequence instead of substring, it means it can be interruptted and not continous, and we always using <code>DP </code> to solve that kind of uncontinous problem.</p>
<p>We first create a <code>two-dimension DP array</code> to store the length.</p>
<p><code>dp[i][j]</code> means the max palindromic subsequence between start of <code>i</code> and end of<code>j</code> in the string <code>s</code></p>
<p><code>Transition Function</code> :</p>
<ol>
<li>When <code>s.charAt(i) == s.charAt(j) </code>  :  <code>dp[i][j] = dp[i+1][j-1] + 2</code>
<ul>
<li>It looks like we expand the range of current <code>i+1, j-1</code> to <code>i,j</code>, which is extremely like two pointers , one with left+1, and one with right-1. Instead, in this problem we solve from inside to outside.</li>
</ul>
</li>
<li>When <code>s.charAt(i) != s.charAt(j) </code>  : <code>dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</code>
<ul>
<li>If ther are not the same, we just choosing the range from <code>left+1,right</code> or <code>left,right-1</code> because the subsequence can be interuppted.</li>
</ul>
</li>
</ol>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N^2) S:O(N^2)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>String</tag>
        <tag>DP</tag>
        <tag>Palindromic</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 5. Longest Palindromic Substring</title>
    <url>/2020/08/06/5.%20Longest%20Palindromic%20Substring/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-5-Longest-Palindromic-Substring-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">5. Longest Palindromic Substring</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-substring/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p><strong>Example 1:</strong><br>
Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bbbab&quot;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p>One possible longest palindromic subsequence is “bbbb”.</p>
<p><strong>Example 2:</strong><br>
Input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cbbd&quot;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<p>One possible longest palindromic subsequence is “bb”.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> consists only of lowercase English letters.</li>
</ul>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<h4 id="Two-Pointers">Two Pointers</h4>
<p>The first navie solution is using two pointers to scan both 1 chars or 2 chars from itself. Like <code>aabbaabb</code> we can start scaling from <code>a</code> or <code>aa</code>, because palindrome can only form with 1 or 2 chars.( 3 is based on 1).</p>
<h4 id="DP">DP</h4>
<p>It can also be solved by using DP.</p>
<p>It’s a bit like problem <a href="[https://leeemask.com/2020/08/06/516.%20Longest%20Palindromic%20Subsequence/](https://leeemask.com/2020/08/06/516. Longest Palindromic Subsequence/)">516. Longest Palindromic Subsequence</a> . We expand from inside to outside.</p>
<p>The only difference in this question is that : we only keep record of boolean array to see whether <code>dp[i][j]</code> can form a palindrome substring from <code>i</code> to <code>j</code>.</p>
<p>Only the situation meet the requirements of following can be a palindrome substring:</p>
<ul>
<li>
<p><code>s.charAt(i) == s.charAt(j)</code>: Two chars need to be same.</p>
</li>
<li>
<p><code>j-i&lt;3</code>: means only 2 or 1 letters in the current range. Like <code>aa</code> or <code>a</code>.</p>
</li>
<li>
<p><code>dp[i+1][j-1] = true </code> : It means that the smaller range from i+1 to j-1 can form a palindrome, so the current range from <code>i</code> to <code>j</code> can also be true.</p>
</li>
</ul>
<p>After updating the current dp state, we need to update the max length of substring and the start point. FInally we just return the substring from <code>start</code> to <code>start + max</code>.</p>
<h3 id="Code">Code</h3>
<h4 id="Two-Pointers-v2">Two Pointers</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start, max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            check(s,i,i);</span><br><span class="line">            check(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left &gt; max)&#123;</span><br><span class="line">            max = right - left - <span class="number">1</span>;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
<h4 id="DP-v2">DP</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = ( s.charAt(i) == s.charAt(j) &amp;&amp; ( j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>] ));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j-i+<span class="number">1</span> &gt; max))&#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
        <tag>DP</tag>
        <tag>Palindromic</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 3. Longest Substring Without Repeating Characters</title>
    <url>/2020/08/07/3.%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-3-Longest-Substring-Without-Repeating-Characters-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">3. Longest Substring Without Repeating Characters</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using two pointers and HashSet to store the current chars. It set contains current char, it means we have seen this before, then move the left point. Update the max after we add a char to the set.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; s.length() &amp;&amp; right &lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(right)))&#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                right++;</span><br><span class="line">                max = Math.max(max,set.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 340. Longest Substring with At Most K Distinct Characters</title>
    <url>/2020/08/07/340.%20Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-340-Longest-Substring-with-At-Most-K-Distinct-Characters-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">340. Longest Substring with At Most K Distinct Characters</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/"><font size="4">🔗  Leetcode Link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;eceba&quot;, k = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: T is &quot;ece&quot; which its length is 3.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, k = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: T is &quot;aa&quot; which its length is 2.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Typical sliding window question. Using <code>left</code> and <code>right</code> pointer to scan the string, and keep each character’s frequency in a <code>HashMap</code>.</p>
<p>When the size of map <code>( which is also the total num of distinct characters)</code> is greater than k, we need to substract chars from left.</p>
<p>When the <code>map size &lt;= 2</code>, we update the res.</p>
<p>This question can share the same code template with question <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. Longest Substring with At Most Two Distinct Characters</a></p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() ==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right =<span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(right);</span><br><span class="line">            map.put(temp, map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">char</span> leftchar = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(leftchar))&#123;</span><br><span class="line">                    map.put(leftchar,map.get(leftchar)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(leftchar) == <span class="number">0</span>)&#123;</span><br><span class="line">                        map.remove(leftchar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 992. Subarrays with K Different Integers</title>
    <url>/2020/08/07/992.%20Subarrays%20with%20K%20Different%20Integers/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-992-Subarrays-with-K-Different-Integers-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">992. Subarrays with K Different Integers</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/subarrays-with-k-different-integers/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given an array <code>A</code> of positive integers, call a (contiguous, not necessarily distinct) subarray of <code>A</code> <em>good</em> if the number of different integers in that subarray is exactly <code>K</code>.</p>
<p>(For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.)</p>
<p>Return the number of good subarrays of <code>A</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,1,2,3], K = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,1,3,4], K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= A.length</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s a bit different from previous <code> at most K different/distinct</code> problem. This question need just<code>K</code> different integers.</p>
<p>However, it’s straightforward to prove that <code>Just(K) = AtMost(K) - AtMost(K-1)</code>, so we can call the <a href="https://leeemask.com/2020/08/07/340.%20Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters/" target="_blank" rel="noopener">previous kinda code</a> twice and substract them then will get the res.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(A,K) - help(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length ;j++)&#123;</span><br><span class="line">            map.put(A[j],map.getOrDefault(A[j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; K)&#123;</span><br><span class="line">                map.put(A[i],map.get(A[i])-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(A[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(A[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(N) S:O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Two Pointers</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 815. Bus Routes</title>
    <url>/2020/08/08/815.%20Bus%20Routes/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-815-Bus-Routes-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">815. Bus Routes</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/bus-routes/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>We have a list of bus routes. Each <code>routes[i]</code> is a bus route that the i-th bus repeats forever. For example if <code>routes[0] = [1, 5, 7]</code>, this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;… forever.</p>
<p>We start at bus stop <code>S</code> (initially not on a bus), and we want to go to bus stop <code>T</code>. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: </span><br><span class="line">routes = [[1, 2, 7], [3, 6, 7]]</span><br><span class="line">S = 1</span><br><span class="line">T = 6</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= routes.length &lt;= 500</code>.</li>
<li><code>1 &lt;= routes[i].length &lt;= 10^5</code>.</li>
<li><code>0 &lt;= routes[i][j] &lt; 10 ^ 6</code>.</li>
</ul>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Using BFS.</p>
<p>We can think from the other point.</p>
<p>Assume in real life, we are at stop 1, and there a several buses can stop here, so we can choose anyone we want.</p>
<p>So it’s simple that we can store the buses and stop in the map, with key of <code>stop</code> and value of <code>buses that stop here</code>.</p>
<p>Inorder to prevent the duplicate bus, we can using an array of bus number to check whether the bus has been visited.</p>
<p>Then transfer the map into a graph like below.</p>
<img src="https://assets.leetcode.com/users/images/043c8e91-4b67-4eb4-8858-05ba98c56a47_1596899756.2404113.png">
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(S == T)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;routes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;routes[i].length; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; buses = map.getOrDefault(routes[i][j],<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                buses.add(i);</span><br><span class="line">                map.put(routes[i][j], buses);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] seen = <span class="keyword">new</span> <span class="keyword">int</span>[routes.length];</span><br><span class="line">        </span><br><span class="line">        queue.add(S);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                List&lt;Integer&gt; buses = map.get(temp);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> bus : buses)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(seen[bus] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    seen[bus] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;routes[bus].length; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(routes[bus][k] == T)<span class="keyword">return</span> res;</span><br><span class="line">                        queue.offer(routes[bus][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T: O(M*N)  S: O(N)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 314. Binary Tree Vertical Order Traversal</title>
    <url>/2020/08/10/314.%20Binary%20Tree%20Vertical%20Order%20Traversal/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-314-Binary-Tree-Vertical-Order-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">314. Binary Tree Vertical Order Traversal</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"><font size="4">🔗  Leetcode Link</font></a></p>
<p><a target="_blank" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"><font size="4">🔗 Similar Questoin 987 link</font></a></p>
<h3 id="Examples">Examples</h3>
<p>Given a binary tree, return the <em>vertical order</em> traversal of its nodes’ values. (ie, from top to bottom, column by column).</p>
<p>If two nodes are in the same row and column, the order should be from <strong>left to right</strong>.</p>
<p><strong>Examples 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /\</span><br><span class="line"> /  \</span><br><span class="line"> 9  20</span><br><span class="line">    /\</span><br><span class="line">   /  \</span><br><span class="line">  15   7 </span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [9],</span><br><span class="line">  [3,15],</span><br><span class="line">  [20],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>This question has the same solution with question <a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/ " target="_blank">987. Vertical Order Traversal of a Binary Tree</a></p>
<h4 id="1-Pair-Class-with-BFS">1. Pair Class with BFS</h4>
<p>According to the question, we need to store the position of both <code>x</code> and <code>y</code> and it’s <code>node</code>. We can just define another simple class instead of using other TreeMap or PriorityQueue.</p>
<p>What we need to do is just store the node that have same <code>x</code> in the HashMap using <code>BFS</code>/ <code>Level Traversal</code>.</p>
<h4 id="2-Two-Queue-and-BFS">2. Two Queue and BFS</h4>
<p>Using two queue to store position of <code>x</code>/<code>col</code> and nodes.</p>
<p>Using Map to store the nodes that have same <code>x</code>/ <code>col</code></p>
<p>We follow the order of <code>root -&gt; left -&gt; right</code> to add both <code>x</code>/<code>col</code> and <code>node</code> into queue. So each time we just need to poll up the latest one to update the <code>x</code>/<code>col</code> and <code>node</code>.</p>
<p>Also remember to keep track of leftmost <code>left</code> and rightmost <code>right</code> for the later loop.</p>
<h3 id="Code">Code</h3>
<h4 id="Pair-class-BFS">Pair class + BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.node = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res; <span class="comment">// corner case</span></span><br><span class="line">		</span><br><span class="line">        Map&lt;Integer, List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//BFS</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(<span class="number">0</span>,<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// leftmost x </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">// rightmost x</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.poll();</span><br><span class="line">            left = Math.min(left, temp.x);</span><br><span class="line">            right = Math.max(right,temp.x);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(<span class="keyword">new</span> pair(temp.x, temp.y, temp.node));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left != <span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x-<span class="number">1</span>, temp.y+<span class="number">1</span>, temp.node.left));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right != <span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x+<span class="number">1</span>, temp.y+<span class="number">1</span>, temp.node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y); <span class="comment">// sort the node that have same y value</span></span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; map.get(i).size(); j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Two-Queue-BFS">Two Queue + BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"> 		<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res; <span class="comment">// check the input</span></span><br><span class="line"></span><br><span class="line">          Map&lt;Integer,ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          Queue&lt;TreeNode&gt; node_queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          Queue&lt;Integer&gt; cols = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> leftmost = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">          node_queue.add(root);</span><br><span class="line">          cols.add(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">while</span>(!node_queue.isEmpty())&#123;</span><br><span class="line">              TreeNode node = node_queue.poll();</span><br><span class="line">              <span class="keyword">int</span> col = cols.poll();</span><br><span class="line">              <span class="keyword">if</span>(!map.containsKey(col))&#123;</span><br><span class="line">                  map.put(col,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">              &#125;</span><br><span class="line">              map.get(col).add(node.val);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  node_queue.add(node.left);</span><br><span class="line">                  cols.add(col-<span class="number">1</span>);</span><br><span class="line">                  leftmost = Math.min(leftmost,col-<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  node_queue.add(node.right);</span><br><span class="line">                  cols.add(col+<span class="number">1</span>);</span><br><span class="line">                  rightmost = Math.max(rightmost,col+<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i= leftmost ; i &lt;= rightmost ; i++)&#123;</span><br><span class="line">              res.add(map.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Tree</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 675. Cut Off Trees for Golf Event</title>
    <url>/2020/08/16/675.%20Cut%20Off%20Trees%20for%20Golf%20Event/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-675-Cut-Off-Trees-for-Golf-Event-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">675. Cut Off Trees for Golf Event </font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/cut-off-trees-for-golf-event/"><font size="4">🔗  LeetCode Link </font></a></p>
<h3 id="Example">Example</h3>
<p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p>
<ol>
<li><code>0</code> represents the <code>obstacle</code> can’t be reached.</li>
<li><code>1</code> represents the <code>ground</code> can be walked through.</li>
<li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree’s height.</li>
</ol>
<p>In one step you can walk in any of the four directions <code>top</code>, <code>bottom</code>, <code>left</code> and <code>right</code> also when standing in a point which is a tree you can decide whether or not to cut off the tree.</p>
<p>You are asked to cut off <strong>all</strong> the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p>
<p>You will start from the point (0, 0) and you should output the minimum steps <strong>you need to walk</strong> to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.</p>
<p>You are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,4],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [2,3,4],</span><br><span class="line"> [0,0,5],</span><br><span class="line"> [8,7,6]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= forest.length &lt;= 50</code></li>
<li><code>1 &lt;= forest[i].length &lt;= 50</code></li>
<li><code>0 &lt;= forest[i][j] &lt;= 10^9</code></li>
</ul>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Apparently we can using BFS.</p>
<p>Using priority queue to sort the node by it’s value.</p>
<p>We start from the (0,0).  Keep record of the next tree that we want to cut , after BFS we need to update the current start with last <code>next tree</code>.</p>
<p>Using BFS to find the best steps from the current tree to the next target tree.</p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(forest == <span class="keyword">null</span> || forest.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;(a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">int</span> m = forest.size();</span><br><span class="line">        <span class="keyword">int</span> n = forest.get(<span class="number">0</span>).size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(forest.get(i).get(j) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j,forest.get(i).get(j)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tree = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> step = help(forest,start,tree,m,n);</span><br><span class="line">            <span class="keyword">if</span>(step == -<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            sum+=step;</span><br><span class="line">            start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">            start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        seen[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; temp[<span class="number">1</span>] == tree[<span class="number">1</span>])<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = temp[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = temp[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                        seen[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(m^2 * n^2)   S:O(m*n)</p>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Easy | 733. Flood Fill</title>
    <url>/2020/08/16/733.%20Flood%20Fill/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-733-Flood-Fill-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">733. Flood Fill</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/flood-fill/"><font size="4">🔗 LeetCode Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p>
<p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, “flood fill” the image.</p>
<p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p>
<p>At the end, return the modified image.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">image = [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr = 1, sc = 1, newColor = 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</p>
<p>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</p>
<p>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</p>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>Take care of corner case that cause many times in my submission.</p>
<p>Just return the image when the newColor is same as start point’s color.</p>
<h4 id="BFS">BFS</h4>
<p>It’s traditional BFS solution. Using template for BFS is enough.</p>
<h4 id="DFS">DFS</h4>
<p>It’s traditional DFS solution. Using template for DFS is enough.</p>
<h3 id="Code">Code</h3>
<h4 id="DFS-v2">DFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> old;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)<span class="keyword">return</span> image;</span><br><span class="line">        m = image.length;</span><br><span class="line">        n = image[<span class="number">0</span>].length;</span><br><span class="line">        old = image[sr][sc];</span><br><span class="line">        dfs(image,sr,sc,newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> newColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n || image[row][col] != old)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image[row][col] = newColor;</span><br><span class="line">        dfs(image,row-<span class="number">1</span>,col,newColor);</span><br><span class="line">        dfs(image,row+<span class="number">1</span>,col,newColor);</span><br><span class="line">        dfs(image,row,col-<span class="number">1</span>,newColor);</span><br><span class="line">        dfs(image,row,col+<span class="number">1</span>,newColor);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS-v2">BFS</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span> m = image.length;</span><br><span class="line">        <span class="keyword">int</span> n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> color = image[sr][sc];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp  = queue.poll();</span><br><span class="line">            image[temp[<span class="number">0</span>]][temp[<span class="number">1</span>]] = newColor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y&lt; n &amp;&amp; image[x][y] == color) &#123;</span><br><span class="line">                    image[x][y] = newColor;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | 1192. Critical Connections in a Network</title>
    <url>/2020/09/10/1192.%20Critical%20Connections%20in%20a%20Network/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1192-Critical-Connections-in-a-Network-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1192. Critical Connections in a Network</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/critical-connections-in-a-network//"><font size="4">🔗  Question Link </font></a></p>
<h3 id="Examples">Examples</h3>
<p>There are <code>n</code> servers numbered from <code>0</code> to <code>n-1</code> connected by undirected server-to-server <code>connections</code> forming a network where <code>connections[i] = [a, b]</code> represents a connection between servers <code>a</code> and <code>b</code>. Any server can reach any other server directly or indirectly through the network.</p>
<p>A <em>critical connection</em> is a connection that, if removed, will make some server unable to reach some other server.</p>
<p>Return all critical connections in the network in any order.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png" alt="img"></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">Output: [[1,3]]</span><br><span class="line">Explanation: [[3,1]] is also accepted.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
<li><code>n-1 &lt;= connections.length &lt;= 10^5</code></li>
<li><code>connections[i][0] != connections[i][1]</code></li>
<li>There are no repeated connections.</li>
</ul>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>It’s a typical Tarjan solution. We need to find the parts that are not strong components.</p>
<p>Detailed information about Tarjan can be found in this post. <a href="https://blog.csdn.net/hurmishine/article/details/75248876" target="_blank" rel="noopener">CSDN Link</a></p>
<p><code>Time</code>: the time that the node be visited</p>
<p><code>Low</code>: the lowest time that current node’s parent nodes have.</p>
<p><code>findTime</code>: the time stamp that increases by itself.</p>
<p>We first create a graph to store <code>v</code> and <code>u</code>.  Then perfom DFS on each unvisited node <code>v</code> in <code>graph[u]</code>.</p>
<p>If v is unvisited, recursively call the function DFS. Then update the low[u].</p>
<p>If <code>low[v] &gt; time[u]</code>, it means the current node v can not go back to it’s parrent node <code>u</code>. So this is an critical connection and we add them to res.</p>
<p>Otherwise, we update low[u] with <code>Math.min(low[u], time[v])</code></p>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] time, low;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> findTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">        res = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">        time = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(time,-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;connections.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = connections.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> end = connections.get(i).get(<span class="number">1</span>);</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(time[i] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> u, <span class="keyword">int</span> prev)</span></span>&#123;</span><br><span class="line">        time[u] = low[u] = ++findTime;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;graph[u].size(); k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = graph[u].get(k);</span><br><span class="line">            <span class="keyword">if</span>(v == prev)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(time[v] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph,v,u);</span><br><span class="line">                low[u] = Math.min(low[u],low[v]);</span><br><span class="line">                <span class="keyword">if</span>( low[v] &gt; time[u])&#123;</span><br><span class="line">                    res.add(Arrays.asList(u,v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = Math.min(low[u], time[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Hard | Country Roads</title>
    <url>/2020/09/25/CountryRoads/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-Country-Roads-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">Country Roads</font></td></tr></table></h2>
<p><a target="_blank" href="https://binarysearch.com/problems/Country-Roads"><font size="4">🔗 Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>A country can be represented as a tree with <code>N</code> nodes and <code>N-1</code> edges. Each node represents a town, and each edge represents a piece of road.</p>
<p>You’re given two lists of integers of size <code>N-1</code>, <code>source</code> and <code>dest</code>. The <code>i</code>-th road connects town <code>source[i]</code> to town <code>dest[i]</code>. The roads are bidirectional.</p>
<p>You’re also given a list of integers <code>population</code> of size <code>N</code>, where <code>population[i]</code> represents the population of the <code>i</code>-th town.</p>
<p>You are looking to upgrade some number of towns into cities.</p>
<p>However, there is a catch: no two cities should be adjacent to each other due to fierce competition, and every node adjacent to a town should be a city to allow easier access to infrastructure. In other words, every road must connect a town and a city.</p>
<p>What is the maximum possible population of all the cities?</p>
<p><strong>Constraints</strong></p>
<ul>
<li><code>N ≤ 10000</code></li>
</ul>
<p><strong>Example</strong></p>
<p><strong>Input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source = [0, 0, 2, 2]</span><br><span class="line">dest = [1, 2, 4, 3]</span><br><span class="line">population = [5, 7, 3, 2, 4]</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<p><strong>Explanation</strong></p>
<p>We can upgrade cities 0, 3, and 4 to get a population of 11.</p>
<a id="more"></a>
<h3 id="Solution">Solution</h3>
<p>The key point is that, we only need to check the <code>odd</code> and <code>even</code> position. According to the question, we can not set neighboors as two cities, so we can only set a city with a distance of 1. So we can keep record of two sum, one is the final population of cities at even position, and another is the total population of cities at odd position.</p>
<p>After figuring the above out, we can using both <code>DFS</code> and <code>BFS</code> to solve it.</p>
<img src="https://user-images.githubusercontent.com/48079913/94323706-dbf06a00-ff64-11ea-8bfa-d0806a8505f1.png" alt="question image">
<h3 id="Code">Code</h3>
<ul>
<li>
<p>BFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] dest, <span class="keyword">int</span>[] population)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[source.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;source.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = source[i];</span><br><span class="line">            <span class="keyword">int</span> end = dest[i];</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">        res1+=population[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> s = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> d = temp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[s])&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(next))<span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;next, d + <span class="number">1</span>&#125;);</span><br><span class="line">                set.add(next);</span><br><span class="line">                <span class="keyword">if</span>(d % <span class="number">2</span> == <span class="number">0</span>)res2+=population[next];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(d % <span class="number">2</span> != <span class="number">0</span>)res1 +=population[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] dest, <span class="keyword">int</span>[] population)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[source.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;source.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = source[i];</span><br><span class="line">            <span class="keyword">int</span> end = dest[i];</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        even += population[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            dfs(graph,i,<span class="number">0</span>,population);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[]graph, <span class="keyword">int</span> node, <span class="keyword">int</span> dist,<span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!set.contains(node))&#123;</span><br><span class="line">            set.add(node);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[node])&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(next))<span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                dfs(graph,next,dist+<span class="number">1</span>, p);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(dist % <span class="number">2</span> == <span class="number">0</span>)res2 += p[next];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dist % <span class="number">2</span> != <span class="number">0</span>)res1 +=p[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Review | Medium | 1145. Binary Tree Coloring Game</title>
    <url>/2020/10/17/1145.%20Binary%20Tree%20Coloring%20Game/</url>
    <content><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1145-Binary-Tree-Coloring-Game-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1145. Binary Tree Coloring Game</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/binary-tree-coloring-game/"><font size="4">🔗  Leetcode Link</font></a></p>
<p>Two players play a turn based game on a binary tree. We are given the <code>root</code> of this binary tree, and the number of nodes <code>n</code> in the tree. <code>n</code> is odd, and each node has a distinct value from <code>1</code> to <code>n</code>.</p>
<p>Initially, the first player names a value <code>x</code> with <code>1 &lt;= x &lt;= n</code>, and the second player names a value <code>y</code> with <code>1 &lt;= y &lt;= n</code> and <code>y != x</code>. The first player colors the node with value <code>x</code> red, and the second player colors the node with value <code>y</code> blue.</p>
<p>Then, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an <strong>uncolored</strong> neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)</p>
<p>If (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.</p>
<p>You are the second player. If it is possible to choose such a <code>y</code> to ensure you win the game, return <code>true</code>. If it is not possible, return <code>false</code>.</p>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-game.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation: The second player can choose the node with value 2.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>root</code> is the root of a binary tree with <code>n</code> nodes and distinct node values from <code>1</code> to <code>n</code>.</li>
<li><code>n</code> is odd.</li>
<li><code>1 &lt;= x &lt;= n &lt;= 100</code></li>
</ul>
<p><em><a id="more"></a></em></p>
<h3 id="Solution">Solution</h3>
<p>We first find the <code>left</code> and <code>right</code> childs of the given <code>x</code>. Once we got them, we can get the child count of <code>x's</code> parent node.</p>
<p>Here has three option we can choose:</p>
<ol>
<li>
<p>If the left childs is bigger than half of the total nodes :<code>left child</code> &gt; <code>n/2</code>:</p>
<p>Then the second player can win if choose the left child of x.</p>
</li>
<li>
<p>If the right childs is bigger than half of the total nodes :<code>right child</code> &gt; <code>n/2</code>:</p>
<p>Then the second player can win if choose the right child of x.</p>
</li>
<li>
<p>If the childs of parent of x is bigger than n/2 : <code>n - (left + right + 1</code> &gt; <code>n/2</code>:</p>
<p>Then the second player can win if choose the parent of x.</p>
</li>
</ol>
<h3 id="Code">Code</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftchild, rightchild, parentchild = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">btreeGameWinningMove</span><span class="params">(TreeNode root, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        count(root,x,n);</span><br><span class="line">        parentchild = n - (leftchild + rightchild + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftchild &gt; n/<span class="number">2</span> || rightchild &gt; n/<span class="number">2</span> || parentchild &gt; n/<span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode root, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = count(root.left, x, n);</span><br><span class="line">        <span class="keyword">int</span> r = count(root.right, x, n);</span><br><span class="line">        <span class="keyword">if</span>(root.val == x)&#123;</span><br><span class="line">            leftchild = l;</span><br><span class="line">            rightchild = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + r + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Leetcode Cracking</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Code-Review</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
</search>
