<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leee&#39;s World</title>
  
  <subtitle>Talk is Cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="WangHngLeee.github.io/"/>
  <updated>2020-03-07T05:52:04.738Z</updated>
  <id>WangHngLeee.github.io/</id>
  
  <author>
    <name>HongLeee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Review Problems List 📌</title>
    <link href="WangHngLeee.github.io/9999/12/31/problemslist/"/>
    <id>WangHngLeee.github.io/9999/12/31/problemslist/</id>
    <published>9999-12-31T16:13:23.000Z</published>
    <updated>2020-03-07T05:52:04.738Z</updated>
    
    <content type="html"><![CDATA[<br><font size="3"> 记录Problems list的完成情况 每日更新。<br><a href="https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ6qpA/edit#gid=972946549" target="_blank" rel="noopener"><font size="4">🔗 Problems List  Link </font></a><br>Github Leetcode Summary 同步更新。<br><a href="https://github.com/WangHngLeee/LeetcodeSummary" target="_blank" rel="noopener"><font size="4">🔗 Github Summary Link </font></a><br>2020/03/02 —— 500题成就达成 💪</font><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br&gt;
&lt;font size=&quot;3&quot;&gt; 记录Problems list的完成情况 每日更新。&lt;br&gt;
&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ
      
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Problems List" scheme="WangHngLeee.github.io/tags/Problems-List/"/>
    
  </entry>
  
  <entry>
    <title>Front-end Interview Note 6 💪</title>
    <link href="WangHngLeee.github.io/2020/06/24/frontend-interview-06/"/>
    <id>WangHngLeee.github.io/2020/06/24/frontend-interview-06/</id>
    <published>2020-06-24T12:05:35.000Z</published>
    <updated>2020-06-24T23:18:50.414Z</updated>
    
    <content type="html"><![CDATA[<h1>JS</h1><p>这几天复习了一下JS的知识，发现有些知识点变模糊了，于是打算写一篇JS常见问题的总结帖巩固一下。</p><h2 id="JS里的深浅拷贝">JS里的深浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">letet a a = &#123;</span><br><span class="line">    age     : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 输出为2</span></span><br></pre></td></tr></table></figure><ul><li>上述例子可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</li><li>通常在开发中并不希望出现这样的问题，于是浅拷贝就可以来解决这个问题</li></ul><h3 id="浅拷贝">浅拷贝</h3><blockquote><p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>也可以通过展开运算符<code>（…）</code>来解决</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当遇到如下情况就需要使用到深拷贝了</p></blockquote><a id="more"></a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝只能解决一层数据的问题，如果接下去的值中还有对象的话，那么就又回到原来的问题了，两者享有相同的引用。要解决这个问题，需要使用深拷贝。</p></blockquote><h3 id="深拷贝">深拷贝</h3><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><blockquote><p>将对象所有的内容变成JSON格式，再解析JSON出来即可。但是该方法也是有局限性的：</p></blockquote><ul><li>会忽略 <code>undefined</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure><blockquote><p>如果有一个循环引用对象，会发现并不能通过该方法深拷贝</p></blockquote><ul><li>在遇到函数或者 <code>undefined</code> 的时候，该对象也不能正常的序列化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    name: <span class="string">'poetries'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "poetries"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在上述情况中，该方法会忽略掉<code>函数</code>和<code>undefined</code>。</li><li>但是在通常情况下，复杂数据都是可以序列化的，所以<code>JSON.parse</code>和<code>JSON.stringify</code>函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。如果数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数。</li></ul><h2 id="原型问题">原型问题</h2><p><img src="https://camo.githubusercontent.com/71cab2efcf6fb8401a2f0ef49443dd94bffc1373/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f31332f313632316538613962636230383732643f773d34383826683d35393026663d706e6726733d313531373232" alt></p><ul><li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li><li>每个对象都有 <code>__proto__ </code>属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</li><li>对象可以通过<code> __proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链</li></ul><h2 id="instanceof-和-typeof-的区别">instanceof 和 typeof 的区别</h2><h3 id="typeof">typeof</h3><blockquote><p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>null </code>来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 <code>bug</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof null // &apos;object&apos;</span><br></pre></td></tr></table></figure><blockquote><p>原因：因为在 <code>JS </code>的最初版本中，使用的是 <code>32</code> 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null </code>表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个<code>bug</code>却是一直流传下来。</p></blockquote><ul><li>如果想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call(xxxx)</code>。这样就可以获得类似 <code>[object Type]</code> 的字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( a ) );</span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( b ) );</span><br><span class="line"><span class="built_in">console</span>.log( object.prototype.toString.call( c ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[object <span class="built_in">String</span>];</span><br><span class="line">[object <span class="built_in">Array</span>];</span><br><span class="line">[object <span class="built_in">Function</span>];</span><br><span class="line"></span><br><span class="line">因此,想要得到具体的类型可以字符串截取：</span><br><span class="line"> <span class="built_in">console</span>.log( object.prototype.toString.call( a ).slice( <span class="number">8</span>, <span class="number">-1</span>) );</span><br><span class="line">结果: <span class="built_in">String</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="comment">// 也可以这样判断 undefined</span></span><br><span class="line">a === <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="instanceof">instanceof</h3><blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Bar; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果仅仅设置 Bar.prototype 为函数 Foo 本身，而不是 Foo 构造函数的一个实例</span></span><br><span class="line">Bar.prototype = Foo;</span><br><span class="line"><span class="keyword">new</span> Bar() <span class="keyword">instanceof</span> Foo; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="闭包">闭包</h2><blockquote><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么函数 <code>A </code>已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A </code>中的变量？ 因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS </code>引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p></blockquote><p>经典中的经典面试题，循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出会是一堆6</span></span><br></pre></td></tr></table></figure><ul><li>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code>。</li><li>解决办法两种，第一种使用闭包和<code>immediately-invoked function expression (IIFE)</code>方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, i*<span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 形成块级作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;JS&lt;/h1&gt;
&lt;p&gt;这几天复习了一下JS的知识，发现有些知识点变模糊了，于是打算写一篇JS常见问题的总结帖巩固一下。&lt;/p&gt;
&lt;h2 id=&quot;JS里的深浅拷贝&quot;&gt;JS里的深浅拷贝&lt;/h2&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;letet a a = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age     : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.age = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.age) &lt;span class=&quot;comment&quot;&gt;// 输出为2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;上述例子可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。&lt;/li&gt;
&lt;li&gt;通常在开发中并不希望出现这样的问题，于是浅拷贝就可以来解决这个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;浅拷贝&quot;&gt;浅拷贝&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先可以通过 &lt;code&gt;Object.assign&lt;/code&gt; 来解决这个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.assign(&amp;#123;&amp;#125;, a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.age = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.age) &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以通过展开运算符&lt;code&gt;（…）&lt;/code&gt;来解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; b = &amp;#123;...a&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.age = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b.age) &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;通常浅拷贝就能解决大部分问题了，但是当遇到如下情况就需要使用到深拷贝了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Interview" scheme="WangHngLeee.github.io/categories/Interview/"/>
    
    
      <category term="Front-end" scheme="WangHngLeee.github.io/tags/Front-end/"/>
    
      <category term="Interview Questions" scheme="WangHngLeee.github.io/tags/Interview-Questions/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 102 / DFS(1) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/14/dfs01/"/>
    <id>WangHngLeee.github.io/2020/06/14/dfs01/</id>
    <published>2020-06-14T17:53:35.000Z</published>
    <updated>2020-06-14T22:22:35.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-332-Reconstruct-Itinerary-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">332. Reconstruct Itinerary</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p><p>Note:</p><p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.<br>One must use all the tickets once and only once.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].</span><br><span class="line">But it is larger in lexical order.</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();;</span><br><span class="line">    Map&lt;String,PriorityQueue&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets == <span class="keyword">null</span> || tickets.size() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; ticket : tickets)&#123;</span><br><span class="line">            map.putIfAbsent(ticket.get(<span class="number">0</span>),<span class="keyword">new</span> PriorityQueue&lt;&gt;());</span><br><span class="line">            map.get(ticket.get(<span class="number">0</span>)).add(ticket.get(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="string">"JFK"</span>);<span class="comment">//类似tree的postorder遍历，</span></span><br><span class="line">        Collections.reverse(res);<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String start)</span></span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; ends = map.get(start);</span><br><span class="line">        <span class="keyword">while</span>(ends != <span class="keyword">null</span> &amp;&amp; !ends.isEmpty())&#123;</span><br><span class="line">            dfs(ends.poll());<span class="comment">//不断遍历children，也就是当前map里start对应的ends里lexi最小的那个。</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using pq to make sure that every polled element is the smallest leximal one. DFS is just like tree postorder traversal, we need to find the minmum leximal city as start, which is same as traversing children treenode at first. Then we add the root value to the res in the last.</p><iframe width="560" height="315" src="https://www.youtube.com/embed/4udFSOWQpdg?start=278" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-28B463-font-color-white-339-Nested-List-Weight-Sum-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">339. Nested List Weight Sum</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><h3 id="Example-v2">Example</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Four 1&apos;s at depth 2, one 2 at depth 1.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 27</span><br><span class="line">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><ol><li><p>In dfs we only recursively to call the function in NestedInteger.</p></li><li><p>In bfs we can regard the nums like tree level traversal. The Integer one is root node, and nestedinteger is like the next levels’s nodes.</p></li></ol><p>DFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger nest : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nest.isInteger()) &#123;</span><br><span class="line">                sum += depth * nest.getInteger();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += helper(nest.getList(), depth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())sum+=temp.getInteger()*level;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-364-Nested-List-Weight-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">364. Nested List Weight Sum II</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v3">Example</h3><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: 8 </span><br><span class="line">Explanation: Four 1&apos;s at depth 1, one 2 at depth 2.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 17 </span><br><span class="line">Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><p>It is a little different from the 339. In this question the nestedinteger has the lower depth and single integer has higher depth.</p><ol><li><p>DFS: First we find the total depth of the nestedlist,then we loop each element in the nestedlist,if it is integer then we multiply it by the layer, else we recursevely call the getSum function.</p></li><li><p>BFS: We use presum to store the temp sum of each layer.</p></li></ol><p>DFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span> || nestedList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = helper(nestedList);</span><br><span class="line">        <span class="keyword">int</span> res = getSum(nestedList, h);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(List&lt;NestedInteger&gt; l, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || l.size() == <span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger n : l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.isInteger()) sum += n.getInteger() * layer;</span><br><span class="line">            <span class="keyword">else</span> sum += getSum(n.getList(), layer - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span> || l.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger n : l) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n.isInteger()) max = Math.max(max, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> max = Math.max(max, helper(n.getList()) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prevsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> levelsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())levelsum+=temp.getInteger();</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prevsum+=levelsum;</span><br><span class="line">            total+=prevsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-472-Concatenated-Words-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">472. Concatenated Words</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/concatenated-words/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.<br>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]</span><br><span class="line">Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; </span><br><span class="line"> &quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; </span><br><span class="line">&quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;.</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Arrays.sort(words,(a,b)-&gt;a.length() - b.length());<span class="comment">//sort the words with its length</span></span><br><span class="line">        <span class="keyword">for</span>(String str : words)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.length() &gt; <span class="number">0</span> &amp;&amp; check(set,str))&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Set&lt;String&gt; set, String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(str))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            String temp = str.substring(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(set,str.substring(i)))&#123;</span><br><span class="line">                    set.add(str);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We first sort the str array from min length to max length. Then we add each string to set. Before add it to the set, we check it with the current set to see whether current word can be made up by any words in the set. We loop each part of the string, if one part exist in the set, then we recursively call the check function to see the other part.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-332-Reconstruct-Itinerary-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;332. Reconstruct Itinerary&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reconstruct-itinerary/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].&lt;br&gt;
All airports are represented by three capital letters (IATA code).&lt;br&gt;
You may assume all tickets form at least one valid itinerary.&lt;br&gt;
One must use all the tickets once and only once.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [[&amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;], [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;], [&amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;], [&amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [&amp;quot;JFK&amp;quot;, &amp;quot;MUC&amp;quot;, &amp;quot;LHR&amp;quot;, &amp;quot;SFO&amp;quot;, &amp;quot;SJC&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [[&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;],[&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;],[&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Another possible reconstruction is [&amp;quot;JFK&amp;quot;,&amp;quot;SFO&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;JFK&amp;quot;,&amp;quot;ATL&amp;quot;,&amp;quot;SFO&amp;quot;].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;But it is larger in lexical order.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;String&amp;gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Map&amp;lt;String,PriorityQueue&amp;lt;String&amp;gt;&amp;gt; map=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span class=&quot;title&quot;&gt;findItinerary&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; tickets)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(tickets == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || tickets.size() == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(List&amp;lt;String&amp;gt; ticket : tickets)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            map.putIfAbsent(ticket.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            map.get(ticket.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)).add(ticket.get(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dfs(&lt;span class=&quot;string&quot;&gt;&quot;JFK&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//类似tree的postorder遍历，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Collections.reverse(res);&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String start)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PriorityQueue&amp;lt;String&amp;gt; ends = map.get(start);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(ends != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !ends.isEmpty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dfs(ends.poll());&lt;span class=&quot;comment&quot;&gt;//不断遍历children，也就是当前map里start对应的ends里lexi最小的那个。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res.add(start);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Using pq to make sure that every polled element is the smallest leximal one. DFS is just like tree postorder traversal, we need to find the minmum leximal city as start, which is same as traversing children treenode at first. Then we add the root value to the res in the last.&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/4udFSOWQpdg?start=278&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="DFS" scheme="WangHngLeee.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 101 / Graph(2) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/13/graph03/"/>
    <id>WangHngLeee.github.io/2020/06/13/graph03/</id>
    <published>2020-06-13T17:53:35.000Z</published>
    <updated>2020-06-13T16:23:54.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-37-Sudoku-Solver-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">37. Sudoku Solver</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/sudoku-solver/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy all of the following rules:</p><p>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>Empty cells are indicated by the character ‘.’.</p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="leetcode 37"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="leetcode 37"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The given board contain only digits 1-9 and the character &apos;.&apos;.</span><br><span class="line">You may assume that the given Sudoku puzzle will have a single unique solution.</span><br><span class="line">The given board size is always 9x9.</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>)<span class="keyword">return</span>; <span class="comment">//corner case</span></span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ;j&lt;board[<span class="number">0</span>].length ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] ==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'1'</span> ; c&lt;=<span class="string">'9'</span> ;c++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(valid(board,i,j,c))&#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span>(solve(board))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;<span class="comment">//used to check every row and col;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">9</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] != <span class="string">'.'</span> &amp;&amp; board[i][col] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// check each col;</span></span><br><span class="line">            <span class="keyword">if</span>(board[row][i] != <span class="string">'.'</span> &amp;&amp; board[row][i] == c)<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check each row;</span></span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">3</span>*(row /<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]!=<span class="string">'.'</span>&amp;&amp;board[<span class="number">3</span>*(row/<span class="number">3</span>)+i/<span class="number">3</span>][<span class="number">3</span>*(col/<span class="number">3</span>)+i%<span class="number">3</span>]==c)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recursively call the solve function to check the graph. We try to put number 1-9 in each empty cell and then check its col and row to find whether there exist duplicate numbers. If not then we return true.</p><p>The tricky part is the last case in valid function. We check each 3x3 grid for a single part in each loop to make sure every number is unique in their 3x3 square area.</p><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-131-Palindrome-Partitioning-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">131. Palindrome Partitioning</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/palindrome-partitioning/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Given a string s, partition s such that every substring of the partition is a palindrome.</p><p>Return all possible palindrome partitioning of s.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(res,temp,<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; temp, <span class="keyword">int</span> start, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(s,start,i))&#123;</span><br><span class="line">                temp.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">                help(res,temp,i+<span class="number">1</span>,s);</span><br><span class="line">                temp.remove(temp.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Common backtracking solution. Only difference is that we use a common method ‘valid’ to check whether a string is palindrome or not.</p><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-980-Unique-Paths-IIIr-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">980. Unique Paths IIIr</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/unique-paths-iii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples-v2">Examples</h3><p>On a 2-dimensional grid, there are 4 types of squares:</p><p>1 represents the starting square.  There is exactly one starting square.<br>2 represents the ending square.  There is exactly one ending square.<br>0 represents empty squares we can walk over.<br>-1 represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths:</span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, empty = <span class="number">1</span>, startx, starty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) empty++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    startx = i;</span><br><span class="line">                    starty = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(grid, startx, starty);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.length || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || grid[x][y] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y]==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (empty == <span class="number">0</span>) res++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = -<span class="number">2</span>;</span><br><span class="line">        empty--;</span><br><span class="line">        dfs(grid, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(grid, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(grid, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, x, y - <span class="number">1</span>);</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        empty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we find the start point, then using dfs and backtracking to find the unique path to the end point. Triky point is that the initial empty num is 1 because start point is caculated as empty too.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-37-Sudoku-Solver-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;37. Sudoku Solver&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/sudoku-solver/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Write a program to solve a Sudoku puzzle by filling the empty cells.&lt;/p&gt;
&lt;p&gt;A sudoku solution must satisfy all of the following rules:&lt;/p&gt;
&lt;p&gt;Each of the digits 1-9 must occur exactly once in each row.&lt;br&gt;
Each of the digits 1-9 must occur exactly once in each column.&lt;br&gt;
Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.&lt;br&gt;
Empty cells are indicated by the character ‘.’.&lt;/p&gt;
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png&quot; alt=&quot;leetcode 37&quot;&gt;
&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png&quot; alt=&quot;leetcode 37&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Note:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The given board contain only digits 1-9 and the character &amp;apos;.&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You may assume that the given Sudoku puzzle will have a single unique solution.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The given board size is always 9x9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solveSudoku&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || board.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//corner case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        solve(board);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] board)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;i&amp;lt;board.length;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;j&amp;lt;board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length ;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j] ==&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&#39;1&#39;&lt;/span&gt; ; c&amp;lt;=&lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt; ;c++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(valid(board,i,j,c))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            board[i][j] = c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(solve(board))&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;valid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] board, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//used to check every row and col;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;i&amp;lt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; ;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][col] != &lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt; &amp;amp;&amp;amp; board[i][col] == c)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// check each col;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[row][i] != &lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt; &amp;amp;&amp;amp; board[row][i] == c)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//check each row;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*(row /&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)+i/&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*(col/&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)+i%&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]!=&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;&amp;amp;&amp;amp;board[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*(row/&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)+i/&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*(col/&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)+i%&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]==c)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Recursively call the solve function to check the graph. We try to put number 1-9 in each empty cell and then check its col and row to find whether there exist duplicate numbers. If not then we return true.&lt;/p&gt;
&lt;p&gt;The tricky part is the last case in valid function. We check each 3x3 grid for a single part in each loop to make sure every number is unique in their 3x3 square area.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="BackTracking" scheme="WangHngLeee.github.io/tags/BackTracking/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 100 / Tree(2) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/11/tree02/"/>
    <id>WangHngLeee.github.io/2020/06/11/tree02/</id>
    <published>2020-06-11T17:53:35.000Z</published>
    <updated>2020-06-11T20:15:54.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-96-Unique-Binary-Search-Trees-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">96. Unique Binary Search Trees</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/unique-binary-search-trees/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><p>DP + Math</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt;=i ; j ++)&#123;</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p><p>Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST.</p><p>Take 1,2,3 for example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    G(3)</span><br><span class="line">            /         |             \</span><br><span class="line">     F(1,3)    +    F(2,3)   +    F(3,3)</span><br><span class="line">  (1 as root)     (2 as root)    (3 as root)</span><br><span class="line">     /  \            /  \           /  \</span><br><span class="line">  G(0)  G(1)      G(1) G(1)     G(2)  G(1)</span><br><span class="line">According to defination of BST, so different root have different subtrees.</span><br></pre></td></tr></table></figure><iframe width="560" height="315" src="https://www.youtube.com/embed/GgP75HAvrlY?start=438" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">105. Construct Binary Tree from Preorder and Inorder Traversal</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v2">Example</h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p><p>Note:<br>You may assume that duplicates do not exist in the tree.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, given</span><br><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>|| inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[]inorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is &gt; ie || ps &gt; pe)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> inidx = map.get(preorder[ps]); <span class="comment">// 在inorder里得到node的位置</span></span><br><span class="line">        <span class="keyword">int</span> remains = inidx - is; <span class="comment">// 得到左半部分的剩余</span></span><br><span class="line">        node.left = build(inorder,is,inidx-<span class="number">1</span>,preorder,ps+<span class="number">1</span>,ps+remains,map);</span><br><span class="line">        node.right = build(inorder,inidx+<span class="number">1</span>,ie,preorder,ps+remains+<span class="number">1</span>,pe,map);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recursively building a tree from preorder and inorder array. Root is the first element in preorder, and use that element to find the index in inorder to caculate the left and right part’s length. Using map to store the index and element in the map.</p><p>T:O(n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-863-All-Nodes-Distance-K-in-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">863. All Nodes Distance K in Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v3">Example</h3><p>We are given a binary tree (with root node root), a target node, and an integer value K.</p><p>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="leetcode 863"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line"></span><br><span class="line">Output: [7,4,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)res.add(root.val);</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.right,dist+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using map to store different node’s distance to the target node.(Only sublayer node). Then using dfs to scan each node to caculate the distance. If it is not in the map, it means that node is uplayer of the target, so we using default 0 from root to scan, each step we add 1. If we meet a node that stored in the map, the we use the distance stored in the map to justify the distance.</p><p>T:O(n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-366-Find-Leaves-of-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">366. Find Leaves of Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/find-leaves-of-binary-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v4">Example</h3><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line"></span><br><span class="line">Output: [[4,5,3],[2],[1]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1. Removing the leaves [4,5,3] would result in this tree:</span><br><span class="line">          1</span><br><span class="line">         / </span><br><span class="line">        2          </span><br><span class="line">2. Now removing the leaf [2] would result in this tree:</span><br><span class="line">          1          </span><br><span class="line">3. Now removing the leaf [1] would result in the empty tree:</span><br><span class="line">          []</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><p>Recursive</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,res);</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,res);</span><br><span class="line">        <span class="keyword">int</span> level = Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level+<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using every node’s level to determine whether current node is leaf or not. Leaf node’s level return -1+1=0. Then we add the nodes to res by the order of it’s level. -&gt; 0: 4,5,3  -&gt; 1:2 -&gt; 2:1</p><p>T:O(n) S:O(n)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-96-Unique-Binary-Search-Trees-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;96. Unique Binary Search Trees&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/unique-binary-search-trees/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given n = 3, there are a total of 5 unique BST&amp;apos;s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1         3     3      2      1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    \       /     /      / \      \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     3     2     1      1   3      2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /     /       \                 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   2     1         2                 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;p&gt;DP + Math&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;numTrees&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] dp = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = dp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; i &amp;lt;=n;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ; j&amp;lt;=i ; j ++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                dp[i] += dp[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]*dp[i-j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dp[n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;T:O(n) S:O(n)&lt;/p&gt;
&lt;p&gt;Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST.&lt;/p&gt;
&lt;p&gt;Take 1,2,3 for example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;                    G(3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            /         |             \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     F(1,3)    +    F(2,3)   +    F(3,3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (1 as root)     (2 as root)    (3 as root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /  \            /  \           /  \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  G(0)  G(1)      G(1) G(1)     G(2)  G(1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;According to defination of BST, so different root have different subtrees.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/GgP75HAvrlY?start=438&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="WangHngLeee.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 99 / Graph(2) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/09/graph02/"/>
    <id>WangHngLeee.github.io/2020/06/09/graph02/</id>
    <published>2020-06-09T17:53:35.000Z</published>
    <updated>2020-06-09T22:11:49.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1102-Path-With-Maximum-Minimum-Value-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1102. Path With Maximum Minimum Value</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/path-with-maximum-minimum-value/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].</p><p>The score of a path is the minimum value in that path.  For example, the value of the path 8 →  4 →  5 →  9 is 4.</p><p>A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south).</p><img src="https://assets.leetcode.com/uploads/2019/04/23/1313_ex1.JPG" alt="leetcode 1102"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[5,4,5],[1,2,6],[7,4,6]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: </span><br><span class="line">The path with the maximum score is highlighted in yellow.</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumMinimumPath</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;Integer.compare(b[<span class="number">0</span>],a[<span class="number">0</span>]));</span><br><span class="line">        pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[<span class="number">0</span>][<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> minval = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> m = A.length;</span><br><span class="line">        <span class="keyword">int</span> n = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        seen[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = pq.poll();</span><br><span class="line">            <span class="keyword">int</span> i = temp[<span class="number">1</span>], j= temp[<span class="number">2</span>],val = temp[<span class="number">0</span>];</span><br><span class="line">            minval = Math.min(minval,val);</span><br><span class="line">            <span class="keyword">if</span>(i==m-<span class="number">1</span> &amp;&amp; j==n-<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> newx = i+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> newy = j+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(newx &gt;=<span class="number">0</span> &amp;&amp; newx&lt;m &amp;&amp; newy&gt;=<span class="number">0</span> &amp;&amp; newy&lt;n &amp;&amp; !seen[newx][newy])&#123;</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;A[newx][newy],newx,newy&#125;);</span><br><span class="line">                    seen[newx][newy] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using BFS to keep searching the max value path. Using priorityqueue to keep the max one on the top. And keep the minval to find the minval in the max path.</p><p>T:O(n) S:O(n)</p><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-765-Couples-Holding-Hands-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">765. Couples Holding Hands</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/couples-holding-hands/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p><p>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</p><p>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: row = [0, 2, 1, 3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only need to swap the second (row[1]) and third (row[2]) person.</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UF</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UF</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            parents = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;n ;i++)&#123;</span><br><span class="line">                parents[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">( <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[n] == n)<span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">return</span> parents[n] = find(parents[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(a);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(b);</span><br><span class="line">            <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">                parents[root1] = root2;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="keyword">int</span>[] row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = row.length /<span class="number">2</span>;</span><br><span class="line">        UF unionfind = <span class="keyword">new</span> UF(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;N ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a  = row[i*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> b  = row[i*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            unionfind.union(a/<span class="number">2</span>,b/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionfind.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using UF is more efficient. Just regard each couple is a vertex in the graph, what we need to do is to find the number of unconnected components, which is also the times we need to swap.</p><p>T:O(n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1267-Count-Servers-that-Communicate-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1267. Count Servers that Communicate</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/count-servers-that-communicate/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v2">Example</h3><p>You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.</p><p>Return the number of servers that communicate with any other server.<br><img src="https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg" alt="leetcode 1267"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: grid = [[1,0],[0,1]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: No servers can communicate with others.</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countServers</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        <span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    row[i]++;</span><br><span class="line">                    col[j]++;</span><br><span class="line">                    total++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[i]==<span class="number">1</span> &amp;&amp; col[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                        total--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we loop each vertex in the graph, if it’s value is 1 we add 1 to total and update the row and col array to count the total computers that are on the same row or col. Then we loop the graph again to remove the single computer, which row and col is only 1.</p><p>T:O(m*n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">802. Find Eventual Safe States</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/find-eventual-safe-states/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v3">Example</h3><p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p><p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</p><p>Which nodes are eventually safe?  Return them as an array in sorted order.</p><p>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="leetcode 802"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><p>DFS -  Tarjan’s Torpological</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,i,state))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> node, <span class="keyword">int</span>[] state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[node] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(state[node] == <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        state[node] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,num,state))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: O(V + E) S: O(V)</p><p>Using <a target="_blank" href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#:~:text=Tarjan's%20algorithm%20is%20an%20algorithm,path%2Dbased%20strong%20component%20algorithm.">Tarjan’s algo torpological</a> to find SCC. If there is no SCC then we return true which means we can reach final safe state, then we add current node into res. Otherwise we return false.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-684-Redundant-Connection-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">684. Redundant Connection</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/redundant-connection/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v4">Example</h3><p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p><p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p><p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><h3 id="Solution-v5">Solution</h3><p>Union-Find:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] parents = <span class="keyword">new</span> <span class="keyword">int</span>[edges.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=edges.length; i++)&#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge: edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> root1 = find(parents,edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> root2 = find(parents,edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(root1 == root2)&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parents[root1] = root2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parents, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == parents[i])<span class="keyword">return</span> i;</span><br><span class="line">        parents[i] = find(parents,parents[i]);</span><br><span class="line">        <span class="keyword">return</span> parents[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is clearly that we have to find the edge that cause a loop in the graph. So UF is the best way to do that. Once we find one vertex have the same root with other vertex then we return the edge that current vertex exist in.</p><p>T:O(n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-841-Keys-and-Rooms-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">841. Keys and Rooms</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/keys-and-rooms/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v5">Example</h3><p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room.</p><p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p><p>Initially, all the rooms start locked (except for room 0).</p><p>You can walk back and forth between rooms freely.</p><p>Return true if and only if you can enter every room.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure><h3 id="Solution-v6">Solution</h3><p>BFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(rooms == <span class="keyword">null</span> || rooms.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> key : rooms.get(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set.contains(key))&#123;</span><br><span class="line">                    set.add(key);</span><br><span class="line">                    stack.push(key);</span><br><span class="line">                    <span class="keyword">if</span>(set.size() == rooms.size())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size() == rooms.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p><p>Straight forward solution. Using BFS to get each key and store them in set. Using stack to keep track of the rooms that we just opened.<br>We only need to check whether the size of set and size of rooms are same.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-1102-Path-With-Maximum-Minimum-Value-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;1102. Path With Maximum Minimum Value&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/path-with-maximum-minimum-value/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1].&lt;/p&gt;
&lt;p&gt;The score of a path is the minimum value in that path.  For example, the value of the path 8 →  4 →  5 →  9 is 4.&lt;/p&gt;
&lt;p&gt;A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south).&lt;/p&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2019/04/23/1313_ex1.JPG&quot; alt=&quot;leetcode 1102&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [[5,4,5],[1,2,6],[7,4,6]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The path with the maximum score is highlighted in yellow.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] dirs = &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maximumMinimumPath&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] A)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PriorityQueue&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;gt; pq = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;((a,b)-&amp;gt;Integer.compare(b[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pq.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;#123;A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; minval = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m = A.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n = A[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt;[][] seen = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt;[m][n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        seen[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!pq.isEmpty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] temp = pq.poll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = temp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], j= temp[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],val = temp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minval = Math.min(minval,val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i==m-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; j==n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] dir : dirs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newx = i+dir[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; newy = j+dir[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(newx &amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; newx&amp;lt;m &amp;amp;&amp;amp; newy&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; newy&amp;lt;n &amp;amp;&amp;amp; !seen[newx][newy])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    pq.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;#123;A[newx][newy],newx,newy&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    seen[newx][newy] = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; minval;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Using BFS to keep searching the max value path. Using priorityqueue to keep the max one on the top. And keep the minval to find the minval in the max path.&lt;/p&gt;
&lt;p&gt;T:O(n) S:O(n)&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 98 / Graph(1) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/08/graph01/"/>
    <id>WangHngLeee.github.io/2020/06/08/graph01/</id>
    <published>2020-06-08T17:53:35.000Z</published>
    <updated>2020-06-09T00:36:07.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-207-Course-Schedule-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">207. Course Schedule</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><ol><li>DFS (Tarjan’s Algorithm) with two different state</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = pre[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = pre[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,state,i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span>[] state, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[v] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// current node is being tracking in other dfs process</span></span><br><span class="line">        <span class="keyword">if</span>(state[v] == <span class="number">2</span>)<span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// current node have been tracked so no loop here.</span></span><br><span class="line">        </span><br><span class="line">        state[v] = <span class="number">1</span>; <span class="comment">// change current node to be tracking </span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,state,w))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        state[v] = <span class="number">2</span>; <span class="comment">// after searching and no loop here then we change state to be tracked</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V+E) S:O(V)</p><a id="more"></a><ol start="2"><li>DFS (Tarjan’s Algorithm) with two boolean array</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = pre[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = pre[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">boolean</span>[] tracking = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(graph,marked,tracking,i))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">boolean</span>[] marked, <span class="keyword">boolean</span>[]tracking, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        tracking[v] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: graph[v])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(graph,marked,tracking,w))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tracking[w])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tracking[v] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V+E) S:O(V)</p><ol start="3"><li>BFS</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indegrees = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = prerequisite[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> w = prerequisite[<span class="number">0</span>];</span><br><span class="line">            graph[v].add(w);</span><br><span class="line">            indegrees[w]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; start = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                start.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!start.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = start.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : graph[v]) &#123;</span><br><span class="line">                indegrees[w]--;</span><br><span class="line">                <span class="keyword">if</span> (indegrees[w] == <span class="number">0</span>) &#123;</span><br><span class="line">                    start.add(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V+E) S:O(V)</p><p>DFS solution we use two states / two boolean array to check whether current node is being tracking or have been checked.</p><p>Normal BFS Torpological solution. Using queue to check each course’s indegree. Finally if the total courses left is not 0 then we return false.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-210-Course-Schedule-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">210. Course Schedule II</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v2">Example</h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p><p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class="line">             course 0. So the correct course order is [0,1] .</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. </span><br><span class="line">             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><p>BFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">            indegree[pair[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;indegree.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">                res[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> course = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : prerequisites)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pair[<span class="number">1</span>] == course)&#123;</span><br><span class="line">                    indegree[pair[<span class="number">0</span>]]--;</span><br><span class="line">                    <span class="keyword">if</span>(indegree[pair[<span class="number">0</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(pair[<span class="number">0</span>]);</span><br><span class="line">                        res[index] = pair[<span class="number">0</span>];</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == numCourses ? res : <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS ( to be added)</p><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-133-Clone-Graph-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">133. Clone Graph</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v3">Example</h3><p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png" alt="leetcode 133"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: adjList = [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Output: [[2,4],[1,3],[2,4],[1,3]]</span><br><span class="line">Explanation: There are 4 nodes in the graph.</span><br><span class="line">1st node (val = 1)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).</span><br><span class="line">2nd node (val = 2)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3).</span><br><span class="line">3rd node (val = 3)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).</span><br><span class="line">4th node (val = 4)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3).</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(node);</span><br><span class="line">        map.put(node,dummy);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Node temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(Node nb : temp.neighbors)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!map.containsKey(nb))&#123;</span><br><span class="line">                    map.put(nb,<span class="keyword">new</span> Node(nb.val));</span><br><span class="line">                    queue.add(nb);</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(temp).neighbors.add(map.get(nb));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BFS thoughts. Clone each node to it’s new node and put them into hashmap. Then using dummy node to keep recode of the new map.</p><p>T:O(n) S:O(n)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-207-Course-Schedule-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;207. Course Schedule&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: numCourses = 2, prerequisites = [[1,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: There are a total of 2 courses to take. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             To take course 1 you should have finished course 0. So it is possible.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: numCourses = 2, prerequisites = [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: There are a total of 2 courses to take. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             To take course 1 you should have finished course 0, and to take course 0 you should&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             also have finished course 1. So it is impossible.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DFS (Tarjan’s Algorithm) with two different state&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;canFinish&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] prerequisites)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt;[] graph = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; List[n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            graph[i] = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] pre : prerequisites)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v = pre[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; w = pre[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            graph[v].add(w);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] state = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dfs(graph,state,i))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;Integer&amp;gt;[] graph, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] state, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; v)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state[v] == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// current node is being tracking in other dfs process&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(state[v] == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// current node have been tracked so no loop here.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[v] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// change current node to be tracking &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; w: graph[v])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(dfs(graph,state,w))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        state[v] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// after searching and no loop here then we change state to be tracked&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;T:O(V+E) S:O(V)&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 97 / Tree(1) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/07/tree01/"/>
    <id>WangHngLeee.github.io/2020/06/07/tree01/</id>
    <published>2020-06-07T17:53:35.000Z</published>
    <updated>2020-06-08T13:50:00.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-199-Binary-Tree-Right-Side-View-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">199. Binary Tree Right Side View</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/next-permutation/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><ol><li>DFS</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        dfs(root,res,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res, <span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(depth == res.size())&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right,res,depth+<span class="number">1</span>);</span><br><span class="line">        dfs(root.left,res,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res.</p><p>T:O(n) S:O(n)</p><ol start="2"><li>BFS</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>( i == size-<span class="number">1</span>)res.add(temp.val); <span class="comment">// only add the last node in every level into res</span></span><br><span class="line">                <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)queue.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node.</p><p>T:O(n) S:O(n)</p><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)res.append(<span class="string">"null"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(root.left,res);</span><br><span class="line">            serial(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String source)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = source.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> des(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">des</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.equals(<span class="string">"null"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        node.left = des(queue);</span><br><span class="line">        node.right = des(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In serialize function, we use recursive preorder way to save the tree node’s value into a String. In deserialize function, we use the previous string as source data. Then we recursively to build a new tree using pre-order too.</p><p>T:O(n) S:O(n)</p><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-124-Binary-Tree-Maximum-Path-Sum-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">124. Binary Tree Maximum Path Sum</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples-v2">Examples</h3><p>Given a non-empty binary tree, find the maximum path sum.</p><p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure><h3 id="Solutoin">Solutoin</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>,help(root.left));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>,help(root.right));</span><br><span class="line">        max = Math.max(max,left+right+root.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using revursive to find the max in right / left branch. Max is updated when current node is seen as the root node, so we sum the value of left+right+node.val . But in return line, we can only choose one branch in left/right branch.</p><p>T:O(n) S:O(1)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-236-Lowest-Common-Ancestor-of-a-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">236. Lowest Common Ancestor of a Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v2">Example</h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="leetcode 236"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>)<span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="keyword">null</span>)<span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are three cases:</p><ol><li>when left and right both have return value, it means that two nodes are displayed in both left and right branch. The current root is their LCA, so we return root.</li><li>when left has null, it means two nodes are both in right branch. So we just return right value. Right keep record the first target node we meet.</li><li>when right has null, it means two nodes are both in left branch. So we just return left value. Left keep record the first target node we meet.</li></ol><p>T:O(n) S:O(1)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-98-Validate-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">98. Validate Binary Search Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/validate-binary-search-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v3">Example</h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).</p><p>Assume a BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line"></span><br><span class="line">Input: [2,1,3]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line"></span><br><span class="line">Input: [5,1,4,null,null,3,6]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The root node&apos;s value is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root,Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode root, <span class="keyword">long</span> min, <span class="keyword">long</span> max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt;= min || root.val &gt;= max)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using defination of BST:left &lt; root &lt; right. Then we can set up two max / min boundary to check each layer.</p><p>Tricky: The test case contains large number which can only be included by Long type number.</p><p>T:O(n) S:O(1)</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-987-Vertical-Order-Traversal-of-a-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">987. Vertical Order Traversal of a Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/"><font size="4">🔗 Question Link </font></a></p><h3 id="Example-v4">Example</h3><p>Given a binary tree, return the vertical order traversal of its nodes values.</p><p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p><p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p><p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p><p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.<br><img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure><h3 id="Solution-v5">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            node = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Map&lt;Integer,List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(<span class="number">0</span>,<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.poll();</span><br><span class="line">            min = Math.min(min,temp.x);</span><br><span class="line">            max = Math.max(max,temp.x);</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(<span class="keyword">new</span> pair(temp.x,temp.y,temp.node));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x-<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.left));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right!=<span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x+<span class="number">1</span>,temp.y+<span class="number">1</span>,temp.node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= min ;i&lt;= max; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y);</span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;map.get(i).size() ;j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using HashMap to store each x position’s nodes. And then sort each nodes wiht it’s y’s positon value. If two nodes have same y position, then sort them with node’s value.</p><p>T:O(n^2logn) S:O(n)</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-199-Binary-Tree-Right-Side-View-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;199. Binary Tree Right Side View&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/next-permutation/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [1,2,3,null,5,null,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1, 3, 4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   1            &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /   \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2     3         &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; \     \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5     4       &amp;lt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DFS&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;rightSideView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dfs(root,res,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root, List&amp;lt;Integer&amp;gt; res, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; depth)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(depth == res.size())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.add(root.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dfs(root.right,res,depth+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dfs(root.left,res,depth+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res.&lt;/p&gt;
&lt;p&gt;T:O(n) S:O(n)&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;BFS&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;rightSideView&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Queue&amp;lt;TreeNode&amp;gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        queue.add(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!queue.isEmpty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size = queue.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;i&amp;lt;size;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                TreeNode temp = queue.poll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( i == size-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)res.add(temp.val); &lt;span class=&quot;comment&quot;&gt;// only add the last node in every level into res&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(temp.left!=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)queue.add(temp.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(temp.right!=&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)queue.add(temp.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node.&lt;/p&gt;
&lt;p&gt;T:O(n) S:O(n)&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="WangHngLeee.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 96 / Array(2) 💪</title>
    <link href="WangHngLeee.github.io/2020/06/06/array02/"/>
    <id>WangHngLeee.github.io/2020/06/06/array02/</id>
    <published>2020-06-06T17:53:35.000Z</published>
    <updated>2020-06-13T15:16:39.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-31-Next-Permutation-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">31. Next Permutation</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Example">Example</h3><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be in-place and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span> ;i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                val = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == -<span class="number">1</span>)&#123; <span class="comment">// already sort in descending order like 321 then we return 123</span></span><br><span class="line">            reverse(nums,<span class="number">0</span>,len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len ;i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; val)&#123;</span><br><span class="line">                swap(nums,pos,i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums,pos+<span class="number">1</span>,len);<span class="comment">// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            swap(nums,start,end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p><p>From end to start we need to find the first num target which cause drop and keep record ot it’s pos and value. Then we start from end again to find the first num that is bigger than than target’s value. Then we swap this num with the target num , then reverse the array from pos+1 to len.</p><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-54-Spiral-Matrix-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">54. Spiral Matrix</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> down = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.size() &lt; m*n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left ;i &lt;= right &amp;&amp; res.size() &lt; n * m ;i++)&#123;</span><br><span class="line">                res.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top + <span class="number">1</span> ; i&lt;= down-<span class="number">1</span> &amp;&amp; res.size() &lt; m * n ;i++)&#123;</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right ;i&gt;= left &amp;&amp; res.size() &lt; m*n;i--)&#123;</span><br><span class="line">                res.add(matrix[down][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = down-<span class="number">1</span> ;i&gt;=top+<span class="number">1</span> &amp;&amp; res.size() &lt; m * n;i--)&#123;</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)<br>Simple idea. Just loop the matrix from left-&gt; right, top-&gt;down, right-&gt;left, down-&gt;top. Then minus each value by 1.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-289-Game-of-Life-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">289. Game of Life</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples-v2">Examples</h3><p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>Any live cell with two or three live neighbors lives on to the next generation.<br>Any live cell with more than three live neighbors dies, as if by over-population…<br>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</p><p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dir =&#123;&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dir)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[<span class="number">0</span>]+i&lt;<span class="number">0</span> || d[<span class="number">0</span>]+i&gt;=board.length || d[<span class="number">1</span>]+j&lt;<span class="number">0</span> || d[<span class="number">1</span>]+j&gt;=board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">1</span> || board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">2</span>) live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">0</span> &amp;&amp; live==<span class="number">3</span>) board[i][j]=<span class="number">3</span>;<span class="comment">// dead to live</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live&lt;<span class="number">2</span> || live&gt;<span class="number">3</span>)) board[i][j]=<span class="number">2</span>; <span class="comment">// live to dead</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live ==<span class="number">2</span> || live ==<span class="number">3</span>))board[i][j]=<span class="number">1</span>; <span class="comment">// continue live;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                board[i][j]%=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(mn) S:O(1)</p><p>Tricky point is that we can use three state to keep record of the next generation.</p><p>1-&gt; live cell continue to live</p><p>2-&gt; live cell died due to lives &lt;2 or lives&gt;3</p><p>3-&gt; dead cell become live due to lives ==2 or lives ==3</p><p>After that we can use %2 to caculate whether it’s 0 or 1.</p><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-128-Longest-Consecutive-Sequence-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">128. Longest Consecutive Sequence</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples-v3">Examples</h3><p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p><p>Your algorithm should run in O(n) complexity.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//corner case</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> left = map.getOrDefault(num-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">int</span> right = map.getOrDefault(num+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                sum += left + right + <span class="number">1</span>;</span><br><span class="line">                max = Math.max(max,sum);</span><br><span class="line">                map.put(num,sum);</span><br><span class="line">                map.put(num-left,sum);</span><br><span class="line">                map.put(num+right,sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p><p>Everytime we just to find max continus length of num-1 and num+1, then we mix them up to form a new sum of current num. Then we update max , and also update the num-left, num+right with new sum value, it works because left and right is the length of continus length.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1054-Distant-Barcodes-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1054. Distant Barcodes</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/distant-barcodes/"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples-v4">Examples</h3><p>n a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].</p><p>Rearrange the barcodes so that no two adjacent barcodes are equal.  You may return any answer, and it is guaranteed an answer exists.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,1,1,2,2,2]</span><br><span class="line">Output: [2,1,2,1,2,1]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,1,1,1,2,2,3,3]</span><br><span class="line">Output: [1,3,1,3,2,1,2,1]</span><br></pre></td></tr></table></figure><h3 id="Solution-v5">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rearrangeBarcodes(<span class="keyword">int</span>[] barcodes) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[barcodes.length];</span><br><span class="line">        <span class="keyword">if</span>(barcodes.length == <span class="number">0</span> || barcodes == <span class="keyword">null</span>)<span class="keyword">return</span> res;<span class="comment">//corner case</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b : barcodes)&#123;</span><br><span class="line">            map.put(b,map.getOrDefault(b,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;b[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key: map.keySet())&#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;key,map.get(key)&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = pq.poll();</span><br><span class="line">            <span class="keyword">while</span>(temp[<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res[idx] = temp[<span class="number">0</span>];</span><br><span class="line">                temp[<span class="number">1</span>]--;</span><br><span class="line">                idx+=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(idx&gt;=barcodes.length)idx=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(nlogn) S:O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-31-Next-Permutation-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;31. Next Permutation&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/next-permutation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.&lt;/p&gt;
&lt;p&gt;If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).&lt;/p&gt;
&lt;p&gt;The replacement must be in-place and use only constant extra memory.&lt;/p&gt;
&lt;p&gt;Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1,2,3 → 1,3,2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3,2,1 → 1,2,3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1,1,5 → 1,5,1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nextPermutation&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = nums.length -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pos = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = len-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ;i&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;i--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nums[i] &amp;lt; nums[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                pos = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                val = nums[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(pos == -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// already sort in descending order like 321 then we return 123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            reverse(nums,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,len);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = len ;i&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;i--)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nums[i] &amp;gt; val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                swap(nums,pos,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        reverse(nums,pos+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,len);&lt;span class=&quot;comment&quot;&gt;// 1 2 5 4 1 =&amp;gt; 1 4 5 2 1 =&amp;gt; 1 4 1 2 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(start &amp;lt;= end)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            swap(nums,start,end);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            start++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            end--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; start, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; end)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = nums[start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums[start] = nums[end];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums[end] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;T:O(n) S:O(1)&lt;/p&gt;
&lt;p&gt;From end to start we need to find the first num target which cause drop and keep record ot it’s pos and value. Then we start from end again to find the first num that is bigger than than target’s value. Then we swap this num with the target num , then reverse the array from pos+1 to len.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 95 / Array(1) ðŸ’ª</title>
    <link href="WangHngLeee.github.io/2020/06/03/array01/"/>
    <id>WangHngLeee.github.io/2020/06/03/array01/</id>
    <published>2020-06-03T17:53:35.000Z</published>
    <updated>2020-06-07T14:02:34.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-42-Trapping-Rain-Water-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">42. Trapping Rain Water</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height == <span class="keyword">null</span> || height.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmost = Integer.MIN_VALUE; <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">int</span> rightmost = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            leftmost = Math.max(leftmost,height[left]);</span><br><span class="line">            rightmost = Math.max(rightmost,height[right]);</span><br><span class="line">            <span class="keyword">if</span>(leftmost &lt; rightmost)&#123;</span><br><span class="line">                area+=leftmost-height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                area+=rightmost-height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1.</p><a id="more"></a><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-238-Product-of-Array-Except-Self-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">238. Product of Array Except Self</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples-v2">Examples</h3><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br><span class="line">Constraint: It&apos;s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                left = left * nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length-<span class="number">1</span>; j&gt;=<span class="number">0</span> ;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                right = right * nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = res[j] * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First from left to get the left multiply num, then from right to left to get the final result.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-152-Maximum-Product-Subarray-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">152. Maximum Product Subarray</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples-v3">Examples</h3><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;nums.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)max = sum;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j&lt;nums.length ;j++)&#123;</span><br><span class="line">                sum = sum * nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; max)max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Simple two side for loops solution.</p><hr><h2 id="table-tr-td-bgcolor-28B463-font-color-white-121-Best-Time-to-Buy-and-Sell-Stock-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">121. Best Time to Buy and Sell Stock</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples-v4">Examples</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Note that you cannot sell a stock before you buy one.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure><h3 id="Soluiton">Soluiton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &gt; min)&#123;</span><br><span class="line">                max = Math.max(prices[i]-min,max);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set first day’s value to be min which is like the price to buy in. Max is the value that to sell.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-56-Merge-Intervals-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">56. Merge Intervals</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples-v5">Examples</h3><p>Given a collection of intervals, merge all overlapping intervals.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals)&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span> )<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] item : intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end &gt;= item[<span class="number">0</span>])&#123; <span class="comment">// [0,4][1,3]</span></span><br><span class="line">                end = Math.max(end,item[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">                start = item[<span class="number">0</span>];</span><br><span class="line">                end = item[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Classic merge intervals questions. Using start and end to decide whether merge a new interval or add current interval into answer.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-560-Subarray-Sum-Equals-K-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">560. Subarray Sum Equals K</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><h3 id="Examples-v6">Examples</h3><p>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h3 id="Solution-v5">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum = sum + num;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum - k))&#123;</span><br><span class="line">                count+=map.get(sum-k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using presum to precaculate the sum with different length of nums in array.</p><p>Eg:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array : 1 1 1 1 1</span><br><span class="line">       0:1</span><br><span class="line">       1:1</span><br><span class="line"> map -&gt;2:1</span><br><span class="line">       3:1</span><br><span class="line">       4:1</span><br><span class="line">       5:1</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-42-Trapping-Rain-Water-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;42. Trapping Rain Water&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;ðŸ”— Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;br&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [0,1,0,2,1,0,1,3,2,1,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Solution&quot;&gt;Solution&lt;/h3&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;trap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] height)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(height == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || height.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; leftmost = Integer.MIN_VALUE; &lt;span class=&quot;comment&quot;&gt;//corner case&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rightmost = Integer.MIN_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right = height.length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; area = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(left &amp;lt; right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            leftmost = Math.max(leftmost,height[left]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rightmost = Math.max(rightmost,height[right]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(leftmost &amp;lt; rightmost)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                area+=leftmost-height[left];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                left++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                area+=rightmost-height[right];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                right--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; area;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 94 / String(2) ðŸ’ª</title>
    <link href="WangHngLeee.github.io/2020/06/02/string02/"/>
    <id>WangHngLeee.github.io/2020/06/02/string02/</id>
    <published>2020-06-02T17:53:35.000Z</published>
    <updated>2020-06-06T01:33:53.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-609-Find-Duplicate-File-in-System-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">609. Find Duplicate File in System</font> </td></tr></table></h2><p><a href="https://leetcode.com/problems/find-duplicate-file-in-system/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><p>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p><h3 id="Example">Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]</span><br><span class="line">Output:</span><br><span class="line">[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,Set&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : paths)&#123;</span><br><span class="line">            String[] strs = str.split(<span class="string">"\\s++"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i&lt;strs.length ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = strs[i].indexOf(<span class="string">'('</span>);</span><br><span class="line">                String msg = strs[i].substring(idx);</span><br><span class="line">                String totalName = strs[<span class="number">0</span>] + <span class="string">"/"</span> + strs[i].substring(<span class="number">0</span>,idx);</span><br><span class="line">                Set&lt;String&gt; names = map.getOrDefault(msg,<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                names.add(totalName);</span><br><span class="line">                map.put(msg,names);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key).size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(map.get(key)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p><p>First we split the string with &quot; &quot; to seprate the string with two parts : paths + file.<br>Then we go to the file part, and find the message in it using “(”, we split the file with two part: file name + file message.<br>Using map and set to store the file like &quot; message -&gt; Set <paths of file> &quot;. Then we add the path in the set to final res list.</paths></p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-767-Reorganize-String-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">767. Reorganize String</font> </td></tr></table></h2><p><a href="https://leetcode.com/problems/reorganize-string/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><p>Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.</p><p>If possible, output any possible result.  If not possible, return the empty string.</p><h3 id="Example-v2">Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: S = &quot;aab&quot;</span><br><span class="line">Output: &quot;aba&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: S = &quot;aaab&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; S.length() ;i++)&#123;</span><br><span class="line">            arr[S.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, letter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                letter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max &gt; (S.length() + <span class="number">1</span>)/<span class="number">2</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(arr[letter] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            res[index] = (<span class="keyword">char</span>)(letter +<span class="string">'a'</span>);</span><br><span class="line">            index+=<span class="number">2</span>;</span><br><span class="line">            arr[letter]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(index &gt;= S.length())&#123;</span><br><span class="line">                    index = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[index] = (<span class="keyword">char</span>)(i + <span class="string">'a'</span>);</span><br><span class="line">                index+=<span class="number">2</span>;</span><br><span class="line">                arr[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p><p>Easy thoughts: We first find the char with max currency and put it on the even positin first like 0,2,4,6… Then we keep to put all other chars in the remained position.</p><p>If we get the end of the size of string, we turn back to the position of 1 and keep put char in it.<br>It easy to understand with the following explain.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a _ a _ a _ _ _ _ // fill in &quot;a&quot; at position 0, 2, 4</span><br><span class="line">a b a _ a _ b _ b // fill in &quot;b&quot; at position 6, 8, 1</span><br><span class="line">a b a c a _ b _ b // fill in &quot;c&quot; at position 3</span><br><span class="line">a b a c a d b d b // fill in &quot;d&quot; at position 5, 7</span><br></pre></td></tr></table></figure><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-32-Longest-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">32. Longest Valid Parentheses</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><h3 id="Example-v3">Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;(()&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;)()())&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is &quot;()()&quot;</span><br></pre></td></tr></table></figure><h3 id="Solution-v3">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)open++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(open &gt;<span class="number">0</span> &amp;&amp; s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-dp[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i]+=dp[i-dp[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                open--;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(dp[i],max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DP problem. When we meet ‘)’ and open &gt;0 then we start dp operation.</p><p>Tricky point is the line in the bellow:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(i-dp[i] &gt; 0)&#123;</span><br><span class="line">    dp[i]+=dp[i-dp[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We are looking for the longest continuous parentheses, so we have to check the dp value before the current valid length.</p><p>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">()()() // case 1</span><br><span class="line">((())) // case 2</span><br></pre></td></tr></table></figure><p>In case 1, only we meet ) then we can make current dp to 2, but after that we will back to the value of 0. So we have to check whether there is valid length before the current length.</p><p>In case 2 it is normal way what we think in the first time.</p><hr><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-43-Multiply-Strings-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">43. Multiply Strings</font> </td></tr></table></h2><p><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener"><font size="4">ðŸ”— Question Link </font></a></p><p>Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</p><h3 id="Example-v4">Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure><h3 id="Solution-v4">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = num1.length();</span><br><span class="line">        <span class="keyword">int</span> n = num2.length();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> mul = (num1.charAt(i)-<span class="string">'0'</span>) * (num2.charAt(j)-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">int</span> pos1 = i+j,pos2 = i+j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = arr[pos2] + mul;</span><br><span class="line">                arr[pos1] += sum / <span class="number">10</span>;</span><br><span class="line">                arr[pos2] = sum % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(sb.length() == <span class="number">0</span> &amp;&amp; num == <span class="number">0</span>))&#123;</span><br><span class="line">                sb.append(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"0"</span> : sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n^2) S:O(1)</p><p>We simulate the multiply process. Using pos1 and pos2 to store the carry.<br>For example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1 2 5</span><br><span class="line">    * 3 2</span><br><span class="line">    ------</span><br><span class="line">      1 0 ( 5*2 ) step 1</span><br><span class="line">    0 4   ( 2*2 ) step 2</span><br><span class="line">  0 2     ( 1*2 ) .... 3</span><br><span class="line">    1 5   ( 3*5 ) .... 4</span><br><span class="line">  0 6   ...</span><br><span class="line">0 3   ...</span><br><span class="line">--------------</span><br><span class="line">  4 0 0 0</span><br></pre></td></tr></table></figure><p>Like above, cause every time we caculate the two number to get mul, then we have to use the last time’s pos1 value, which is the same as current pos2’s vlaue. Then after caculate that we add them together to get the final value string.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-609-Find-Duplicate-File-in-System-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;609. Find Duplicate File in System&lt;/font&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/find-duplicate-file-in-system/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;ðŸ”— Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&amp;quot;root/a 1.txt(abcd) 2.txt(efgh)&amp;quot;, &amp;quot;root/c 3.txt(abcd)&amp;quot;, &amp;quot;root/c/d 4.txt(efgh)&amp;quot;, &amp;quot;root 4.txt(efgh)&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[&amp;quot;root/a/2.txt&amp;quot;,&amp;quot;root/c/d/4.txt&amp;quot;,&amp;quot;root/4.txt&amp;quot;],[&amp;quot;root/a/1.txt&amp;quot;,&amp;quot;root/c/3.txt&amp;quot;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>New App Deployed 🎉</title>
    <link href="WangHngLeee.github.io/2020/05/31/app1/"/>
    <id>WangHngLeee.github.io/2020/05/31/app1/</id>
    <published>2020-05-31T16:13:54.000Z</published>
    <updated>2020-06-20T16:25:18.757Z</updated>
    
    <content type="html"><![CDATA[<h1>Covid-19 Tracker App now available online ! 💊</h1><p><a href="https://leeemask.com/covid-track/" target="_blank" rel="noopener"><font size="4"> 🔗 COVID-19 tracker </font></a></p><p>Brief content of the application.</p><img src="https://s1.ax1x.com/2020/06/01/t3OiWj.md.png"><p>Skill included:</p><ul><li>React, JavaScript, Chart.js, axios, MongoDB, ElementUI…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Covid-19 Tracker App now available online ! 💊&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://leeemask.com/covid-track/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font 
      
    
    </summary>
    
      <category term="Depolyed Web App" scheme="WangHngLeee.github.io/categories/Depolyed-Web-App/"/>
    
    
      <category term="Web Application" scheme="WangHngLeee.github.io/tags/Web-Application/"/>
    
      <category term="React" scheme="WangHngLeee.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 93 / String(1) 💪</title>
    <link href="WangHngLeee.github.io/2020/05/30/string01/"/>
    <id>WangHngLeee.github.io/2020/05/30/string01/</id>
    <published>2020-05-30T17:53:35.000Z</published>
    <updated>2020-06-02T21:14:03.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-14-Longest-Common-Prefix-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">14. Longest Common Prefix</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener"><font size="4">🔗 Question Link </font></a></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><h3 id="Example">Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h3 id="Solution">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; strs.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(pre)!=<span class="number">0</span>)&#123;</span><br><span class="line">                pre = pre.substring(<span class="number">0</span>,pre.length()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: O(n) S: O(1)</p><p>Using tricky of function of indexOf to get the first positoin of string. We take first string as comparator, then loop all the other strings to check if the first position of comparator in these strings is 0. If not 0, then we shrink the comparator string’s length - 1.</p><hr><h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-10-Regular-Expression-Matching-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">10. Regular Expression Matching</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><p>Given an input string (s) and a pattern §, implement regular expression matching with support for ‘.’ and ‘*’.</p><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p>Note:</p><p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><h3 id="Solution-v2">Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] state = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        state[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; state[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (state[<span class="number">0</span>][j - <span class="number">1</span>] || (j &gt; <span class="number">1</span> &amp;&amp; state[<span class="number">0</span>][j - <span class="number">2</span>])) &#123;</span><br><span class="line">                    state[<span class="number">0</span>][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; state.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; state[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    state[i][j] = state[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != p.charAt(j - <span class="number">2</span>) &amp;&amp; p.charAt(j - <span class="number">2</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">                        state[i][j] = state[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        state[i][j] = state[i - <span class="number">1</span>][j] || state[i][j - <span class="number">1</span>] || state[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DP solution.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];</span><br><span class="line">2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];</span><br><span class="line">3, If p.charAt(j) == &apos;*&apos;: </span><br><span class="line">here are two sub conditions:</span><br><span class="line">    1   if p.charAt(j-1) != s.charAt(i) </span><br><span class="line">           dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty</span><br><span class="line">    2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;:</span><br><span class="line">           dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a </span><br><span class="line">        or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a</span><br><span class="line">        or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-14-Longest-Common-Prefix-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;14. Longest Common Prefix&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;
&lt;p&gt;If there is no common prefix, return an empty string “”.&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &amp;quot;fl&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 92 💪</title>
    <link href="WangHngLeee.github.io/2020/05/24/code02/"/>
    <id>WangHngLeee.github.io/2020/05/24/code02/</id>
    <published>2020-05-24T22:15:39.000Z</published>
    <updated>2020-05-24T22:26:31.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-130-Surrounded-Regions-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">130. Surrounded Regions</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener"><font size="4">ðŸ”—Question Link </font></a></p><ul><li>BFS Solution :</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (i==<span class="number">0</span> || i==row-<span class="number">1</span> || j==<span class="number">0</span> || j==col-<span class="number">1</span> ) &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                    board[i][j] = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; board[x][y] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    board[x][y] = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'a'</span>)board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DFS Solution :</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length &lt; <span class="number">3</span> || board[<span class="number">0</span>].length &lt; <span class="number">3</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> row = board.length;</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( (i==<span class="number">0</span> || i==row-<span class="number">1</span> || j==<span class="number">0</span> || j==col-<span class="number">1</span> ) &amp;&amp; board[i][j] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                    helper(i,j,board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; row ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;col ; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'a'</span>)board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">char</span>[][]board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt;= board.length - <span class="number">1</span> &amp;&amp; c &lt;= board[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; board[r][c] == <span class="string">'O'</span>)&#123;</span><br><span class="line">            board[r][c] = <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = r + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = c + dir[<span class="number">1</span>];</span><br><span class="line">                helper(x,y,board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into ‘a’. After that, we make a loop of the whole board to change ‘a’ into O and all other Os into ‘X’.</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-130-Surrounded-Regions-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;130. Surrounded Regions&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/surrounded-regions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;ðŸ”—Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BFS Solution :&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board.length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; || board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Queue&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;gt; queue = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] dirs = &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row = board.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col = board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i&amp;lt;row;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j&amp;lt;col;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( (i==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || i==row-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || j==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || j==col-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ) &amp;amp;&amp;amp; board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    queue.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;#123;i,j&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!queue.isEmpty())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] temp = queue.poll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] dir : dirs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = temp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+dir[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y = temp[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+dir[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; x &amp;lt; row &amp;amp;&amp;amp; y &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; y &amp;lt; col &amp;amp;&amp;amp; board[x][y] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    queue.add(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[]&amp;#123;x,y&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    board[x][y] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; row ; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j&amp;lt;col ; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;)board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;)board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;X&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;DFS Solution :&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] dirs = &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;solve&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board.length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; || board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length &amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row = board.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col = board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i&amp;lt;row;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j&amp;lt;col;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( (i==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || i==row-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || j==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || j==col-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ) &amp;amp;&amp;amp; board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    helper(i,j,board);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; row ; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; j&amp;lt;col ; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;)board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;)board[i][j] = &lt;span class=&quot;string&quot;&gt;&#39;X&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;helper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; r, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][]board)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (r &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; c &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r &amp;lt;= board.length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; c &amp;lt;= board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; board[r][c] == &lt;span class=&quot;string&quot;&gt;&#39;O&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            board[r][c] = &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] dir : dirs)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = r + dir[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y = c + dir[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                helper(x,y,board);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into ‘a’. After that, we make a loop of the whole board to change ‘a’ into O and all other Os into ‘X’.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>React Review 📓</title>
    <link href="WangHngLeee.github.io/2020/05/19/react1/"/>
    <id>WangHngLeee.github.io/2020/05/19/react1/</id>
    <published>2020-05-19T13:58:50.000Z</published>
    <updated>2020-05-19T19:39:10.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-复习">React 复习</h2><h3 id="生命周期">生命周期</h3><p>生命周期就是组件从实例化到渲染再到最终从页面中销毁，整个过程就是生命周期。在生命周期中，有很多可以调用的事件，也称为hook/钩子函数。</p><h3 id="生命周期三个状态">生命周期三个状态</h3><ul><li>Mounting : 将组件插入DOM中</li><li>Updating : 将组件更新到DOM中</li><li>Unmounting : 将组件移出DOM</li></ul><h3 id="钩子函数（方法，事件）">钩子函数（方法，事件）</h3><ul><li><p>componentWillMount(): 组件将要渲染,AJAX,添加动画前的类</p></li><li><p>componentDidMount(): 组件渲染完毕，添加动画</p></li><li><p>componentWillReceiveProps(): 组件将要接受props数据</p></li><li><p>shouldComponentUpdate(): 组件接收到新的props/state时判断是否更新，返回boolean值</p></li><li><p>componentWillUpdate(): 组件将要更新</p></li><li><p>componentDidUpdate(): 组件更新完毕</p></li><li><p>compnentWillUnmount(): 组件将要卸载</p></li></ul><a id="more"></a><p>尝试以下代码输出情况：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complife</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            msg:<span class="string">'test msg'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'构造函数'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'挂载完毕，准备渲染'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'渲染完毕'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件将要接受props'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate()&#123;</span><br><span class="line">        <span class="comment">//如果希望更新返回true，不希望则返回false，不更新就是undefined</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.msg == <span class="string">'test msg'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件将要更新'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件更新完毕'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件卸载'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log（<span class="string">'渲染函数'</span>)</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;hello world&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Complife /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>console结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">组件将要渲染</span><br><span class="line">渲染函数</span><br><span class="line">组件渲染完毕</span><br></pre></td></tr></table></figure><p>没有其他event时构造的顺序如上面结果所示。</p><p>但如果有clickevent更新状态时，组件的状态顺序又是怎样的呢？</p><p>其他不变，在render函数中增加一个ondlick事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">......</span><br><span class="line">    render()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log（<span class="string">'渲染函数'</span>)</span><br><span class="line">            <span class="keyword">return</span>(</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;h1&gt;&#123;<span class="keyword">this</span>.state.msg&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;button onClick=&#123;this.changeMsg&#125;&gt;更新&lt;/</span>button&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        changeMsg=()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">            this.setState(&#123;</span></span><br><span class="line"><span class="regexp">                msg:"changing msg"</span></span><br><span class="line"><span class="regexp">            &#125;)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">......</span></span><br><span class="line"><span class="regexp">......</span></span><br></pre></td></tr></table></figure><p>点击更新后此时console将会多出以下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件将要更新</span><br><span class="line">渲染函数</span><br><span class="line">组件更新完毕</span><br></pre></td></tr></table></figure><p>在complife之后增加parent class尝试Unmount函数</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state=&#123;</span><br><span class="line">            isshow:<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.remove&#125;&gt; remove complif组件 &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;complife /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    remove=()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">            isshow:false;</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Parent /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>此时点击button后会增加一条console</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组件卸载</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;React-复习&quot;&gt;React 复习&lt;/h2&gt;
&lt;h3 id=&quot;生命周期&quot;&gt;生命周期&lt;/h3&gt;
&lt;p&gt;生命周期就是组件从实例化到渲染再到最终从页面中销毁，整个过程就是生命周期。在生命周期中，有很多可以调用的事件，也称为hook/钩子函数。&lt;/p&gt;
&lt;h3 id=&quot;生命周期三个状态&quot;&gt;生命周期三个状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mounting : 将组件插入DOM中&lt;/li&gt;
&lt;li&gt;Updating : 将组件更新到DOM中&lt;/li&gt;
&lt;li&gt;Unmounting : 将组件移出DOM&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;钩子函数（方法，事件）&quot;&gt;钩子函数（方法，事件）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;componentWillMount(): 组件将要渲染,AJAX,添加动画前的类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentDidMount(): 组件渲染完毕，添加动画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillReceiveProps(): 组件将要接受props数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shouldComponentUpdate(): 组件接收到新的props/state时判断是否更新，返回boolean值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentWillUpdate(): 组件将要更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;componentDidUpdate(): 组件更新完毕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compnentWillUnmount(): 组件将要卸载&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端框架" scheme="WangHngLeee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
      <category term="React" scheme="WangHngLeee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/React/"/>
    
    
      <category term="Front-end" scheme="WangHngLeee.github.io/tags/Front-end/"/>
    
      <category term="React" scheme="WangHngLeee.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode EveryDay 91 💪</title>
    <link href="WangHngLeee.github.io/2020/05/16/code01/"/>
    <id>WangHngLeee.github.io/2020/05/16/code01/</id>
    <published>2020-05-16T15:16:38.000Z</published>
    <updated>2020-05-16T23:15:14.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-289-Game-of-Life-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">289. Game of Life</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/game-of-life/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dir =&#123;&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> live=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] d:dir)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[<span class="number">0</span>]+i&lt;<span class="number">0</span> || d[<span class="number">0</span>]+i&gt;=board.length || d[<span class="number">1</span>]+j&lt;<span class="number">0</span> || d[<span class="number">1</span>]+j&gt;=board[<span class="number">0</span>].length) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">1</span> || board[d[<span class="number">0</span>]+i][d[<span class="number">1</span>]+j]==<span class="number">2</span>) live++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">0</span> &amp;&amp; live==<span class="number">3</span>) board[i][j]=<span class="number">3</span>;<span class="comment">// dead to live</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live&lt;<span class="number">2</span> || live&gt;<span class="number">3</span>)) board[i][j]=<span class="number">2</span>; <span class="comment">// live to dead</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="number">1</span> &amp;&amp; (live ==<span class="number">2</span> || live ==<span class="number">3</span>))board[i][j]=<span class="number">1</span>; <span class="comment">// continue live;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                board[i][j]%=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state:</p><ul><li>1 means keep living</li><li>2 means live to dead*</li><li>3 means dead to live.</li></ul><p>Finally we just use the number to %2 to get the final result.</p><a id="more"></a><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1249-Minimum-Remove-to-Make-Valid-Parentheses-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1249. Minimum Remove to Make Valid Parentheses</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] check = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;s.length() ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">'('</span>)stack.push(i); <span class="comment">// add idnex of ( to stack</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123; <span class="comment">// stack not empty then add index of ) to stack</span></span><br><span class="line">                    check[i] = <span class="keyword">true</span>;</span><br><span class="line">                    check[stack.pop()] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                check[i] = <span class="keyword">true</span>; <span class="comment">// any character in s should be true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; check.length ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check[i])&#123;</span><br><span class="line">                res.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we add index of open / close parenthes to stack. Then we check for pair. If there is a pair of them we change the index of these in check to be true. All other chars should be true in check array except for ( and ). Finally we loop the check array to form the final res string.</p><h2 id="table-tr-td-bgcolor-28B463-font-color-white-415-Add-Strings-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">415. Add Strings</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/add-strings/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = num1.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = num2.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(len1 &gt;=<span class="number">0</span> || len2 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(len1 &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                n1  = num1.charAt(len1)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                n2 = num2.charAt(len2)-<span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">            sb.append(sum%<span class="number">10</span>);</span><br><span class="line">            len1--;</span><br><span class="line">            len2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Normal solution. Using carry and sum/10 and sum%10. Remeber to reverse the ans in the final.</p><h2 id="table-tr-td-bgcolor-28B463-font-color-white-953-Verifying-an-Alien-Dictionary-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">953. Verifying an Alien Dictionary</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/verifying-an-alien-dictionary/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dict = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlienSorted</span><span class="params">(String[] words, String order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;order.length() ;i++)&#123;</span><br><span class="line">            dict[order.charAt(i)-<span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ;j&lt;words.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(checkbig(words[j-<span class="number">1</span>],words[j]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkbig</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = word1.length();</span><br><span class="line">        <span class="keyword">int</span> b = word2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;a &amp;&amp; i&lt;b;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i) != word2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">if</span>(dict[word1.charAt(i)-<span class="string">'a'</span>] &lt; dict[word2.charAt(i)-<span class="string">'a'</span>])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(dict[word1.charAt(i)-<span class="string">'a'</span>] &gt; dict[word2.charAt(i)-<span class="string">'a'</span>])<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word1.length() &gt; word2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>First we use int[26] to store the new order of letters. Then we use it as a new dictionary to compare.</p><p>After we make it, we loop the given string array, then check them one by one.</p><p>Make a new function checkbig to check whether the later word is bigger than the former. If yes then return false. Otherwise we continue.<br>In the checkbig function, we check the value of each char in the dictionary. If word1’s char is little than the word2 then we return true. So back to the main function it will return false.</p><p>In final we also need check the length of them. eg ( ‘word’, ‘wordl’).</p><h2 id="table-tr-td-bgcolor-28B463-font-color-white-339-Nested-List-Weight-Sum-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">339. Nested List Weight Sum</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/nested-list-weight-sum/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"> * <span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line"> *     <span class="comment">// Constructor initializes an empty nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Constructor initializes a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a nested list</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NestedInteger ni)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a single integer</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())sum+=temp.getInteger()*level;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Using BFS to loop the whole array like a binary tree. In the queue loop, we only need to check whether current is an integer or a nestedarray. If is an integer, we add its value * level to the sum. After each level loop, we increase level by 1.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 27</span><br><span class="line">Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.</span><br></pre></td></tr></table></figure><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-364-Nested-List-Weight-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">364. Nested List Weight Sum II</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/nested-list-weight-sum-ii/" target="_blank" rel="noopener"><font size="4">🔗Question Link </font></a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"> * <span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"> * <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedInteger</span> </span>&#123;</span><br><span class="line"> *     <span class="comment">// Constructor initializes an empty nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Constructor initializes a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="title">NestedInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a nested list</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">()</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a single integer.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInteger</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NestedInteger ni)</span></span>;</span><br><span class="line"> *</span><br><span class="line"> *     <span class="comment">// @return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"> *     <span class="comment">// Return null if this NestedInteger holds a single integer</span></span><br><span class="line"> *     <span class="function"><span class="keyword">public</span> List&lt;NestedInteger&gt; <span class="title">getList</span><span class="params">()</span></span>;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;NestedInteger&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger ni : nestedList)&#123;</span><br><span class="line">            queue.add(ni);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prevsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">int</span> levelsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; size ;i++)&#123;</span><br><span class="line">                NestedInteger temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.isInteger())levelsum+=temp.getInteger();</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(NestedInteger n : temp.getList())&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prevsum+=levelsum;</span><br><span class="line">            total+=prevsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Different to the former question, in this question we have to loop from the leaf. So we have to keep a prevsum to keep track of.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-289-Game-of-Life-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;289. Game of Life&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/game-of-life/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Solution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] dir =&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;,&amp;#123;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;gameOfLife&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] board)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;board.length;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; live=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] d:dir)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+i&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+i&amp;gt;=board.length || d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+j&amp;lt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+j&amp;gt;=board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+i][d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+j]==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || board[d[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]+i][d[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]+j]==&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) live++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j]==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; live==&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) board[i][j]=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;// dead to live&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j]==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; (live&amp;lt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; || live&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)) board[i][j]=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// live to dead&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(board[i][j]==&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; (live ==&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; || live ==&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;))board[i][j]=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// continue live;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;board.length;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;board[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                board[i][j]%=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 means keep living&lt;/li&gt;
&lt;li&gt;2 means live to dead*&lt;/li&gt;
&lt;li&gt;3 means dead to live.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally we just use the number to %2 to get the final result.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Front-end Interview Questions 1 💪</title>
    <link href="WangHngLeee.github.io/2020/05/12/Font-end%20Interview/"/>
    <id>WangHngLeee.github.io/2020/05/12/Font-end Interview/</id>
    <published>2020-05-12T18:28:27.000Z</published>
    <updated>2020-06-20T16:26:34.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-篇">HTML 篇</h2><h3 id="HTML5语义化">HTML5语义化</h3><p>就是用合理、正确的标签来展示内容，如h1h2h3 p 这些。<br>pros：1.易于阅读，当样式表现丢失时，结构方便读者阅读。<br>2.利于开发维护，类别清晰。</p><a id="more"></a><h3 id="结构">结构</h3><img src="https://res.cloudinary.com/duc8au3q3/image/upload/v1557709663/1_tchbca.png">1.header定义文档或者文档的部分区域的页眉，应作为介绍内容或者导航链接栏的容器。2.nav包含多个超链接的区域，包含可以跳转到其他页面或者该页面其他部分的链接列表。3.main定义文档的主要部分，只能有一个，<h3 id="为什么最好把-CSS-的link标签放在head之间？为什么最好把JS的script标签恰好放在body之前，有例外情况吗？">为什么最好把 CSS 的link标签放在head之间？为什么最好把JS的script标签恰好放在body之前，有例外情况吗？</h3><p>1.把link放在head中<br>首先，这是规范文档的要求。其次，是为了让页面逐步呈现，提高用户体验。若放在底部，部分浏览器不能逐步呈现甚至加载失败。<br>这样做可以防止呈现空白页或者无样式页面。<br>2.把script放在/body之前<br>脚本在下载时和执行期前，会阻止HTML解析，放在底部是为了保证html能够顺利加载，将页面尽快呈现。<br>例外的情况是脚本里包含document.write()时。或者是script使用defer属性，放在head中。</p><h3 id="什么是渐进式渲染（progressive-rendering）？">什么是渐进式渲染（progressive rendering）？</h3><p>是用于提高网页性能，以尽快呈现网页的技术，现多用于移动端(移动端网速不稳定)<br>1.图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。<br>2.分层次渲染。页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。<br>3.异步加载 HTML 片段——当页面通过后台渲染时，把HTML拆分，通过异步请求，分块发送给浏览器。</p><h3 id="viewport">viewport</h3><p>视图窗口，在移动web开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动web站点跨设备显示效果基本一致.</p><h3 id="Reflow和Repaint">Reflow和Repaint</h3><p>Reflow<br>当涉及到DOM节点的布局属性发生改变时，会重新计算该属性，并重新描绘相应的元素，称为回流。<br>Repaint<br>当影响DOM元素可见性的属性发生变化时，浏览器会重新描述该元素，称为重绘。<br>但Repaint和Reflow是不可避免的，只能说对性能的影响减到最小。</p><h3 id="img中的alt和元素的title属性作用">img中的alt和元素的title属性作用</h3><p>alt<br>如果无法显示图像，浏览器会显示alt指定的元素。<br>img<br>鼠标悬浮时显示title内容。</p><h3 id="href和src区别">href和src区别</h3><p>href超文本引用，用于a和link元素上<br>src是引用资源，替换当前元素。浏览器解析到src时会暂停其他任务，也是为什么js应该放在底部的原因。</p><h3 id="浏览器渲染过程">浏览器渲染过程</h3><p>1.解析html生成DOM树<br>2.解析css生成cssom树<br>3.将dom和cssom合并成渲染树<br>4.遍历渲染树开始布局，计算每个位置的大小<br>5.将渲染树每个节点绘制到屏幕上</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTML-篇&quot;&gt;HTML 篇&lt;/h2&gt;
&lt;h3 id=&quot;HTML5语义化&quot;&gt;HTML5语义化&lt;/h3&gt;
&lt;p&gt;就是用合理、正确的标签来展示内容，如h1h2h3 p 这些。&lt;br&gt;
pros：1.易于阅读，当样式表现丢失时，结构方便读者阅读。&lt;br&gt;
2.利于开发维护，类别清晰。&lt;/p&gt;
    
    </summary>
    
      <category term="Interview" scheme="WangHngLeee.github.io/categories/Interview/"/>
    
    
      <category term="Front-end" scheme="WangHngLeee.github.io/tags/Front-end/"/>
    
      <category term="Interview Questions" scheme="WangHngLeee.github.io/tags/Interview-Questions/"/>
    
  </entry>
  
  <entry>
    <title>Front-end Interview Note 5 💪</title>
    <link href="WangHngLeee.github.io/2020/04/26/front-end-interview2/"/>
    <id>WangHngLeee.github.io/2020/04/26/front-end-interview2/</id>
    <published>2020-04-26T18:28:27.000Z</published>
    <updated>2020-05-19T15:45:43.592Z</updated>
    
    <content type="html"><![CDATA[<h1>HTML</h1><h2 id="DOCTYPE-作用">&lt;!DOCTYPE&gt;作用</h2><p>一般在html文档第一行声明。用来告知浏览器用什么文档解析标准来解析当前文档。解析模式分为标准模式和兼容模式。</p><h2 id="标准模式-兼容模式">标准模式 &amp;&amp; 兼容模式</h2><ul><li>标准模式：标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。</li><li>兼容模式：页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li></ul><h2 id="link-和-import区别">link 和 @import区别</h2><ul><li>从属关系：link是基于html的语法，而@import是基于css的，css2.1之后才出现。</li><li>加载顺序：link中的内容可以随页面其他内容一起加载，而@import中引入的css必须等其他全部加载完成后再开始加载。</li><li>兼容性区别：link是基于html的，不存在兼容性问题。@import是css2.1之后才出现的，会存在部分IE5+之前的浏览器在不兼容的问题。</li><li>DOM可操作性： 可以通过JS操作DOM改变link中的内容来改变样式；而DOM是基于文档的，无法使用@import来改变。</li></ul><h2 id="浏览器渲染原理">浏览器渲染原理</h2><ol><li>首先解析收到HTML的文件，构造DOM树。</li><li>对CSS文件进行解析，构造CSSOM规则树。</li><li>根据DOM和CSSOM规则树构造渲染树。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也叫做回流/重排）.</li><li>布局阶段结束后是绘制阶段（重绘），遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><h2 id="async-和-defer-的作用和区别">async 和 defer 的作用和区别</h2><ol><li>如果script中没有async和defer，则浏览器会自动加载和执行指定对脚本文件，并暂停其他资源的加载和执行，知道script中的资源加载执行完毕。</li><li><strong>defer</strong>：表示延迟执行引入的JS。JS加载时 HTML 并未停止解析，这两个过程是并行的。当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</li><li><strong>async</strong>：表示异步执行引入JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</li></ol><img src="https://segmentfault.com/img/bVWhRl?w=801&h=814"><h2 id="DOMContentLoaded-事件和-Load-事件的区别">DOMContentLoaded 事件和 Load 事件的区别</h2><p>DOMContentLoaded在HTML文件全部加载完成后触发，并不需要等待css样式、图片图表等文件的加载。</p><p>Load必须等到所有文件全部加载完成后才会触发。</p><h2 id="HTML离线缓存">HTML离线缓存</h2><p>原理：HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术），通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p><p>离线的情况下，浏览器就直接使用离线存储的资源。</p><h2 id="attibute和property区别">attibute和property区别</h2><p>attribute 是 dom 元素在文档中作为 html 标签拥有的属性；<br>property 就是 dom 元素在 js 中作为对象拥有的属性。</p><p>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。</p><h1>CSS</h1><h2 id></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;HTML&lt;/h1&gt;
&lt;h2 id=&quot;DOCTYPE-作用&quot;&gt;&amp;lt;!DOCTYPE&amp;gt;作用&lt;/h2&gt;
&lt;p&gt;一般在html文档第一行声明。用来告知浏览器用什么文档解析标准来解析当前文档。解析模式分为标准模式和兼容模式。&lt;/p&gt;
&lt;h2 id=&quot;标准模式-兼容模式&quot;&gt;
      
    
    </summary>
    
      <category term="Interview" scheme="WangHngLeee.github.io/categories/Interview/"/>
    
      <category term="HTML" scheme="WangHngLeee.github.io/categories/Interview/HTML/"/>
    
    
      <category term="Front-end" scheme="WangHngLeee.github.io/tags/Front-end/"/>
    
      <category term="Interview Questions" scheme="WangHngLeee.github.io/tags/Interview-Questions/"/>
    
  </entry>
  
  <entry>
    <title>Front-end Interview Note 4 💪</title>
    <link href="WangHngLeee.github.io/2020/04/26/frontend-interview-note/"/>
    <id>WangHngLeee.github.io/2020/04/26/frontend-interview-note/</id>
    <published>2020-04-26T18:28:27.000Z</published>
    <updated>2020-05-19T15:45:59.415Z</updated>
    
    <content type="html"><![CDATA[<h1>CSS</h1><h2 id="before-和-after中单引号和双引号的区别">::before 和:after中单引号和双引号的区别</h2><p>单冒号(:)用于css伪类，双冒号(::)用于css伪元素。有些浏览器考虑到兼容问题，部分情况下也可以用单引号(:)表示伪元素。</p><p>伪类(😃：一般匹配的是元素的某些特定状态，例如:hover, :link</p><ul><li>伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的<br>元素时，我们可以通过 :hover 来描述这个元素的状态。</li></ul><p>伪元素(:😃：一般匹配的是特殊位置，比如::before ::after等。</p><ul><li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过 ::be<br>fore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li></ul><a id="more"></a><h2 id="居中问题">居中问题</h2><h3 id="1-水平居中">1.水平居中</h3><ol><li>为div设置宽度，让margin为0 auto。</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用text-align实现</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:black;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:pink;<span class="comment">/*和black区分开更清楚*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-水平垂直居中">2.水平垂直居中</h3><ol><li>容器高宽值给定时,margin设为自身宽高一半</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">100px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将div左上角移到屏幕中心，再设置margin为自身size的一半。</p><ol start="2"><li>容器宽高未知时，使用transform方法。</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;<span class="comment">/* 相对定位或绝对定位均可 */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用flex布局</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:red;<span class="comment">/*看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="position中，不同的值其定位原点各是什么？-relative-absolute-static-fixed-inherit">position中，不同的值其定位原点各是什么？(relative,absolute,static,fixed,inherit)</h2><ul><li><p>absolute:<br>生成绝对定位的元素，相对于值不为 static 的第一个父元素的 padding box 进行定位，也可以理解为离自己这一级元素最近的<br>一级 position 设置为 absolute 或者 relative 的父元素的 padding box 的左上角为原点的。</p></li><li><p>fixed :生成绝对定位的元素，相对于浏览器窗口进行定位。</p></li><li><p>relative: 生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</p></li><li><p>static: 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right, z-index 声明）。</p></li><li><p>inherit: 规定从父元素继承 position 属性的值。</p></li></ul><h2 id="li-与-li-之间有看不见的空白间隔问题-解决方法">li 与 li 之间有看不见的空白间隔问题 &amp;&amp; 解决方法</h2><p>浏览器在渲染inline行内元素的时候，为了美观会将元素间的空白字符渲染成换空格。而我们在写li的时候为了美观会将li放在单独一行，所以li换行后会产生换行符。</p><ul><li>为li设置 float: left。</li><li>将所有 li 写在同一行。</li><li>将 ul 内的font-size设为0。</li><li>消除 ul 的字符间隔 ，设置letter-spacing: -8px，</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1&gt;CSS&lt;/h1&gt;
&lt;h2 id=&quot;before-和-after中单引号和双引号的区别&quot;&gt;::before 和:after中单引号和双引号的区别&lt;/h2&gt;
&lt;p&gt;单冒号(:)用于css伪类，双冒号(::)用于css伪元素。有些浏览器考虑到兼容问题，部分情况下也可以用单引号(:)表示伪元素。&lt;/p&gt;
&lt;p&gt;伪类(😃：一般匹配的是元素的某些特定状态，例如:hover, :link&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪类用于当已有的元素处于某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的&lt;br&gt;
元素时，我们可以通过 :hover 来描述这个元素的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;伪元素(:😃：一般匹配的是特殊位置，比如::before ::after等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;伪元素用于创建一些不在文档树中的元素，并为其添加样式。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过 ::be&lt;br&gt;
fore 来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Interview" scheme="WangHngLeee.github.io/categories/Interview/"/>
    
      <category term="CSS" scheme="WangHngLeee.github.io/categories/Interview/CSS/"/>
    
    
      <category term="Front-end" scheme="WangHngLeee.github.io/tags/Front-end/"/>
    
      <category term="Interview Questions" scheme="WangHngLeee.github.io/tags/Interview-Questions/"/>
    
  </entry>
  
  <entry>
    <title>📖 Vue学习笔记(3)</title>
    <link href="WangHngLeee.github.io/2020/04/13/vue3/"/>
    <id>WangHngLeee.github.io/2020/04/13/vue3/</id>
    <published>2020-04-13T17:15:41.000Z</published>
    <updated>2020-04-27T00:06:07.125Z</updated>
    
    <content type="html"><![CDATA[<h1>vue v-model 和 数据双向绑定</h1><h2 id="v-model">v-model</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span> &#123;&#123; msg &#125;&#125; <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-bind:value</span> = <span class="string">"msg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">v-model</span> = <span class="string">"msg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="javascript">            msg: <span class="string">'This is new data '</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码很清楚的展示了v-bind 单向数据绑定和 v-model 双向数据绑定的区别。<br><br>第一个input框内的文字只会和h4内同步一次，当对input做出改变时，h4内容不会随之改变。<br><br>相反，使用了v-model的input发生改变时，h4显示的内容会随之一起改变。</p><p>待更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;vue v-model 和 数据双向绑定&lt;/h1&gt;
&lt;h2 id=&quot;v-model&quot;&gt;v-model&lt;/h2&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
      <category term="前端框架" scheme="WangHngLeee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Vue" scheme="WangHngLeee.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/Vue/"/>
    
    
      <category term="Vue" scheme="WangHngLeee.github.io/tags/Vue/"/>
    
  </entry>
  
</feed>
