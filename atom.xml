<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leee&#39;s World</title>
  
  <subtitle>Talk is Cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="WangHngLeee.github.io/"/>
  <updated>2020-07-22T05:27:38.047Z</updated>
  <id>WangHngLeee.github.io/</id>
  
  <author>
    <name>HomLee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Review Problems List üìå</title>
    <link href="WangHngLeee.github.io/9999/12/31/problemslist/"/>
    <id>WangHngLeee.github.io/9999/12/31/problemslist/</id>
    <published>9999-12-31T16:13:23.000Z</published>
    <updated>2020-07-22T05:27:38.047Z</updated>
    
    <content type="html"><![CDATA[<br><font size="3"> ËÆ∞ÂΩïProblems listÁöÑÂÆåÊàêÊÉÖÂÜµ ÊØèÊó•Êõ¥Êñ∞„ÄÇ<br><a href="https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ6qpA/edit#gid=972946549" target="_blank" rel="noopener"><font size="4">üîó Problems List  Link </font></a><br>Github Leetcode Summary ÂêåÊ≠•Êõ¥Êñ∞„ÄÇ<br><a href="https://github.com/WangHngLeee/LeetcodeSummary" target="_blank" rel="noopener"><font size="4">üîó Github Summary Link </font></a><br></font><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br&gt;
&lt;font size=&quot;3&quot;&gt; ËÆ∞ÂΩïProblems listÁöÑÂÆåÊàêÊÉÖÂÜµ ÊØèÊó•Êõ¥Êñ∞„ÄÇ&lt;br&gt;
&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ
      
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Problems List" scheme="WangHngLeee.github.io/tags/Problems-List/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | Country Roads</title>
    <link href="WangHngLeee.github.io/2020/09/25/CountryRoads/"/>
    <id>WangHngLeee.github.io/2020/09/25/CountryRoads/</id>
    <published>2020-09-25T21:27:29.000Z</published>
    <updated>2020-09-25T23:29:23.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-Country-Roads-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">Country Roads</font></td></tr></table></h2><p><a target="_blank" href="https://binarysearch.com/problems/Country-Roads"><font size="4">üîó Question Link </font></a></p><h3 id="Example">Example</h3><p>A country can be represented as a tree with <code>N</code> nodes and <code>N-1</code> edges. Each node represents a town, and each edge represents a piece of road.</p><p>You‚Äôre given two lists of integers of size <code>N-1</code>, <code>source</code> and <code>dest</code>. The <code>i</code>-th road connects town <code>source[i]</code> to town <code>dest[i]</code>. The roads are bidirectional.</p><p>You‚Äôre also given a list of integers <code>population</code> of size <code>N</code>, where <code>population[i]</code> represents the population of the <code>i</code>-th town.</p><p>You are looking to upgrade some number of towns into cities.</p><p>However, there is a catch: no two cities should be adjacent to each other due to fierce competition, and every node adjacent to a town should be a city to allow easier access to infrastructure. In other words, every road must connect a town and a city.</p><p>What is the maximum possible population of all the cities?</p><p><strong>Constraints</strong></p><ul><li><code>N ‚â§ 10000</code></li></ul><p><strong>Example</strong></p><p><strong>Input</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source = [0, 0, 2, 2]</span><br><span class="line">dest = [1, 2, 4, 3]</span><br><span class="line">population = [5, 7, 3, 2, 4]</span><br></pre></td></tr></table></figure><p><strong>Output</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p><strong>Explanation</strong></p><p>We can upgrade cities 0, 3, and 4 to get a population of 11.</p><a id="more"></a><h3 id="Solution">Solution</h3><p>The key point is that, we only need to check the <code>odd</code> and <code>even</code> position. According to the question, we can not set neighboors as two cities, so we can only set a city with a distance of 1. So we can keep record of two sum, one is the final population of cities at even position, and another is the total population of cities at odd position.</p><p>After figuring the above out, we can using both <code>DFS</code> and <code>BFS</code> to solve it.</p><img src="https://user-images.githubusercontent.com/48079913/94323706-dbf06a00-ff64-11ea-8bfa-d0806a8505f1.png" alt="question image"><h3 id="Code">Code</h3><ul><li><p>BFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] dest, <span class="keyword">int</span>[] population)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[source.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;source.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = source[i];</span><br><span class="line">            <span class="keyword">int</span> end = dest[i];</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        set.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res2 = <span class="number">0</span>;</span><br><span class="line">        res1+=population[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> s = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> d = temp[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[s])&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(next))<span class="keyword">continue</span>;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;next, d + <span class="number">1</span>&#125;);</span><br><span class="line">                set.add(next);</span><br><span class="line">                <span class="keyword">if</span>(d % <span class="number">2</span> == <span class="number">0</span>)res2+=population[next];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(d % <span class="number">2</span> != <span class="number">0</span>)res1 +=population[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res1,res2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DFS</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] dest, <span class="keyword">int</span>[] population)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[source.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;source.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = source[i];</span><br><span class="line">            <span class="keyword">int</span> end = dest[i];</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        even += population[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            dfs(graph,i,<span class="number">0</span>,population);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(odd, even);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[]graph, <span class="keyword">int</span> node, <span class="keyword">int</span> dist,<span class="keyword">int</span>[] p)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!set.contains(node))&#123;</span><br><span class="line">            set.add(node);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> next : graph[node])&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(next))<span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                dfs(graph,next,dist+<span class="number">1</span>, p);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(dist % <span class="number">2</span> == <span class="number">0</span>)res2 += p[next];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dist % <span class="number">2</span> != <span class="number">0</span>)res1 +=p[next];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-Country-Roads-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;Country Roads&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://binarysearch.com/problems/Country-Roads&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;A country can be represented as a tree with &lt;code&gt;N&lt;/code&gt; nodes and &lt;code&gt;N-1&lt;/code&gt; edges. Each node represents a town, and each edge represents a piece of road.&lt;/p&gt;
&lt;p&gt;You‚Äôre given two lists of integers of size &lt;code&gt;N-1&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt;. The &lt;code&gt;i&lt;/code&gt;-th road connects town &lt;code&gt;source[i]&lt;/code&gt; to town &lt;code&gt;dest[i]&lt;/code&gt;. The roads are bidirectional.&lt;/p&gt;
&lt;p&gt;You‚Äôre also given a list of integers &lt;code&gt;population&lt;/code&gt; of size &lt;code&gt;N&lt;/code&gt;, where &lt;code&gt;population[i]&lt;/code&gt; represents the population of the &lt;code&gt;i&lt;/code&gt;-th town.&lt;/p&gt;
&lt;p&gt;You are looking to upgrade some number of towns into cities.&lt;/p&gt;
&lt;p&gt;However, there is a catch: no two cities should be adjacent to each other due to fierce competition, and every node adjacent to a town should be a city to allow easier access to infrastructure. In other words, every road must connect a town and a city.&lt;/p&gt;
&lt;p&gt;What is the maximum possible population of all the cities?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;N ‚â§ 10000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Input&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;source = [0, 0, 2, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dest = [1, 2, 4, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;population = [5, 7, 3, 2, 4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Explanation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can upgrade cities 0, 3, and 4 to get a population of 11.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="BFS" scheme="WangHngLeee.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="WangHngLeee.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 1192. Critical Connections in a Network</title>
    <link href="WangHngLeee.github.io/2020/09/10/1192.%20Critical%20Connections%20in%20a%20Network/"/>
    <id>WangHngLeee.github.io/2020/09/10/1192. Critical Connections in a Network/</id>
    <published>2020-09-10T20:27:29.000Z</published>
    <updated>2020-09-10T23:49:59.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1192-Critical-Connections-in-a-Network-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1192. Critical Connections in a Network</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/critical-connections-in-a-network//"><font size="4">üîó  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>There are <code>n</code> servers numbered from <code>0</code> to <code>n-1</code> connected by undirected server-to-server <code>connections</code> forming a network where <code>connections[i] = [a, b]</code> represents a connection between servers <code>a</code> and <code>b</code>. Any server can reach any other server directly or indirectly through the network.</p><p>A <em>critical connection</em> is a connection that, if removed, will make some server unable to reach some other server.</p><p>Return all critical connections in the network in any order.</p><p><strong>Example 1:</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">Output: [[1,3]]</span><br><span class="line">Explanation: [[3,1]] is also accepted.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>n-1 &lt;= connections.length &lt;= 10^5</code></li><li><code>connections[i][0] != connections[i][1]</code></li><li>There are no repeated connections.</li></ul><a id="more"></a><h3 id="Solution">Solution</h3><p>It‚Äôs a typical Tarjan solution. We need to find the parts that are not strong components.</p><p>Detailed information about Tarjan can be found in this post. <a href="https://blog.csdn.net/hurmishine/article/details/75248876" target="_blank" rel="noopener">CSDN Link</a></p><p><code>Time</code>: the time that the node be visited</p><p><code>Low</code>: the lowest time that current node‚Äôs parent nodes have.</p><p><code>findTime</code>: the time stamp that increases by itself.</p><p>We first create a graph to store <code>v</code> and <code>u</code>.  Then perfom DFS on each unvisited node <code>v</code> in <code>graph[u]</code>.</p><p>If v is unvisited, recursively call the function DFS. Then update the low[u].</p><p>If <code>low[v] &gt; time[u]</code>, it means the current node v can not go back to it‚Äôs parrent node <code>u</code>. So this is an critical connection and we add them to res.</p><p>Otherwise, we update low[u] with <code>Math.min(low[u], time[v])</code></p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] time, low;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> findTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">        res = <span class="keyword">new</span>  ArrayList&lt;&gt;();</span><br><span class="line">        time = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(time,-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;connections.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = connections.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> end = connections.get(i).get(<span class="number">1</span>);</span><br><span class="line">            graph[start].add(end);</span><br><span class="line">            graph[end].add(start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(time[i] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph, i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> u, <span class="keyword">int</span> prev)</span></span>&#123;</span><br><span class="line">        time[u] = low[u] = ++findTime;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;graph[u].size(); k++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = graph[u].get(k);</span><br><span class="line">            <span class="keyword">if</span>(v == prev)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(time[v] == -<span class="number">1</span>)&#123;</span><br><span class="line">                dfs(graph,v,u);</span><br><span class="line">                low[u] = Math.min(low[u],low[v]);</span><br><span class="line">                <span class="keyword">if</span>( low[v] &gt; time[u])&#123;</span><br><span class="line">                    res.add(Arrays.asList(u,v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low[u] = Math.min(low[u], time[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-1192-Critical-Connections-in-a-Network-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;1192. Critical Connections in a Network&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/critical-connections-in-a-network//&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;There are &lt;code&gt;n&lt;/code&gt; servers numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt; connected by undirected server-to-server &lt;code&gt;connections&lt;/code&gt; forming a network where &lt;code&gt;connections[i] = [a, b]&lt;/code&gt; represents a connection between servers &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Any server can reach any other server directly or indirectly through the network.&lt;/p&gt;
&lt;p&gt;A &lt;em&gt;critical connection&lt;/em&gt; is a connection that, if removed, will make some server unable to reach some other server.&lt;/p&gt;
&lt;p&gt;Return all critical connections in the network in any order.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png&quot; alt=&quot;img&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [[1,3]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: [[3,1]] is also accepted.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n-1 &amp;lt;= connections.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;connections[i][0] != connections[i][1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;There are no repeated connections.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="DFS" scheme="WangHngLeee.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 733. Flood Fill</title>
    <link href="WangHngLeee.github.io/2020/08/16/733.%20Flood%20Fill/"/>
    <id>WangHngLeee.github.io/2020/08/16/733. Flood Fill/</id>
    <published>2020-08-16T14:30:29.000Z</published>
    <updated>2020-08-16T15:53:40.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-733-Flood-Fill-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">733. Flood Fill</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/flood-fill/"><font size="4">üîó LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>An <code>image</code> is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p><p>Given a coordinate <code>(sr, sc)</code> representing the starting pixel (row and column) of the flood fill, and a pixel value <code>newColor</code>, ‚Äúflood fill‚Äù the image.</p><p>To perform a ‚Äúflood fill‚Äù, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p><p>At the end, return the modified image.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">image = [[1,1,1],[1,1,0],[1,0,1]]</span><br><span class="line">sr = 1, sc = 1, newColor = 2</span><br><span class="line">Output: [[2,2,2],[2,2,0],[2,0,1]]</span><br><span class="line">Explanation: </span><br><span class="line">From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected </span><br><span class="line">by a path of the same color as the starting pixel are colored with the new color.</span><br><span class="line">Note the bottom corner is not colored 2, because it is not 4-directionally connected</span><br><span class="line">to the starting pixel.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The length of <code>image</code> and <code>image[0]</code> will be in the range <code>[1, 50]</code>.</p><p>The given starting pixel will satisfy <code>0 &lt;= sr &lt; image.length</code> and <code>0 &lt;= sc &lt; image[0].length</code>.</p><p>The value of each color in <code>image[i][j]</code> and <code>newColor</code> will be an integer in <code>[0, 65535]</code>.</p><a id="more"></a><h3 id="Solution">Solution</h3><p>Take care of corner case that cause many times in my submission.</p><p>Just return the image when the newColor is same as start point‚Äôs color.</p><h4 id="BFS">BFS</h4><p>It‚Äôs traditional BFS solution. Using template for BFS is enough.</p><h4 id="DFS">DFS</h4><p>It‚Äôs traditional DFS solution. Using template for DFS is enough.</p><h3 id="Code">Code</h3><h4 id="DFS-v2">DFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> old;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)<span class="keyword">return</span> image;</span><br><span class="line">        m = image.length;</span><br><span class="line">        n = image[<span class="number">0</span>].length;</span><br><span class="line">        old = image[sr][sc];</span><br><span class="line">        dfs(image,sr,sc,newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> newColor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;<span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n || image[row][col] != old)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        image[row][col] = newColor;</span><br><span class="line">        dfs(image,row-<span class="number">1</span>,col,newColor);</span><br><span class="line">        dfs(image,row+<span class="number">1</span>,col,newColor);</span><br><span class="line">        dfs(image,row,col-<span class="number">1</span>,newColor);</span><br><span class="line">        dfs(image,row,col+<span class="number">1</span>,newColor);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS-v2">BFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span> m = image.length;</span><br><span class="line">        <span class="keyword">int</span> n = image[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> color = image[sr][sc];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp  = queue.poll();</span><br><span class="line">            image[temp[<span class="number">0</span>]][temp[<span class="number">1</span>]] = newColor;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = temp[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = temp[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (x&gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y&lt; n &amp;&amp; image[x][y] == color) &#123;</span><br><span class="line">                    image[x][y] = newColor;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-733-Flood-Fill-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;733. Flood Fill&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/flood-fill/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;An &lt;code&gt;image&lt;/code&gt; is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).&lt;/p&gt;
&lt;p&gt;Given a coordinate &lt;code&gt;(sr, sc)&lt;/code&gt; representing the starting pixel (row and column) of the flood fill, and a pixel value &lt;code&gt;newColor&lt;/code&gt;, ‚Äúflood fill‚Äù the image.&lt;/p&gt;
&lt;p&gt;To perform a ‚Äúflood fill‚Äù, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.&lt;/p&gt;
&lt;p&gt;At the end, return the modified image.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image = [[1,1,1],[1,1,0],[1,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sr = 1, sc = 1, newColor = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [[2,2,2],[2,2,0],[2,0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;by a path of the same color as the starting pixel are colored with the new color.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note the bottom corner is not colored 2, because it is not 4-directionally connected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;to the starting pixel.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The length of &lt;code&gt;image&lt;/code&gt; and &lt;code&gt;image[0]&lt;/code&gt; will be in the range &lt;code&gt;[1, 50]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The given starting pixel will satisfy &lt;code&gt;0 &amp;lt;= sr &amp;lt; image.length&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= sc &amp;lt; image[0].length&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The value of each color in &lt;code&gt;image[i][j]&lt;/code&gt; and &lt;code&gt;newColor&lt;/code&gt; will be an integer in &lt;code&gt;[0, 65535]&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="BFS" scheme="WangHngLeee.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="WangHngLeee.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 675. Cut Off Trees for Golf Event</title>
    <link href="WangHngLeee.github.io/2020/08/16/675.%20Cut%20Off%20Trees%20for%20Golf%20Event/"/>
    <id>WangHngLeee.github.io/2020/08/16/675. Cut Off Trees for Golf Event/</id>
    <published>2020-08-16T14:27:29.000Z</published>
    <updated>2020-08-16T15:16:02.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-675-Cut-Off-Trees-for-Golf-Event-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">675. Cut Off Trees for Golf Event¬†</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/cut-off-trees-for-golf-event/"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p><ol><li><code>0</code> represents the <code>obstacle</code> can‚Äôt be reached.</li><li><code>1</code> represents the <code>ground</code> can be walked through.</li><li><code>The place with number bigger than 1</code> represents a <code>tree</code> can be walked through, and this positive number represents the tree‚Äôs height.</li></ol><p>In one step you can walk in any of the four directions <code>top</code>, <code>bottom</code>, <code>left</code> and <code>right</code> also when standing in a point which is a tree you can decide whether or not to cut off the tree.</p><p>You are asked to cut off <strong>all</strong> the trees in this forest in the order of tree‚Äôs height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p><p>You will start from the point (0, 0) and you should output the minimum steps <strong>you need to walk</strong> to cut off all the trees. If you can‚Äôt cut off all the trees, output -1 in that situation.</p><p>You are guaranteed that no two <code>trees</code> have the same height and there is at least one tree needs to be cut off.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,4],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [1,2,3],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [7,6,5]</span><br><span class="line">]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line"> [2,3,4],</span><br><span class="line"> [0,0,5],</span><br><span class="line"> [8,7,6]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= forest.length &lt;= 50</code></li><li><code>1 &lt;= forest[i].length &lt;= 50</code></li><li><code>0 &lt;= forest[i][j] &lt;= 10^9</code></li></ul><a id="more"></a><h3 id="Solution">Solution</h3><p>Apparently we can using BFS.</p><p>Using priority queue to sort the node by it‚Äôs value.</p><p>We start from the (0,0).  Keep record of the next tree that we want to cut , after BFS we need to update the current start with last <code>next tree</code>.</p><p>Using BFS to find the best steps from the current tree to the next target tree.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(forest == <span class="keyword">null</span> || forest.size() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt;(a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">int</span> m = forest.size();</span><br><span class="line">        <span class="keyword">int</span> n = forest.get(<span class="number">0</span>).size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(forest.get(i).get(j) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j,forest.get(i).get(j)&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tree = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> step = help(forest,start,tree,m,n);</span><br><span class="line">            <span class="keyword">if</span>(step == -<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            sum+=step;</span><br><span class="line">            start[<span class="number">0</span>] = tree[<span class="number">0</span>];</span><br><span class="line">            start[<span class="number">1</span>] = tree[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span>[] start, <span class="keyword">int</span>[] tree, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(start);</span><br><span class="line">        seen[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size ;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp[<span class="number">0</span>] == tree[<span class="number">0</span>] &amp;&amp; temp[<span class="number">1</span>] == tree[<span class="number">1</span>])<span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = temp[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = temp[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt; m &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= <span class="number">0</span>)&#123;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                        seen[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(m^2 * n^2)   S:O(m*n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-675-Cut-Off-Trees-for-Golf-Event-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;675. Cut Off Trees for Golf Event¬†&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/cut-off-trees-for-golf-event/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; represents the &lt;code&gt;obstacle&lt;/code&gt; can‚Äôt be reached.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; represents the &lt;code&gt;ground&lt;/code&gt; can be walked through.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;The place with number bigger than 1&lt;/code&gt; represents a &lt;code&gt;tree&lt;/code&gt; can be walked through, and this positive number represents the tree‚Äôs height.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In one step you can walk in any of the four directions &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;bottom&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; also when standing in a point which is a tree you can decide whether or not to cut off the tree.&lt;/p&gt;
&lt;p&gt;You are asked to cut off &lt;strong&gt;all&lt;/strong&gt; the trees in this forest in the order of tree‚Äôs height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).&lt;/p&gt;
&lt;p&gt;You will start from the point (0, 0) and you should output the minimum steps &lt;strong&gt;you need to walk&lt;/strong&gt; to cut off all the trees. If you can‚Äôt cut off all the trees, output -1 in that situation.&lt;/p&gt;
&lt;p&gt;You are guaranteed that no two &lt;code&gt;trees&lt;/code&gt; have the same height and there is at least one tree needs to be cut off.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [7,6,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,0],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [7,6,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: -1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [2,3,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [0,0,5],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [8,7,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= forest.length &amp;lt;= 50&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= forest[i].length &amp;lt;= 50&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= forest[i][j] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="BFS" scheme="WangHngLeee.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 314. Binary Tree Vertical Order Traversal</title>
    <link href="WangHngLeee.github.io/2020/08/10/314.%20Binary%20Tree%20Vertical%20Order%20Traversal/"/>
    <id>WangHngLeee.github.io/2020/08/10/314. Binary Tree Vertical Order Traversal/</id>
    <published>2020-08-10T12:30:29.000Z</published>
    <updated>2020-08-10T13:28:21.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-314-Binary-Tree-Vertical-Order-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">314. Binary Tree Vertical Order Traversal</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"><font size="4">üîó  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode.com/problems/binary-tree-vertical-order-traversal/"><font size="4">üîó Similar Questoin 987 link</font></a></p><h3 id="Examples">Examples</h3><p>Given a binary tree, return the <em>vertical order</em> traversal of its nodes‚Äô values. (ie, from top to bottom, column by column).</p><p>If two nodes are in the same row and column, the order should be from <strong>left to right</strong>.</p><p><strong>Examples 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /\</span><br><span class="line"> /  \</span><br><span class="line"> 9  20</span><br><span class="line">    /\</span><br><span class="line">   /  \</span><br><span class="line">  15   7 </span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [9],</span><br><span class="line">  [3,15],</span><br><span class="line">  [20],</span><br><span class="line">  [7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>This question has the same solution with question <a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/ " target="_blank">987. Vertical Order Traversal of a Binary Tree</a></p><h4 id="1-Pair-Class-with-BFS">1. Pair Class with BFS</h4><p>According to the question, we need to store the position of both <code>x</code> and <code>y</code> and it‚Äôs <code>node</code>. We can just define another simple class instead of using other TreeMap or PriorityQueue.</p><p>What we need to do is just store the node that have same <code>x</code> in the HashMap using <code>BFS</code>/ <code>Level Traversal</code>.</p><h4 id="2-Two-Queue-and-BFS">2. Two Queue and BFS</h4><p>Using two queue to store position of <code>x</code>/<code>col</code> and nodes.</p><p>Using Map to store the nodes that have same <code>x</code>/ <code>col</code></p><p>We follow the order of <code>root -&gt; left -&gt; right</code> to add both <code>x</code>/<code>col</code> and <code>node</code> into queue. So each time we just need to poll up the latest one to update the <code>x</code>/<code>col</code> and <code>node</code>.</p><p>Also remember to keep track of leftmost <code>left</code> and rightmost <code>right</code> for the later loop.</p><h3 id="Code">Code</h3><h4 id="Pair-class-BFS">Pair class + BFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">pair</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">pair</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, TreeNode n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.node = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res; <span class="comment">// corner case</span></span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, List&lt;pair&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;pair&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//BFS</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> pair(<span class="number">0</span>,<span class="number">0</span>,root));</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// leftmost x </span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>; <span class="comment">// rightmost x</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            pair temp = queue.poll();</span><br><span class="line">            left = Math.min(left, temp.x);</span><br><span class="line">            right = Math.max(right,temp.x);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(temp.x))&#123;</span><br><span class="line">                map.put(temp.x, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            map.get(temp.x).add(<span class="keyword">new</span> pair(temp.x, temp.y, temp.node));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.left != <span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x-<span class="number">1</span>, temp.y+<span class="number">1</span>, temp.node.left));</span><br><span class="line">            <span class="keyword">if</span>(temp.node.right != <span class="keyword">null</span>)queue.add(<span class="keyword">new</span> pair(temp.x+<span class="number">1</span>, temp.y+<span class="number">1</span>, temp.node.right));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">            Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y); <span class="comment">// sort the node that have same y value</span></span><br><span class="line">            List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; map.get(i).size(); j++)&#123;</span><br><span class="line">                templist.add(map.get(i).get(j).node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(templist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Two-Queue-BFS">Two Queue + BFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">          List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res; <span class="comment">// check the input</span></span><br><span class="line"></span><br><span class="line">          Map&lt;Integer,ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">          Queue&lt;TreeNode&gt; node_queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">          Queue&lt;Integer&gt; cols = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> leftmost = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">int</span> rightmost = <span class="number">0</span>;</span><br><span class="line">          node_queue.add(root);</span><br><span class="line">          cols.add(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">while</span>(!node_queue.isEmpty())&#123;</span><br><span class="line">              TreeNode node = node_queue.poll();</span><br><span class="line">              <span class="keyword">int</span> col = cols.poll();</span><br><span class="line">              <span class="keyword">if</span>(!map.containsKey(col))&#123;</span><br><span class="line">                  map.put(col,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">              &#125;</span><br><span class="line">              map.get(col).add(node.val);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  node_queue.add(node.left);</span><br><span class="line">                  cols.add(col-<span class="number">1</span>);</span><br><span class="line">                  leftmost = Math.min(leftmost,col-<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                  node_queue.add(node.right);</span><br><span class="line">                  cols.add(col+<span class="number">1</span>);</span><br><span class="line">                  rightmost = Math.max(rightmost,col+<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i= leftmost ; i &lt;= rightmost ; i++)&#123;</span><br><span class="line">              res.add(map.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-314-Binary-Tree-Vertical-Order-Traversal-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;314. Binary Tree Vertical Order Traversal&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/binary-tree-vertical-order-traversal/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/binary-tree-vertical-order-traversal/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó Similar Questoin 987 link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;vertical order&lt;/em&gt; traversal of its nodes‚Äô values. (ie, from top to bottom, column by column).&lt;/p&gt;
&lt;p&gt;If two nodes are in the same row and column, the order should be from &lt;strong&gt;left to right&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,9,20,null,null,15,7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  /\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /  \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 9  20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /  \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  15   7 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,15],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [20],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [7]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Tree" scheme="WangHngLeee.github.io/tags/Tree/"/>
    
      <category term="BFS" scheme="WangHngLeee.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 815. Bus Routes</title>
    <link href="WangHngLeee.github.io/2020/08/08/815.%20Bus%20Routes/"/>
    <id>WangHngLeee.github.io/2020/08/08/815. Bus Routes/</id>
    <published>2020-08-08T14:27:29.000Z</published>
    <updated>2020-08-08T15:24:10.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-815-Bus-Routes-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">815. Bus Routes</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/bus-routes/"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>We have a list of bus routes. Each <code>routes[i]</code> is a bus route that the i-th bus repeats forever. For example if <code>routes[0] = [1, 5, 7]</code>, this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;‚Ä¶ forever.</p><p>We start at bus stop <code>S</code> (initially not on a bus), and we want to go to bus stop <code>T</code>. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: </span><br><span class="line">routes = [[1, 2, 7], [3, 6, 7]]</span><br><span class="line">S = 1</span><br><span class="line">T = 6</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= routes.length &lt;= 500</code>.</li><li><code>1 &lt;= routes[i].length &lt;= 10^5</code>.</li><li><code>0 &lt;= routes[i][j] &lt; 10 ^ 6</code>.</li></ul><a id="more"></a><h3 id="Solution">Solution</h3><p>Using BFS.</p><p>We can think from the other point.</p><p>Assume in real life, we are at stop 1, and there a several buses can stop here, so we can choose anyone we want.</p><p>So it‚Äôs simple that we can store the buses and stop in the map, with key of <code>stop</code> and value of <code>buses that stop here</code>.</p><p>Inorder to prevent the duplicate bus, we can using an array of bus number to check whether the bus has been visited.</p><p>Then transfer the map into a graph like below.</p><img src="https://assets.leetcode.com/users/images/043c8e91-4b67-4eb4-8858-05ba98c56a47_1596899756.2404113.png"><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numBusesToDestination</span><span class="params">(<span class="keyword">int</span>[][] routes, <span class="keyword">int</span> S, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(S == T)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;routes.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;routes[i].length; j++)&#123;</span><br><span class="line">                List&lt;Integer&gt; buses = map.getOrDefault(routes[i][j],<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                buses.add(i);</span><br><span class="line">                map.put(routes[i][j], buses);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] seen = <span class="keyword">new</span> <span class="keyword">int</span>[routes.length];</span><br><span class="line">        </span><br><span class="line">        queue.add(S);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                List&lt;Integer&gt; buses = map.get(temp);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> bus : buses)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(seen[bus] == <span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    seen[bus] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;routes[bus].length; k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(routes[bus][k] == T)<span class="keyword">return</span> res;</span><br><span class="line">                        queue.offer(routes[bus][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: O(M*N)  S: O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-815-Bus-Routes-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;815. Bus Routes&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/bus-routes/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;We have a list of bus routes. Each &lt;code&gt;routes[i]&lt;/code&gt; is a bus route that the i-th bus repeats forever. For example if &lt;code&gt;routes[0] = [1, 5, 7]&lt;/code&gt;, this means that the first bus (0-th indexed) travels in the sequence 1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;‚Ä¶ forever.&lt;/p&gt;
&lt;p&gt;We start at bus stop &lt;code&gt;S&lt;/code&gt; (initially not on a bus), and we want to go to bus stop &lt;code&gt;T&lt;/code&gt;. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;routes = [[1, 2, 7], [3, 6, 7]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;S = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;T = 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes.length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes[i].length &amp;lt;= 10^5&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= routes[i][j] &amp;lt; 10 ^ 6&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="BFS" scheme="WangHngLeee.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 992. Subarrays with K Different Integers</title>
    <link href="WangHngLeee.github.io/2020/08/07/992.%20Subarrays%20with%20K%20Different%20Integers/"/>
    <id>WangHngLeee.github.io/2020/08/07/992. Subarrays with K Different Integers/</id>
    <published>2020-08-07T22:27:29.000Z</published>
    <updated>2020-08-07T23:50:13.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-992-Subarrays-with-K-Different-Integers-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">992. Subarrays with K Different Integers</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/subarrays-with-k-different-integers/"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>Given an array <code>A</code> of positive integers, call a (contiguous, not necessarily distinct) subarray of <code>A</code> <em>good</em> if the number of different integers in that subarray is exactly <code>K</code>.</p><p>(For example, <code>[1,2,3,1,2]</code> has <code>3</code> different integers: <code>1</code>, <code>2</code>, and <code>3</code>.)</p><p>Return the number of good subarrays of <code>A</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,1,2,3], K = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: A = [1,2,1,3,4], K = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>1 &lt;= A[i] &lt;= A.length</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol><a id="more"></a><h3 id="Solution">Solution</h3><p>It‚Äôs a bit different from previous <code> at most K different/distinct</code> problem. This question need just<code>K</code> different integers.</p><p>However, it‚Äôs straightforward to prove that <code>Just(K) = AtMost(K) - AtMost(K-1)</code>, so we can call the <a href="https://leeemask.com/2020/08/07/340.%20Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters/" target="_blank" rel="noopener">previous kinda code</a> twice and substract them then will get the res.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(A,K) - help(A,K-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; A.length ;j++)&#123;</span><br><span class="line">            map.put(A[j],map.getOrDefault(A[j],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; K)&#123;</span><br><span class="line">                map.put(A[i],map.get(A[i])-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(A[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(A[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-992-Subarrays-with-K-Different-Integers-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;992. Subarrays with K Different Integers&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/subarrays-with-k-different-integers/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an array &lt;code&gt;A&lt;/code&gt; of positive integers, call a (contiguous, not necessarily distinct) subarray of &lt;code&gt;A&lt;/code&gt; &lt;em&gt;good&lt;/em&gt; if the number of different integers in that subarray is exactly &lt;code&gt;K&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(For example, &lt;code&gt;[1,2,3,1,2]&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt; different integers: &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, and &lt;code&gt;3&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Return the number of good subarrays of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: A = [1,2,1,2,3], K = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: A = [1,2,1,3,4], K = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= A[i] &amp;lt;= A.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= K &amp;lt;= A.length&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 340. Longest Substring with At Most K Distinct Characters</title>
    <link href="WangHngLeee.github.io/2020/08/07/340.%20Longest%20Substring%20with%20At%20Most%20K%20Distinct%20Characters/"/>
    <id>WangHngLeee.github.io/2020/08/07/340. Longest Substring with At Most K Distinct Characters/</id>
    <published>2020-08-07T19:30:29.000Z</published>
    <updated>2020-08-07T23:50:38.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-340-Longest-Substring-with-At-Most-K-Distinct-Characters-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">340. Longest Substring with At Most K Distinct Characters</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/"><font size="4">üîó  Leetcode Link</font></a></p><h3 id="Examples">Examples</h3><p>Given a string, find the length of the longest substring T that contains at most <em>k</em> distinct characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;eceba&quot;, k = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: T is &quot;ece&quot; which its length is 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, k = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: T is &quot;aa&quot; which its length is 2.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Typical sliding window question. Using <code>left</code> and <code>right</code> pointer to scan the string, and keep each character‚Äôs frequency in a <code>HashMap</code>.</p><p>When the size of map <code>( which is also the total num of distinct characters)</code> is greater than k, we need to substract chars from left.</p><p>When the <code>map size &lt;= 2</code>, we update the res.</p><p>This question can share the same code template with question <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank" rel="noopener">159. Longest Substring with At Most Two Distinct Characters</a></p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//corner case</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() ==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right =<span class="number">0</span>; right &lt; s.length(); right++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(right);</span><br><span class="line">            map.put(temp, map.getOrDefault(temp,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(map.size() &gt; k)&#123;</span><br><span class="line">                <span class="keyword">char</span> leftchar = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(leftchar))&#123;</span><br><span class="line">                    map.put(leftchar,map.get(leftchar)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(map.get(leftchar) == <span class="number">0</span>)&#123;</span><br><span class="line">                        map.remove(leftchar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-340-Longest-Substring-with-At-Most-K-Distinct-Characters-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;340. Longest Substring with At Most K Distinct Characters&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a string, find the length of the longest substring T that contains at most &lt;em&gt;k&lt;/em&gt; distinct characters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: s = &amp;quot;eceba&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: T is &amp;quot;ece&amp;quot; which its length is 3.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: s = &amp;quot;aa&amp;quot;, k = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: T is &amp;quot;aa&amp;quot; which its length is 2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 3. Longest Substring Without Repeating Characters</title>
    <link href="WangHngLeee.github.io/2020/08/07/3.%20Longest%20Substring%20Without%20Repeating%20Characters/"/>
    <id>WangHngLeee.github.io/2020/08/07/3. Longest Substring Without Repeating Characters/</id>
    <published>2020-08-07T14:30:29.000Z</published>
    <updated>2020-08-07T22:34:24.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-3-Longest-Substring-Without-Repeating-Characters-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">3. Longest Substring Without Repeating Characters</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/"><font size="4">üîó  Leetcode Link</font></a></p><h3 id="Examples">Examples</h3><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using two pointers and HashSet to store the current chars. It set contains current char, it means we have seen this before, then move the left point. Update the max after we add a char to the set.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; s.length() &amp;&amp; right &lt;s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(right)))&#123;</span><br><span class="line">                set.add(s.charAt(right));</span><br><span class="line">                right++;</span><br><span class="line">                max = Math.max(max,set.size());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(left));</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-3-Longest-Substring-Without-Repeating-Characters-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;3. Longest Substring Without Repeating Characters&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;abcabcbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;bbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;pwwkew&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Note that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 5. Longest Palindromic Substring</title>
    <link href="WangHngLeee.github.io/2020/08/06/5.%20Longest%20Palindromic%20Substring/"/>
    <id>WangHngLeee.github.io/2020/08/06/5. Longest Palindromic Substring/</id>
    <published>2020-08-06T20:30:29.000Z</published>
    <updated>2020-08-07T22:27:54.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-5-Longest-Palindromic-Substring-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">5. Longest Palindromic Substring</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-substring/"><font size="4">üîó  Leetcode Link</font></a></p><h3 id="Examples">Examples</h3><p>Given a string s, find the longest palindromic subsequence‚Äôs length in s. You may assume that the maximum length of s is 1000.</p><p><strong>Example 1:</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bbbab&quot;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is ‚Äúbbbb‚Äù.</p><p><strong>Example 2:</strong><br>Input:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cbbd&quot;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>One possible longest palindromic subsequence is ‚Äúbb‚Äù.</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> consists only of lowercase English letters.</li></ul><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Two-Pointers">Two Pointers</h4><p>The first navie solution is using two pointers to scan both 1 chars or 2 chars from itself. Like <code>aabbaabb</code> we can start scaling from <code>a</code> or <code>aa</code>, because palindrome can only form with 1 or 2 chars.( 3 is based on 1).</p><h4 id="DP">DP</h4><p>It can also be solved by using DP.</p><p>It‚Äôs a bit like problem <a href="[https://leeemask.com/2020/08/06/516.%20Longest%20Palindromic%20Subsequence/](https://leeemask.com/2020/08/06/516. Longest Palindromic Subsequence/)">516. Longest Palindromic Subsequence</a> . We expand from inside to outside.</p><p>The only difference in this question is that : we only keep record of boolean array to see whether <code>dp[i][j]</code> can form a palindrome substring from <code>i</code> to <code>j</code>.</p><p>Only the situation meet the requirements of following can be a palindrome substring:</p><ul><li><p><code>s.charAt(i) == s.charAt(j)</code>: Two chars need to be same.</p></li><li><p><code>j-i&lt;3</code>: means only 2 or 1 letters in the current range. Like <code>aa</code> or <code>a</code>.</p></li><li><p><code>dp[i+1][j-1] = true </code> : It means that the smaller range from i+1 to j-1 can form a palindrome, so the current range from <code>i</code> to <code>j</code> can also be true.</p></li></ul><p>After updating the current dp state, we need to update the max length of substring and the start point. FInally we just return the substring from <code>start</code> to <code>start + max</code>.</p><h3 id="Code">Code</h3><h4 id="Two-Pointers-v2">Two Pointers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start, max;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            check(s,i,i);</span><br><span class="line">            check(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start + max);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right - left &gt; max)&#123;</span><br><span class="line">            max = right - left - <span class="number">1</span>;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p><h4 id="DP-v2">DP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = ( s.charAt(i) == s.charAt(j) &amp;&amp; ( j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>] ));</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j-i+<span class="number">1</span> &gt; max))&#123;</span><br><span class="line">                    max = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-5-Longest-Palindromic-Substring-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;5. Longest Palindromic Substring&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a string s, find the longest palindromic subsequence‚Äôs length in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
Input:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;bbbab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;One possible longest palindromic subsequence is ‚Äúbbbb‚Äù.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
Input:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;cbbd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;One possible longest palindromic subsequence is ‚Äúbb‚Äù.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; consists only of lowercase English letters.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
      <category term="DP" scheme="WangHngLeee.github.io/tags/DP/"/>
    
      <category term="Palindromic" scheme="WangHngLeee.github.io/tags/Palindromic/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 516. Longest Palindromic Subsequence</title>
    <link href="WangHngLeee.github.io/2020/08/06/516.%20Longest%20Palindromic%20Subsequence/"/>
    <id>WangHngLeee.github.io/2020/08/06/516. Longest Palindromic Subsequence/</id>
    <published>2020-08-06T14:30:29.000Z</published>
    <updated>2020-08-06T21:40:14.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-516-Longest-Palindromic-Subsequence-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">516. Longest Palindromic Subsequence</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/longest-palindromic-subsequence/"><font size="4">üîó  Leetcode Link</font></a></p><h3 id="Exapmles">Exapmles</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a string s, find the longest palindromic subsequence&apos;s length in s. You may assume that the maximum length of s is 1000.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">&quot;bbbab&quot;</span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line">One possible longest palindromic subsequence is &quot;bbbb&quot;.</span><br><span class="line"> </span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">&quot;cbbd&quot;</span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line">One possible longest palindromic subsequence is &quot;bb&quot;.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>It‚Äôs a typical palindromic string problem. When we see subsequence instead of substring, it means it can be interruptted and not continous, and we always using <code>DP </code> to solve that kind of uncontinous problem.</p><p>We first create a <code>two-dimension DP array</code> to store the length.</p><p><code>dp[i][j]</code> means the max palindromic subsequence between start of <code>i</code> and end of<code>j</code> in the string <code>s</code></p><p><code>Transition Function</code> :</p><ol><li>When <code>s.charAt(i) == s.charAt(j) </code>  :  <code>dp[i][j] = dp[i+1][j-1] + 2</code><ul><li>It looks like we expand the range of current <code>i+1, j-1</code> to <code>i,j</code>, which is extremely like two pointers , one with left+1, and one with right-1. Instead, in this problem we solve from inside to outside.</li></ul></li><li>When <code>s.charAt(i) != s.charAt(j) </code>  : <code>dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</code><ul><li>If ther are not the same, we just choosing the range from <code>left+1,right</code> or <code>left,right-1</code> because the subsequence can be interuppted.</li></ul></li></ol><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N^2) S:O(N^2)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-516-Longest-Palindromic-Subsequence-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;516. Longest Palindromic Subsequence&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Exapmles&quot;&gt;Exapmles&lt;/h3&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given a string s, find the longest palindromic subsequence&amp;apos;s length in s. You may assume that the maximum length of s is 1000.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;bbbab&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;One possible longest palindromic subsequence is &amp;quot;bbbb&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;cbbd&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;One possible longest palindromic subsequence is &amp;quot;bb&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
      <category term="DP" scheme="WangHngLeee.github.io/tags/DP/"/>
    
      <category term="Palindromic" scheme="WangHngLeee.github.io/tags/Palindromic/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 23. Merge k Sorted Lists</title>
    <link href="WangHngLeee.github.io/2020/08/03/23.%20Merge%20k%20Sorted%20Lists/"/>
    <id>WangHngLeee.github.io/2020/08/03/23. Merge k Sorted Lists/</id>
    <published>2020-08-04T00:27:29.000Z</published>
    <updated>2020-08-04T02:30:15.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-23-Merge-k-Sorted-Lists-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">23. Merge k Sorted Lists</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/merge-k-sorted-lists/"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using self-design <code>PriorityQueue</code> to store each head of <code>list</code> in the <code>lists</code>. Then loop each head and add their next listnode into the priorityqueue. Finally we can get a sorted linkedlist.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode head = dummy;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b)-&gt; a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span>(ListNode list : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            head.next = pq.poll();</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span>(head.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pq.add(head.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-23-Merge-k-Sorted-Lists-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;23. Merge k Sorted Lists&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/merge-k-sorted-lists/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1-&amp;gt;4-&amp;gt;5,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1-&amp;gt;3-&amp;gt;4,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2-&amp;gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="LinkedList" scheme="WangHngLeee.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 4. Median of Two Sorted Arrays</title>
    <link href="WangHngLeee.github.io/2020/08/03/4.%20Median%20of%20Two%20Sorted%20Arrays/"/>
    <id>WangHngLeee.github.io/2020/08/03/4. Median of Two Sorted Arrays/</id>
    <published>2020-08-03T22:27:29.000Z</published>
    <updated>2020-08-05T00:03:59.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-4-Median-of-Two-Sorted-Arrays-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">4. Median of Two Sorted Arrays</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/median-of-two-sorted-arrays/"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p><p>You may assume nums1 and nums2 cannot be both empty.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Brute-force">Brute force</h4><p>The first solution we can come up with is getting two arrays into one and sort the final array, then try to get the middle index number. But it will cost <code>O(nlogn)</code>, which doesn‚Äôt meet the time complexity requirement of <code>log(m+n)</code>.</p><p>Apparently, the <code>O(log(n+m))</code> can be approached only by <code>Binary Search</code>.</p><h4 id="Binary-Search">Binary Search</h4><p>Idea copied from <a href="https://leetcode.com/yaokaiyang" target="_blank" rel="noopener">@YaokaiYang<br></a></p><p>In order to solve this question, we need to first understand what a median is. A median is the middle value of a dataset.</p><p>Since we have 2 seperately sorted array in this question, to find the middle value is somewhat complicated. However, keep in mind that we do not care about the actual value of the numbers, what we want is the middle point from the combination of 2 arrays. In other words, we are looking for the middle index of the 2 arrays. Thus approach like binary search could be employed.</p><p>Based on the fact that the 2 arrays are sorted seperatedly, we could try to get the submedian of the 2 arrays in each round. Than compare them. And the basic idea is that the left half of the array with a smaller submedian can never contains the common median.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (mid1 &lt; mid2) keep nums1.right + nums2</span><br><span class="line">else keep nums1 + nums2.right</span><br></pre></td></tr></table></figure><h3 id="Code">Code</h3><h4 id="Navie-Brute-Force">Navie Brute Force</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;m ;i++)&#123;</span><br><span class="line">            arr[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j&lt;n;j++)&#123;</span><br><span class="line">            arr[m+j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> k = arr.length;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span> != <span class="number">0</span>)<span class="keyword">return</span> (<span class="keyword">double</span>)arr[k/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> ((<span class="keyword">double</span>)(arr[(k/<span class="number">2</span>) - <span class="number">1</span>] + arr[(k/<span class="number">2</span>)])/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(NlogN) S:O(N)</p><h4 id="Binary-Search-v2">Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> n = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (m + n + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (m + n + <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (help(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left) + help(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> s1, <span class="keyword">int</span>[]nums2, <span class="keyword">int</span> s2, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s1 &gt; nums1.length-<span class="number">1</span>)<span class="keyword">return</span> nums2[s2 + position - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>( s2 &gt; nums2.length-<span class="number">1</span>)<span class="keyword">return</span> nums1[s1 + position - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[s1], nums2[s2]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mid1 = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> mid2 = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s1 + position/<span class="number">2</span> - <span class="number">1</span> &lt; nums1.length)mid1 = nums1[s1 + position/<span class="number">2</span> -<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s2 + position/<span class="number">2</span> - <span class="number">1</span> &lt; nums2.length)mid2 = nums2[s2 + position/<span class="number">2</span> -<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mid1 &lt; mid2)&#123;</span><br><span class="line">            <span class="keyword">return</span> help(nums1,s1 + position/<span class="number">2</span>, nums2, s2, position - position/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> help(nums1,s1,nums2,s2 + position/<span class="number">2</span>, position - position/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(log(M+N)) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-4-Median-of-Two-Sorted-Arrays-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;4. Median of Two Sorted Arrays&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;/p&gt;
&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;
&lt;p&gt;You may assume nums1 and nums2 cannot be both empty.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 = [1, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 = [2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The median is 2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums1 = [1, 2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums2 = [3, 4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The median is (2 + 3)/2 = 2.5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 125. Valid Palindrome</title>
    <link href="WangHngLeee.github.io/2020/08/03/125.%20Valid%20Palindrome/"/>
    <id>WangHngLeee.github.io/2020/08/03/125. Valid Palindrome/</id>
    <published>2020-08-03T12:30:29.000Z</published>
    <updated>2020-08-03T14:07:08.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-125-Valid-Palindrome-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">125. Valid Palindrome</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/valid-palindrome/"><font size="4">LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p><p>Note: For the purpose of this problem, we define empty string as valid palindrome‚Ä¶</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using two pointers to scan the string from start and end. Skip all <code>unletterOrDigit</code> character like ‚Äô ‚Äô and ‚Äò.‚Äô and other signs. Then check two characters is same or not.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(!Character.isLetterOrDigit(l))&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(r))&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.toLowerCase(l) != Character.toLowerCase(r))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-125-Valid-Palindrome-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;125. Valid Palindrome&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/valid-palindrome/&quot;&gt;&lt;font size=&quot;4&quot;&gt;LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.&lt;/p&gt;
&lt;p&gt;Note: For the purpose of this problem, we define empty string as valid palindrome‚Ä¶&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: &amp;quot;race a car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 359. Logger Rate Limiter</title>
    <link href="WangHngLeee.github.io/2020/08/02/359.%20Logger%20Rate%20Limiter/"/>
    <id>WangHngLeee.github.io/2020/08/02/359. Logger Rate Limiter/</id>
    <published>2020-08-02T12:30:29.000Z</published>
    <updated>2020-08-03T01:47:19.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-359-Logger-Rate-Limiter-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">359. Logger Rate Limiter</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/logger-rate-limiter/"><font size="4">LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.</p><p>Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.</p><p>It is possible that several messages arrive roughly at the same time.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Logger logger = new Logger();</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 1</span><br><span class="line">logger.shouldPrintMessage(1, &quot;foo&quot;); returns true;</span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 2</span><br><span class="line">logger.shouldPrintMessage(2,&quot;bar&quot;); returns true;</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 3</span><br><span class="line">logger.shouldPrintMessage(3,&quot;foo&quot;); returns false;</span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 8</span><br><span class="line">logger.shouldPrintMessage(8,&quot;bar&quot;); returns false;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Navie">Navie</h4><p>It‚Äôs obvious that we can use a <code>HashMap</code> to store each message‚Äôs timestamp. Each time we meet a previous existed message, we only need check whether <code>current timestamp - map.get(message) &gt; 10</code>, if not return false. Otherwise update the message‚Äôs timestamp and return true.</p><p>However, using hashmap in some huge date stream can cause memory usage keeps growing, which is a waste of performance. So we have to think a better solution to save memory.</p><h4 id="Cicular-buffer">Cicular buffer</h4><p>Using Set and bucket array to store at most 10 seconds before. After that we clear the set. Give each <code>timestamp % 10</code> a new set to store message.</p><h4 id="Two-HashMap">Two HashMap</h4><p><code>starttime</code> record the start time of the <code>newmap</code>.</p><p><code>newmap</code> keeps the messages of <code>[starttime, starttime +10)</code>;</p><p><code>oldmap</code> keeps messages at most <code>20</code> seconds before.</p><h3 id="Code">Code</h3><h4 id="Navie-v2">Navie</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(message))&#123;</span><br><span class="line">            map.put(message,timestamp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(timestamp - map.get(message) &lt; <span class="number">10</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            map.put(message,timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(1) S:O(N)</p><h4 id="Circular-buffer">Circular buffer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bucket;</span><br><span class="line">    Set[] sets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sets = <span class="keyword">new</span> Set[<span class="number">10</span>];</span><br><span class="line">        bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sets.length;i++)&#123;</span><br><span class="line">            sets[i] = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = timestamp % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(timestamp != bucket[index])&#123;</span><br><span class="line">            sets[index].clear();</span><br><span class="line">            bucket[index] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bucket.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(timestamp - bucket[i] &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sets[i].contains(message))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[index].add(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(1) S:O(N)</p><h4 id="Two-HashMaps">Two HashMaps</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; oldmap;</span><br><span class="line">    Map&lt;String, Integer&gt; newmap;</span><br><span class="line">    <span class="keyword">int</span> startime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        oldmap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        newmap = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        starttime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timestamp &gt;= latest + <span class="number">20</span>)&#123; <span class="comment">// both map need refresh</span></span><br><span class="line">            oldmap.clear();</span><br><span class="line">            newmap.clear();</span><br><span class="line">            starttime = timestamp;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(timestamp &gt;= latest + <span class="number">10</span>)&#123; <span class="comment">// refresh new map and assign old map with the value of new map</span></span><br><span class="line">            oldmap = <span class="keyword">new</span> HashMap&lt;&gt;(newmap);</span><br><span class="line">            newmap.clear();</span><br><span class="line">            starttime = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newmap.containsKey(message)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(oldmap.containsKey(message))&#123;</span><br><span class="line">            <span class="keyword">int</span> last = oldmap.get(message);</span><br><span class="line">            <span class="keyword">if</span>(last + <span class="number">10</span> &gt; timestamp) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newmap.put(message, timestamp);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(1) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-359-Logger-Rate-Limiter-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;359. Logger Rate Limiter&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/logger-rate-limiter/&quot;&gt;&lt;font size=&quot;4&quot;&gt;LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.&lt;/p&gt;
&lt;p&gt;Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.&lt;/p&gt;
&lt;p&gt;It is possible that several messages arrive roughly at the same time.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Logger logger = new Logger();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// logging string &amp;quot;foo&amp;quot; at timestamp 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger.shouldPrintMessage(1, &amp;quot;foo&amp;quot;); returns true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// logging string &amp;quot;bar&amp;quot; at timestamp 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger.shouldPrintMessage(2,&amp;quot;bar&amp;quot;); returns true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// logging string &amp;quot;foo&amp;quot; at timestamp 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger.shouldPrintMessage(3,&amp;quot;foo&amp;quot;); returns false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// logging string &amp;quot;bar&amp;quot; at timestamp 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger.shouldPrintMessage(8,&amp;quot;bar&amp;quot;); returns false;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Design" scheme="WangHngLeee.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 844. Backspace String Compare</title>
    <link href="WangHngLeee.github.io/2020/07/29/844.%20Backspace%20String%20Compare/"/>
    <id>WangHngLeee.github.io/2020/07/29/844. Backspace String Compare/</id>
    <published>2020-07-29T23:30:29.000Z</published>
    <updated>2020-07-30T02:47:33.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-844-Backspace-String-Compare-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">844. Backspace String Compare</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/backspace-string-compare/"><font size="4">üîó LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Note that after backspacing an empty text, the text will continue empty.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Navie">Navie</h4><p>We can using stack to simulate backspacing option. When we meet <code>#</code> we just pop up the top element in the stack. Finally we only need to compare the two stacks.</p><h4 id="Backforward">Backforward</h4><p>Starting from the last element, keep count of the <code>#</code>. If current is <code>#</code>, we increase by 1. Otherwise, if count is larger than 0, it means current char is before # and need to be deleted. If count is equal to 0, we add current char to the res.</p><h4 id="Optimized-Two-pointers-with-O-1-space">Optimized - Two pointers with O(1) space</h4><p>Follow up : Can you make up only O(1) space ?</p><p>Apparently we can only using two pointers to achieve O(1) spce without any other space.</p><p>Start from both tails, keep record the number of ‚Äò#‚Äô.</p><p>It will eventually stop at the final char of res. Then we can check the rest of chars to see whether they are the same.</p><p>If not, we have to check whether they both have been cleaned up with index of -1.</p><h3 id="Code">Code</h3><h4 id="Navie-v2">Navie</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(S).equals(help(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Stack&lt;Character&gt; <span class="title">help</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) != <span class="string">'#'</span>)stack.push(str.charAt(i));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p><h4 id="Backforward-v2">Backforward</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(S).equals(help(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">help</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'#'</span>)count++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)count--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res+=c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p><h4 id="Two-pointers">Two pointers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(S == <span class="keyword">null</span> || T == <span class="keyword">null</span>)<span class="keyword">return</span> S == T;</span><br><span class="line">        <span class="keyword">int</span> m = S.length();</span><br><span class="line">        <span class="keyword">int</span> n = T.length();</span><br><span class="line">        <span class="keyword">int</span> cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; (S.charAt(i) == <span class="string">'#'</span> || cnt1 &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(i) == <span class="string">'#'</span>)cnt1++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt1--;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; (T.charAt(j) == <span class="string">'#'</span> || cnt2 &gt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(T.charAt(j) == <span class="string">'#'</span>)cnt2++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt2--;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j&gt;=<span class="number">0</span> &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; S.charAt(i) == T.charAt(j))&#123;</span><br><span class="line">                j--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i == -<span class="number">1</span> &amp;&amp; j == -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-844-Backspace-String-Compare-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;844. Backspace String Compare&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/backspace-string-compare/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Note that after backspacing an empty text, the text will continue empty.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Both S and T become &amp;quot;ac&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Both S and T become &amp;quot;&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: S = &amp;quot;a##c&amp;quot;, T = &amp;quot;#a#c&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Both S and T become &amp;quot;c&amp;quot;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
      <category term="Stack" scheme="WangHngLeee.github.io/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 683. K Empty Slots</title>
    <link href="WangHngLeee.github.io/2020/07/29/683.%20K%20Empty%20Slots/"/>
    <id>WangHngLeee.github.io/2020/07/29/683. K Empty Slots/</id>
    <published>2020-07-29T19:27:29.000Z</published>
    <updated>2020-07-29T21:43:43.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-683-K-Empty-Slots"><table><tr><td bgcolor="#E74C3C"><font color="white">683. K Empty Slots</font></td></tr></table></h2><p></p><p><a href="https://leetcode.com/problems/k-empty-slots/" target="_blank" rel="noopener"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Example">Example</h3><p>You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days.</p><p>You are given an array bulbs of length N where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed.</p><p>Given an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactly K bulbs between them that are all turned off.</p><p>If there isn‚Äôt such day, return -1.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">bulbs: [1,3,2]</span><br><span class="line">K: 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]</span><br><span class="line">On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]</span><br><span class="line">On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]</span><br><span class="line">We return 2 because on the second day, there were two on bulbs with one off bulb between them.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="TreeSet">TreeSet</h4><p>Using TreeSet to get the higher and lower pos of bulb in the previous. The only requirement is <code> currentDay - lower - 1 == K || higher - currentDay - 1 == K</code>.</p><p><code>set.lower(pos)</code> is going to find the first lower element from <code>pos</code> in the set.</p><p><code>set.higher(pos)</code> is going to find the first higher element from <code>pos</code> in the set.</p><h4 id="Straight-Forward">Straight Forward</h4><p>Checking by date. Create a new array of <code>days</code> to store the open time of each position bulb.</p><p>The only thing we need to do is keeping a window of size K and check left,right and current bulb‚Äôs open day. If <code>days[left] &lt; currentDay &amp;&amp; days[right] &lt; currentDay</code>, it means both left and right bulb will open before the currentDay. Like <code> ..open - close - open.. , assuming K is 1</code>, meeting the requirement of the question.</p><h3 id="Code">Code</h3><h4 id="TreeSet-v2">TreeSet</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] bulbs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bulbs.length;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> day = <span class="number">1</span>; day&lt;=n; day++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = bulbs[day-<span class="number">1</span>];</span><br><span class="line">            set.add(pos);</span><br><span class="line">            Integer lower = set.lower(pos);</span><br><span class="line">            Integer higher = set.higher(pos);</span><br><span class="line">            <span class="keyword">if</span>(lower != <span class="keyword">null</span> &amp;&amp; pos - lower -<span class="number">1</span> == k)<span class="keyword">return</span> day;</span><br><span class="line">            <span class="keyword">if</span>(higher != <span class="keyword">null</span> &amp;&amp; higher - pos - <span class="number">1</span> == k)<span class="keyword">return</span> day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: O(NlogN) S:O(N)</p><h4 id="Straight-Forward-v2">Straight Forward</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kEmptySlots</span><span class="params">(<span class="keyword">int</span>[] bulbs, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bulbs == <span class="keyword">null</span> || bulbs.length == <span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = bulbs.length;</span><br><span class="line">        <span class="keyword">int</span>[] days = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            days[bulbs[i]-<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; right &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(days[i] &gt; days[left] &amp;&amp; days[i] &gt; days[right])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i == right)&#123;</span><br><span class="line">                res = Math.min(res, Math.max(days[left], days[right]));</span><br><span class="line">            &#125;</span><br><span class="line">            left = i;</span><br><span class="line">            right = left + k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-683-K-Empty-Slots&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;683. K Empty Slots&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/k-empty-slots/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days.&lt;/p&gt;
&lt;p&gt;You are given an array bulbs of length N where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed.&lt;/p&gt;
&lt;p&gt;Given an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactly K bulbs between them that are all turned off.&lt;/p&gt;
&lt;p&gt;If there isn‚Äôt such day, return -1.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bulbs: [1,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;K: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;We return 2 because on the second day, there were two on bulbs with one off bulb between them.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 1248. Count Number of Nice Subarrays</title>
    <link href="WangHngLeee.github.io/2020/07/29/1248.%20Count%20Number%20of%20Nice%20Subarrays/"/>
    <id>WangHngLeee.github.io/2020/07/29/1248. Count Number of Nice Subarrays/</id>
    <published>2020-07-29T13:27:29.000Z</published>
    <updated>2020-07-29T15:08:31.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-1248-Count-Number-of-Nice-Subarrays-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">1248. Count Number of Nice Subarrays</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/count-number-of-nice-subarrays/submissions/" target="_blank" rel="noopener"><font size="4">üîó  LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Given an array of integers nums and an integer k. A subarray is called nice if there are k odd numbers on it.</p><p>Return the number of nice sub-arrays.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,2,1,1], k = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,4,6], k = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no odd numbers in the array.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Navie-Solution">Navie Solution</h4><p>Apparently using sliding window. Keep the window that matain K odd numbers. Then perform <code>atMost</code> algo, to get the number of subarray with exactly <code>k</code> odd numbers.</p><p><code>k = atMost(k) - atMost(k-1)</code></p><h4 id="Optimized-Solution">Optimized Solution</h4><p>Based on the sliding window, we record the number of even num and to get all the subarray number. It‚Äôs true that when we add the even number from 0 to max one , then we can get all the possible nums of combination.</p><h3 id="Code">Code</h3><h4 id="Sliding-Window-with-atMost">Sliding Window with atMost</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atMost(A, k) - atMost(A, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atMost</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, n = A.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            k -= A[j] % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                k+=A[i] % <span class="number">2</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p><h4 id="Optimized-Solution-v2">Optimized Solution</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSubarrays</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; n; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( k == <span class="number">0</span>)&#123;</span><br><span class="line">                k+=A[start++]%<span class="number">2</span>;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res+=count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-1248-Count-Number-of-Nice-Subarrays-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;1248. Count Number of Nice Subarrays&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/count-number-of-nice-subarrays/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given an array of integers nums and an integer k. A subarray is called nice if there are k odd numbers on it.&lt;/p&gt;
&lt;p&gt;Return the number of nice sub-arrays.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums = [1,1,2,1,1], k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums = [2,4,6], k = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: There is no odd numbers in the array.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 1004. Max Consecutive Ones III</title>
    <link href="WangHngLeee.github.io/2020/07/28/1004.%20Max%20Consecutive%20Ones%20III/"/>
    <id>WangHngLeee.github.io/2020/07/28/1004. Max Consecutive Ones III/</id>
    <published>2020-07-28T23:27:29.000Z</published>
    <updated>2020-07-29T04:18:59.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">946. Validate Stack Sequences</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/validate-stack-sequences/"><font size="4">üîó  Leetcode Link</font></a></p><h3 id="Example">Example</h3><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.</p><p>Return the length of the longest (contiguous) subarray that contains only 1s.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using <code>sliding window</code> to maintain just at most <code>K</code> zeros in the window.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; A.length; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] == <span class="number">0</span>)K--;</span><br><span class="line">            <span class="keyword">while</span>(start &lt;= end &amp;&amp; K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[start] == <span class="number">0</span>)K++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end - start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actually we can just using <code>if</code> instead of <code>while</code> cause we need the max length of 1s. So we can either matain the same size or increasing the size of window instead decrease it.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; A.length; end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[end] == <span class="number">0</span>)K--;</span><br><span class="line">            <span class="keyword">if</span>(K&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[start] == <span class="number">0</span>)K++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,end - start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;946. Validate Stack Sequences&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/validate-stack-sequences/&quot;&gt;&lt;font size=&quot;4&quot;&gt;üîó  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an array A of 0s and 1s, we may change up to K values from 0 to 1.&lt;/p&gt;
&lt;p&gt;Return the length of the longest (contiguous) subarray that contains only 1s.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1,1,1,0,0,1,1,1,1,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Two Pointers" scheme="WangHngLeee.github.io/tags/Two-Pointers/"/>
    
  </entry>
  
</feed>
