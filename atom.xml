<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leee&#39;s World</title>
  
  <subtitle>Talk is Cheap. Show me the code.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="WangHngLeee.github.io/"/>
  <updated>2020-07-22T05:27:38.047Z</updated>
  <id>WangHngLeee.github.io/</id>
  
  <author>
    <name>HongLeee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Review Problems List 📌</title>
    <link href="WangHngLeee.github.io/9999/12/31/problemslist/"/>
    <id>WangHngLeee.github.io/9999/12/31/problemslist/</id>
    <published>9999-12-31T16:13:23.000Z</published>
    <updated>2020-07-22T05:27:38.047Z</updated>
    
    <content type="html"><![CDATA[<br><font size="3"> 记录Problems list的完成情况 每日更新。<br><a href="https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ6qpA/edit#gid=972946549" target="_blank" rel="noopener"><font size="4">🔗 Problems List  Link </font></a><br>Github Leetcode Summary 同步更新。<br><a href="https://github.com/WangHngLeee/LeetcodeSummary" target="_blank" rel="noopener"><font size="4">🔗 Github Summary Link </font></a><br></font><br><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;br&gt;
&lt;font size=&quot;3&quot;&gt; 记录Problems list的完成情况 每日更新。&lt;br&gt;
&lt;a href=&quot;https://docs.google.com/spreadsheets/d/1SwcfcnOXL_7lbdqZm8dia_WU20aQ-ZTjGf4G0oJ
      
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Problems List" scheme="WangHngLeee.github.io/tags/Problems-List/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 234. Palindrome Linked List</title>
    <link href="WangHngLeee.github.io/2020/07/28/234-Palindrome-Linked-List/"/>
    <id>WangHngLeee.github.io/2020/07/28/234-Palindrome-Linked-List/</id>
    <published>2020-07-28T19:30:29.000Z</published>
    <updated>2020-07-28T22:43:18.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-234-Palindrome-Linked-List-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">234. Palindrome Linked List</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/palindrome-linked-list/"><font size="4">LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a singly linked list, determine if it is a palindrome.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using two pointers to find the two half of linkedlist, and reverse one of them. Then start comparation one by one.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast!=<span class="keyword">null</span> )&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = reverse(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span> &amp;&amp; fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow.val != fast.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-234-Palindrome-Linked-List-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;234. Palindrome Linked List&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/palindrome-linked-list/&quot;&gt;&lt;font size=&quot;4&quot;&gt;LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: 1-&amp;gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="LinkedList" scheme="WangHngLeee.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 53. Maximum Subarray</title>
    <link href="WangHngLeee.github.io/2020/07/28/53-Maximum-Subarray/"/>
    <id>WangHngLeee.github.io/2020/07/28/53-Maximum-Subarray/</id>
    <published>2020-07-28T19:30:29.000Z</published>
    <updated>2020-07-28T22:43:27.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-53-Maximum-Subarray-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">53. Maximum Subarray</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/maximum-subarray/"><font size="4">LeetCode Link </font></a></p><h3 id="Examples">Examples</h3><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure><h4 id="Follow-Up">Follow Up</h4><p>If you have figured out the O(n) solution, try coding another solution using the <code>divide and conquer</code> approach, which is more subtle.</p><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Greedy">Greedy</h4><p>It’s the first navie solution we can come with. Keep a record of sum and update only when the new sum is positive. Otherwise let current num be the sum value.</p><h4 id="DP">DP</h4><p>Based on the <code>greedy</code> solution, we can using <code>DP</code> to easily solve it. The basic idea is same.</p><p>The transition function is <code>dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0)</code>. Only add <code>nums[i]</code> to previous sum only when the sum is positive, otherwise only set <code>dp[i]</code> with current <code>nums[i]</code></p><h4 id="Divide-and-Conquer">Divide and Conquer</h4><p>Follow up solution. Just divide array into left and right part, and caculate another left and right parts of each part. Then reutrn the sum. If <code>leftsum</code> is bigger than both <code>rightsum</code> and <code>crosssum</code>, just return it. Same as rightsum and crosssum.</p><h3 id="Code">Code</h3><h4 id="Greedy-v2">Greedy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=num;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(sum,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p><h4 id="DP-v2">DP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            dp[i] = nums[i] + (dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> ? dp[i-<span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(n)</p><h4 id="Divide-and-Conquer-v2">Divide and Conquer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxsum = subArray(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subArray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right)&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">return</span> A[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> leftsum = subArray(A, left, mid); <span class="comment">//left part of the subarray sum, condition 1</span></span><br><span class="line">        <span class="keyword">int</span> rightsum = subArray(A, mid+<span class="number">1</span>, right); <span class="comment">//right part of the subarray sum, condition 2</span></span><br><span class="line">        <span class="keyword">int</span> middlesum = midSubArray(A, left, mid, right); <span class="comment">//cross part of the subarray sum, condition 3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftsum &gt;= rightsum &amp;&amp; leftsum &gt;= middlesum)&#123;</span><br><span class="line">            <span class="keyword">return</span> leftsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightsum &gt;= leftsum &amp;&amp; rightsum &gt;= middlesum)&#123;</span><br><span class="line">            <span class="keyword">return</span> rightsum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> middlesum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">midSubArray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leftsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> rightsum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--)&#123;</span><br><span class="line">            sum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; leftsum)&#123;</span><br><span class="line">                leftsum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = mid + <span class="number">1</span>; j &lt;= right; j++)&#123;</span><br><span class="line">            sum += A[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; rightsum)&#123;</span><br><span class="line">                rightsum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftsum + rightsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(nlogn) S:O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-53-Maximum-Subarray-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;53. Maximum Subarray&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/maximum-subarray/&quot;&gt;&lt;font size=&quot;4&quot;&gt;LeetCode Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [-2,1,-3,4,-1,2,1,-5,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: [4,-1,2,1] has the largest sum = 6.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Follow up:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;Follow-Up&quot;&gt;Follow Up&lt;/h4&gt;
&lt;p&gt;If you have figured out the O(n) solution, try coding another solution using the &lt;code&gt;divide and conquer&lt;/code&gt; approach, which is more subtle.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 1153. String Transforms Into Another String</title>
    <link href="WangHngLeee.github.io/2020/07/27/1153.%20String%20Transforms%20Into%20Another%20String/"/>
    <id>WangHngLeee.github.io/2020/07/27/1153. String Transforms Into Another String/</id>
    <published>2020-07-27T23:27:29.000Z</published>
    <updated>2020-07-28T02:30:41.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-1153-String-Transforms-Into-Another-String-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">1153. String Transforms Into Another String</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/string-transforms-into-another-string/"><font size="4">🔗  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions.</p><p>In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character.</p><p>Return true if and only if you can transform str1 into str2.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Convert &apos;c&apos; to &apos;e&apos; then &apos;b&apos; to &apos;d&apos; then &apos;a&apos; to &apos;c&apos;. Note that the order of conversions matter.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: str1 = &quot;leetcode&quot;, str2 = &quot;codeleet&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There is no way to transform str1 to str2.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Tricky-Part">Tricky Part</h4><p>We can use HashMap to store the link of chars. For example,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a -&gt; b, b-&gt;c , c-&gt;d</span><br></pre></td></tr></table></figure><p>So each time when we scan from both str1 and str2, we check the str2 character with the one stored in map of str1, if it non exist then set default one with str2’ char. Otherwise, if they are different, like the link in map is <code>a-&gt;c</code> but the reality is <code>a-&gt;d</code> then return false, because one character can’t transform to two different chars at same time.</p><h4 id="Special-Edge-case">Special/Edge case :</h4><p>First case is two string are equal then we return true.</p><p>Second one is like the unique chars of both strs are same and have 26 chars. But in order to transform one to another we need a temp char that is unused, like <code> temp -&gt; a, a -&gt; b , b-&gt; c , c-&gt; temp</code>. Same as swap two number in array. So in this case we can’t perform the transformation, because there is just 26 chars and no more for us to mark as temp, so just return false.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str1.equals(str2))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(str1 == <span class="keyword">null</span> || str1.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str1.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(str1.charAt(i), str2.charAt(i)) != str2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(str1.charAt(i),str2.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> set.size() &lt; <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-1153-String-Transforms-Into-Another-String-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;1153. String Transforms Into Another String&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/string-transforms-into-another-string/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions.&lt;/p&gt;
&lt;p&gt;In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character.&lt;/p&gt;
&lt;p&gt;Return true if and only if you can transform str1 into str2.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: str1 = &amp;quot;aabcc&amp;quot;, str2 = &amp;quot;ccdee&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Convert &amp;apos;c&amp;apos; to &amp;apos;e&amp;apos; then &amp;apos;b&amp;apos; to &amp;apos;d&amp;apos; then &amp;apos;a&amp;apos; to &amp;apos;c&amp;apos;. Note that the order of conversions matter.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: str1 = &amp;quot;leetcode&amp;quot;, str2 = &amp;quot;codeleet&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: There is no way to transform str1 to str2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="String" scheme="WangHngLeee.github.io/tags/String/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 209. Minimum Size Subarray Sum</title>
    <link href="WangHngLeee.github.io/2020/07/25/209.%20Minimum%20Size%20Subarray%20Sum/"/>
    <id>WangHngLeee.github.io/2020/07/25/209. Minimum Size Subarray Sum/</id>
    <published>2020-07-25T22:30:29.000Z</published>
    <updated>2020-07-26T04:28:25.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-209-Minimum-Size-Subarray-Sum-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">209. Minimum Size Subarray Sum</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/minimum-size-subarray-sum/"><font size="4">🔗  Leetcode Link</font></a></p><h3 id="Example">Example</h3><p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: s = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br><span class="line">Follow up:</span><br><span class="line">If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="Two-pointers-Sliding-window">Two pointers + Sliding window</h4><p>Since the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don’t have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices.</p><h4 id="Binary-search-Presum-array">Binary search + Presum array</h4><p>Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search.</p><h3 id="Code">Code</h3><h4 id="Two-pointers">Two pointers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(end &lt; len)&#123;</span><br><span class="line">            sum+=nums[end];</span><br><span class="line">            <span class="keyword">while</span>(start &lt;= end &amp;&amp; sum&gt;= s)&#123;</span><br><span class="line">                sum-=nums[start];</span><br><span class="line">                res = Math.min(res, end - start + <span class="number">1</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(n) S:O(1)</p><h4 id="Binary-Search">Binary Search</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="comment">// preSum[i] for i in [0, n-1], preSum[j] for j in [i+1, n]</span></span><br><span class="line">            <span class="keyword">int</span> j = binarySearch(i + <span class="number">1</span>, n + <span class="number">1</span> , preSum, s + preSum[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">                res = Math.min(res, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == n + <span class="number">1</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span>[] preSum, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = low, r = high;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (preSum[mid] &gt;= key) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l == high ? -<span class="number">1</span> : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(nlogn) S:O(n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-209-Minimum-Size-Subarray-Sum-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;209. Minimum Size Subarray Sum&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/minimum-size-subarray-sum/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: s = 7, nums = [2,3,1,2,4,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: the subarray [4,3] has the minimal length under the problem constraint.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Follow up:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 269. Alien Dictionary</title>
    <link href="WangHngLeee.github.io/2020/07/25/269.%20Alien%20Dictionary/"/>
    <id>WangHngLeee.github.io/2020/07/25/269. Alien Dictionary/</id>
    <published>2020-07-25T22:27:29.000Z</published>
    <updated>2020-07-26T04:29:08.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-269-Alien-Dictionary-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">269. Alien Dictionary</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/alien-dictionary/"><font size="4">🔗  Question Link </font></a></p><h3 id="Example">Example</h3><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;wrt&quot;,</span><br><span class="line">  &quot;wrf&quot;,</span><br><span class="line">  &quot;er&quot;,</span><br><span class="line">  &quot;ett&quot;,</span><br><span class="line">  &quot;rftt&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Output: &quot;wertf&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>It’s simple to come up with DFS and BFS solutions.</p><h4 id="DFS">DFS</h4><p>We can build a graph of connectin characters and make a topological sort using DFS. We can define different state of a character during DFS.</p><p><code>state[i] = -1</code> : Not even exist.</p><p><code>state[i] = 0</code> : Exist. Non-visited.</p><p><code>state[i] = 1</code> : Visiting.</p><p><code>state[i] = 2</code> : Visited.</p><h4 id="BFS">BFS</h4><p>We can using solution like indegree sorting to create a indegree of each character. And also create a set of other characters that ranks after current character. <code>Eg: wrf -&gt; w : r</code></p><h4 id="Edge-case-consideration">Edge case consideration</h4><p>In the new test cases ,there exist some cases like <code> 'abc', 'ab'</code>,which will occur ERROR when we using original code. So we have to add some code to return this case with “”.</p><p>Only thing we need to do is just compare the two adjcent string to check whether the first one can be made up with the whole next one.</p><h3 id="Code">Code</h3><h4 id="DFS-v2">DFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="comment">//     private final int N = 26;</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">boolean</span>[][] cnt = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(!build(words))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(state[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(words,i))<span class="keyword">return</span><span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String[] words, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        state[i] = <span class="number">1</span>; <span class="comment">// visiting</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(state[j] == <span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(state[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dfs(words,j))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[i] = <span class="number">2</span>;</span><br><span class="line">        sb.append((<span class="keyword">char</span>)(i+<span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">build</span><span class="params">(String[] words)</span></span>&#123;</span><br><span class="line">        Arrays.fill(state,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : words[i].toCharArray())&#123;</span><br><span class="line">                state[c-<span class="string">'a'</span>] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    String w1 = words[i-<span class="number">1</span>];</span><br><span class="line">                    String w2 = words[i];</span><br><span class="line">                    <span class="keyword">int</span> len = Math.min(w1.length(), w2.length());</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;len; k++)&#123;</span><br><span class="line">                        <span class="keyword">char</span> c1 = w1.charAt(k);</span><br><span class="line">                        <span class="keyword">char</span> c2 = w2.charAt(k);</span><br><span class="line">                        <span class="keyword">if</span>(c1 != c2)&#123;</span><br><span class="line">                            cnt[c1-<span class="string">'a'</span>][c2-<span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(w1.length() &gt; w2.length() &amp;&amp; w1.substring(<span class="number">0</span>,len).equals(w2.substring(<span class="number">0</span>,len)))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS-v2">BFS</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Set&lt;Character&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;Character, Set&lt;Character&gt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; degree=<span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(words==<span class="keyword">null</span> || words.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(String s: words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">                degree.put(c,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            String cur=words[i];</span><br><span class="line">            String next=words[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur.length() &gt; next.length() &amp;&amp; cur.startsWith(next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> length=Math.min(cur.length(), next.length());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;length; j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c1=cur.charAt(j);</span><br><span class="line">                <span class="keyword">char</span> c2=next.charAt(j);</span><br><span class="line">                <span class="keyword">if</span>(c1!=c2)&#123;</span><br><span class="line">                    Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(c1)) set=map.get(c1);</span><br><span class="line">                    <span class="keyword">if</span>(!set.contains(c2))&#123;</span><br><span class="line">                        set.add(c2);</span><br><span class="line">                        map.put(c1, set);</span><br><span class="line">                        degree.put(c2, degree.get(c2)+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Character&gt; q=<span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: degree.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(degree.get(c)==<span class="number">0</span>) q.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> c=q.remove();</span><br><span class="line">            result+=c;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c2: map.get(c))&#123;</span><br><span class="line">                    degree.put(c2,degree.get(c2)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(degree.get(c2)==<span class="number">0</span>) q.add(c2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result.length()!=degree.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-269-Alien-Dictionary-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;269. Alien Dictionary&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/alien-dictionary/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;wrt&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;wrf&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;er&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;ett&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;rftt&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: &amp;quot;wertf&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 138. Copy List with Random Pointer</title>
    <link href="WangHngLeee.github.io/2020/07/23/138.%20Copy%20List%20with%20Random%20Pointer/"/>
    <id>WangHngLeee.github.io/2020/07/23/138. Copy List with Random Pointer/</id>
    <published>2020-07-23T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:56.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-138-Copy-List-with-Random-Pointer-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">138. Copy List with Random Pointer</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/copy-list-with-random-pointer/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a deep copy of the list.</p><p>The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p><p>val: an integer representing Node.val</p><p>random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.</p><img src="https://assets.leetcode.com/uploads/2019/12/18/e1.png" alt="leetcode 138"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Easy to come up with <code>HashMap</code> solution. Keep record of the node and it’s new copied one. And assign each next and ramdon to the copied one.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> Node(node.val));</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.get(node).next = map.get(node.next);</span><br><span class="line">            map.get(node).random = map.get(node.random);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-138-Copy-List-with-Random-Pointer-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;138. Copy List with Random Pointer&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/copy-list-with-random-pointer/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.&lt;/p&gt;
&lt;p&gt;Return a deep copy of the list.&lt;/p&gt;
&lt;p&gt;The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:&lt;/p&gt;
&lt;p&gt;val: an integer representing Node.val&lt;/p&gt;
&lt;p&gt;random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.&lt;/p&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2019/12/18/e1.png&quot; alt=&quot;leetcode 138&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="LinkedList" scheme="WangHngLeee.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <link href="WangHngLeee.github.io/2020/07/23/426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/"/>
    <id>WangHngLeee.github.io/2020/07/23/426. Convert Binary Search Tree to Sorted Doubly Linked List/</id>
    <published>2020-07-23T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:41.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">426. Convert Binary Search Tree to Sorted Doubly Linked List</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.</p><p>You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p><p>We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: root = [4,2,5,1,3]</span><br></pre></td></tr></table></figure><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output: [1,2,3,4,5]</span><br></pre></td></tr></table></figure><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Using the benifit of inorder to traverse the tree.</p><p>As we all know that inorder is an assending array. So we can using DFS to inorder traverse the whole tree.</p><p>Hence during the middle line code, all we need to do is linking the nodes and reassign the new node to the variables.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        pre.right = head; <span class="comment">// link the pre.right to the head</span></span><br><span class="line">        head.left = pre;  <span class="comment">// link the head.left to the pre. In order to make the listnode cycled.</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span>)head = cur; <span class="comment">// pre is used to store the left node of cur. If pre is null, it means cur has no node in the left, so the head should be cur.</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right = cur; <span class="comment">// otherwise we link pre node to cur using pre.right = cur like `pre-&gt;cur`; </span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.left = pre; <span class="comment">// linking pre to the cur node like `pre&lt;-cur` (We have link those two before from `pre-&gt;cur`)</span></span><br><span class="line">        pre = cur; <span class="comment">// updating the value of pre and keeping dfs.</span></span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;426. Convert Binary Search Tree to Sorted Doubly Linked List&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.&lt;/p&gt;
&lt;p&gt;You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.&lt;/p&gt;
&lt;p&gt;We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.&lt;/p&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: root = [4,2,5,1,3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Output: [1,2,3,4,5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="LinkedList" scheme="WangHngLeee.github.io/tags/LinkedList/"/>
    
      <category term="BST" scheme="WangHngLeee.github.io/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 297. Serialize and Deserialize Binary Tree</title>
    <link href="WangHngLeee.github.io/2020/07/23/297.%20Serialize%20and%20Deserialize%20Binary%20Tree/"/>
    <id>WangHngLeee.github.io/2020/07/23/297. Serialize and Deserialize Binary Tree/</id>
    <published>2020-07-23T22:27:29.000Z</published>
    <updated>2020-07-24T04:02:52.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">297. Serialize and Deserialize Binary Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/submissions/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.</p><p>You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><ul><li><p>Serialize: Using stringbuilder to take tree into a string split with &quot; &quot; using preorder + dfs.</p></li><li><p>Deserialize: Using the result from serialize to form a new tree preorderly.</p></li></ul><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serial(root,res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serial</span><span class="params">(TreeNode root, StringBuilder res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)res.append(<span class="string">"null"</span>).append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.append(root.val).append(<span class="string">" "</span>);</span><br><span class="line">            serial(root.left,res);</span><br><span class="line">            serial(root.right,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String source)</span></span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        String[] strs = source.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            queue.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> des(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">des</span><span class="params">(Queue&lt;String&gt; queue)</span></span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(cur.equals(<span class="string">"null"</span>))<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        node.left = des(queue);</span><br><span class="line">        node.right = des(queue);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-297-Serialize-and-Deserialize-Binary-Tree-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;297. Serialize and Deserialize Binary Tree&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/serialize-and-deserialize-binary-tree/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/submissions/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;/p&gt;
&lt;p&gt;Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.&lt;/p&gt;
&lt;p&gt;You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You may serialize the following tree:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4   5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;as &amp;quot;[1,2,3,null,null,4,5]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Tree" scheme="WangHngLeee.github.io/tags/Tree/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 255. Verify Preorder Sequence in Binary Search Tree</title>
    <link href="WangHngLeee.github.io/2020/07/22/255.%20Verify%20Preorder%20Sequence%20in%20Binary%20Search%20Tree/"/>
    <id>WangHngLeee.github.io/2020/07/22/255. Verify Preorder Sequence in Binary Search Tree/</id>
    <published>2020-07-22T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:54.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-255-Verify-Preorder-Sequence-in-Binary-Search-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">255. Verify Preorder Sequence in Binary Search Tree</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.</p><p>You may assume each number in the sequence is unique.</p><p>Consider the following binary search tree:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [5,2,6,1,3]</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [5,2,1,3,6]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><ol><li><p>Using DFS and loop the whole array to find the bigger index, then dfs the left and right part.</p></li><li><p>Using stack to iterate the tree. When current node is bigger than the peek in the stack, let low equal to the popped one, until the peek is greater than current node.</p></li></ol><h3 id="Code">Code</h3><ol><li>DFS</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[start];</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max == -<span class="number">1</span> &amp;&amp; a[i] &gt; temp) max = i;</span><br><span class="line">            <span class="keyword">if</span>(max != -<span class="number">1</span> &amp;&amp; a[i] &lt; temp) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bigger == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> help(a, start + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> help(a, start + <span class="number">1</span>, max - <span class="number">1</span>) &amp;&amp; help(a, max, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Stack</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = Integer.MIN_VALUE;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : preorder) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p &lt; low)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (!path.empty() &amp;&amp; p &gt; path.peek())</span><br><span class="line">                low = path.pop();</span><br><span class="line">            path.push(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-255-Verify-Preorder-Sequence-in-Binary-Search-Tree-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;255. Verify Preorder Sequence in Binary Search Tree&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/verify-preorder-sequence-in-binary-search-tree/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree.&lt;/p&gt;
&lt;p&gt;You may assume each number in the sequence is unique.&lt;/p&gt;
&lt;p&gt;Consider the following binary search tree:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [5,2,6,1,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [5,2,1,3,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 113. Path Sum II</title>
    <link href="WangHngLeee.github.io/2020/07/22/113.%20Path%20Sum%20II/"/>
    <id>WangHngLeee.github.io/2020/07/22/113. Path Sum II/</id>
    <published>2020-07-22T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:57.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-113-Path-Sum-II-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">113. Path Sum II</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/path-sum-ii/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p><p>Note: A leaf is a node with no children.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>It’s simple and clear we have to use DFS + backtracking to get all the possible paths.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; templist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        help(root,res,sum,templist);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span> sum, List&lt;Integer&gt; templist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        templist.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(templist));</span><br><span class="line">        &#125;</span><br><span class="line">        help(root.left,res,sum - root.val, templist);</span><br><span class="line">        help(root.right,res,sum-root.val, templist);</span><br><span class="line">        templist.remove(templist.size() -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-113-Path-Sum-II-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;113. Path Sum II&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/path-sum-ii/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.&lt;/p&gt;
&lt;p&gt;Note: A leaf is a node with no children.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given the below binary tree and sum = 22,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4   8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  11  13  4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; /  \    / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7    2  5   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Return:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [5,4,11,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [5,8,4,5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 946. Validate Stack Sequences</title>
    <link href="WangHngLeee.github.io/2020/07/22/946.%20Validate%20Stack%20Sequences/"/>
    <id>WangHngLeee.github.io/2020/07/22/946. Validate Stack Sequences/</id>
    <published>2020-07-22T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:43.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">946. Validate Stack Sequences</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/validate-stack-sequences/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Example">Example</h3><p>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>We can solve this by simulating a real stack. We first Loop through the pushed array, keep pushing pushed elements into stack if the top element on the stack is different from the current one of popped;</p><p>Keep poping out of the top element from stack if it is same as the current one of popped;<br>Check if the stack is empty after loop.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; idx &lt; popped.length &amp;&amp; stack.peek() == popped[idx])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx == popped.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(N) S:O(N)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-946-Validate-Stack-Sequences-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;946. Validate Stack Sequences&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/validate-stack-sequences/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: We might do the following sequence:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push(1), push(2), push(3), push(4), pop() -&amp;gt; 4,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 79. Word Search</title>
    <link href="WangHngLeee.github.io/2020/07/21/79.%20Word%20Search/"/>
    <id>WangHngLeee.github.io/2020/07/21/79. Word Search/</id>
    <published>2020-07-21T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:58.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">341. Flatten Nested List Iterator</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/word-search/"><font size="4">🔗  Leetcode Link</font></a></p><p><a target="_blank" href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/submissions/"><font size="4">🔗  Leetcode-CN Link</font></a></p><h3 id="Examples">Examples</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Clearly we can using <code>DFS</code> and <code>Backtracking</code> to find the matched path in four different directions. Temperaily changing <code>borad[i][j</code>] to <code>'#'</code> before next DFS.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,word,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == word.length())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || board[i][j] != word.charAt(start))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board,word,i+<span class="number">1</span>,j,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i-<span class="number">1</span>,j,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i,j+<span class="number">1</span>,start+<span class="number">1</span>)||</span><br><span class="line">                      dfs(board,word,i,j-<span class="number">1</span>,start+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = word.charAt(start);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;341. Flatten Nested List Iterator&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/word-search/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/submissions/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Leetcode-CN Link&lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;/p&gt;
&lt;p&gt;The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;board =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;apos;A&amp;apos;,&amp;apos;B&amp;apos;,&amp;apos;C&amp;apos;,&amp;apos;E&amp;apos;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;apos;S&amp;apos;,&amp;apos;F&amp;apos;,&amp;apos;C&amp;apos;,&amp;apos;S&amp;apos;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&amp;apos;A&amp;apos;,&amp;apos;D&amp;apos;,&amp;apos;E&amp;apos;,&amp;apos;E&amp;apos;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given word = &amp;quot;ABCCED&amp;quot;, return true.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given word = &amp;quot;SEE&amp;quot;, return true.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given word = &amp;quot;ABCB&amp;quot;, return false.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 341. Flatten Nested List Iterator</title>
    <link href="WangHngLeee.github.io/2020/07/20/341.%20Flatten%20Nested%20List%20Iterator/"/>
    <id>WangHngLeee.github.io/2020/07/20/341. Flatten Nested List Iterator/</id>
    <published>2020-07-20T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:48.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">341. Flatten Nested List Iterator</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/flatten-nested-list-iterator/"><font size="4">🔗  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a nested list of integers, implement an iterator to flatten it.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,1,2,1,1].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,[4,[6]]]</span><br><span class="line">Output: [1,4,6]</span><br><span class="line">Explanation: By calling next repeatedly until hasNext returns false, </span><br><span class="line">             the order of elements returned by next should be: [1,4,6].</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Typical flatten array question. We can using stack to add each part from right to left, in order to keep the <code>leftmost</code> at the top of stack.</p><p>In <code>hasNext()</code> we have to check the peek, if the peek is integer then we just return true. If not it means it’a <code>nestedList</code> so we have to flatten it and push back to the stack.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    Stack&lt;NestedInteger&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        help(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext() ? stack.pop().getInteger() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.peek().isInteger())<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            help(stack.pop().getList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;NestedInteger&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            stack.push(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-341-Flatten-Nested-List-Iterator-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;341. Flatten Nested List Iterator&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/flatten-nested-list-iterator/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a nested list of integers, implement an iterator to flatten it.&lt;/p&gt;
&lt;p&gt;Each element is either an integer, or a list – whose elements may also be integers or other lists.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [[1,1],2,[1,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1,1,2,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: By calling next repeatedly until hasNext returns false, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             the order of elements returned by next should be: [1,1,2,1,1].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: [1,[4,[6]]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1,4,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: By calling next repeatedly until hasNext returns false, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             the order of elements returned by next should be: [1,4,6].&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Design" scheme="WangHngLeee.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 346. Moving Average from Data Stream</title>
    <link href="WangHngLeee.github.io/2020/07/20/346.%20Moving%20Average%20from%20Data%20Stream/"/>
    <id>WangHngLeee.github.io/2020/07/20/346. Moving Average from Data Stream/</id>
    <published>2020-07-20T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:45.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-346-Moving-Average-from-Data-Stream-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">346. Moving Average from Data Stream</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/moving-average-from-data-stream/"><font size="4">🔗 Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1</span><br><span class="line">m.next(10) = (1 + 10) / 2</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>Simple question that we can using circular queue to solve it. When the queue reach size then we poll one element and substract it from the sum.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        s = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.size() == s)&#123;</span><br><span class="line">            sum-=queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(val);</span><br><span class="line">        sum+=val;</span><br><span class="line">        <span class="keyword">return</span> sum/queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-346-Moving-Average-from-Data-Stream-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;346. Moving Average from Data Stream&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/moving-average-from-data-stream/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗 Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MovingAverage m = new MovingAverage(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;m.next(1) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;m.next(10) = (1 + 10) / 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;m.next(3) = (1 + 10 + 3) / 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;m.next(5) = (10 + 3 + 5) / 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Design" scheme="WangHngLeee.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>Review | Easy | 350. Intersection of Two Arrays II</title>
    <link href="WangHngLeee.github.io/2020/07/20/350.%20Intersection%20of%20Two%20Arrays%20II/"/>
    <id>WangHngLeee.github.io/2020/07/20/350. Intersection of Two Arrays II/</id>
    <published>2020-07-20T22:30:29.000Z</published>
    <updated>2020-07-28T19:40:15.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-28B463-font-color-white-350-Intersection-of-Two-Arrays-II-font-td-tr-table"><table><tr><td bgcolor="#28B463"><font color="white">350. Intersection of Two Arrays II</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/intersection-of-two-arrays-ii/"><font size="4">🔗Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given two arrays, write a function to compute their intersection.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>We can using one hashmap to store each number’s frequency in the nums1 array. Then make a loop in nums2. If the num in nums2 exist in map and it’s frequency is bigger than 0 then add it to res.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums1)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num) &amp;&amp; map.get(num)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">                map.put(num,map.get(num)-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++)&#123;</span><br><span class="line">            ans[index++]=res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-28B463-font-color-white-350-Intersection-of-Two-Arrays-II-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#28B463&quot;&gt;&lt;font color=&quot;white&quot;&gt;350. Intersection of Two Arrays II&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/intersection-of-two-arrays-ii/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums1 = [1,2,2,1], nums2 = [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [4,9]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Array" scheme="WangHngLeee.github.io/tags/Array/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 802. Find Eventual Safe States</title>
    <link href="WangHngLeee.github.io/2020/07/20/802.%20Find%20Eventual%20Safe%20States/"/>
    <id>WangHngLeee.github.io/2020/07/20/802. Find Eventual Safe States/</id>
    <published>2020-07-20T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:41.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">802. Find Eventual Safe States</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/find-eventual-safe-states/"><font size="4">🔗  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p><p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</p><p>Which nodes are eventually safe?  Return them as an array in sorted order.</p><p>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Here is a diagram of the above graph.</span><br></pre></td></tr></table></figure><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png" alt="leetcode 802"><a id="more"></a><h3 id="Solution">Solution</h3><h4 id="1-Topological-DFS">1. Topological + DFS</h4><p>We can use Topological sort and DFS to get the circle. Using seen[] to keep record of each node’s state in the looping.</p><p>Three different states:</p><ul><li>0 means <code>unvisited</code> unsafe</li><li>1 means <code>visiting</code>  unsafe</li><li>2 means <code>visited</code>   safe<br>We only need to add the node that has state == 2, which is the safe state.</li></ul><h4 id="2-Topologial-BFS-degree-solution">2. Topologial + BFS degree solution</h4><p>Originally we using BFS to find a circle in an indegree array. In this question we have to loop from the end point, so we need to reverse the whole graph to a indegree array. Then we just add the node with degree of 0 into the res array.</p><h3 id="Code">Code</h3><ul><li>Topological + DFS</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;graph.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(graph,i,state))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> node, <span class="keyword">int</span>[] state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state[node] !=<span class="number">0</span> )<span class="keyword">return</span> state[node] == <span class="number">2</span>;</span><br><span class="line">        state[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,num,state))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state[node] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V+E) S:O(V)</p><ul><li>Topological + BFS + Reverse Graph</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        List&lt;Integer&gt;[] map = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            map[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : graph[i])&#123;</span><br><span class="line">                map[num].add(i);</span><br><span class="line">                indegree[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">            res.add(node);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : map[node])&#123;</span><br><span class="line">                indegree[num]--;</span><br><span class="line">                <span class="keyword">if</span>(indegree[num] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V+E) S:O(V)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-802-Find-Eventual-Safe-States-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;802. Find Eventual Safe States&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/find-eventual-safe-states/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.&lt;/p&gt;
&lt;p&gt;Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.&lt;/p&gt;
&lt;p&gt;Which nodes are eventually safe?  Return them as an array in sorted order.&lt;/p&gt;
&lt;p&gt;The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [2,4,5,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Here is a diagram of the above graph.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png&quot; alt=&quot;leetcode 802&quot;&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 351. Android Unlock Patterns</title>
    <link href="WangHngLeee.github.io/2020/07/17/351.%20Android%20Unlock%20Patterns/"/>
    <id>WangHngLeee.github.io/2020/07/17/351. Android Unlock Patterns/</id>
    <published>2020-07-17T22:30:29.000Z</published>
    <updated>2020-07-24T04:02:39.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-351-Android-Unlock-Patterns-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">351. Android Unlock Patterns</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/android-unlock-patterns/" target="_blank" rel="noopener"><font size="4">🔗  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.</p><p><strong>Rules for a valid pattern:</strong></p><ul><li>Each pattern must connect at least m keys and at most n keys.</li><li>All the keys must be distinct.</li><li>If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern.</li><li>No jumps through non selected key is allowed.</li><li>The order of keys used matters.</li></ul><img src="https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png"><p>Explanation:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 1 | 2 | 3 |</span><br><span class="line">| 4 | 5 | 6 |</span><br><span class="line">| 7 | 8 | 9 |</span><br><span class="line"></span><br><span class="line">Invalid move: 4 - 1 - 3 - 6</span><br><span class="line">Line 1 - 3 passes through key 2 which had not been selected in the pattern.</span><br><span class="line"></span><br><span class="line">Invalid move: 4 - 1 - 9 - 2</span><br><span class="line">Line 1 - 9 passes through key 5 which had not been selected in the pattern.</span><br><span class="line"></span><br><span class="line">Valid move: 2 - 4 - 1 - 3 - 6</span><br><span class="line">Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern</span><br><span class="line"></span><br><span class="line">Valid move: 6 - 5 - 4 - 1 - 9 - 2</span><br><span class="line">Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>First thought is using DFS to find all the possible path and count it’s total count. But it can be optimized by using a skip array.</p><p>The optimization idea is that 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4.</p><p>Skip array store the number that between two numbers with only one interval.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cur: the current position</span></span><br><span class="line">    <span class="comment">// remain: the steps remaining</span></span><br><span class="line">    <span class="keyword">int</span>[][] skip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">boolean</span> seen[] = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> remain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(remain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        seen[cur] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// If vis[i] is not visited and (two numbers are adjacent or skip number is already visited)</span></span><br><span class="line">            <span class="keyword">if</span>(!seen[i] &amp;&amp; (skip[cur][i] == <span class="number">0</span> || seen[skip[cur][i]])) &#123;</span><br><span class="line">                res+= DFS(i, remain - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        seen[cur] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">3</span>] = skip[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">        skip[<span class="number">3</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">        skip[<span class="number">7</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">        skip[<span class="number">1</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">1</span>] = skip[<span class="number">2</span>][<span class="number">8</span>] = skip[<span class="number">8</span>][<span class="number">2</span>] = skip[<span class="number">3</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">3</span>] = skip[<span class="number">4</span>][<span class="number">6</span>] = skip[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// DFS search each length from m to n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; ++i) &#123;</span><br><span class="line">            res+= DFS(<span class="number">1</span>, i - <span class="number">1</span>) * <span class="number">4</span>; <span class="comment">// start with 1(same as 3, 7, 9 ), so we multiply 4 here.</span></span><br><span class="line">            res+= DFS(<span class="number">2</span>, i - <span class="number">1</span>) * <span class="number">4</span>; <span class="comment">// start with 2(same as 4,6,8), so we multiply 4 here.</span></span><br><span class="line">            res+= DFS(<span class="number">5</span>, i - <span class="number">1</span>); <span class="comment">// start with 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T:O(V^2) S:O(V)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-351-Android-Unlock-Patterns-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;351. Android Unlock Patterns&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/android-unlock-patterns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rules for a valid pattern:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each pattern must connect at least m keys and at most n keys.&lt;/li&gt;
&lt;li&gt;All the keys must be distinct.&lt;/li&gt;
&lt;li&gt;If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern.&lt;/li&gt;
&lt;li&gt;No jumps through non selected key is allowed.&lt;/li&gt;
&lt;li&gt;The order of keys used matters.&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/12/android-unlock.png&quot;&gt;
&lt;p&gt;Explanation:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;| 1 | 2 | 3 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 4 | 5 | 6 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 7 | 8 | 9 |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Invalid move: 4 - 1 - 3 - 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Line 1 - 3 passes through key 2 which had not been selected in the pattern.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Invalid move: 4 - 1 - 9 - 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Line 1 - 9 passes through key 5 which had not been selected in the pattern.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Valid move: 2 - 4 - 1 - 3 - 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Line 1 - 3 is valid because it passes through key 2, which had been selected in the pattern&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Valid move: 6 - 5 - 4 - 1 - 9 - 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Hard | 329. Longest Increasing Path in a Matrix</title>
    <link href="WangHngLeee.github.io/2020/07/17/329.%20Longest%20Increasing%20Path%20in%20a%20Matrix/"/>
    <id>WangHngLeee.github.io/2020/07/17/329. Longest Increasing Path in a Matrix/</id>
    <published>2020-07-17T22:27:29.000Z</published>
    <updated>2020-07-24T04:02:51.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-E74C3C-font-color-white-329-Longest-Increasing-Path-in-a-Matrix-font-td-tr-table"><table><tr><td bgcolor="#E74C3C"><font color="white">329. Longest Increasing Path in a Matrix</font></td></tr></table></h2><p><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener"><font size="4">🔗  Question Link </font></a></p><h3 id="Example">Example</h3><p>Given an integer matrix, find the length of the longest increasing path.</p><p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = </span><br><span class="line">[</span><br><span class="line">  [9,9,4],</span><br><span class="line">  [6,6,8],</span><br><span class="line">  [2,1,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [1, 2, 6, 9].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = </span><br><span class="line">[</span><br><span class="line">  [3,4,5],</span><br><span class="line">  [3,2,6],</span><br><span class="line">  [2,2,1]</span><br><span class="line">] </span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>It is a typical <code>recursive + memo</code> question. We might think using db at first, but it is unnecessary. We can just DFS every number and keep a memo of it’s max length of increasing path in <code>memo[i][j]</code>.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = dfs(matrix, i, j, memo);</span><br><span class="line">                max = Math.max(max, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            max = Math.max(max,  <span class="number">1</span> + dfs(matrix, x, y, memo));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i][j] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T: O(n^2) S: O(n^2)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-E74C3C-font-color-white-329-Longest-Increasing-Path-in-a-Matrix-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#E74C3C&quot;&gt;&lt;font color=&quot;white&quot;&gt;329. Longest Increasing Path in a Matrix&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-path-in-a-matrix/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Example&quot;&gt;Example&lt;/h3&gt;
&lt;p&gt;Given an integer matrix, find the length of the longest increasing path.&lt;/p&gt;
&lt;p&gt;From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [9,9,4],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [6,6,8],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The longest increasing path is [1, 2, 6, 9].&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Example 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input: nums = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,4,5],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3,2,6],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="WangHngLeee.github.io/tags/Graph/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
  </entry>
  
  <entry>
    <title>Review | Medium | 348. Design Tic-Tac-Toe</title>
    <link href="WangHngLeee.github.io/2020/07/17/348.%20Design%20Tic-Tac-Toe/"/>
    <id>WangHngLeee.github.io/2020/07/17/348. Design Tic-Tac-Toe/</id>
    <published>2020-07-17T22:27:29.000Z</published>
    <updated>2020-07-24T04:02:44.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-348-Design-Tic-Tac-Toe-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">348. Design Tic-Tac-Toe</font></td></tr></table></h2><p><a target="_blank" href="https://leetcode.com/problems/design-tic-tac-toe/"><font size="4">🔗  Question Link </font></a></p><h3 id="Examples">Examples</h3><p>Design a Tic-tac-toe game that is played between two players on a n x n grid.</p><p>You may assume the following rules:</p><p>A move is guaranteed to be valid and is placed on an empty block.<br>Once a winning condition is reached, no more moves is allowed.<br>A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.</span><br><span class="line"></span><br><span class="line">TicTacToe toe = new TicTacToe(3);</span><br><span class="line"></span><br><span class="line">toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| | |</span><br><span class="line">| | | |    // Player 1 makes a move at (0, 0).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 2 makes a move at (0, 2).</span><br><span class="line">| | | |</span><br><span class="line"></span><br><span class="line">toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| | | |    // Player 1 makes a move at (2, 2).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 2 makes a move at (1, 1).</span><br><span class="line">| | |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">| |O| |    // Player 1 makes a move at (2, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 2 makes a move at (1, 0).</span><br><span class="line">|X| |X|</span><br><span class="line"></span><br><span class="line">toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)</span><br><span class="line">|X| |O|</span><br><span class="line">|O|O| |    // Player 1 makes a move at (2, 1).</span><br><span class="line">|X|X|X|</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Solution">Solution</h3><p>It’s a simple question. We can use two array to store the score in rows and cols. And keep two record for diag and antidiag directions. If anyone of them reach to the size, then return current player. Otherwise just return 0.</p><h3 id="Code">Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicTacToe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] rows;</span><br><span class="line">    <span class="keyword">int</span>[] cols;</span><br><span class="line">    <span class="keyword">int</span> diag;</span><br><span class="line">    <span class="keyword">int</span> antidiag;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicTacToe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        rows = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        cols = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        diag = <span class="number">0</span>;</span><br><span class="line">        antidiag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> row The row of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> col The column of the board.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> player The player, can be either 1 or 2.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@return</span> The current winning condition, can be either:</span></span><br><span class="line"><span class="comment">                0: No one wins.</span></span><br><span class="line"><span class="comment">                1: Player 1 wins.</span></span><br><span class="line"><span class="comment">                2: Player 2 wins. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = player == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        rows[row] += step;</span><br><span class="line">        cols[col] += step;</span><br><span class="line">        <span class="keyword">if</span>(row == col)&#123;</span><br><span class="line">            diag+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(col == cols.length - row - <span class="number">1</span>)&#123;</span><br><span class="line">            antidiag+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = rows.length;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(rows[row]) == size || Math.abs(cols[col]) == size || Math.abs(diag) == size || Math.abs(antidiag) == size)<span class="keyword">return</span> player;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;table-tr-td-bgcolor-F5B041-font-color-white-348-Design-Tic-Tac-Toe-font-td-tr-table&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#F5B041&quot;&gt;&lt;font color=&quot;white&quot;&gt;348. Design Tic-Tac-Toe&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://leetcode.com/problems/design-tic-tac-toe/&quot;&gt;&lt;font size=&quot;4&quot;&gt;🔗  Question Link &lt;/font&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Examples&quot;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Design a Tic-tac-toe game that is played between two players on a n x n grid.&lt;/p&gt;
&lt;p&gt;You may assume the following rules:&lt;/p&gt;
&lt;p&gt;A move is guaranteed to be valid and is placed on an empty block.&lt;br&gt;
Once a winning condition is reached, no more moves is allowed.&lt;br&gt;
A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Given n = 3, assume that player 1 is &amp;quot;X&amp;quot; and player 2 is &amp;quot;O&amp;quot; in the board.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TicTacToe toe = new TicTacToe(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(0, 0, 1); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| | |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | | |    // Player 1 makes a move at (0, 0).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | | |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(0, 2, 2); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | | |    // Player 2 makes a move at (0, 2).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | | |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(2, 2, 1); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | | |    // Player 1 makes a move at (2, 2).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | |X|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(1, 1, 2); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |O| |    // Player 2 makes a move at (1, 1).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | |X|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(2, 0, 1); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |O| |    // Player 1 makes a move at (2, 0).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |X|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(1, 0, 2); -&amp;gt; Returns 0 (no one wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|O|O| |    // Player 2 makes a move at (1, 0).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |X|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toe.move(2, 1, 1); -&amp;gt; Returns 1 (player 1 wins)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X| |O|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|O|O| |    // Player 1 makes a move at (2, 1).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|X|X|X|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Leetcode Cracking" scheme="WangHngLeee.github.io/categories/Leetcode-Cracking/"/>
    
    
      <category term="Leetcode" scheme="WangHngLeee.github.io/tags/Leetcode/"/>
    
      <category term="Code-Review" scheme="WangHngLeee.github.io/tags/Code-Review/"/>
    
      <category term="Design" scheme="WangHngLeee.github.io/tags/Design/"/>
    
  </entry>
  
</feed>
