<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Front-end Interview Note 3 💪"><meta name="keywords" content="Front-end,Interview Questions"><meta name="author" content="HongLeee"><meta name="copyright" content="HongLeee"><title>Front-end Interview Note 3 💪 | Leee's World</title><link rel="shortcut icon" href="/a1.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7147375581336623',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-166070746-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-number">1.</span> <span class="toc-text">JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">1.0.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类的创建和继承"><span class="toc-number">1.0.2.</span> <span class="toc-text">类的创建和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript-的作用域链？"><span class="toc-number">1.0.3.</span> <span class="toc-text">Javascript 的作用域链？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件流和事件模型"><span class="toc-number">1.0.4.</span> <span class="toc-text">事件流和事件模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何让事件先冒泡后捕获"><span class="toc-number">1.0.5.</span> <span class="toc-text">如何让事件先冒泡后捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托与冒泡原理"><span class="toc-number">1.0.6.</span> <span class="toc-text">事件委托与冒泡原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何阻止冒泡？"><span class="toc-number">1.0.7.</span> <span class="toc-text">如何阻止冒泡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深拷贝-浅拷贝"><span class="toc-number">1.0.8.</span> <span class="toc-text">深拷贝 浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#懒加载和预加载"><span class="toc-number">1.0.9.</span> <span class="toc-text">懒加载和预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#改变函数内部this指针的指向函数（bind，apply，call的区别）"><span class="toc-number">1.0.10.</span> <span class="toc-text">改变函数内部this指针的指向函数（bind，apply，call的区别）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS节流与防抖"><span class="toc-number">1.0.11.</span> <span class="toc-text">JS节流与防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe-iframe的缺点"><span class="toc-number">1.0.12.</span> <span class="toc-text">iframe &amp;&amp; iframe的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS中的垃圾回收机制"><span class="toc-number">1.0.13.</span> <span class="toc-text">JS中的垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#common-js"><span class="toc-number">1.0.14.</span> <span class="toc-text">common.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组去重"><span class="toc-number">1.0.15.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断数据类型（是数组）？"><span class="toc-number">1.0.16.</span> <span class="toc-text">判断数据类型（是数组）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨域？实现方法"><span class="toc-number">1.0.17.</span> <span class="toc-text">跨域？实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排和重绘"><span class="toc-number">1.0.18.</span> <span class="toc-text">重排和重绘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟virtual-dom"><span class="toc-number">1.0.19.</span> <span class="toc-text">虚拟virtual dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack？"><span class="toc-number">1.0.20.</span> <span class="toc-text">webpack？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise"><span class="toc-number">1.0.21.</span> <span class="toc-text">promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue生命周期"><span class="toc-number">1.0.22.</span> <span class="toc-text">vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6箭头函数特性"><span class="toc-number">1.0.23.</span> <span class="toc-text">es6箭头函数特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#es6新特性"><span class="toc-number">1.0.24.</span> <span class="toc-text">es6新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同源策略"><span class="toc-number">1.0.25.</span> <span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PWA"><span class="toc-number">1.0.26.</span> <span class="toc-text">PWA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux"><span class="toc-number">1.0.27.</span> <span class="toc-text">Redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue双向绑定原理："><span class="toc-number">1.0.28.</span> <span class="toc-text">vue双向绑定原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-DOM-和-BOM？"><span class="toc-number">1.0.29.</span> <span class="toc-text">什么是 DOM 和 BOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ajax"><span class="toc-number">1.0.30.</span> <span class="toc-text">Ajax</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/05/11/YYYDdf.jpg"></div><div class="author-info__name text-center">HongLeee</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/WangHngLeee">+ Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">125</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">49</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">23</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.ax1x.com/2019/10/08/uWbqMj.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Leee's World</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/about">About Me</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Front-end Interview Note 3 💪</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 03-05-2020</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Interview/">Interview</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Interview/JS/">JS</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1>JS</h1>
<h3 id="闭包">闭包</h3>
<p>闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。<br>
应用场景？函数防抖，使用闭包设计单例模式，为多个组件独立属性，设置私有变量，取到正确值。</p>
<h3 id="类的创建和继承">类的创建和继承</h3>
<p>创建：new一个function，在这个function的prototype里面增加属性和方法。<br>
1、原型链继承，将父类的实例作为子类的原型，他的特点是实例是子类的实例也是父类的实例，父类新增的原型方法/属性，子类都能够访问，并且原型链继承简单易于实现，缺点是来自原型对象的所有属性被所有实例共享，无法实现多继承，无法向父类构造函数传参。<br>
2、构造继承，使用父类的构造函数来增强子类实例，即复制父类的实例属性给子类，<br>
构造继承可以向父类传递参数，可以实现多继承，通过call多个父类对象。但是构造继承只能继承父类的实例属性和方法，不能继承原型属性和方法，无法实现函数服用，每个子类都有父类实例函数的副本，影响性能<br>
3、实例继承，为父类实例添加新特性，作为子类实例返回，实例继承的特点是不限制调用方法，不管是new 子类（）还是子类（）返回的对象具有相同的效果，缺点是实例是父类的实例，不是子类的实例，不支持多继承<br>
4、拷贝继承：特点：支持多继承，缺点：效率较低，内存占用高（因为要拷贝父类的属性）无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）<br>
5、组合继承：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用<br>
6、寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>
<h3 id="Javascript-的作用域链？">Javascript 的作用域链？</h3>
<p>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和<br>
函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前<br>
端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>
当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</p>
<a id="more"></a>
<h3 id="事件流和事件模型">事件流和事件模型</h3>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。<br>
1.DOM0 级模型，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实<br>
现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。<br>
<a href="http://2.IE" target="_blank" rel="noopener">2.IE</a> 事件模型，在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。事件处理阶段会<br>
首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点<br>
是否绑定了事件监听函数，如果有则执行。这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依<br>
次执行。<br>
3.DOM2 级事件模型，在该事件模型中，一次事件共有三个过程，事件捕获阶段。捕获指的是事件从 docu<br>
ment 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型<br>
的两个阶段相同。这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。<br>
事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。事件捕获阶段，处于目标阶段，事件冒泡阶段</p>
<h3 id="如何让事件先冒泡后捕获">如何让事件先冒泡后捕获</h3>
<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。<br>
根据w3c标准，应先捕获再冒泡。若要实现先冒泡后捕获，给一个元素绑定两个addEventListener，其中一个第三个参数设置为false（即冒泡），另一个第三个参数设置为true（即捕获），调整它们的代码顺序，将设置为false的监听事件放在设置为true的监听事件前面即可。</p>
<h3 id="事件委托与冒泡原理">事件委托与冒泡原理</h3>
<p>事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。<br>
事件冒泡，就是元素自身的事件被触发后，如果父元素有相同的事件，如onclick事件，那么元素本身的触发状态就会传递，也就是冒到父元素，父元素的相同事件也会一级一级根据嵌套关系向外触发，直到document/window，冒泡过程结束。<br>
举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</p>
<h3 id="如何阻止冒泡？">如何阻止冒泡？</h3>
<p>w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true</p>
<h3 id="深拷贝-浅拷贝">深拷贝 浅拷贝</h3>
<p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此<br>
两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</p>
<p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引<br>
用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对<br>
象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。</p>
<h3 id="懒加载和预加载">懒加载和预加载</h3>
<p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br>
懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。<br>
两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<h3 id="改变函数内部this指针的指向函数（bind，apply，call的区别）">改变函数内部this指针的指向函数（bind，apply，call的区别）</h3>
<p>Call，apply它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。<br>
bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用</p>
<h3 id="JS节流与防抖">JS节流与防抖</h3>
<ul>
<li>函数节流: 指定时间间隔内只会执行一次任务；</li>
<li>函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</li>
</ul>
<h3 id="iframe-iframe的缺点">iframe &amp;&amp; iframe的缺点</h3>
<p>定义：iframe元素会创建包含另一个文档的内联框架<br>
提示：可以将提示文字放在<iframe></iframe>之间，来提示某些不支持iframe的浏览器<br>
缺点：iframe 会阻塞主页面的 onload 事件。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才<br>
会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 src 可以避免这种阻塞情况。<br>
（2） 搜索引擎的检索程序无法解读这种页面，不利于网页的 SEO 。<br>
（3） iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>
（4） 浏览器的后退按钮失效。<br>
（5） 小型的移动设备无法完全显示框架。</p>
<h3 id="JS中的垃圾回收机制">JS中的垃圾回收机制</h3>
<p>垃圾回收有两种实现方式，分别是标记清除和引用计数<br>
标记清除：当变量进入执行环境时标记为“进入环境”，当变量离开执行环境时则标记为“离开环境”，被标记为“进入环境”的变量是不能被回收的，因为它们正在被使用，而标记为“离开环境”的变量则可以被回收。<br>
引用计数：统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收。</p>
<h3 id="common-js">common.js</h3>
<p>Commonjs：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载require()引入模块。</p>
<h3 id="数组去重">数组去重</h3>
<p>法一：indexOf循环去重<br>
法二：ES6 Set去重；Array.from(new Set(array))<br>
法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。</p>
<h3 id="判断数据类型（是数组）？">判断数据类型（是数组）？</h3>
<p>Object.prototype.call.toString()<br>
Instanceof</p>
<h3 id="跨域？实现方法">跨域？实现方法</h3>
<p>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制，那么只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。<br>
JSONP：通过动态创建script，再请求一个带参网址实现跨域通信。document.domain + iframe跨域：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。<br>
location.hash + iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。<br>
<a href="http://window.name" target="_blank" rel="noopener">window.name</a> + iframe跨域：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。<br>
postMessage跨域：可以跨域操作的window属性之一。<br>
CORS：服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。<br>
代理跨域：起一个代理服务器，实现数据的转发</p>
<h3 id="重排和重绘">重排和重绘</h3>
<p>重绘：当盒子的位置、大小以及其他属性，颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。<br>
重排：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。<br>
重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。所以，重排必定会引发重绘，但重绘不一定会引发重排。</p>
<h3 id="虚拟virtual-dom">虚拟virtual dom</h3>
<p>用JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的DOM树上，视图就更新了。Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。</p>
<h3 id="webpack？">webpack？</h3>
<p>css文件<br>
webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。</p>
<h3 id="promise">promise</h3>
<p>ES6新语法，Promise是一个对象，保存着未来将要结束的事件，她有两个特征:<br>
1、对象的状态不受外部影响，Promise对象代表一个异步操作，有三种状态，pending进行中，fulfilled已成功，rejected已失败，只有异步操作的结果，才可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也就是promise名字的由来<br>
2、一旦状态改变，就不会再变，promise对象状态改变只有两种可能，从pending改到fulfilled或者从pending改到rejected，只要这两种情况发生，状态就凝固了，不会再改变，这个时候就称为定型resolved,</p>
<h3 id="vue生命周期">vue生命周期</h3>
<p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p>
<h3 id="es6箭头函数特性">es6箭头函数特性</h3>
<p>1、箭头函数没有this，所以需要通过查找作用域链来确定this的值，这就意味着如果箭头函数被非箭头函数包含，this绑定的就是最近一层非箭头函数的this，<br>
2、箭头函数没有自己的arguments对象，但是可以访问外围函数的arguments对象<br>
3、不能通过new关键字调用，同样也没有new.target值和原型</p>
<h3 id="es6新特性">es6新特性</h3>
<p>块级作用域：ES5只有全局作用域和函数作用域，块级作用域的好处是不再需要立即执行的函数表达式，循环体中的闭包不再有问题<br>
rest参数：用于获取函数的多余参数，这样就不需要使用arguments对象了，<br>
promise:一种异步编程的解决方案，比传统的解决方案回调函数和事件更合理强大<br>
模块化：其模块功能主要有两个命令构成，export和import，export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能</p>
<h3 id="同源策略">同源策略</h3>
<p>如果没有同源策略，不同源的数据和资源（如HTTP头、Cookie、DOM、localStorage等）就能相互随意访问，根本没有隐私和安全可言。为了安全起见和资源的有效管理，浏览器当然要采用这种策略。</p>
<h3 id="PWA">PWA</h3>
<p>PWA全称Progressive Web App，即渐进式WEB应用。一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能</p>
<h3 id="Redux">Redux</h3>
<p>在组件化的应用中，会有着大量的组件层级关系，深嵌套的组件与浅层父组件进行数据交互，变得十分繁琐困难。而redux，站在一个服务级别的角度，可以毫无阻碍地将应用的状态传递到每一个层级的组件中。redux就相当于整个应用的管家。<br>
redux里常用方法<br>
提供 getState() 方法获取 state；<br>
提供 dispatch(action) 方法更新 state；<br>
通过 subscribe(listener) 注册监听器;</p>
<h3 id="vue双向绑定原理：">vue双向绑定原理：</h3>
<p>vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的。利用了 Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)。</p>
<h3 id="什么是-DOM-和-BOM？">什么是 DOM 和 BOM？</h3>
<p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。<br>
BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM<br>
的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。</p>
<h3 id="Ajax">Ajax</h3>
<p>我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，<br>
更新网页的相应部分，而不用刷新整个页面的一种方法。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Front-end/">Front-end</a><a class="post-meta__tags" href="/tags/Interview-Questions/">Interview Questions</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/05/chin-up-24/"><i class="fa fa-chevron-left">  </i><span>Leetcode EveryDay 86 💪</span></a></div><div class="next-post pull-right"><a href="/2020/03/04/front-end-interview-css/"><span>Front-end Interview Note 2 💪</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'osOa9nOdMvJ7waVycMHyXcpL-gzGzoHsz',
  appKey:'k2MfP5O1nYredg5XqqbEH6DC',
  placeholder:'Add your first comment here!',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.ax1x.com/2019/10/08/uWbqMj.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HongLeee</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-glasses"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>