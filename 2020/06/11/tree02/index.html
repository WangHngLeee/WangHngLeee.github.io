<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Leetcode EveryDay 100 / Tree(2) üí™"><meta name="keywords" content="Leetcode,Tree"><meta name="author" content="HongLeee"><meta name="copyright" content="HongLeee"><title>Leetcode EveryDay 100 / Tree(2) üí™ | Leee's World</title><link rel="shortcut icon" href="/a1.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7147375581336623',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-166070746-1', 'auto');
ga('send', 'pageview');</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#table-tr-td-bgcolor-F5B041-font-color-white-96-Unique-Binary-Search-Trees-font-td-tr-table"><span class="toc-number">1.</span> <span class="toc-text">96. Unique Binary Search Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example"><span class="toc-number">1.1.</span> <span class="toc-text">Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution"><span class="toc-number">1.2.</span> <span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table-tr-td-bgcolor-F5B041-font-color-white-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-font-td-tr-table"><span class="toc-number">2.</span> <span class="toc-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-v2"><span class="toc-number">2.1.</span> <span class="toc-text">Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-v2"><span class="toc-number">2.2.</span> <span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table-tr-td-bgcolor-F5B041-font-color-white-863-All-Nodes-Distance-K-in-Binary-Tree-font-td-tr-table"><span class="toc-number">3.</span> <span class="toc-text">863. All Nodes Distance K in Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-v3"><span class="toc-number">3.1.</span> <span class="toc-text">Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-v3"><span class="toc-number">3.2.</span> <span class="toc-text">Solution</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#table-tr-td-bgcolor-F5B041-font-color-white-366-Find-Leaves-of-Binary-Tree-font-td-tr-table"><span class="toc-number">4.</span> <span class="toc-text">366. Find Leaves of Binary Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example-v4"><span class="toc-number">4.1.</span> <span class="toc-text">Example</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Solution-v4"><span class="toc-number">4.2.</span> <span class="toc-text">Solution</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s1.ax1x.com/2020/05/11/YYYDdf.jpg"></div><div class="author-info__name text-center">HongLeee</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/WangHngLeee">+ Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">166</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">56</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">23</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://res.cloudinary.com/dhgcccpqm/image/upload/v1592016388/Yosemite_zixphv.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Leee's World</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/about">About Me</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Leetcode EveryDay 100 / Tree(2) üí™</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 06-11-2020</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Leetcode-Cracking/">Leetcode Cracking</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="table-tr-td-bgcolor-F5B041-font-color-white-96-Unique-Binary-Search-Trees-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">96. Unique Binary Search Trees</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/unique-binary-search-trees/"><font size="4">üîó Question Link </font></a></p>
<h3 id="Example">Example</h3>
<p>Given n, how many structurally unique BST‚Äôs (binary search trees) that store values 1 ‚Ä¶ n?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h3 id="Solution">Solution</h3>
<p>DP + Math</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j&lt;=i ; j ++)&#123;</span><br><span class="line">                dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T:O(n) S:O(n)</p>
<p>Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST.</p>
<p>Take 1,2,3 for example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    G(3)</span><br><span class="line">            /         |             \</span><br><span class="line">     F(1,3)    +    F(2,3)   +    F(3,3)</span><br><span class="line">  (1 as root)     (2 as root)    (3 as root)</span><br><span class="line">     /  \            /  \           /  \</span><br><span class="line">  G(0)  G(1)      G(1) G(1)     G(2)  G(1)</span><br><span class="line">According to defination of BST, so different root have different subtrees.</span><br></pre></td></tr></table></figure>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GgP75HAvrlY?start=438" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<a id="more"></a>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">105. Construct Binary Tree from Preorder and Inorder Traversal</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"><font size="4">üîó Question Link </font></a></p>
<h3 id="Example-v2">Example</h3>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>
You may assume that duplicates do not exist in the tree.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For example, given</span><br><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br><span class="line">Return the following binary tree:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v2">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span>|| inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;inorder.length; i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[]inorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, Map&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(is &gt; ie || ps &gt; pe)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">        <span class="keyword">int</span> inidx = map.get(preorder[ps]); <span class="comment">// Âú®inorderÈáåÂæóÂà∞nodeÁöÑ‰ΩçÁΩÆ</span></span><br><span class="line">        <span class="keyword">int</span> remains = inidx - is; <span class="comment">// ÂæóÂà∞Â∑¶ÂçäÈÉ®ÂàÜÁöÑÂâ©‰Ωô</span></span><br><span class="line">        node.left = build(inorder,is,inidx-<span class="number">1</span>,preorder,ps+<span class="number">1</span>,ps+remains,map);</span><br><span class="line">        node.right = build(inorder,inidx+<span class="number">1</span>,ie,preorder,ps+remains+<span class="number">1</span>,pe,map);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Recursively building a tree from preorder and inorder array. Root is the first element in preorder, and use that element to find the index in inorder to caculate the left and right part‚Äôs length. Using map to store the index and element in the map.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-863-All-Nodes-Distance-K-in-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">863. All Nodes Distance K in Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/"><font size="4">üîó Question Link </font></a></p>
<h3 id="Example-v3">Example</h3>
<p>We are given a binary tree (with root node root), a target node, and an integer value K.</p>
<p>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p>
<img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="leetcode 863">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2</span><br><span class="line"></span><br><span class="line">Output: [7,4,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The nodes that are a distance 2 from the target node (with value 5)</span><br><span class="line">have values 7, 4, and 1.</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v3">Solution</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,target);</span><br><span class="line">        dfs(root,<span class="number">0</span>,K,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, TreeNode target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target)&#123;</span><br><span class="line">            map.put(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,target);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,left+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,target);</span><br><span class="line">        <span class="keyword">if</span>(right&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            map.put(root,right+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> dist, <span class="keyword">int</span> K, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(root))&#123;</span><br><span class="line">            dist = map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist == K)res.add(root.val);</span><br><span class="line">        dfs(root.left,dist+<span class="number">1</span>,K,res);</span><br><span class="line">        dfs(root.right,dist+<span class="number">1</span>,K,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using map to store different node‚Äôs distance to the target node.(Only sublayer node). Then using dfs to scan each node to caculate the distance. If it is not in the map, it means that node is uplayer of the target, so we using default 0 from root to scan, each step we add 1. If we meet a node that stored in the map, the we use the distance stored in the map to justify the distance.</p>
<p>T:O(n) S:O(n)</p>
<hr>
<h2 id="table-tr-td-bgcolor-F5B041-font-color-white-366-Find-Leaves-of-Binary-Tree-font-td-tr-table"><table><tr><td bgcolor="#F5B041"><font color="white">366. Find Leaves of Binary Tree</font></td></tr></table></h2>
<p><a target="_blank" href="https://leetcode.com/problems/find-leaves-of-binary-tree/"><font size="4">üîó Question Link </font></a></p>
<h3 id="Example-v4">Example</h3>
<p>Given a binary tree, collect a tree‚Äôs nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">          1</span><br><span class="line">         / \</span><br><span class="line">        2   3</span><br><span class="line">       / \     </span><br><span class="line">      4   5    </span><br><span class="line"></span><br><span class="line">Output: [[4,5,3],[2],[1]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1. Removing the leaves [4,5,3] would result in this tree:</span><br><span class="line">          1</span><br><span class="line">         / </span><br><span class="line">        2          </span><br><span class="line">2. Now removing the leaf [2] would result in this tree:</span><br><span class="line">          1          </span><br><span class="line">3. Now removing the leaf [1] would result in the empty tree:</span><br><span class="line">          []</span><br></pre></td></tr></table></figure>
<h3 id="Solution-v4">Solution</h3>
<p>Recursive</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        find(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = find(root.left,res);</span><br><span class="line">        <span class="keyword">int</span> right = find(root.right,res);</span><br><span class="line">        <span class="keyword">int</span> level = Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level+<span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(level).add(root.val);</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using every node‚Äôs level to determine whether current node is leaf or not. Leaf node‚Äôs level return -1+1=0. Then we add the nodes to res by the order of it‚Äôs level. -&gt; 0: 4,5,3  -&gt; 1:2 -&gt; 2:1</p>
<p>T:O(n) S:O(n)</p>
<hr>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Leetcode/">Leetcode</a><a class="post-meta__tags" href="/tags/Tree/">Tree</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/13/graph03/"><i class="fa fa-chevron-left">  </i><span>Leetcode EveryDay 101 / Graph(2) üí™</span></a></div><div class="next-post pull-right"><a href="/2020/06/09/graph02/"><span>Leetcode EveryDay 99 / Graph(2) üí™</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'osOa9nOdMvJ7waVycMHyXcpL-gzGzoHsz',
  appKey:'k2MfP5O1nYredg5XqqbEH6DC',
  placeholder:'Add your first comment here!',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'en'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://res.cloudinary.com/dhgcccpqm/image/upload/v1592016388/Yosemite_zixphv.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By HongLeee</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-glasses"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>