{"meta":{"title":"Leee's World","subtitle":"Talk is Cheap. Show me the code.","description":null,"author":"HongLeee","url":"WangHngLeee.github.io","root":"/"},"pages":[{"title":"Categories","date":"2019-02-28T21:39:53.000Z","updated":"2019-03-03T02:14:08.000Z","comments":true,"path":"categories/index.html","permalink":"WangHngLeee.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-02-28T21:39:40.000Z","updated":"2019-03-03T02:14:22.000Z","comments":true,"path":"tags/index.html","permalink":"WangHngLeee.github.io/tags/index.html","excerpt":"","text":""},{"title":"AboutMe | Leeeâ€˜s Info","date":"2019-02-28T21:56:13.000Z","updated":"2020-05-19T03:23:42.300Z","comments":true,"path":"about/index.html","permalink":"WangHngLeee.github.io/about/index.html","excerpt":"","text":"Contact me Social Link Github Link WeChat/å¾®ä¿¡: whl6596245 LinkedIn Profile E-mail hwang85@ncsu.edu 1023836798@qq.com hongli9749@gmail.com Achievements Projects My Portfolio page; https://leeeinfo.com Personal Website( keep updating ): https://leeemask.com React Online Hotel Reserve( keep updating ): https://bookinghotel-react.netlify.com Streaming Web Application https://github.com/WangHngLeee/Streamy Online Chatting Room https://github.com/WangHngLeee/online-chating Skills Programming Language: Python, Java, JavaScript, C/ C++, HTML, CSS/SCSS, Ruby Database : MySQL, Oracle, MongoDB, Firebase, NoSQL Tools: AWS,Gulp, Docker, Mesos, Swagger, Kafka Framework: React.JS, Vue.jsï¼ŒAngular, ReactNative, Node.JS, jQuery,Zepto, Flask, Django, Spring, Ajax, Bootstrap, Ruby on rails Paper Application of Machine Learning Algorithm in Medical Data Analysis First Author Submitted to Applied Intelligence, a CCF-C journal. Awards 2015-2018 Second and Third Prizes of Excellent University Scholarship for 3 years 08/2018 NXP Semiconductors National Smart Car Race, Second Prize 06/2018 Biomimetic Climbing Robots, Provincial Prize of University Student Innovation Competition"},{"title":"","date":"2020-05-19T19:25:18.595Z","updated":"2019-03-03T02:14:20.000Z","comments":true,"path":"top/index.html","permalink":"WangHngLeee.github.io/top/index.html","excerpt":"","text":"AV.initialize(\"osOa9nOdMvJ7waVycMHyXcpL-gzGzoHsz\", \"k2MfP5O1nYredg5XqqbEH6DC\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"}],"posts":[{"title":"Review Problems List ğŸ“Œ","slug":"problemslist","date":"9999-12-31T16:13:23.000Z","updated":"2020-03-07T05:52:04.738Z","comments":true,"path":"9999/12/31/problemslist/","link":"","permalink":"WangHngLeee.github.io/9999/12/31/problemslist/","excerpt":"","text":"è®°å½•Problems listçš„å®Œæˆæƒ…å†µ æ¯æ—¥æ›´æ–°ã€‚ ğŸ”— Problems List Link Github Leetcode Summary åŒæ­¥æ›´æ–°ã€‚ ğŸ”— Github Summary Link 2020/03/02 â€”â€” 500é¢˜æˆå°±è¾¾æˆ ğŸ’ª","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Problems List","slug":"Problems-List","permalink":"WangHngLeee.github.io/tags/Problems-List/"}]},{"title":"Leetcode EveryDay 97 / Tree(1) ğŸ’ª","slug":"tree01","date":"2020-06-07T17:53:35.000Z","updated":"2020-06-07T16:38:14.018Z","comments":true,"path":"2020/06/07/tree01/","link":"","permalink":"WangHngLeee.github.io/2020/06/07/tree01/","excerpt":"199. Binary Tree Right Side View ğŸ”— Question Link Example Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Solution DFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; dfs(root,res,0); return res; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; res, int depth)&#123; if(root == null)return; if(depth == res.size())&#123; res.add(root.val); &#125; dfs(root.right,res,depth+1); dfs(root.left,res,depth+1); &#125;&#125; We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res. T:O(n) S:O(n) BFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i == size-1)res.add(temp.val); // only add the last node in every level into res if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node. T:O(n) S:O(n)","text":"199. Binary Tree Right Side View ğŸ”— Question Link Example Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Solution DFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; dfs(root,res,0); return res; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; res, int depth)&#123; if(root == null)return; if(depth == res.size())&#123; res.add(root.val); &#125; dfs(root.right,res,depth+1); dfs(root.left,res,depth+1); &#125;&#125; We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res. T:O(n) S:O(n) BFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i == size-1)res.add(temp.val); // only add the last node in every level into res if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node. T:O(n) S:O(n) 297. Serialize and Deserialize Binary Tree ğŸ”— Question Link Examples Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5as &quot;[1,2,3,null,null,4,5]&quot; Solution public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder res = new StringBuilder(); serial(root,res); return res.toString(); &#125; public void serial(TreeNode root, StringBuilder res)&#123; if(root == null)res.append(\"null\").append(\" \"); else&#123; res.append(root.val).append(\" \"); serial(root.left,res); serial(root.right,res); &#125; &#125; public TreeNode deserialize(String source)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = source.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return des(queue); &#125; public TreeNode des(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"null\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = des(queue); node.right = des(queue); return node; &#125;&#125; In serialize function, we use recursive preorder way to save the tree nodeâ€™s value into a String. In deserialize function, we use the previous string as source data. Then we recursively to build a new tree using pre-order too. T:O(n) S:O(n) 124. Binary Tree Maximum Path Sum ğŸ”— Question Link Examples Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:Input: [1,2,3] 1 / \\ 2 3Output: 6Example 2:Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7Output: 42 Solutoin class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; Using revursive to find the max in right / left branch. Max is updated when current node is seen as the root node, so we sum the value of left+right+node.val . But in return line, we can only choose one branch in left/right branch. T:O(n) S:O(1) 236. Lowest Common Ancestor of a Binary Tree ğŸ”— Question Link Example Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).â€ Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Solution class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; else if(right == null)return left; else return root; &#125;&#125; There are three cases: when left and right both have return value, it means that two nodes are displayed in both left and right branch. The current root is their LCA, so we return root. when left has null, it means two nodes are both in right branch. So we just return right value. Right keep record the first target node we meet. when right has null, it means two nodes are both in left branch. So we just return left value. Left keep record the first target node we meet. T:O(n) S:O(1) 98. Validate Binary Search Tree ğŸ”— Question Link Example Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3Input: [2,1,3]Output: trueExample 2: 5 / \\ 1 4 / \\ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&apos;s value is 5 but its right child&apos;s value is 4. Solution class Solution &#123; public boolean isValidBST(TreeNode root)&#123; if(root == null)return true; return help(root,Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean help(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val &lt;= min || root.val &gt;= max)return false; return help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max); &#125;&#125; Using defination of BST:left &lt; root &lt; right. Then we can set up two max / min boundary to check each layer. Tricky: The test case contains large number which can only be included by Long type number. T:O(n) S:O(1) 987. Vertical Order Traversal of a Binary Tree ğŸ”— Question Link Example Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1:Input: [1,2,3,4,5,6,7]Output: [[4],[2],[1,5,6],[3],[7]]Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme.However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6. Solution class Solution &#123; class pair&#123; TreeNode node; int x; int y; public pair(int x, int y, TreeNode n)&#123; this.x = x; this.y = y; node = n; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(0,0,root)); int min = 0; int max = 0; while(!queue.isEmpty())&#123; pair temp = queue.poll(); min = Math.min(min,temp.x); max = Math.max(max,temp.x); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(new pair(temp.x,temp.y,temp.node)); if(temp.node.left!=null)queue.add(new pair(temp.x-1,temp.y+1,temp.node.left)); if(temp.node.right!=null)queue.add(new pair(temp.x+1,temp.y+1,temp.node.right)); &#125; for(int i= min ;i&lt;= max; i++)&#123; Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j = 0; j&lt;map.get(i).size() ;j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; Using HashMap to store each x positionâ€™s nodes. And then sort each nodes wiht itâ€™s yâ€™s positon value. If two nodes have same y position, then sort them with nodeâ€™s value. T:O(n^2logn) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 96 / Array(2) ğŸ’ª","slug":"array02","date":"2020-06-06T17:53:35.000Z","updated":"2020-06-07T03:29:51.236Z","comments":true,"path":"2020/06/06/array02/","link":"","permalink":"WangHngLeee.github.io/2020/06/06/array02/","excerpt":"31. Next Permutation ğŸ”— Question Link Example Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 â†’ 1,3,23,2,1 â†’ 1,2,31,1,5 â†’ 1,5,1 Solution class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length -1; int pos = -1; int val = 0; for(int i = len-1 ;i&gt;=0 ;i--)&#123; if(nums[i] &lt; nums[i+1])&#123; pos = i; val = nums[i]; break; &#125; &#125; if(pos == -1)&#123; // already sort in descending order like 321 then we return 123 reverse(nums,0,len); return; &#125; for(int i = len ;i&gt;=0 ;i--)&#123; if(nums[i] &gt; val)&#123; swap(nums,pos,i); break; &#125; &#125; reverse(nums,pos+1,len);// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5 &#125; public void reverse(int[] nums, int start, int end)&#123; while(start &lt;= end)&#123; swap(nums,start,end); start++; end--; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125; T:O(n) S:O(1) From end to start we need to find the first num target which cause drop and keep record ot itâ€™s pos and value. Then we start from end again to find the first num that is bigger than than targetâ€™s value. Then we swap this num with the target num , then reverse the array from pos+1 to len.","text":"31. Next Permutation ğŸ”— Question Link Example Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 â†’ 1,3,23,2,1 â†’ 1,2,31,1,5 â†’ 1,5,1 Solution class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length -1; int pos = -1; int val = 0; for(int i = len-1 ;i&gt;=0 ;i--)&#123; if(nums[i] &lt; nums[i+1])&#123; pos = i; val = nums[i]; break; &#125; &#125; if(pos == -1)&#123; // already sort in descending order like 321 then we return 123 reverse(nums,0,len); return; &#125; for(int i = len ;i&gt;=0 ;i--)&#123; if(nums[i] &gt; val)&#123; swap(nums,pos,i); break; &#125; &#125; reverse(nums,pos+1,len);// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5 &#125; public void reverse(int[] nums, int start, int end)&#123; while(start &lt;= end)&#123; swap(nums,start,end); start++; end--; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125; T:O(n) S:O(1) From end to start we need to find the first num target which cause drop and keep record ot itâ€™s pos and value. Then we start from end again to find the first num that is bigger than than targetâ€™s value. Then we swap this num with the target num , then reverse the array from pos+1 to len. 54. Spiral Matrix ğŸ”— Question Link Examples Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1:Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] Solution class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(matrix.length == 0 || matrix == null)return res; int m = matrix.length; int n = matrix[0].length; int left= 0; int right = n-1; int top = 0; int down = m-1; while(res.size() &lt; m*n)&#123; for(int i = left ;i &lt;= right &amp;&amp; res.size() &lt; n * m ;i++)&#123; res.add(matrix[top][i]); &#125; for(int i = top + 1 ; i&lt;= down-1 &amp;&amp; res.size() &lt; m * n ;i++)&#123; res.add(matrix[i][right]); &#125; for(int i = right ;i&gt;= left &amp;&amp; res.size() &lt; m*n;i--)&#123; res.add(matrix[down][i]); &#125; for(int i = down-1 ;i&gt;=top+1 &amp;&amp; res.size() &lt; m * n;i--)&#123; res.add(matrix[i][left]); &#125; left++; right--; top++; down--; &#125; return res; &#125;&#125; T:O(n) S:O(n) Simple idea. Just loop the matrix from left-&gt; right, top-&gt;down, right-&gt;left, down-&gt;top. Then minus each value by 1. 289. Game of Life ğŸ”— Question Link Examples Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-populationâ€¦ Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example:Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] Solution class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; T:O(mn) S:O(1) Tricky point is that we can use three state to keep record of the next generation. 1-&gt; live cell continue to live 2-&gt; live cell died due to lives &lt;2 or lives&gt;3 3-&gt; dead cell become live due to lives ==2 or lives ==3 After that we can use %2 to caculate whether itâ€™s 0 or 1. 128. Longest Consecutive Sequence ğŸ”— Question Link Examples Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example:Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; //corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.getOrDefault(num-1,0); int right = map.getOrDefault(num+1,0); sum += left + right + 1; max = Math.max(max,sum); map.put(num,sum); map.put(num-left,sum); map.put(num+right,sum); &#125; &#125; return max; &#125;&#125; T:O(n) S:O(n) Everytime we just to find max continus length of num-1 and num+1, then we mix them up to form a new sum of current num. Then we update max , and also update the num-left, num+right with new sum value, it works because left and right is the length of continus length.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 95 / Array(1) Ã°Å¸â€™Âª","slug":"array01","date":"2020-06-03T17:53:35.000Z","updated":"2020-06-07T14:02:34.368Z","comments":true,"path":"2020/06/03/array01/","link":"","permalink":"WangHngLeee.github.io/2020/06/03/array01/","excerpt":"42. Trapping Rain Water Ã°Å¸â€â€” Question Link Examples Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 Solution class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; //corner case int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1.","text":"42. Trapping Rain Water Ã°Å¸â€â€” Question Link Examples Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 Solution class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; //corner case int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1. 238. Product of Array Except Self Ã°Å¸â€â€” Question Link Examples Given an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example:Input: [1,2,3,4]Output: [24,12,8,6]Constraint: It&apos;s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Solution class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; int left = 1; int right = 1; if(nums == null || nums.length == 0)return res; for(int i = 0; i &lt; nums.length ;i++)&#123; if(i&gt;0)&#123; left = left * nums[i-1]; &#125; res[i] = left; &#125; for(int j = nums.length-1; j&gt;=0 ;j--)&#123; if(j&lt;nums.length-1)&#123; right = right * nums[j+1]; &#125; res[j] = res[j] * right; &#125; return res; &#125;&#125; First from left to get the left multiply num, then from right to left to get the final result. 152. Maximum Product Subarray Ã°Å¸â€â€” Question Link Examples Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1:Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6.Example 2:Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Solution class Solution &#123; public int maxProduct(int[] nums) &#123; int max = Integer.MIN_VALUE; if(nums == null || nums.length == 0)return 0; for(int i = 0 ;i&lt;nums.length ;i++)&#123; int sum = nums[i]; if(sum &gt; max)max = sum; for(int j = i+1; j&lt;nums.length ;j++)&#123; sum = sum * nums[j]; if(sum &gt; max)max = sum; &#125; &#125; return max; &#125;&#125; Simple two side for loops solution. 121. Best Time to Buy and Sell Stock Ã°Å¸â€â€” Question Link Examples Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1:Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Soluiton class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0)return 0; int max = 0; int min = prices[0]; for(int i = 0 ; i &lt; prices.length ;i++)&#123; if(prices[i] &gt; min)&#123; max = Math.max(prices[i]-min,max); &#125;else&#123; min = prices[i]; &#125; &#125; return max; &#125;&#125; Set first dayâ€™s value to be min which is like the price to buy in. Max is the value that to sell. 56. Merge Intervals Ã°Å¸â€â€” Question Link Examples Given a collection of intervals, merge all overlapping intervals. Example 1:Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Solution class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0 )return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0] - b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] item : intervals)&#123; if(end &gt;= item[0])&#123; // [0,4][1,3] end = Math.max(end,item[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = item[0]; end = item[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125; Classic merge intervals questions. Using start and end to decide whether merge a new interval or add current interval into answer. 560. Subarray Sum Equals K Ã°Å¸â€â€” Question Link Examples Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1:Input:nums = [1,1,1], k = 2Output: 2 Solution class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if(nums == null || nums.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int count = 0; int sum = 0; for(int num : nums)&#123; sum = sum + num; if(map.containsKey(sum - k))&#123; count+=map.get(sum-k); &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; Using presum to precaculate the sum with different length of nums in array. Eg: array : 1 1 1 1 1 0:1 1:1 map -&gt;2:1 3:1 4:1 5:1","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 94 / String(2) Ã°Å¸â€™Âª","slug":"string02","date":"2020-06-02T17:53:35.000Z","updated":"2020-06-06T01:33:53.800Z","comments":true,"path":"2020/06/02/string02/","link":"","permalink":"WangHngLeee.github.io/2020/06/02/string02/","excerpt":"609. Find Duplicate File in System Ã°Å¸â€â€” Question Link Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. Example Input:[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]Output:[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]","text":"609. Find Duplicate File in System Ã°Å¸â€â€” Question Link Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. Example Input:[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]Output:[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]] Solution class Solution &#123; public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String str : paths)&#123; String[] strs = str.split(\"\\\\s++\"); for(int i = 1 ;i&lt;strs.length ;i++)&#123; int idx = strs[i].indexOf('('); String msg = strs[i].substring(idx); String totalName = strs[0] + \"/\" + strs[i].substring(0,idx); Set&lt;String&gt; names = map.getOrDefault(msg,new HashSet&lt;&gt;()); names.add(totalName); map.put(msg,names); &#125; &#125; for(String key : map.keySet())&#123; if(map.get(key).size() &gt; 1)&#123; res.add(new ArrayList&lt;&gt;(map.get(key))); &#125; &#125; return res; &#125;&#125; T:O(n) S:O(n) First we split the string with &quot; &quot; to seprate the string with two parts : paths + file. Then we go to the file part, and find the message in it using â€œ(â€, we split the file with two part: file name + file message. Using map and set to store the file like &quot; message -&gt; Set &quot;. Then we add the path in the set to final res list. 767. Reorganize String Ã°Å¸â€â€” Question Link Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example Example 1:Input: S = &quot;aab&quot;Output: &quot;aba&quot;Example 2:Input: S = &quot;aaab&quot;Output: &quot;&quot; Solution class Solution &#123; public String reorganizeString(String S) &#123; int[] arr = new int[26]; for(int i = 0 ; i &lt; S.length() ;i++)&#123; arr[S.charAt(i)-'a']++; &#125; int max = 0, letter = 0; for(int i = 0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max = arr[i]; letter = i; &#125; &#125; if(max &gt; (S.length() + 1)/2)return \"\"; char[] res = new char[S.length()]; int index = 0; while(arr[letter] &gt; 0)&#123; res[index] = (char)(letter +'a'); index+=2; arr[letter]--; &#125; for(int i = 0; i&lt;arr.length ;i++)&#123; while(arr[i]&gt;0)&#123; if(index &gt;= S.length())&#123; index = 1; &#125; res[index] = (char)(i + 'a'); index+=2; arr[i]--; &#125; &#125; return String.valueOf(res); &#125;&#125; T:O(n) S:O(1) Easy thoughts: We first find the char with max currency and put it on the even positin first like 0,2,4,6â€¦ Then we keep to put all other chars in the remained position. If we get the end of the size of string, we turn back to the position of 1 and keep put char in it. It easy to understand with the following explain. a _ a _ a _ _ _ _ // fill in &quot;a&quot; at position 0, 2, 4a b a _ a _ b _ b // fill in &quot;b&quot; at position 6, 8, 1a b a c a _ b _ b // fill in &quot;c&quot; at position 3a b a c a d b d b // fill in &quot;d&quot; at position 5, 7 32. Longest Valid Parentheses Ã°Å¸â€â€” Question Link Given a string containing just the characters â€˜(â€™ and â€˜)â€™, find the length of the longest valid (well-formed) parentheses substring. Example Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot;Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; Solution class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i = 0; i&lt;len ;i++)&#123; if(s.charAt(i) == '(')open++; else if(open &gt;0 &amp;&amp; s.charAt(i)==')')&#123; dp[i] = dp[i-1]+2; if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(dp[i],max); &#125; return max; &#125;&#125; DP problem. When we meet â€˜)â€™ and open &gt;0 then we start dp operation. Tricky point is the line in the bellow: if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]];&#125; We are looking for the longest continuous parentheses, so we have to check the dp value before the current valid length. For example: ()()() // case 1((())) // case 2 In case 1, only we meet ) then we can make current dp to 2, but after that we will back to the value of 0. So we have to check whether there is valid length before the current length. In case 2 it is normal way what we think in the first time. 43. Multiply Strings Ã°Å¸â€â€” Question Link Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example Example 1:Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot;Example 2:Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Solution class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(); int n = num2.length(); int[] arr = new int[m+n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; int mul = (num1.charAt(i)-'0') * (num2.charAt(j)-'0'); int pos1 = i+j,pos2 = i+j+1; int sum = arr[pos2] + mul; arr[pos1] += sum / 10; arr[pos2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int num : arr)&#123; if(!(sb.length() == 0 &amp;&amp; num == 0))&#123; sb.append(num); &#125; &#125; return sb.length() == 0 ? \"0\" : sb.toString(); &#125;&#125; T:O(n^2) S:O(1) We simulate the multiply process. Using pos1 and pos2 to store the carry. For example: 1 2 5 * 3 2 ------ 1 0 ( 5*2 ) step 1 0 4 ( 2*2 ) step 2 0 2 ( 1*2 ) .... 3 1 5 ( 3*5 ) .... 4 0 6 ...0 3 ...-------------- 4 0 0 0 Like above, cause every time we caculate the two number to get mul, then we have to use the last timeâ€™s pos1 value, which is the same as current pos2â€™s vlaue. Then after caculate that we add them together to get the final value string.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"New App Deployed ğŸ‰","slug":"app1","date":"2020-05-31T16:13:54.000Z","updated":"2020-05-31T19:58:21.302Z","comments":true,"path":"2020/05/31/app1/","link":"","permalink":"WangHngLeee.github.io/2020/05/31/app1/","excerpt":"","text":"Covid-19 Tracker App now available online ! ğŸ’Š ğŸ”— COVID-19 tracker Brief content of the application. Skill included: React, JavaScript, Chart.js, axios, MongoDB, ElementUIâ€¦","categories":[{"name":"Depolyed Web App","slug":"Depolyed-Web-App","permalink":"WangHngLeee.github.io/categories/Depolyed-Web-App/"}],"tags":[{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"},{"name":"Web Application","slug":"Web-Application","permalink":"WangHngLeee.github.io/tags/Web-Application/"}]},{"title":"Leetcode EveryDay 93 / String(1) ğŸ’ª","slug":"string01","date":"2020-05-30T17:53:35.000Z","updated":"2020-06-02T21:14:03.882Z","comments":true,"path":"2020/05/30/string01/","link":"","permalink":"WangHngLeee.github.io/2020/05/30/string01/","excerpt":"14. Longest Common Prefix ğŸ”— Question Link Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string â€œâ€. Example Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;","text":"14. Longest Common Prefix ğŸ”— Question Link Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string â€œâ€. Example Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Solution class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs.length == 0 || strs == null) return \"\"; String pre = strs[0]; for(int i = 1 ; i &lt; strs.length ;i++)&#123; while(strs[i].indexOf(pre)!=0)&#123; pre = pre.substring(0,pre.length()-1); &#125; &#125; return pre; &#125;&#125; T: O(n) S: O(1) Using tricky of function of indexOf to get the first positoin of string. We take first string as comparator, then loop all the other strings to check if the first position of comparator in these strings is 0. If not 0, then we shrink the comparator stringâ€™s length - 1. 10. Regular Expression Matching ğŸ”—Â—Question Link Given an input string (s) and a pattern Â§, implement regular expression matching with support for â€˜.â€™ and â€˜*â€™. â€˜.â€™ Matches any single character. â€˜*â€™ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Solution class Solution&#123; public boolean isMatch(String s, String p) &#123; if(s == null || p == null) &#123; return false; &#125; boolean[][] state = new boolean[s.length() + 1][p.length() + 1]; state[0][0] = true; for (int j = 1; j &lt; state[0].length; j++) &#123; if (p.charAt(j - 1) == '*') &#123; if (state[0][j - 1] || (j &gt; 1 &amp;&amp; state[0][j - 2])) &#123; state[0][j] = true; &#125; &#125; &#125; for (int i = 1; i &lt; state.length; i++) &#123; for (int j = 1; j &lt; state[0].length; j++) &#123; if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') &#123; state[i][j] = state[i - 1][j - 1]; &#125; if (p.charAt(j - 1) == '*') &#123; if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != '.') &#123; state[i][j] = state[i][j - 2]; &#125; else &#123; state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2]; &#125; &#125; &#125; &#125; return state[s.length()][p.length()]; &#125;&#125; DP solution. 1, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Leetcode EveryDay 92 ğŸ’ª","slug":"code02","date":"2020-05-24T22:15:39.000Z","updated":"2020-05-24T22:26:31.171Z","comments":true,"path":"2020/05/24/code02/","link":"","permalink":"WangHngLeee.github.io/2020/05/24/code02/","excerpt":"130. Surrounded Regions Ã°Å¸â€â€”Question Link BFS Solution : class Solution &#123; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; queue.add(new int[]&#123;i,j&#125;); board[i][j] = 'a'; &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] temp = queue.poll(); for(int[] dir : dirs)&#123; int x = temp[0]+dir[0]; int y = temp[1]+dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; board[x][y] == 'O') &#123; queue.add(new int[]&#123;x,y&#125;); board[x][y] = 'a'; &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125;&#125; DFS Solution : class Solution &#123; int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; helper(i,j,board); &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125; public void helper(int r, int c, char[][]board)&#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = 'a'; for(int[] dir : dirs)&#123; int x = r + dir[0]; int y = c + dir[1]; helper(x,y,board); &#125; &#125; &#125;&#125; In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into â€˜aâ€™. After that, we make a loop of the whole board to change â€˜aâ€™ into O and all other Os into â€˜Xâ€™.","text":"130. Surrounded Regions Ã°Å¸â€â€”Question Link BFS Solution : class Solution &#123; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; queue.add(new int[]&#123;i,j&#125;); board[i][j] = 'a'; &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] temp = queue.poll(); for(int[] dir : dirs)&#123; int x = temp[0]+dir[0]; int y = temp[1]+dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; board[x][y] == 'O') &#123; queue.add(new int[]&#123;x,y&#125;); board[x][y] = 'a'; &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125;&#125; DFS Solution : class Solution &#123; int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; helper(i,j,board); &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125; public void helper(int r, int c, char[][]board)&#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = 'a'; for(int[] dir : dirs)&#123; int x = r + dir[0]; int y = c + dir[1]; helper(x,y,board); &#125; &#125; &#125;&#125; In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into â€˜aâ€™. After that, we make a loop of the whole board to change â€˜aâ€™ into O and all other Os into â€˜Xâ€™.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"}]},{"title":"React Review ğŸ““","slug":"react1","date":"2020-05-19T13:58:50.000Z","updated":"2020-05-19T19:39:10.747Z","comments":true,"path":"2020/05/19/react1/","link":"","permalink":"WangHngLeee.github.io/2020/05/19/react1/","excerpt":"React å¤ä¹  ç”Ÿå‘½å‘¨æœŸ ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ç»„ä»¶ä»å®ä¾‹åŒ–åˆ°æ¸²æŸ“å†åˆ°æœ€ç»ˆä»é¡µé¢ä¸­é”€æ¯ï¼Œæ•´ä¸ªè¿‡ç¨‹å°±æ˜¯ç”Ÿå‘½å‘¨æœŸã€‚åœ¨ç”Ÿå‘½å‘¨æœŸä¸­ï¼Œæœ‰å¾ˆå¤šå¯ä»¥è°ƒç”¨çš„äº‹ä»¶ï¼Œä¹Ÿç§°ä¸ºhook/é’©å­å‡½æ•°ã€‚ ç”Ÿå‘½å‘¨æœŸä¸‰ä¸ªçŠ¶æ€ Mounting : å°†ç»„ä»¶æ’å…¥DOMä¸­ Updating : å°†ç»„ä»¶æ›´æ–°åˆ°DOMä¸­ Unmounting : å°†ç»„ä»¶ç§»å‡ºDOM é’©å­å‡½æ•°ï¼ˆæ–¹æ³•ï¼Œäº‹ä»¶ï¼‰ componentWillMount(): ç»„ä»¶å°†è¦æ¸²æŸ“,AJAX,æ·»åŠ åŠ¨ç”»å‰çš„ç±» componentDidMount(): ç»„ä»¶æ¸²æŸ“å®Œæ¯•ï¼Œæ·»åŠ åŠ¨ç”» componentWillReceiveProps(): ç»„ä»¶å°†è¦æ¥å—propsæ•°æ® shouldComponentUpdate(): ç»„ä»¶æ¥æ”¶åˆ°æ–°çš„props/stateæ—¶åˆ¤æ–­æ˜¯å¦æ›´æ–°ï¼Œè¿”å›booleanå€¼ componentWillUpdate(): ç»„ä»¶å°†è¦æ›´æ–° componentDidUpdate(): ç»„ä»¶æ›´æ–°å®Œæ¯• compnentWillUnmount(): ç»„ä»¶å°†è¦å¸è½½","text":"React å¤ä¹  ç”Ÿå‘½å‘¨æœŸ ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ç»„ä»¶ä»å®ä¾‹åŒ–åˆ°æ¸²æŸ“å†åˆ°æœ€ç»ˆä»é¡µé¢ä¸­é”€æ¯ï¼Œæ•´ä¸ªè¿‡ç¨‹å°±æ˜¯ç”Ÿå‘½å‘¨æœŸã€‚åœ¨ç”Ÿå‘½å‘¨æœŸä¸­ï¼Œæœ‰å¾ˆå¤šå¯ä»¥è°ƒç”¨çš„äº‹ä»¶ï¼Œä¹Ÿç§°ä¸ºhook/é’©å­å‡½æ•°ã€‚ ç”Ÿå‘½å‘¨æœŸä¸‰ä¸ªçŠ¶æ€ Mounting : å°†ç»„ä»¶æ’å…¥DOMä¸­ Updating : å°†ç»„ä»¶æ›´æ–°åˆ°DOMä¸­ Unmounting : å°†ç»„ä»¶ç§»å‡ºDOM é’©å­å‡½æ•°ï¼ˆæ–¹æ³•ï¼Œäº‹ä»¶ï¼‰ componentWillMount(): ç»„ä»¶å°†è¦æ¸²æŸ“,AJAX,æ·»åŠ åŠ¨ç”»å‰çš„ç±» componentDidMount(): ç»„ä»¶æ¸²æŸ“å®Œæ¯•ï¼Œæ·»åŠ åŠ¨ç”» componentWillReceiveProps(): ç»„ä»¶å°†è¦æ¥å—propsæ•°æ® shouldComponentUpdate(): ç»„ä»¶æ¥æ”¶åˆ°æ–°çš„props/stateæ—¶åˆ¤æ–­æ˜¯å¦æ›´æ–°ï¼Œè¿”å›booleanå€¼ componentWillUpdate(): ç»„ä»¶å°†è¦æ›´æ–° componentDidUpdate(): ç»„ä»¶æ›´æ–°å®Œæ¯• compnentWillUnmount(): ç»„ä»¶å°†è¦å¸è½½ å°è¯•ä»¥ä¸‹ä»£ç è¾“å‡ºæƒ…å†µï¼š import React,&#123;Component&#125; from 'react';import ReactDOM from 'react-dom';class Complife extends React.Component()&#123; constructor(props)&#123; super(props); this.state=&#123; msg:'test msg' &#125; console.log('æ„é€ å‡½æ•°') &#125; componentWillMount()&#123; console.log('æŒ‚è½½å®Œæ¯•ï¼Œå‡†å¤‡æ¸²æŸ“') &#125; componentDidMount()&#123; console.log('æ¸²æŸ“å®Œæ¯•') &#125; componentWillReceiveProps()&#123; console.log('ç»„ä»¶å°†è¦æ¥å—props') &#125; shouldComponentUpdate()&#123; //å¦‚æœå¸Œæœ›æ›´æ–°è¿”å›trueï¼Œä¸å¸Œæœ›åˆ™è¿”å›falseï¼Œä¸æ›´æ–°å°±æ˜¯undefined if(this.state.msg == 'test msg')&#123; return true; console.log(true); &#125; else&#123; return false; console.log(false); &#125; &#125; componentWillUpdate()&#123; console.log('ç»„ä»¶å°†è¦æ›´æ–°') &#125; componentDidUpdate()&#123; console.log('ç»„ä»¶æ›´æ–°å®Œæ¯•') &#125; componentWillUnmount()&#123; console.log('ç»„ä»¶å¸è½½') &#125; render()&#123; console.logï¼ˆ'æ¸²æŸ“å‡½æ•°') return( &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Complife /&gt;, document.querySelector('#app')) consoleç»“æœ æ„é€ å‡½æ•°ç»„ä»¶å°†è¦æ¸²æŸ“æ¸²æŸ“å‡½æ•°ç»„ä»¶æ¸²æŸ“å®Œæ¯• æ²¡æœ‰å…¶ä»–eventæ—¶æ„é€ çš„é¡ºåºå¦‚ä¸Šé¢ç»“æœæ‰€ç¤ºã€‚ ä½†å¦‚æœæœ‰clickeventæ›´æ–°çŠ¶æ€æ—¶ï¼Œç»„ä»¶çš„çŠ¶æ€é¡ºåºåˆæ˜¯æ€æ ·çš„å‘¢ï¼Ÿ å…¶ä»–ä¸å˜ï¼Œåœ¨renderå‡½æ•°ä¸­å¢åŠ ä¸€ä¸ªondlickäº‹ä»¶ ............ render()&#123; console.logï¼ˆ'æ¸²æŸ“å‡½æ•°') return( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.changeMsg&#125;&gt;æ›´æ–°&lt;/button&gt; &lt;/div&gt; ) &#125; changeMsg=()=&gt;&#123; this.setState(&#123; msg:\"changing msg\" &#125;) &#125; &#125;............ ç‚¹å‡»æ›´æ–°åæ­¤æ—¶consoleå°†ä¼šå¤šå‡ºä»¥ä¸‹å†…å®¹ ç»„ä»¶å°†è¦æ›´æ–°æ¸²æŸ“å‡½æ•°ç»„ä»¶æ›´æ–°å®Œæ¯• åœ¨complifeä¹‹åå¢åŠ parent classå°è¯•Unmountå‡½æ•° ......class Parent extends React.Component()&#123; constructor(props)&#123; super(props); this.state=&#123; isshow:true; &#125; &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.remove&#125;&gt; remove complifç»„ä»¶ &lt;/button&gt; &lt;complife /&gt; &lt;/div&gt; ) &#125; remove=()=&gt;&#123; this.setState(&#123; isshow:false; &#125;) &#125;&#125;ReactDOM.render( &lt;Parent /&gt;, document.querySelector('#app')) æ­¤æ—¶ç‚¹å‡»buttonåä¼šå¢åŠ ä¸€æ¡console ç»„ä»¶å¸è½½","categories":[{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"React","slug":"å‰ç«¯æ¡†æ¶/React","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/React/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"}]},{"title":"Leetcode EveryDay 91 ğŸ’ª","slug":"code01","date":"2020-05-16T15:16:38.000Z","updated":"2020-05-16T23:15:14.451Z","comments":true,"path":"2020/05/16/code01/","link":"","permalink":"WangHngLeee.github.io/2020/05/16/code01/","excerpt":"289. Game of Life ğŸ”—Question Link class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state: 1 means keep living 2 means live to dead* 3 means dead to live. Finally we just use the number to %2 to get the final result.","text":"289. Game of Life ğŸ”—Question Link class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state: 1 means keep living 2 means live to dead* 3 means dead to live. Finally we just use the number to %2 to get the final result. 1249. Minimum Remove to Make Valid Parentheses ğŸ”—Question Link class Solution &#123; public String minRemoveToMakeValid(String s) &#123; if(s == null || s.length() == 0)return \"\"; boolean[] check = new boolean[s.length()]; StringBuilder res = new StringBuilder(\"\"); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0 ;i&lt;s.length() ;i++)&#123; if(s.charAt(i) == '(')stack.push(i); // add idnex of ( to stack else if(s.charAt(i) == ')')&#123; if(!stack.isEmpty())&#123; // stack not empty then add index of ) to stack check[i] = true; check[stack.pop()] = true; &#125; &#125;else&#123; check[i] = true; // any character in s should be true &#125; &#125; for(int i = 0 ; i &lt; check.length ;i++)&#123; if(check[i])&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); &#125;&#125; First we add index of open / close parenthes to stack. Then we check for pair. If there is a pair of them we change the index of these in check to be true. All other chars should be true in check array except for ( and ). Finally we loop the check array to form the final res string. 415. Add Strings ğŸ”—Question Link class Solution &#123; public String addStrings(String num1, String num2) &#123; int len1 = num1.length()-1; int len2 = num2.length()-1; int carry = 0; StringBuilder sb = new StringBuilder(); while(len1 &gt;=0 || len2 &gt;=0)&#123; int n1 = 0; int n2 = 0; if(len1 &gt;=0)&#123; n1 = num1.charAt(len1)-'0'; &#125; if(len2&gt;=0)&#123; n2 = num2.charAt(len2)-'0'; &#125; int sum = n1 + n2 + carry; carry = sum/10; sb.append(sum%10); len1--; len2--; &#125; if(carry!=0)&#123; sb.append(carry); &#125; return sb.reverse().toString(); &#125;&#125; Normal solution. Using carry and sum/10 and sum%10. Remeber to reverse the ans in the final. 953. Verifying an Alien Dictionary ğŸ”—Question Link class Solution &#123; int[] dict = new int[26]; public boolean isAlienSorted(String[] words, String order) &#123; for(int i = 0 ; i&lt;order.length() ;i++)&#123; dict[order.charAt(i)-'a'] = i; &#125; for(int j = 1 ;j&lt;words.length;j++)&#123; if(checkbig(words[j-1],words[j]))&#123; return false; &#125; &#125; return true; &#125; public boolean checkbig(String word1, String word2)&#123; int a = word1.length(); int b = word2.length(); for(int i = 0 ; i&lt;a &amp;&amp; i&lt;b;i++)&#123; if(word1.charAt(i) != word2.charAt(i))&#123; if(dict[word1.charAt(i)-'a'] &lt; dict[word2.charAt(i)-'a'])return false; if(dict[word1.charAt(i)-'a'] &gt; dict[word2.charAt(i)-'a'])return true; &#125; &#125; return word1.length() &gt; word2.length(); &#125;&#125; First we use int[26] to store the new order of letters. Then we use it as a new dictionary to compare. After we make it, we loop the given string array, then check them one by one. Make a new function checkbig to check whether the later word is bigger than the former. If yes then return false. Otherwise we continue. In the checkbig function, we check the value of each char in the dictionary. If word1â€™s char is little than the word2 then we return true. So back to the main function it will return false. In final we also need check the length of them. eg ( â€˜wordâ€™, â€˜wordlâ€™). 339. Nested List Weight Sum ğŸ”—Question Link * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null)return 0; int sum = 0; int level = 1; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i&lt;size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())sum+=temp.getInteger()*level; else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; level++; &#125; return sum; &#125;&#125; Using BFS to loop the whole array like a binary tree. In the queue loop, we only need to check whether current is an integer or a nestedarray. If is an integer, we add its value * level to the sum. After each level loop, we increase level by 1. Input: [1,[4,[6]]]Output: 27Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27. 364. Nested List Weight Sum II ğŸ”—Question Link * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null) return 0; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; int prevsum = 0; int total = 0; while(!queue.isEmpty())&#123; int size = queue.size(); int levelsum = 0; for(int i = 0 ; i&lt; size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())levelsum+=temp.getInteger(); else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; prevsum+=levelsum; total+=prevsum; &#125; return total; &#125;&#125; Different to the former question, in this question we have to loop from the leaf. So we have to keep a prevsum to keep track of. Input: [1,[4,[6]]]Output: 17Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"}]},{"title":"Front-end Interview Note 5 ğŸ’ª","slug":"front-end-interview2","date":"2020-04-26T18:28:27.000Z","updated":"2020-05-19T15:45:43.592Z","comments":true,"path":"2020/04/26/front-end-interview2/","link":"","permalink":"WangHngLeee.github.io/2020/04/26/front-end-interview2/","excerpt":"","text":"HTML &lt;!DOCTYPE&gt;ä½œç”¨ ä¸€èˆ¬åœ¨htmlæ–‡æ¡£ç¬¬ä¸€è¡Œå£°æ˜ã€‚ç”¨æ¥å‘ŠçŸ¥æµè§ˆå™¨ç”¨ä»€ä¹ˆæ–‡æ¡£è§£ææ ‡å‡†æ¥è§£æå½“å‰æ–‡æ¡£ã€‚è§£ææ¨¡å¼åˆ†ä¸ºæ ‡å‡†æ¨¡å¼å’Œå…¼å®¹æ¨¡å¼ã€‚ æ ‡å‡†æ¨¡å¼ &amp;&amp; å…¼å®¹æ¨¡å¼ æ ‡å‡†æ¨¡å¼ï¼šæ ‡å‡†æ¨¡å¼çš„æ¸²æŸ“æ–¹å¼å’Œ JS å¼•æ“çš„è§£ææ–¹å¼éƒ½æ˜¯ä»¥è¯¥æµè§ˆå™¨æ”¯æŒçš„æœ€é«˜æ ‡å‡†è¿è¡Œã€‚ å…¼å®¹æ¨¡å¼ï¼šé¡µé¢ä»¥å®½æ¾çš„å‘åå…¼å®¹çš„æ–¹å¼æ˜¾ç¤ºï¼Œæ¨¡æ‹Ÿè€å¼æµè§ˆå™¨çš„è¡Œä¸ºä»¥é˜²æ­¢ç«™ç‚¹æ— æ³•å·¥ä½œã€‚ link å’Œ @importåŒºåˆ« ä»å±å…³ç³»ï¼šlinkæ˜¯åŸºäºhtmlçš„è¯­æ³•ï¼Œè€Œ@importæ˜¯åŸºäºcssçš„ï¼Œcss2.1ä¹‹åæ‰å‡ºç°ã€‚ åŠ è½½é¡ºåºï¼šlinkä¸­çš„å†…å®¹å¯ä»¥éšé¡µé¢å…¶ä»–å†…å®¹ä¸€èµ·åŠ è½½ï¼Œè€Œ@importä¸­å¼•å…¥çš„csså¿…é¡»ç­‰å…¶ä»–å…¨éƒ¨åŠ è½½å®Œæˆåå†å¼€å§‹åŠ è½½ã€‚ å…¼å®¹æ€§åŒºåˆ«ï¼šlinkæ˜¯åŸºäºhtmlçš„ï¼Œä¸å­˜åœ¨å…¼å®¹æ€§é—®é¢˜ã€‚@importæ˜¯css2.1ä¹‹åæ‰å‡ºç°çš„ï¼Œä¼šå­˜åœ¨éƒ¨åˆ†IE5+ä¹‹å‰çš„æµè§ˆå™¨åœ¨ä¸å…¼å®¹çš„é—®é¢˜ã€‚ DOMå¯æ“ä½œæ€§ï¼š å¯ä»¥é€šè¿‡JSæ“ä½œDOMæ”¹å˜linkä¸­çš„å†…å®¹æ¥æ”¹å˜æ ·å¼ï¼›è€ŒDOMæ˜¯åŸºäºæ–‡æ¡£çš„ï¼Œæ— æ³•ä½¿ç”¨@importæ¥æ”¹å˜ã€‚ æµè§ˆå™¨æ¸²æŸ“åŸç† é¦–å…ˆè§£ææ”¶åˆ°HTMLçš„æ–‡ä»¶ï¼Œæ„é€ DOMæ ‘ã€‚ å¯¹CSSæ–‡ä»¶è¿›è¡Œè§£æï¼Œæ„é€ CSSOMè§„åˆ™æ ‘ã€‚ æ ¹æ®DOMå’ŒCSSOMè§„åˆ™æ ‘æ„é€ æ¸²æŸ“æ ‘ã€‚ å½“æ¸²æŸ“å¯¹è±¡è¢«åˆ›å»ºå¹¶æ·»åŠ åˆ°æ ‘ä¸­ï¼Œå®ƒä»¬å¹¶æ²¡æœ‰ä½ç½®å’Œå¤§å°ï¼Œæ‰€ä»¥å½“æµè§ˆå™¨ç”Ÿæˆæ¸²æŸ“æ ‘ä»¥åï¼Œå°±ä¼šæ ¹æ®æ¸²æŸ“æ ‘æ¥è¿›è¡Œå¸ƒå±€ï¼ˆä¹Ÿå«åšå›æµ/é‡æ’ï¼‰. å¸ƒå±€é˜¶æ®µç»“æŸåæ˜¯ç»˜åˆ¶é˜¶æ®µï¼ˆé‡ç»˜ï¼‰ï¼Œéå†æ¸²æŸ“æ ‘å¹¶è°ƒç”¨æ¸²æŸ“å¯¹è±¡çš„ paint æ–¹æ³•å°†å®ƒä»¬çš„å†…å®¹æ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼Œç»˜åˆ¶ä½¿ç”¨ UI åŸºç¡€ç»„ä»¶ã€‚ async å’Œ defer çš„ä½œç”¨å’ŒåŒºåˆ« å¦‚æœscriptä¸­æ²¡æœ‰asyncå’Œdeferï¼Œåˆ™æµè§ˆå™¨ä¼šè‡ªåŠ¨åŠ è½½å’Œæ‰§è¡ŒæŒ‡å®šå¯¹è„šæœ¬æ–‡ä»¶ï¼Œå¹¶æš‚åœå…¶ä»–èµ„æºçš„åŠ è½½å’Œæ‰§è¡Œï¼ŒçŸ¥é“scriptä¸­çš„èµ„æºåŠ è½½æ‰§è¡Œå®Œæ¯•ã€‚ deferï¼šè¡¨ç¤ºå»¶è¿Ÿæ‰§è¡Œå¼•å…¥çš„JSã€‚JSåŠ è½½æ—¶ HTML å¹¶æœªåœæ­¢è§£æï¼Œè¿™ä¸¤ä¸ªè¿‡ç¨‹æ˜¯å¹¶è¡Œçš„ã€‚å½“æ•´ä¸ª document è§£æå®Œæ¯•åå†æ‰§è¡Œè„šæœ¬æ–‡ä»¶ï¼Œåœ¨ DOMContentLoaded äº‹ä»¶è§¦å‘ä¹‹å‰å®Œæˆã€‚å¤šä¸ªè„šæœ¬æŒ‰é¡ºåºæ‰§è¡Œã€‚ asyncï¼šè¡¨ç¤ºå¼‚æ­¥æ‰§è¡Œå¼•å…¥JavaScriptï¼Œä¸ defer çš„åŒºåˆ«åœ¨äºï¼Œå¦‚æœå·²ç»åŠ è½½å¥½ï¼Œå°±ä¼šå¼€å§‹æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒçš„æ‰§è¡Œä»ç„¶ä¼šé˜»å¡æ–‡æ¡£çš„è§£æï¼Œåªæ˜¯å®ƒçš„åŠ è½½è¿‡ç¨‹ä¸ä¼šé˜»å¡ã€‚å¤šä¸ªè„šæœ¬çš„æ‰§è¡Œé¡ºåºæ— æ³•ä¿è¯ã€‚ DOMContentLoaded äº‹ä»¶å’Œ Load äº‹ä»¶çš„åŒºåˆ« DOMContentLoadedåœ¨HTMLæ–‡ä»¶å…¨éƒ¨åŠ è½½å®Œæˆåè§¦å‘ï¼Œå¹¶ä¸éœ€è¦ç­‰å¾…cssæ ·å¼ã€å›¾ç‰‡å›¾è¡¨ç­‰æ–‡ä»¶çš„åŠ è½½ã€‚ Loadå¿…é¡»ç­‰åˆ°æ‰€æœ‰æ–‡ä»¶å…¨éƒ¨åŠ è½½å®Œæˆåæ‰ä¼šè§¦å‘ã€‚ HTMLç¦»çº¿ç¼“å­˜ åŸç†ï¼šHTML5 çš„ç¦»çº¿å­˜å‚¨æ˜¯åŸºäºä¸€ä¸ªæ–°å»ºçš„ .appcache æ–‡ä»¶çš„ç¼“å­˜æœºåˆ¶ï¼ˆä¸æ˜¯å­˜å‚¨æŠ€æœ¯ï¼‰ï¼Œé€šè¿‡è¿™ä¸ªæ–‡ä»¶ä¸Šçš„è§£ææ¸…å•ç¦»çº¿å­˜å‚¨èµ„æºï¼Œè¿™äº›èµ„æºå°±ä¼šåƒ cookie ä¸€æ ·è¢«å­˜å‚¨äº†ä¸‹æ¥ã€‚ä¹‹åå½“ç½‘ç»œåœ¨å¤„äºç¦»çº¿çŠ¶æ€ä¸‹æ—¶ï¼Œæµè§ˆå™¨ä¼šé€šè¿‡è¢«ç¦»çº¿å­˜å‚¨çš„æ•°æ®è¿›è¡Œé¡µé¢å±•ç¤ºã€‚ åœ¨çº¿çš„æƒ…å†µä¸‹ï¼Œæµè§ˆå™¨å‘ç° html å¤´éƒ¨æœ‰ manifest å±æ€§ï¼Œå®ƒä¼šè¯·æ±‚ manifest æ–‡ä»¶ï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è®¿é—® app ï¼Œé‚£ä¹ˆæµè§ˆå™¨å°±ä¼šæ ¹æ® manifest æ–‡ä»¶çš„å†…å®¹ä¸‹è½½ç›¸åº”çš„èµ„æºå¹¶ä¸”è¿›è¡Œç¦»çº¿å­˜å‚¨ã€‚å¦‚æœå·²ç»è®¿é—®è¿‡ app å¹¶ä¸”èµ„æºå·²ç»ç¦»çº¿å­˜å‚¨äº†ï¼Œé‚£ä¹ˆæµè§ˆå™¨å°±ä¼šä½¿ç”¨ç¦»çº¿çš„èµ„æºåŠ è½½é¡µé¢ï¼Œç„¶åæµè§ˆå™¨ä¼šå¯¹æ¯”æ–°çš„ manifest æ–‡ä»¶ä¸æ—§çš„ manifest æ–‡ä»¶ï¼Œå¦‚æœæ–‡ä»¶æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼Œå°±ä¸åšä»»ä½•æ“ä½œï¼Œå¦‚æœæ–‡ä»¶æ”¹å˜äº†ï¼Œé‚£ä¹ˆå°±ä¼šé‡æ–°ä¸‹è½½æ–‡ä»¶ä¸­çš„èµ„æºå¹¶è¿›è¡Œç¦»çº¿å­˜å‚¨ã€‚ ç¦»çº¿çš„æƒ…å†µä¸‹ï¼Œæµè§ˆå™¨å°±ç›´æ¥ä½¿ç”¨ç¦»çº¿å­˜å‚¨çš„èµ„æºã€‚ attibuteå’ŒpropertyåŒºåˆ« attribute æ˜¯ dom å…ƒç´ åœ¨æ–‡æ¡£ä¸­ä½œä¸º html æ ‡ç­¾æ‹¥æœ‰çš„å±æ€§ï¼› property å°±æ˜¯ dom å…ƒç´ åœ¨ js ä¸­ä½œä¸ºå¯¹è±¡æ‹¥æœ‰çš„å±æ€§ã€‚ å¯¹äº html çš„æ ‡å‡†å±æ€§æ¥è¯´ï¼Œattribute å’Œ property æ˜¯åŒæ­¥çš„ï¼Œæ˜¯ä¼šè‡ªåŠ¨æ›´æ–°çš„ï¼Œä½†æ˜¯å¯¹äºè‡ªå®šä¹‰çš„å±æ€§æ¥è¯´ï¼Œä»–ä»¬æ˜¯ä¸åŒæ­¥çš„ã€‚ CSS","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 4 ğŸ’ª","slug":"frontend-interview-note","date":"2020-04-26T18:28:27.000Z","updated":"2020-05-19T15:45:59.415Z","comments":true,"path":"2020/04/26/frontend-interview-note/","link":"","permalink":"WangHngLeee.github.io/2020/04/26/frontend-interview-note/","excerpt":"CSS ::before å’Œ:afterä¸­å•å¼•å·å’ŒåŒå¼•å·çš„åŒºåˆ« å•å†’å·(:)ç”¨äºcssä¼ªç±»ï¼ŒåŒå†’å·(::)ç”¨äºcssä¼ªå…ƒç´ ã€‚æœ‰äº›æµè§ˆå™¨è€ƒè™‘åˆ°å…¼å®¹é—®é¢˜ï¼Œéƒ¨åˆ†æƒ…å†µä¸‹ä¹Ÿå¯ä»¥ç”¨å•å¼•å·(:)è¡¨ç¤ºä¼ªå…ƒç´ ã€‚ ä¼ªç±»(ğŸ˜ƒï¼šä¸€èˆ¬åŒ¹é…çš„æ˜¯å…ƒç´ çš„æŸäº›ç‰¹å®šçŠ¶æ€ï¼Œä¾‹å¦‚:hover, :link ä¼ªç±»ç”¨äºå½“å·²æœ‰çš„å…ƒç´ å¤„äºæŸä¸ªçŠ¶æ€æ—¶ï¼Œä¸ºå…¶æ·»åŠ å¯¹åº”çš„æ ·å¼ï¼Œè¿™ä¸ªçŠ¶æ€æ˜¯æ ¹æ®ç”¨æˆ·è¡Œä¸ºè€ŒåŠ¨æ€å˜åŒ–çš„ã€‚æ¯”å¦‚è¯´ï¼Œå½“ç”¨æˆ·æ‚¬åœåœ¨æŒ‡å®šçš„ å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ :hover æ¥æè¿°è¿™ä¸ªå…ƒç´ çš„çŠ¶æ€ã€‚ ä¼ªå…ƒç´ (:ğŸ˜ƒï¼šä¸€èˆ¬åŒ¹é…çš„æ˜¯ç‰¹æ®Šä½ç½®ï¼Œæ¯”å¦‚::before ::afterç­‰ã€‚ ä¼ªå…ƒç´ ç”¨äºåˆ›å»ºä¸€äº›ä¸åœ¨æ–‡æ¡£æ ‘ä¸­çš„å…ƒç´ ï¼Œå¹¶ä¸ºå…¶æ·»åŠ æ ·å¼ã€‚å®ƒä»¬å…è®¸æˆ‘ä»¬ä¸ºå…ƒç´ çš„æŸäº›éƒ¨åˆ†è®¾ç½®æ ·å¼ã€‚æ¯”å¦‚è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ ::be fore æ¥åœ¨ä¸€ä¸ªå…ƒç´ å‰å¢åŠ ä¸€äº›æ–‡æœ¬ï¼Œå¹¶ä¸ºè¿™äº›æ–‡æœ¬æ·»åŠ æ ·å¼ã€‚è™½ç„¶ç”¨æˆ·å¯ä»¥çœ‹åˆ°è¿™äº›æ–‡æœ¬ï¼Œä½†æ˜¯è¿™äº›æ–‡æœ¬å®é™…ä¸Šä¸åœ¨æ–‡æ¡£æ ‘ä¸­ã€‚","text":"CSS ::before å’Œ:afterä¸­å•å¼•å·å’ŒåŒå¼•å·çš„åŒºåˆ« å•å†’å·(:)ç”¨äºcssä¼ªç±»ï¼ŒåŒå†’å·(::)ç”¨äºcssä¼ªå…ƒç´ ã€‚æœ‰äº›æµè§ˆå™¨è€ƒè™‘åˆ°å…¼å®¹é—®é¢˜ï¼Œéƒ¨åˆ†æƒ…å†µä¸‹ä¹Ÿå¯ä»¥ç”¨å•å¼•å·(:)è¡¨ç¤ºä¼ªå…ƒç´ ã€‚ ä¼ªç±»(ğŸ˜ƒï¼šä¸€èˆ¬åŒ¹é…çš„æ˜¯å…ƒç´ çš„æŸäº›ç‰¹å®šçŠ¶æ€ï¼Œä¾‹å¦‚:hover, :link ä¼ªç±»ç”¨äºå½“å·²æœ‰çš„å…ƒç´ å¤„äºæŸä¸ªçŠ¶æ€æ—¶ï¼Œä¸ºå…¶æ·»åŠ å¯¹åº”çš„æ ·å¼ï¼Œè¿™ä¸ªçŠ¶æ€æ˜¯æ ¹æ®ç”¨æˆ·è¡Œä¸ºè€ŒåŠ¨æ€å˜åŒ–çš„ã€‚æ¯”å¦‚è¯´ï¼Œå½“ç”¨æˆ·æ‚¬åœåœ¨æŒ‡å®šçš„ å…ƒç´ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ :hover æ¥æè¿°è¿™ä¸ªå…ƒç´ çš„çŠ¶æ€ã€‚ ä¼ªå…ƒç´ (:ğŸ˜ƒï¼šä¸€èˆ¬åŒ¹é…çš„æ˜¯ç‰¹æ®Šä½ç½®ï¼Œæ¯”å¦‚::before ::afterç­‰ã€‚ ä¼ªå…ƒç´ ç”¨äºåˆ›å»ºä¸€äº›ä¸åœ¨æ–‡æ¡£æ ‘ä¸­çš„å…ƒç´ ï¼Œå¹¶ä¸ºå…¶æ·»åŠ æ ·å¼ã€‚å®ƒä»¬å…è®¸æˆ‘ä»¬ä¸ºå…ƒç´ çš„æŸäº›éƒ¨åˆ†è®¾ç½®æ ·å¼ã€‚æ¯”å¦‚è¯´ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ ::be fore æ¥åœ¨ä¸€ä¸ªå…ƒç´ å‰å¢åŠ ä¸€äº›æ–‡æœ¬ï¼Œå¹¶ä¸ºè¿™äº›æ–‡æœ¬æ·»åŠ æ ·å¼ã€‚è™½ç„¶ç”¨æˆ·å¯ä»¥çœ‹åˆ°è¿™äº›æ–‡æœ¬ï¼Œä½†æ˜¯è¿™äº›æ–‡æœ¬å®é™…ä¸Šä¸åœ¨æ–‡æ¡£æ ‘ä¸­ã€‚ å±…ä¸­é—®é¢˜ 1.æ°´å¹³å±…ä¸­ ä¸ºdivè®¾ç½®å®½åº¦ï¼Œè®©marginä¸º0 autoã€‚ .div&#123; width:100px; margin: 0 auto;&#125; ä½¿ç”¨text-alignå®ç° .container&#123; background-color:black; text-align: center;&#125;.box&#123; display:inline-block; width:100px; height:100px; background-color:pink;/*å’ŒblackåŒºåˆ†å¼€æ›´æ¸…æ¥š*/&#125; 2.æ°´å¹³å‚ç›´å±…ä¸­ å®¹å™¨é«˜å®½å€¼ç»™å®šæ—¶,marginè®¾ä¸ºè‡ªèº«å®½é«˜ä¸€åŠ .div&#123; width:200; height:200; top:50%; left:50%; margin: -100px 0 0 -100px;&#125; å…ˆå°†divå·¦ä¸Šè§’ç§»åˆ°å±å¹•ä¸­å¿ƒï¼Œå†è®¾ç½®marginä¸ºè‡ªèº«sizeçš„ä¸€åŠã€‚ å®¹å™¨å®½é«˜æœªçŸ¥æ—¶ï¼Œä½¿ç”¨transformæ–¹æ³•ã€‚ .div&#123; position: absolute;/* ç›¸å¯¹å®šä½æˆ–ç»å¯¹å®šä½å‡å¯ */ top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink;&#125; ä½¿ç”¨flexå¸ƒå±€ .center&#123; display:flex; align-items: center; justify-content: center;&#125;.center div&#123; width:100px; height:100px; background-color:red;/*çœ‹æ•ˆæœ*/&#125; positionä¸­ï¼Œä¸åŒçš„å€¼å…¶å®šä½åŸç‚¹å„æ˜¯ä»€ä¹ˆï¼Ÿ(relative,absolute,static,fixed,inherit) absolute: ç”Ÿæˆç»å¯¹å®šä½çš„å…ƒç´ ï¼Œç›¸å¯¹äºå€¼ä¸ä¸º static çš„ç¬¬ä¸€ä¸ªçˆ¶å…ƒç´ çš„ padding box è¿›è¡Œå®šä½ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºç¦»è‡ªå·±è¿™ä¸€çº§å…ƒç´ æœ€è¿‘çš„ ä¸€çº§ position è®¾ç½®ä¸º absolute æˆ–è€… relative çš„çˆ¶å…ƒç´ çš„ padding box çš„å·¦ä¸Šè§’ä¸ºåŸç‚¹çš„ã€‚ fixed :ç”Ÿæˆç»å¯¹å®šä½çš„å…ƒç´ ï¼Œç›¸å¯¹äºæµè§ˆå™¨çª—å£è¿›è¡Œå®šä½ã€‚ relative: ç”Ÿæˆç›¸å¯¹å®šä½çš„å…ƒç´ ï¼Œç›¸å¯¹äºå…¶å…ƒç´ æœ¬èº«æ‰€åœ¨æ­£å¸¸ä½ç½®è¿›è¡Œå®šä½ã€‚ static: é»˜è®¤å€¼ã€‚æ²¡æœ‰å®šä½ï¼Œå…ƒç´ å‡ºç°åœ¨æ­£å¸¸çš„æµä¸­ï¼ˆå¿½ç•¥ top, bottom, left, right, z-index å£°æ˜ï¼‰ã€‚ inherit: è§„å®šä»çˆ¶å…ƒç´ ç»§æ‰¿ position å±æ€§çš„å€¼ã€‚ li ä¸ li ä¹‹é—´æœ‰çœ‹ä¸è§çš„ç©ºç™½é—´éš”é—®é¢˜ &amp;&amp; è§£å†³æ–¹æ³• æµè§ˆå™¨åœ¨æ¸²æŸ“inlineè¡Œå†…å…ƒç´ çš„æ—¶å€™ï¼Œä¸ºäº†ç¾è§‚ä¼šå°†å…ƒç´ é—´çš„ç©ºç™½å­—ç¬¦æ¸²æŸ“æˆæ¢ç©ºæ ¼ã€‚è€Œæˆ‘ä»¬åœ¨å†™liçš„æ—¶å€™ä¸ºäº†ç¾è§‚ä¼šå°†liæ”¾åœ¨å•ç‹¬ä¸€è¡Œï¼Œæ‰€ä»¥liæ¢è¡Œåä¼šäº§ç”Ÿæ¢è¡Œç¬¦ã€‚ ä¸ºliè®¾ç½® float: leftã€‚ å°†æ‰€æœ‰ li å†™åœ¨åŒä¸€è¡Œã€‚ å°† ul å†…çš„font-sizeè®¾ä¸º0ã€‚ æ¶ˆé™¤ ul çš„å­—ç¬¦é—´éš” ï¼Œè®¾ç½®letter-spacing: -8pxï¼Œ","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"ğŸ“– Vueå­¦ä¹ ç¬”è®°(3)","slug":"vue3","date":"2020-04-13T17:15:41.000Z","updated":"2020-04-27T00:06:07.125Z","comments":true,"path":"2020/04/13/vue3/","link":"","permalink":"WangHngLeee.github.io/2020/04/13/vue3/","excerpt":"","text":"vue v-model å’Œ æ•°æ®åŒå‘ç»‘å®š v-model ...&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h4&gt; &#123;&#123; msg &#125;&#125; &lt;/h4&gt; &lt;input type='text' v-bind:value = \"msg\"&gt; &lt;input type='text' v-model = \"msg\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; msg: 'This is new data ' &#125; &#125;)&lt;/script&gt; ä¸Šé¢çš„ä»£ç å¾ˆæ¸…æ¥šçš„å±•ç¤ºäº†v-bind å•å‘æ•°æ®ç»‘å®šå’Œ v-model åŒå‘æ•°æ®ç»‘å®šçš„åŒºåˆ«ã€‚ ç¬¬ä¸€ä¸ªinputæ¡†å†…çš„æ–‡å­—åªä¼šå’Œh4å†…åŒæ­¥ä¸€æ¬¡ï¼Œå½“å¯¹inputåšå‡ºæ”¹å˜æ—¶ï¼Œh4å†…å®¹ä¸ä¼šéšä¹‹æ”¹å˜ã€‚ ç›¸åï¼Œä½¿ç”¨äº†v-modelçš„inputå‘ç”Ÿæ”¹å˜æ—¶ï¼Œh4æ˜¾ç¤ºçš„å†…å®¹ä¼šéšä¹‹ä¸€èµ·æ”¹å˜ã€‚ å¾…æ›´æ–°","categories":[{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"Vue","slug":"å‰ç«¯æ¡†æ¶/Vue","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"ğŸ“– å‰ç«¯é—®é¢˜æ‚çƒ©-Vueç¯‡(1)","slug":"front-end-interview-vue","date":"2020-04-08T18:15:41.000Z","updated":"2020-05-19T15:45:47.471Z","comments":true,"path":"2020/04/08/front-end-interview-vue/","link":"","permalink":"WangHngLeee.github.io/2020/04/08/front-end-interview-vue/","excerpt":"è®²ä¸€è®²MVVMï¼Ÿï¼ˆâ­ï¸â­ï¸â­ï¸â­ï¸ï¼‰ MVVMæ˜¯Model-View-ViewModelçš„ç¼©å†™ï¼Œä¹Ÿå°±æ˜¯æŠŠåç«¯æ¦‚å¿µé‡ŒMVCçš„controlleræ¢æˆäº†viewmodelã€‚ Modelå±‚ä»£è¡¨æ•°æ®æ¨¡å‹ï¼ŒViewä»£è¡¨UIç»„ä»¶ï¼ŒViewModelæ˜¯Viewå’ŒModelå±‚çš„æ¡¥æ¢ï¼Œæ•°æ®ä¼šç»‘å®šåˆ°viewModelå±‚å¹¶è‡ªåŠ¨å°†æ•°æ®æ¸²æŸ“åˆ°é¡µé¢ä¸­ï¼Œè§†å›¾å˜åŒ–çš„æ—¶å€™ä¼šé€šçŸ¥viewModelå±‚æ›´æ–°æ•°æ®ã€‚ è®²ä¸€ä¸‹Vue2.xå“åº”å¼æ•°æ®çš„åŸç†ï¼ˆâ­ï¸â­ï¸â­ï¸ï¼‰ Vueåœ¨åˆå§‹åŒ–æ•°æ®æ—¶ï¼Œä¼šä½¿ç”¨Object.definePropertyé‡æ–°å®šä¹‰dataä¸­çš„æ‰€æœ‰å±æ€§ã€‚å½“é¡µé¢ä½¿ç”¨å¯¹åº”å±æ€§æ—¶ï¼Œé¦–å…ˆä¼šè¿›è¡Œä¾èµ–æ”¶é›†(æ”¶é›†å½“å‰ç»„ä»¶çš„watcher)ï¼Œå¦‚æœå±æ€§å‘ç”Ÿå˜åŒ–ä¼šé€šçŸ¥ç›¸å…³ä¾èµ–è¿›è¡Œæ›´æ–°æ“ä½œ(å‘å¸ƒè®¢é˜…)ã€‚","text":"è®²ä¸€è®²MVVMï¼Ÿï¼ˆâ­ï¸â­ï¸â­ï¸â­ï¸ï¼‰ MVVMæ˜¯Model-View-ViewModelçš„ç¼©å†™ï¼Œä¹Ÿå°±æ˜¯æŠŠåç«¯æ¦‚å¿µé‡ŒMVCçš„controlleræ¢æˆäº†viewmodelã€‚ Modelå±‚ä»£è¡¨æ•°æ®æ¨¡å‹ï¼ŒViewä»£è¡¨UIç»„ä»¶ï¼ŒViewModelæ˜¯Viewå’ŒModelå±‚çš„æ¡¥æ¢ï¼Œæ•°æ®ä¼šç»‘å®šåˆ°viewModelå±‚å¹¶è‡ªåŠ¨å°†æ•°æ®æ¸²æŸ“åˆ°é¡µé¢ä¸­ï¼Œè§†å›¾å˜åŒ–çš„æ—¶å€™ä¼šé€šçŸ¥viewModelå±‚æ›´æ–°æ•°æ®ã€‚ è®²ä¸€ä¸‹Vue2.xå“åº”å¼æ•°æ®çš„åŸç†ï¼ˆâ­ï¸â­ï¸â­ï¸ï¼‰ Vueåœ¨åˆå§‹åŒ–æ•°æ®æ—¶ï¼Œä¼šä½¿ç”¨Object.definePropertyé‡æ–°å®šä¹‰dataä¸­çš„æ‰€æœ‰å±æ€§ã€‚å½“é¡µé¢ä½¿ç”¨å¯¹åº”å±æ€§æ—¶ï¼Œé¦–å…ˆä¼šè¿›è¡Œä¾èµ–æ”¶é›†(æ”¶é›†å½“å‰ç»„ä»¶çš„watcher)ï¼Œå¦‚æœå±æ€§å‘ç”Ÿå˜åŒ–ä¼šé€šçŸ¥ç›¸å…³ä¾èµ–è¿›è¡Œæ›´æ–°æ“ä½œ(å‘å¸ƒè®¢é˜…)ã€‚ è®²ä¸€ä¸‹Vue3.xå“åº”å¼æ•°æ®åŸç†ï¼ˆâ­ï¸â­ï¸â­ï¸â­ï¸ï¼‰ Vue3.xæ”¹ç”¨Proxyæ›¿ä»£Object.definePropertyã€‚å› ä¸ºProxyå¯ä»¥ç›´æ¥ç›‘å¬å¯¹è±¡å’Œæ•°ç»„çš„å˜åŒ–ï¼Œå¹¶ä¸”æœ‰å¤šè¾¾13ç§æ‹¦æˆªæ–¹æ³•ã€‚å¹¶ä¸”ä½œä¸ºæ–°æ ‡å‡†å°†å—åˆ°æµè§ˆå™¨å‚å•†é‡ç‚¹æŒç»­çš„æ€§èƒ½ä¼˜åŒ–ã€‚ Proxyåªä¼šä»£ç†å¯¹è±¡çš„ç¬¬ä¸€å±‚ï¼Œé‚£ä¹ˆVue3åˆæ˜¯æ€æ ·å¤„ç†è¿™ä¸ªé—®é¢˜çš„å‘¢ï¼Ÿï¼ˆâ­ï¸â­ï¸â­ï¸ï¼‰ åˆ¤æ–­å½“å‰Reflect.getçš„è¿”å›å€¼æ˜¯å¦ä¸ºObjectã€‚å¦‚æœæ˜¯åˆ™å†é€šè¿‡reactiveæ–¹æ³•åšä»£ç†ï¼Œè¿™æ ·å°±å®ç°äº†æ·±åº¦è§‚æµ‹ã€‚ ç›‘æµ‹æ•°ç»„çš„æ—¶å€™å¯èƒ½è§¦å‘å¤šæ¬¡get/setï¼Œå¦‚ä½•é˜²æ­¢è§¦å‘å¤šæ¬¡å‘¢ï¼Ÿï¼ˆâ­ï¸â­ï¸â­ï¸ï¼‰ å¯ä»¥é€šè¿‡åˆ¤æ–­keyæ˜¯å¦ä¸ºå½“å‰è¢«ä»£ç†å¯¹è±¡targetè‡ªèº«å±æ€§ï¼Œä¹Ÿå¯ä»¥åˆ¤æ–­æ—§å€¼ä¸æ–°å€¼æ˜¯å¦ç›¸ç­‰ï¼Œåªæœ‰æ»¡è¶³ä»¥ä¸Šä¸¤ä¸ªæ¡ä»¶ä¹‹ä¸€æ—¶ï¼Œæ‰æœ‰å¯èƒ½æ‰§è¡Œtriggerã€‚ vue2.xä¸­å¦‚ä½•ç›‘æµ‹æ•°ç»„å˜åŒ–ï¼ˆâ­ï¸â­ï¸ï¼‰ ä½¿ç”¨äº†å‡½æ•°åŠ«æŒçš„æ–¹å¼ï¼Œé‡å†™äº†æ•°ç»„çš„æ–¹æ³•ï¼ŒVueå°†dataä¸­çš„æ•°ç»„è¿›è¡Œäº†åŸå‹é“¾é‡å†™ï¼ŒæŒ‡å‘äº†è‡ªå·±å®šä¹‰çš„æ•°ç»„åŸå‹æ–¹æ³•ã€‚è¿™æ ·å½“è°ƒç”¨æ•°ç»„apiæ—¶ï¼Œå¯ä»¥é€šçŸ¥ä¾èµ–æ›´æ–°ã€‚å¦‚æœæ•°ç»„ä¸­åŒ…å«ç€å¼•ç”¨ç±»å‹ï¼Œä¼šå¯¹æ•°ç»„ä¸­çš„å¼•ç”¨ç±»å‹å†æ¬¡é€’å½’éå†è¿›è¡Œç›‘æ§ã€‚è¿™æ ·å°±å®ç°äº†ç›‘æµ‹æ•°ç»„å˜åŒ–ã€‚ ï¼ˆè¿™é‡Œè¦å¤šçœ‹vueæºç å’ŒjsåŸå‹é“¾çš„æ¦‚å¿µã€‚) nextTickæ˜¯ä»€ä¹ˆï¼Ÿå®ƒçš„å®ç°åŸç†ï¼Ÿï¼ˆâ­ï¸â­ï¸ï¼‰ åœ¨ä¸‹æ¬¡ DOM æ›´æ–°å¾ªç¯ç»“æŸä¹‹åæ‰§è¡Œå»¶è¿Ÿå›è°ƒã€‚nextTickä¸»è¦ä½¿ç”¨äº†å®ä»»åŠ¡å’Œå¾®ä»»åŠ¡ã€‚æ ¹æ®æ‰§è¡Œç¯å¢ƒåˆ†åˆ«å°è¯•é‡‡ç”¨ Promise MutationObserver setImmediate å¦‚æœä»¥ä¸Šéƒ½ä¸è¡Œåˆ™é‡‡ç”¨setTimeout å®šä¹‰äº†ä¸€ä¸ªå¼‚æ­¥æ–¹æ³•ï¼Œå¤šæ¬¡è°ƒç”¨nextTickä¼šå°†æ–¹æ³•å­˜å…¥é˜Ÿåˆ—ä¸­ï¼Œé€šè¿‡è¿™ä¸ªå¼‚æ­¥æ–¹æ³•æ¸…ç©ºå½“å‰é˜Ÿåˆ—ã€‚ (å…¶å®é—®æ¡†æ¶æœ€ç»ˆè¿˜æ˜¯è€ƒéªŒåŸç”ŸJavaScriptçš„åŠŸåº•) Vueçš„ç”Ÿå‘½å‘¨æœŸï¼ˆâ­ï¸â­ï¸â­ï¸â­ï¸â­ï¸ï¼‰ Vueå®ä¾‹æœ‰ä¸€ä¸ªå®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¹Ÿå°±æ˜¯ä»å¼€å§‹åˆ›å»ºã€åˆå§‹åŒ–æ•°æ®ã€ç¼–è¯‘æ¨¡ç‰ˆã€æŒ‚è½½DOMã€æ¸²æŸ“â¡ï¸æ›´æ–°â¡ï¸æ¸²æŸ“ã€é”€æ¯ç­‰ä¸€ç³»åˆ—è¿‡ç¨‹ï¼Œè¿™å°±æ˜¯Vueç”Ÿå‘½å‘¨æœŸçš„å®šä¹‰ã€‚é€šä¿—è®²å°±æ˜¯Vueå®ä¾‹ä»åˆ›å»ºåˆ°é”€æ¯åˆ°å…¨è¿‡ç¨‹ã€‚ beforeCreateï¼šæ˜¯new Vue()ä¹‹åè§¦å‘çš„ç¬¬ä¸€ä¸ªé’©å­ï¼Œåœ¨å½“å‰é˜¶æ®µdataã€methodsã€computedä»¥åŠwatchä¸Šçš„æ•°æ®å’Œæ–¹æ³•éƒ½ä¸èƒ½è¢«è®¿é—®ã€‚ createdï¼šåœ¨å®ä¾‹åˆ›å»ºå®Œæˆåå‘ç”Ÿï¼Œå½“å‰é˜¶æ®µå·²ç»å®Œæˆäº†æ•°æ®è§‚æµ‹ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ä½¿ç”¨æ•°æ®ï¼Œæ›´æ”¹æ•°æ®ï¼Œåœ¨è¿™é‡Œæ›´æ”¹æ•°æ®ä¸ä¼šè§¦å‘updatedå‡½æ•°ã€‚å¯ä»¥åšä¸€äº›åˆå§‹æ•°æ®çš„è·å–ï¼Œåœ¨å½“å‰é˜¶æ®µæ— æ³•ä¸Domè¿›è¡Œäº¤äº’ï¼Œå¦‚æœéè¦æƒ³ï¼Œå¯ä»¥é€šè¿‡vm.$nextTickæ¥è®¿é—®Domã€‚ beforeMountï¼š å‘ç”Ÿåœ¨æŒ‚è½½ä¹‹å‰ï¼Œåœ¨è¿™ä¹‹å‰templateæ¨¡æ¿å·²å¯¼å…¥æ¸²æŸ“å‡½æ•°ç¼–è¯‘ã€‚è€Œå½“å‰é˜¶æ®µè™šæ‹ŸDomå·²ç»åˆ›å»ºå®Œæˆï¼Œå³å°†å¼€å§‹æ¸²æŸ“ã€‚åœ¨æ­¤æ—¶ä¹Ÿå¯ä»¥å¯¹æ•°æ®è¿›è¡Œæ›´æ”¹ï¼Œä¸ä¼šè§¦å‘updatedã€‚ mountedï¼š åœ¨æŒ‚è½½å®Œæˆåå‘ç”Ÿï¼Œåœ¨å½“å‰é˜¶æ®µï¼ŒçœŸå®çš„DomæŒ‚è½½å®Œæ¯•ï¼Œæ•°æ®å®ŒæˆåŒå‘ç»‘å®šï¼Œå¯ä»¥è®¿é—®åˆ°DomèŠ‚ç‚¹ï¼Œä½¿ç”¨$refså±æ€§å¯¹Domè¿›è¡Œæ“ä½œã€‚ beforeUpdateï¼š å‘ç”Ÿåœ¨æ›´æ–°ä¹‹å‰ï¼Œä¹Ÿå°±æ˜¯å“åº”å¼æ•°æ®å‘ç”Ÿæ›´æ–°ï¼Œè™šæ‹Ÿdomé‡æ–°æ¸²æŸ“ä¹‹å‰è¢«è§¦å‘ï¼Œä½ å¯ä»¥åœ¨å½“å‰é˜¶æ®µè¿›è¡Œæ›´æ”¹æ•°æ®ï¼Œä¸ä¼šé€ æˆé‡æ¸²æŸ“ã€‚ updatedï¼š å‘ç”Ÿåœ¨æ›´æ–°å®Œæˆä¹‹åï¼Œå½“å‰é˜¶æ®µç»„ä»¶Domå·²å®Œæˆæ›´æ–°ã€‚è¦æ³¨æ„çš„æ˜¯é¿å…åœ¨æ­¤æœŸé—´æ›´æ”¹æ•°æ®ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šå¯¼è‡´æ— é™å¾ªç¯çš„æ›´æ–°ã€‚ beforeDestroyï¼š å‘ç”Ÿåœ¨å®ä¾‹é”€æ¯ä¹‹å‰ï¼Œåœ¨å½“å‰é˜¶æ®µå®ä¾‹å®Œå…¨å¯ä»¥è¢«ä½¿ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¿™æ—¶è¿›è¡Œå–„åæ”¶å°¾å·¥ä½œï¼Œæ¯”å¦‚æ¸…é™¤è®¡æ—¶å™¨ã€‚ destroyedï¼š å‘ç”Ÿåœ¨å®ä¾‹é”€æ¯ä¹‹åï¼Œè¿™ä¸ªæ—¶å€™åªå‰©ä¸‹äº†domç©ºå£³ã€‚ç»„ä»¶å·²è¢«æ‹†è§£ï¼Œæ•°æ®ç»‘å®šè¢«å¸é™¤ï¼Œç›‘å¬è¢«ç§»å‡ºï¼Œå­å®ä¾‹ä¹Ÿç»Ÿç»Ÿè¢«é”€æ¯ã€‚","categories":[{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"Vue","slug":"å‰ç«¯æ¡†æ¶/Vue","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/"},{"name":"Interview","slug":"å‰ç«¯æ¡†æ¶/Vue/Interview","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"},{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"ğŸ“– Vueå­¦ä¹ ç¬”è®°(2)","slug":"vue2","date":"2020-04-05T13:15:41.000Z","updated":"2020-04-05T14:29:12.774Z","comments":true,"path":"2020/04/05/vue2/","link":"","permalink":"WangHngLeee.github.io/2020/04/05/vue2/","excerpt":"vueæŒ‡ä»¤â€“äº‹ä»¶ä¿®é¥°ç¬¦ .stopé˜»æ­¢å†’æ³¡ &lt;body&gt; &lt;div id='app'&gt; &lt;div @click = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click.stop =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; è¾“å‡ºç»“æœï¼š btn clicked stopè®©å†’æ³¡åœåœ¨äº†btnè¿™ä¸ªåœ°æ–¹ï¼Œä¸ä¼šç»§ç»­å‘ä¸Šå»¶ä¼¸åˆ°divçˆ¶ç±»ã€‚ å¦‚æœæ²¡æœ‰stopé˜»æ­¢å†’æ³¡çš„è¯ï¼Œæ­£å¸¸å†’æ³¡è¡Œä¸ºè¾“å‡ºåº”è¯¥ä¸ºï¼š btn clickeddiv clicked xxx.stop: è‡ªèº«ä¿®é¥°ç¬¦,å¯ä»¥é˜»æ­¢å†’æ³¡è¡Œä¸ºã€‚","text":"vueæŒ‡ä»¤â€“äº‹ä»¶ä¿®é¥°ç¬¦ .stopé˜»æ­¢å†’æ³¡ &lt;body&gt; &lt;div id='app'&gt; &lt;div @click = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click.stop =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; è¾“å‡ºç»“æœï¼š btn clicked stopè®©å†’æ³¡åœåœ¨äº†btnè¿™ä¸ªåœ°æ–¹ï¼Œä¸ä¼šç»§ç»­å‘ä¸Šå»¶ä¼¸åˆ°divçˆ¶ç±»ã€‚ å¦‚æœæ²¡æœ‰stopé˜»æ­¢å†’æ³¡çš„è¯ï¼Œæ­£å¸¸å†’æ³¡è¡Œä¸ºè¾“å‡ºåº”è¯¥ä¸ºï¼š btn clickeddiv clicked xxx.stop: è‡ªèº«ä¿®é¥°ç¬¦,å¯ä»¥é˜»æ­¢å†’æ³¡è¡Œä¸ºã€‚ .prevent é˜»æ­¢é»˜è®¤äº‹ä»¶ &lt;body&gt; &lt;div id='app'&gt; &lt;a href=\"https://google.com\" @click.prevent=\"linkclicked\"&gt;Google&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; linkclicked()&#123; console.log('link clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ä¸Šè¿°ä»£ç æœ€ç»ˆå°†ä¼šconsoleå‡ºâ€˜link clickedâ€™çš„ç»“æœä½†æ˜¯å¹¶ä¸ä¼šè·³è½¬ï¼Œå› ä¸ºpreventé˜»æ­¢äº†è·³è½¬çš„é»˜è®¤è¡Œä¸ºã€‚ .prevent: å¯ä»¥é˜»æ­¢é»˜è®¤çš„jsè¡Œä¸ºã€‚ .capture æ•è·è¡Œä¸º åˆ©ç”¨ä¹‹å‰.stopä¸­çš„ä»£ç æ¥çœ‹ï¼š &lt;body&gt; &lt;div id='app'&gt; &lt;div @click.capture = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; æ­¤æ—¶æ§åˆ¶å°è¾“å‡ºçš„é¡ºåºåˆ™å°†ä¼šæ˜¯ div clickedbtn clicked captureæ”¹å˜äº†webçš„é»˜è®¤å†’æ³¡è¡Œä¸ºï¼Œå˜æˆäº†æ•è·è¡Œä¸ºã€‚ å†’æ³¡ï¼šæ¸²æŸ“ä¹‹åï¼Œå½“ç”¨æˆ·äº§ç”Ÿäº¤äº’æ—¶ï¼Œå…ˆä»çˆ¶èŠ‚ç‚¹å‘ä¸‹å¯»æ‰¾è§¦å‘è¡Œä¸ºçš„componentï¼Œç„¶åç”±ä¸‹è‡³ä¸Šå†’æ³¡åœ°ä¾æ¬¡è§¦å‘subçˆ¶ç±»ã€‚ æ•è·ï¼šä¸å†’æ³¡ç›¸åï¼Œç›´æ¥ç”±ä¸Šåˆ°ä¸‹è§¦å‘ã€‚ .self è‡ªèº«è§¦å‘ &lt;body&gt; &lt;div id='app'&gt; &lt;div @click.self = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; æ­¤æ—¶åªç‚¹å‡»buttonæ—¶æ§åˆ¶å°åªä¼šè¾“å‡ºï¼š btn clicked å¹¶æ²¡æœ‰divçš„æ¶ˆæ¯å‡ºç°ï¼Œè¿™æ˜¯å› ä¸ºselfå®šä¹‰äº†åªæœ‰ç‚¹å‡»è¯¥å…ƒç´ æœ¬èº«çš„æ—¶å€™æ‰ä¼šè§¦å‘è¡Œä¸ºã€‚æ‰€ä»¥å½“ç‚¹å‡»divèŒƒå›´å†…çš„ç©ºç™½å¤„æ—¶ä¼šè¾“å‡ºâ€˜div clickedâ€™. .once åªæ‰§è¡Œä¸€æ¬¡ &lt;body&gt; &lt;div id='app'&gt; &lt;a href=\"https://google.com\" @click.prevent.self =\"linkclicked\"&gt;Google&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; linkclicked()&#123; console.log('link clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ä¸Šè¿°ä»£ç åªä¼šé˜»æ­¢è¯¥aæ ‡ç­¾è·³è½¬ä¸€æ¬¡ï¼Œç‚¹å‡»ç¬¬äºŒæ¬¡åˆ™ä¼šæ­£å¸¸è·³è½¬ï¼Œå› ä¸ºselfé™åˆ¶äº†preventåªèµ·ä½œç”¨ä¸€æ¬¡ã€‚ äº‹ä»¶ä¿®é¥°ç¬¦å¯ä»¥ä¸²è”ã€‚ onceåªè§¦å‘ä¸€æ¬¡ï¼Œä¸”åªæœ‰ä¸€æ¬¡æœ‰æ•ˆã€‚ .stop å’Œ .self é˜»æ­¢å†’æ³¡çš„åŸç†åŒºåˆ« .stop å’Œ .self éƒ½å¯ä»¥äº§ç”Ÿé˜»æ­¢å†’æ³¡çš„è¡Œä¸ºå‘ç”Ÿï¼Œä½†æ˜¯äºŒè€…åŸç†ä¸åŒã€‚ .stop é˜»æ­¢äº†è¯¥å…ƒç´ ä¹‹ä¸Šçš„æ‰€æœ‰çˆ¶å…ƒç´ çš„å†’æ³¡è¡Œä¸º .self åªé˜»æ­¢äº†è‡ªèº«çš„å†’æ³¡è¡Œä¸ºã€‚ // selfæœºåˆ¶div1 div2 div3 @click.self btn @click ç‚¹å‡»btnåï¼Œé™¤äº†div3ä¸ä¼šå†’æ³¡ï¼Œbtnï¼Œdiv1å’Œdiv2å‡ä¼šæ­£å¸¸å†’æ³¡ã€‚ // stopæœºåˆ¶div1 div2 div3 @click.stop btn @click æ­¤æ—¶ç‚¹å‡»btnï¼Œåªæœ‰btnå’Œdiv3ä¼šå†’æ³¡ï¼Œè€Œdiv1å’Œdiv2å‡ä¸ä¼šå†’æ³¡ã€‚","categories":[{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"Vue","slug":"å‰ç«¯æ¡†æ¶/Vue","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"ğŸ“– Vueå­¦ä¹ ç¬”è®°(1)","slug":"vue1","date":"2020-04-04T17:23:41.000Z","updated":"2020-04-05T14:29:14.739Z","comments":true,"path":"2020/04/04/vue1/","link":"","permalink":"WangHngLeee.github.io/2020/04/04/vue1/","excerpt":"MVC &amp; MVVM MVC MVCæ˜¯åç«¯ä¸­çš„åˆ†å±‚æ¦‚å¿µã€‚M-Modelï¼ŒV-Viewï¼ŒC-Controllerã€‚ MVVM MVVCåªæ˜¯é’ˆå¯¹å‰ç«¯åˆ†å±‚ã€‚M-Modelï¼ŒV-Viewï¼ŒVM-View Modelã€‚å…¶ä¸­Må’ŒVè¦é€šè¿‡VMæ¥è¿›è¡Œæ•°æ®é“¾æ¥ã€‚ VueåŸºæœ¬ä»£ç  åˆ†ä¸¤å¤§éƒ¨åˆ†ã€‚htmlå’Œjsã€‚ htmléƒ¨åˆ† ...&lt;body&gt;//jsä¸­newçš„vueå®ä¾‹å°†ä¼šæ§åˆ¶è¯¥divä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ &lt;div id='app'&gt; &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;p&gt; &lt;/div&gt;&lt;/body&gt;... jséƒ¨åˆ† // åˆ›å»ºæ–°çš„vueå®ä¾‹var vm = new Vue(&#123; el:'#app', // é€‰æ‹©æ§åˆ¶æŸä¸ªdiv data:&#123; title:'test'//å­˜æ”¾data &#125;, method:&#123; func1()&#123; // å®ç°å‡½æ•°å†…å®¹ &#125;, func2()&#123; //å®ç°å‡½æ•°å†…å®¹ &#125; &#125;&#125;) ä¸éš¾çœ‹å‡ºï¼Œhtmlä¸­çš„éƒ¨åˆ†æ˜¯V-viewï¼Œjsä¸­çš„éƒ¨åˆ†æ˜¯VM-ViewModelï¼Œè´Ÿè´£æ•°æ®é“¾æ¥ï¼Œå¦å¤–modeléƒ¨åˆ†ä¹Ÿåœ¨jsä¸­ï¼Œå…·ä½“æ˜¯dataä½“ç°äº†modelçš„åŠŸèƒ½ã€‚ vueä¸­ä¸éœ€è¦ç”¨data.titleæ¥å¼•ç”¨ï¼Œç›´æ¥ç”¨å³å¯ã€‚","text":"MVC &amp; MVVM MVC MVCæ˜¯åç«¯ä¸­çš„åˆ†å±‚æ¦‚å¿µã€‚M-Modelï¼ŒV-Viewï¼ŒC-Controllerã€‚ MVVM MVVCåªæ˜¯é’ˆå¯¹å‰ç«¯åˆ†å±‚ã€‚M-Modelï¼ŒV-Viewï¼ŒVM-View Modelã€‚å…¶ä¸­Må’ŒVè¦é€šè¿‡VMæ¥è¿›è¡Œæ•°æ®é“¾æ¥ã€‚ VueåŸºæœ¬ä»£ç  åˆ†ä¸¤å¤§éƒ¨åˆ†ã€‚htmlå’Œjsã€‚ htmléƒ¨åˆ† ...&lt;body&gt;//jsä¸­newçš„vueå®ä¾‹å°†ä¼šæ§åˆ¶è¯¥divä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚ &lt;div id='app'&gt; &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;p&gt; &lt;/div&gt;&lt;/body&gt;... jséƒ¨åˆ† // åˆ›å»ºæ–°çš„vueå®ä¾‹var vm = new Vue(&#123; el:'#app', // é€‰æ‹©æ§åˆ¶æŸä¸ªdiv data:&#123; title:'test'//å­˜æ”¾data &#125;, method:&#123; func1()&#123; // å®ç°å‡½æ•°å†…å®¹ &#125;, func2()&#123; //å®ç°å‡½æ•°å†…å®¹ &#125; &#125;&#125;) ä¸éš¾çœ‹å‡ºï¼Œhtmlä¸­çš„éƒ¨åˆ†æ˜¯V-viewï¼Œjsä¸­çš„éƒ¨åˆ†æ˜¯VM-ViewModelï¼Œè´Ÿè´£æ•°æ®é“¾æ¥ï¼Œå¦å¤–modeléƒ¨åˆ†ä¹Ÿåœ¨jsä¸­ï¼Œå…·ä½“æ˜¯dataä½“ç°äº†modelçš„åŠŸèƒ½ã€‚ vueä¸­ä¸éœ€è¦ç”¨data.titleæ¥å¼•ç”¨ï¼Œç›´æ¥ç”¨å³å¯ã€‚ v-cloak / v-text / v-html &lt;div id='app'&gt; &lt;p v-cloak&gt;aaa &#123;&#123; msg &#125;&#125; aaa&lt;/p&gt; &lt;h1 v-text=\"msg1\"&gt;aaa&lt;/h1&gt; &lt;h1 v-html=\"msg2\"&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg1:'test'ï¼Œ msg2:'&lt;h1&gt;This is h1 text&lt;/h1&gt;' &#125; &#125;)&lt;/script&gt; ä½¿ç”¨v-cloakèƒ½å¤Ÿè§£å†³æ’å€¼è¡¨è¾¾å¼åœ¨ç½‘é€Ÿä¸ç¨³å®šä¸‹æ–‡æœ¬çš„é—ªçƒé—®é¢˜ã€‚ v-textèƒ½å¤Ÿè¦†ç›–åŸæœ¬çš„æ–‡æœ¬ï¼Œè€Œv-cloakåªä¼šæ›¿ä»£æœ¬èº«çš„å å­—ç¬¦ã€‚ v-htmlå¯ä»¥è‡ªåŠ¨è¯†åˆ«htmlæ–‡æœ¬è¯­å¥å¹¶è½¬æˆhtmlæ¸²æŸ“ã€‚ v-bind å±æ€§ç»‘å®š &lt;div id='app'&gt; &lt;input type=\"button\" value=\"btn\" v-bind:title=\"title\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; title:'this is title' &#125; &#125;)&lt;/script&gt; v-bindä¼šå°†ç›®æ ‡targetç»‘å®šåˆ°è¯¥å…ƒç´ ä¸Šï¼Œå¦‚æœä¸ç”¨v-bindåˆ™ä¼šæ˜¾ç¤ºtitleå­—æ ·è€Œä¸æ˜¯dataä¸­è‡ªå®šä¹‰çš„titleå€¼ã€‚ å¦å¤–ç”±äºv-bind:æ˜¯jsè¯­æ³•ï¼Œæ‰€ä»¥åé¢å¯ä»¥è·Ÿè‡ªå®šä¹‰çš„lambdaï¼Œä¾‹å¦‚v-bind:title=â€œtitle + â€˜123â€™â€. v-bind:ä¹Ÿå¯ä»¥ç›´æ¥ç®€å†™ä¸º: v-on äº‹ä»¶ç»‘å®š &lt;div id='app'&gt; &lt;input type=\"button\" value=\"btn\" v-on:click=\"alert\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; title:'this is title' &#125;, methods:&#123; alert:function()&#123; alert('test') &#125; &#125; &#125;)&lt;/script&gt; v-onç”¨äºäº‹ä»¶ç»‘å®šã€‚åé¢ä¸€èˆ¬è·Ÿè‡ªå·±å®šä¹‰çš„å‡½æ•°ã€‚ç±»ä¼¼jsä¸­çš„onclick. å¯ä»¥ç®€å†™ä¸º@clickï¼Œ@mouseoverã€‚ã€‚ã€‚ jsä¸­å®šä¹‰methodsæ—¶ï¼Œæœ‰ä¸¤ç§å†™æ³•ï¼Œä¸€ç§æ˜¯functionï¼Œä¸€ç§æ˜¯å‡½æ•°åç›´æ¥è·Ÿ(). methods&#123; alert()&#123; alert('test'); &#125;, alert1:function()&#123; alert('test1'); &#125;&#125; demo1 : è·‘é©¬ç¯æ–‡å­—å¾ªç¯ &lt;body&gt; &lt;div id='app'&gt; &lt;input type='button' value='å¼€å§‹' @click=\"begin\"&gt; &lt;input type='button' value='åœæ­¢' @click=\"stop\"&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'æµ‹è¯•è·‘é©¬ç¯æ–‡å­—æµï¼æµ‹è¯•ï¼'ï¼Œ intervalId:null &#125;, methods: begin()&#123; if(intervalId != null)return; this.intervalId = setInterval( ()=&gt;&#123; // ä¿è¯èƒ½å¤Ÿè‡ªåŠ¨åˆ·æ–°åŠ å…¥interval var start = msg.substring(0,1); var end = msg.substring(1); this.msg = start + end;//é‡æ–°æ‹¼æ¥string &#125;,400); &#125;, stop()&#123; clearInterval(this.intervalId); intervalId = null; &#125; &#125; &#125;) æ¯æ¬¡æŠŠç¬¬ä¸€ä½charç§»åˆ°æœ€å ä¸ºäº†ä¿è¯è¿ç»­æ»šåŠ¨ï¼Œè®¾å®šinterval åˆ©ç”¨intervalIdæ¥ä¿è¯å¼€å§‹å’Œåœæ­¢æŒ‰é’®æ­£å¸¸å·¥ä½œã€‚åˆ©ç”¨intervalIdæ˜¯å¦ä¸ºnullæ¥åˆ¤æ–­ä¹‹å‰æ˜¯å¦ç§»åŠ¨è¿‡ã€‚","categories":[{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"Vue","slug":"å‰ç«¯æ¡†æ¶/Vue","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"Leetcode EveryDay 90 ğŸ’ª","slug":"chin-up-28","date":"2020-03-15T18:13:23.000Z","updated":"2020-03-16T01:03:27.806Z","comments":true,"path":"2020/03/15/chin-up-28/","link":"","permalink":"WangHngLeee.github.io/2020/03/15/chin-up-28/","excerpt":"","text":"567. Permutation in String ğŸ”—Question Link class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if(s1 == null || s2 == null)return false; int len1 = s1.length(); int len2 = s2.length(); if(len1 &gt; len2)return false; int[] arr = new int[26]; for(int i = 0 ; i&lt;len1 ;i++)&#123; arr[s1.charAt(i) - 'a']++; arr[s2.charAt(i) - 'a']--; &#125; if(allzero(arr))return true; for(int j = len1; j&lt;len2 ;j++)&#123; arr[s2.charAt(j)-'a']--; arr[s2.charAt(j-len1)-'a']++; if(allzero(arr))return true; &#125; return false; &#125; public boolean allzero(int[] arr)&#123; for(int i = 0 ; i &lt; 26;i++)&#123; if(arr[i]!=0)return false; &#125; return true; &#125;&#125; ç»å…¸26å¤§å°arræ–¹æ³•ã€‚æ£€æŸ¥å„ä¸ªå­—æ¯å‡ºç°çš„æ¬¡æ•°ã€‚ç»´æŠ¤ä¸€ä¸ªlen1å¤§å°çš„çª—å£","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"SilidingWindow","slug":"SilidingWindow","permalink":"WangHngLeee.github.io/tags/SilidingWindow/"}]},{"title":"Weekly Contest 180 ğŸ†","slug":"contest06","date":"2020-03-15T13:02:09.000Z","updated":"2020-03-16T00:11:01.441Z","comments":true,"path":"2020/03/15/contest06/","link":"","permalink":"WangHngLeee.github.io/2020/03/15/contest06/","excerpt":"ç”±äºæ¯”èµ›æ—¶é—´å»¶åæ²¡èµ¶ä¸Šï¼Œæ‰€ä»¥è¿™æ¬¡èµ›ååšçš„ï¼Œæœ¬æ¬¡ä¸‰é¢˜ã€‚ 1380. Lucky Numbers in a Matrix ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; minvalues = new HashSet&lt;&gt;(); for(int i = 0 ; i&lt;matrix.length ;i++)&#123; int min = matrix[i][0]; for(int j = 1 ; j&lt; matrix[0].length ;j++)&#123; if(matrix[i][j] &lt; min)&#123; min = matrix[i][j]; &#125; &#125; minvalues.add(min); &#125; for(int j=0 ; j&lt; matrix[0].length ;j++)&#123; int max = matrix[0][j]; for(int i =1 ; i&lt;matrix.length ;i++)&#123; if(matrix[i][j] &gt; max)&#123; max = matrix[i][j]; &#125; &#125; if(minvalues.contains(max))&#123; res.add(max); &#125; &#125; return res; &#125;&#125; å¾ˆç›´è§‚ã€‚è¡Œçš„minåŒæ—¶ä¹Ÿæ˜¯colçš„maxæ‰æ˜¯lucky numberã€‚ æ‰€ä»¥ä¸€ä¸ªsetå…ˆå­˜å‡ºç°è¿‡çš„minå€¼ï¼Œå†æ‰«æcolæ‰¾åˆ°æ‰€æœ‰çš„maxï¼Œå¦‚æœmaxåœ¨seté‡Œå‡ºç°è¿‡ï¼Œåˆ™åŠ å…¥resã€‚","text":"ç”±äºæ¯”èµ›æ—¶é—´å»¶åæ²¡èµ¶ä¸Šï¼Œæ‰€ä»¥è¿™æ¬¡èµ›ååšçš„ï¼Œæœ¬æ¬¡ä¸‰é¢˜ã€‚ 1380. Lucky Numbers in a Matrix ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; minvalues = new HashSet&lt;&gt;(); for(int i = 0 ; i&lt;matrix.length ;i++)&#123; int min = matrix[i][0]; for(int j = 1 ; j&lt; matrix[0].length ;j++)&#123; if(matrix[i][j] &lt; min)&#123; min = matrix[i][j]; &#125; &#125; minvalues.add(min); &#125; for(int j=0 ; j&lt; matrix[0].length ;j++)&#123; int max = matrix[0][j]; for(int i =1 ; i&lt;matrix.length ;i++)&#123; if(matrix[i][j] &gt; max)&#123; max = matrix[i][j]; &#125; &#125; if(minvalues.contains(max))&#123; res.add(max); &#125; &#125; return res; &#125;&#125; å¾ˆç›´è§‚ã€‚è¡Œçš„minåŒæ—¶ä¹Ÿæ˜¯colçš„maxæ‰æ˜¯lucky numberã€‚ æ‰€ä»¥ä¸€ä¸ªsetå…ˆå­˜å‡ºç°è¿‡çš„minå€¼ï¼Œå†æ‰«æcolæ‰¾åˆ°æ‰€æœ‰çš„maxï¼Œå¦‚æœmaxåœ¨seté‡Œå‡ºç°è¿‡ï¼Œåˆ™åŠ å…¥resã€‚ 1381. Design a Stack With Increment Operation ğŸ”—Question Link First Soluiton class CustomStack &#123; Stack&lt;Integer&gt; stack; int max; public CustomStack(int maxSize) &#123; stack = new Stack&lt;&gt;(); max = maxSize; &#125; public void push(int x) &#123; if(stack.size() &lt; max)&#123; stack.push(x); &#125; &#125; public int pop() &#123; return stack.size() == 0 ? -1 : stack.pop(); &#125; public void increment(int k, int val) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); while(!stack.isEmpty()) temp.push(stack.pop()); while(k!=0 &amp;&amp; !temp.isEmpty()) &#123; int cur = temp.pop() + val; stack.push(cur); k--; &#125; while(!temp.isEmpty()) stack.push(temp.pop()); &#125;&#125; Simply using extra stack to reverse the original stack, and to add some operations on it. Optimized Soluiton class CustomStack &#123; List&lt;Integer&gt; arr; int size; public CustomStack(int maxSize) &#123; arr = new ArrayList&lt;&gt;(); size = maxSize; &#125; public void push(int x) &#123; if(arr.size() &lt; size)&#123; arr.add(x); &#125; &#125; public int pop() &#123; return arr.size() == 0 ? -1 : arr.remove(arr.size()-1); &#125; public void increment(int k, int val) &#123; for(int i = 0; i &lt; k &amp;&amp; i&lt;arr.size() ; i++)&#123; arr.set(i,arr.get(i)+val); &#125; &#125;&#125; Using extra arr to simulate a stack. Pay attention to the â€˜removeâ€™, it can remove the specified index num and return itâ€™s value. 1382. Balance a Binary Search Tree ğŸ”—Question Link class Solution &#123; List&lt;Integer&gt; sortedarr = new ArrayList&lt;&gt;(); public TreeNode balanceBST(TreeNode root) &#123; inorder(root); return buildtree(0,sortedarr.size()-1); &#125; public void inorder(TreeNode root)&#123; if(root == null)return; inorder(root.left); sortedarr.add(root.val); inorder(root.right); &#125; public TreeNode buildtree(int start, int end)&#123; if(start &gt; end)return null; int mid = start + ( end - start)/2; TreeNode root = new TreeNode(sortedarr.get(mid)); root.left = buildtree(start,mid-1); root.right = buildtree(mid+1,end); return root; &#125;&#125; Classic template : inorder traverse + preorder buildtree.","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 89 ğŸ’ª","slug":"chin-up-27","date":"2020-03-12T15:13:23.000Z","updated":"2020-05-16T22:28:46.645Z","comments":true,"path":"2020/03/12/chin-up-27/","link":"","permalink":"WangHngLeee.github.io/2020/03/12/chin-up-27/","excerpt":"734. Sentence Similarity Ä‘ÂŸÂ”Â—Question Link class Solution &#123; public boolean areSentencesSimilar(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123; map.putIfAbsent(str.get(0),new HashSet&lt;&gt;()); map.putIfAbsent(str.get(1),new HashSet&lt;&gt;()); map.get(str.get(0)).add(str.get(1)); map.get(str.get(1)).add(str.get(0)); &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; if(words1[i].equals(words2[i]))continue; if(!map.containsKey(words1[i]))return false; if(!map.get(words1[i]).contains(words2[i]))return false; &#125; return true; &#125;&#125; Using map to store the key-value of each string in the pairs. Then we loop the word1 and words2, only when two stirng is equal or map contains each other then we can continue to loop. Other wise we return fasle.","text":"734. Sentence Similarity Ä‘ÂŸÂ”Â—Question Link class Solution &#123; public boolean areSentencesSimilar(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123; map.putIfAbsent(str.get(0),new HashSet&lt;&gt;()); map.putIfAbsent(str.get(1),new HashSet&lt;&gt;()); map.get(str.get(0)).add(str.get(1)); map.get(str.get(1)).add(str.get(0)); &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; if(words1[i].equals(words2[i]))continue; if(!map.containsKey(words1[i]))return false; if(!map.get(words1[i]).contains(words2[i]))return false; &#125; return true; &#125;&#125; Using map to store the key-value of each string in the pairs. Then we loop the word1 and words2, only when two stirng is equal or map contains each other then we can continue to loop. Other wise we return fasle. 737. Sentence Similarity II Ä‘ÂŸÂ”Â—Question Link class Solution &#123; public boolean areSentencesSimilarTwo(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; // corner case Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123;// initialize union find hashmap String parent1 = find(map,str.get(0)); String parent2 = find(map,str.get(1)); if(!parent1.equals(parent2))map.put(parent1,parent2); // &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; // return false if two string are not equal and both of them are not from the same root string if(!words1[i].equals(words2[i]) &amp;&amp; !find(map,words1[i]).equals(find(map,words2[i])))return false; &#125; return true; &#125; public String find(Map&lt;String,String&gt; map, String s)&#123; if(!map.containsKey(s))map.put(s,s); return s.equals(map.get(s)) ? s : find(map,map.get(s)); &#125;&#125; Using Union-Find. Using map to create unionfind graph. First we initialize each string with the root of itself. Then we update the root with parent2 if they are not the same. Then loop the word1, if we meet two string are not equal and are not from the same root string , we return false. Otherwise we continue until we return true in the final. 277. Find the Celebrity Ä‘ÂŸÂ”Â—Question Link /* The knows API is defined in the parent class Relation. boolean knows(int a, int b); */public class Solution extends Relation &#123; public int findCelebrity(int n) &#123; int person = 0 ; for(int i = 0 ; i&lt; n;i++)&#123; if(knows(person,i))&#123; person = i; &#125; &#125; for(int i = 0 ;i&lt;n ;i++)&#123; if(i != person &amp;&amp; (!knows(i,person) || knows(person,i)))return -1; &#125; return person; &#125;&#125; we first loop the perosn and change the candidate if the first know the second one. Because we have to make sure that candidate know nobody. Then we for loop again, only when the person is not candidate and he donâ€™t know the candidate or the candidate know the person, we return -1. Other wise we just return the candidate that we found. 139. Word Break Ä‘ÂŸÂ”Â—Question Link class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] dp = new boolean[s.length()+1]; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String str : wordDict)&#123; set.add(str); &#125; dp[0] = true; for(int i = 1 ; i &lt;= s.length(); i++)&#123; for(int j = 0 ; j&lt;i ;j++)&#123; if(dp[j] &amp;&amp; set.contains(s.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; dpÄ‡Â›Â´Ä‡Â–Â°0-ÄºËÂ“ÄºÂ‰ÂindexÄ‡Â‰Â€Ä‡ÂœÂ‰substringÄ‡Â˜Å»ÄºÂÅšÄºÂ‡ÅŸÃ§ÂÂ°ÄÅ¼Â‡ÄƒÂ€Â‚ 399. Evaluate Division Ä‘ÂŸÂ”Â—Question Link class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; eq, double[] vals, List&lt;List&lt;String&gt;&gt; q) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; vals.length; i++) &#123; m.putIfAbsent(eq.get(i).get(0), new HashMap&lt;&gt;()); m.putIfAbsent(eq.get(i).get(1), new HashMap&lt;&gt;()); m.get(eq.get(i).get(0)).put(eq.get(i).get(1), vals[i]); m.get(eq.get(i).get(1)).put(eq.get(i).get(0), 1 / vals[i]); &#125; double[] r = new double[q.size()]; for (int i = 0; i &lt; q.size(); i++) r[i] = dfs(q.get(i).get(0), q.get(i).get(1), 1, m, new HashSet&lt;&gt;()); return r; &#125; double dfs(String s, String t, double r, Map&lt;String, Map&lt;String, Double&gt;&gt; m, Set&lt;String&gt; seen) &#123; if (!m.containsKey(s) || !seen.add(s)) return -1; if (s.equals(t)) return r; Map&lt;String, Double&gt; next = m.get(s); for (String c : next.keySet()) &#123; double result = dfs(c, t, r * next.get(c), m, seen); if (result != -1) return result; &#125; return -1; &#125;&#125; Ã§ÂÂ°Ä‡ÂŠÂŠÄ‡Å»ÂÃ¤Â¸ÅÄºÂ­Â—Ä‡Å»ÂÄºÅ»Å¡ÄºÅŸÂ”Ã§ÂšÂ„ÄºÂ…Å‚Ã§Å‚Å¥ÄºÂ­Â˜ÄÅ¼Â›mÄƒÂ€Â‚ÄºÂ†ÂDFSÄ‡Â‰Å¾queryÃ©Â‡ÂŒÃ§Â›Â¸ÄºÅ»Å¡ÄºÅŸÂ”Ã§ÂšÂ„Ã¤Â¸Â¤Ã¤Â¸ÅÃ¤Å¡Â‹Ã©Â—Â´Ã§ÂšÂ„ÄºÂ€ÅºÄƒÂ€Â‚ 990. Satisfiability of Equality Equations Ä‘ÂŸÂ”Â—Question Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26;i++)&#123; UF[i] = i;//initialize UF array. &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a');// link the two == chars &#125; &#125; for(String str : equations)&#123; if(str.charAt(1) == '!')&#123; //check whether two chars in != case have the same root if(UF[find(str.charAt(0)-'a')] == find(str.charAt(3)-'a'))return false; &#125; &#125; return true; &#125; public int find(int a)&#123; // create find function. if(a != UF[a])UF[a] = find(UF[a]); return UF[a]; &#125;&#125; UnionFindÄƒÂ€Â‚Create a UF graph to store the first and second char in equations. In â€˜==â€™ case, we update the UF of first char. In â€˜!=â€™ case, if we find that the two char has the same root, then return false.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 88 ğŸ’ª","slug":"chin-up-26","date":"2020-03-10T15:13:23.000Z","updated":"2020-03-13T23:02:39.026Z","comments":true,"path":"2020/03/10/chin-up-26/","link":"","permalink":"WangHngLeee.github.io/2020/03/10/chin-up-26/","excerpt":"304. Range Sum Query 2D - Immutable ğŸ”—Question Link class NumMatrix &#123; int[][] dp; public NumMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return; int m = matrix.length; int n = matrix[0].length; dp = new int[m+1][n+1]; for(int i= 1; i&lt;=m;i++)&#123; for(int j = 1 ;j&lt;=n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int iMin = Math.min(row1, row2); int iMax = Math.max(row1, row2); int jMin = Math.min(col1, col2); int jMax = Math.max(col1, col2); return dp[iMax + 1][jMax + 1] - dp[iMax + 1][jMin] - dp[iMin][jMax + 1] + dp[iMin][jMin]; &#125;&#125; dpå­˜å½“å‰ä½ç½®æ„æˆçš„æ–¹å½¢å†…æ‰€æœ‰çš„å’Œï¼Œåœ¨è®¡ç®—æ—¶ç”±äºdp[i-1][j-1]åŠ äº†ä¸¤æ¬¡ï¼Œè¦å‡å»ä¸€æ¬¡ï¼Œç„¶ååŠ ä¸Šå½“å‰çš„å€¼matrix[i][j]ã€‚ åœ¨è®¡ç®—sumçš„æ—¶å€™ï¼Œæœ€å³ä¸‹ä½ç½®çš„å’Œå‡å»æœ€å°è¡Œã€æœ€å°åˆ—å¯¹åº”çš„å’Œå€¼ï¼Œç”±äºå·¦ä¸Šçš„å€¼è¢«å‡äº†ä¸¤æ¬¡ï¼Œè¦åŠ å›æ¥ä¸€æ¬¡ã€‚","text":"304. Range Sum Query 2D - Immutable ğŸ”—Question Link class NumMatrix &#123; int[][] dp; public NumMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return; int m = matrix.length; int n = matrix[0].length; dp = new int[m+1][n+1]; for(int i= 1; i&lt;=m;i++)&#123; for(int j = 1 ;j&lt;=n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int iMin = Math.min(row1, row2); int iMax = Math.max(row1, row2); int jMin = Math.min(col1, col2); int jMax = Math.max(col1, col2); return dp[iMax + 1][jMax + 1] - dp[iMax + 1][jMin] - dp[iMin][jMax + 1] + dp[iMin][jMin]; &#125;&#125; dpå­˜å½“å‰ä½ç½®æ„æˆçš„æ–¹å½¢å†…æ‰€æœ‰çš„å’Œï¼Œåœ¨è®¡ç®—æ—¶ç”±äºdp[i-1][j-1]åŠ äº†ä¸¤æ¬¡ï¼Œè¦å‡å»ä¸€æ¬¡ï¼Œç„¶ååŠ ä¸Šå½“å‰çš„å€¼matrix[i][j]ã€‚ åœ¨è®¡ç®—sumçš„æ—¶å€™ï¼Œæœ€å³ä¸‹ä½ç½®çš„å’Œå‡å»æœ€å°è¡Œã€æœ€å°åˆ—å¯¹åº”çš„å’Œå€¼ï¼Œç”±äºå·¦ä¸Šçš„å€¼è¢«å‡äº†ä¸¤æ¬¡ï¼Œè¦åŠ å›æ¥ä¸€æ¬¡ã€‚ 221. Maximal Square ğŸ”—Question Link class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m+1][n+1]; int max = 0; for(int i = 1;i&lt;=m;i++)&#123; for(int j = 1; j&lt;=n;j++)&#123; if(matrix[i-1][j-1] == '1')&#123; dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j]))+1; max = Math.max(max,dp[i][j]); &#125; &#125; &#125; return max*max; &#125;&#125; dp[i][j]è¡¨ç¤ºä½äºå³ä¸‹è§’(i, j)çš„æ­£æ–¹å½¢çš„è¾¹é•¿é•¿åº¦ã€‚ å¦‚æœæ­¤å•å…ƒæ ¼çš„å€¼ä¹Ÿæ˜¯1ï¼Œåˆ™æ­£æ–¹å½¢æœ€å°é•¿åº¦å…¶ä¸Šæ–¹çš„å€¼ï¼Œå·¦ä¾§å’Œå¯¹è§’çº¿å·¦ä¸Šå€¼ä¸­çš„æœ€å°å€¼+1ã€‚å› ä¸ºå¦‚æœä¸€ä¾§çŸ­æˆ–ç¼ºå¤±ï¼Œåˆ™ä¸ä¼šå½¢æˆæ­£æ–¹å½¢ã€‚ 1277. Count Square Submatrices with All One ğŸ”—Question Link class Solution &#123; public int countSquares(int[][] matrix) &#123; int res = 0; int m = matrix.length; int n = matrix[0].length; for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0; j&lt;n ;j++)&#123; if(matrix[i][j] == 1)&#123; if(i&gt;0 &amp;&amp; j &gt;0)&#123; matrix[i][j] = Math.min(matrix[i-1][j-1], Math.min(matrix[i][j-1],matrix[i-1][j]))+1; &#125; res+=matrix[i][j]; &#125;else&#123; continue; &#125; &#125; &#125; return res; &#125;&#125; matrixä¿å­˜æ¯ä¸ªä½ç½®èƒ½å¤Ÿç»„æˆæ­£æ–¹å½¢çš„æœ€å°è¾¹é•¿ï¼Œå…¶å®æŠŠæ‰€æœ‰æƒ…å†µçš„æœ€å°è¾¹é•¿åŠ èµ·æ¥å°±æ˜¯æ­£æ–¹å½¢çš„ä¸ªæ•°ã€‚ 309. Best Time to Buy and Sell Stock with Cooldown ğŸ”—Question Link class Solution &#123; public int maxProfit(int[] prices) &#123; int sell = 0; int prevsell = 0; int buy = Integer.MIN_VALUE; int prevbuy; for(int price : prices)&#123; prevbuy = buy; buy = Math.max(prevsell - price, prevbuy); prevsell = sell; sell = Math.max(prevbuy + price, prevsell); &#125; return sell; &#125;&#125; buyâ€“ç›®å‰ä¹°å®Œä¹‹åæœ€å¤§å‰©ä½™å€¼ï¼Œsellâ€“ç›®å‰å–å®Œæœ€å¤§å‰©ä½™å€¼ï¼Œprevbuyâ€“ä¸Šæ¬¡æ“ä½œä¹‹åå‰©ä½™å€¼ï¼Œprevsellâ€“ä¸Šæ¬¡æ“ä½œä¹‹åå‰©ä½™å€¼ã€‚ æ›´æ–°buyï¼Œè¦æ±‚æœ€å¤§å‰©ä½™å€¼ï¼Œæ‰€ä»¥è¦å’Œprevsell-priceæ¯”è¾ƒã€‚æ›´æ–°sellï¼Œè¦æ±‚æœ€å¤§å–å‡ºå€¼ï¼Œæ‰€ä»¥ prevbuy + priceæ¯”è¾ƒã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Weekly Contest 179 ğŸ†","slug":"contest05","date":"2020-03-08T04:02:09.000Z","updated":"2020-03-09T01:31:22.991Z","comments":true,"path":"2020/03/07/contest05/","link":"","permalink":"WangHngLeee.github.io/2020/03/07/contest05/","excerpt":"æœ¬æ¬¡ä¸‰é¢˜ã€‚ 1374. Generate a String With Characters That Have Odd Counts ğŸ”—Question Link class Solution &#123; public String generateTheString(int n) &#123; if(n == 0 )return \"\"; StringBuilder sb = new StringBuilder(); if(n%2==0)&#123; int k = n-1; for(int i = 0 ; i &lt; k ;i++)&#123; sb.append(\"a\"); &#125; sb.append(\"b\"); return sb.toString(); &#125;else&#123; for(int i = 0 ; i&lt;n ;i++)&#123; sb.append(\"a\"); &#125; return sb.toString(); &#125; &#125;&#125; å°±æ˜¯åˆ¤æ–­nçš„å¥‡å¶æ€§ï¼Œå¦‚æœå¥‡æ•°å…¨éƒ¨åŠ aï¼Œå¦‚æœå¶æ•°åˆ™åœ¨æœ€åä¸€ä½åŠ bå°±è¡Œäº†ã€‚é¢˜ç›®æè¿°ä¸æ¸…ã€‚","text":"æœ¬æ¬¡ä¸‰é¢˜ã€‚ 1374. Generate a String With Characters That Have Odd Counts ğŸ”—Question Link class Solution &#123; public String generateTheString(int n) &#123; if(n == 0 )return \"\"; StringBuilder sb = new StringBuilder(); if(n%2==0)&#123; int k = n-1; for(int i = 0 ; i &lt; k ;i++)&#123; sb.append(\"a\"); &#125; sb.append(\"b\"); return sb.toString(); &#125;else&#123; for(int i = 0 ; i&lt;n ;i++)&#123; sb.append(\"a\"); &#125; return sb.toString(); &#125; &#125;&#125; å°±æ˜¯åˆ¤æ–­nçš„å¥‡å¶æ€§ï¼Œå¦‚æœå¥‡æ•°å…¨éƒ¨åŠ aï¼Œå¦‚æœå¶æ•°åˆ™åœ¨æœ€åä¸€ä½åŠ bå°±è¡Œäº†ã€‚é¢˜ç›®æè¿°ä¸æ¸…ã€‚ 1375. Bulb Switcher III ğŸ”—Question Link class Solution &#123; public int numTimesAllBlue(int[] light) &#123; int right = 0; int len = light.length; int res = 0; for(int i = 0 ; i &lt; len; i++)&#123; right = Math.max(right,light[i]); if(right == i+1)res++; &#125; return res; &#125;&#125; ç»´æŠ¤æœ€å³çš„ç¯æ³¡ç¼–å·ï¼Œå¦‚æœå½“å‰index+1ç­‰äºæœ€å³çš„ç¯æ³¡ç¼–å·ï¼Œåˆ™è¯´æ˜å·¦è¾¹å…¨éƒ¨ç‚¹äº®ï¼Œres++ã€‚å› ä¸ºindexåæ˜ äº†ç‚¹äº®äº†å¤šå°‘ç¯æ³¡ï¼Œè€Œç¯æ³¡ä¸å¯èƒ½é‡å¤ï¼Œæ‰€ä»¥åœ¨æœ€å³ç¼–å·ä¸å˜çš„æƒ…å†µä¸‹ï¼Œå¦‚æœindex+1ç­‰äºæœ€å³ç¼–å·(ç¼–å·ä»1å¼€å§‹æ‰€ä»¥è¦+1)ï¼Œè¯´æ˜å·¦è¾¹å…¨éƒ¨ç‚¹è¿‡ï¼Œres++ã€‚ 1376. Time Needed to Inform All Employees ğŸ”—Question Link class Solution &#123; public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) &#123; Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int i = 0 ; i&lt;manager.length ;i++)&#123; if(manager[i]!=-1)&#123; if(!map.containsKey(manager[i]))&#123; map.put(manager[i],new ArrayList&lt;&gt;()); &#125; map.get(manager[i]).add(i); &#125; &#125; int max = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(headID); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i&lt;size ; i++)&#123; int temp = queue.poll(); if(manager[temp]!=-1)&#123; // é¿å¼€headçš„ä½ç½®ï¼Œä»ä¸æ˜¯headçš„timeå¼€å§‹ç´¯åŠ ã€‚ informTime[temp]+=informTime[manager[temp]]; &#125; max = Math.max(max,informTime[temp]); if(map.get(temp)!=null)&#123; for(int num : map.get(temp))&#123; queue.add(num); &#125; &#125; &#125; &#125; return max; &#125;&#125; ç›´æ¥è£¸BFSã€‚æ›´æ–°informTimeçš„å€¼ï¼Œä½¿å…¶æˆä¸ºç´¯è®¡å’Œã€‚æœ€åè¿”å›å…¶ä¸­çš„maxã€‚","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 87 ğŸ’ª","slug":"chin-up-25","date":"2020-03-06T16:13:23.000Z","updated":"2020-03-13T20:43:12.937Z","comments":true,"path":"2020/03/06/chin-up-25/","link":"","permalink":"WangHngLeee.github.io/2020/03/06/chin-up-25/","excerpt":"992. Subarrays with K Different Integers ğŸ”—Question Link class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return help(A,K) - help(A,K-1); &#125; public int help(int[] A, int K)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; int ans = 0; for(int j = 0 ; j &lt; A.length ;j++)&#123; if (map.getOrDefault(A[j], 0) == 0) K--; map.put(A[j],map.getOrDefault(A[j],0)+1); while(K&lt;0)&#123; map.put(A[i],map.get(A[i])-1); if(map.get(A[i]) == 0)K++; i++; &#125; ans += j-i+1; &#125; return ans; &#125;&#125; æ­£å¥½æœ‰Kä¸ª = æœ€å¤šKä¸ªçš„æƒ…å†µå‡å»æœ€å¤šK-1çš„æƒ…å†µã€‚","text":"992. Subarrays with K Different Integers ğŸ”—Question Link class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return help(A,K) - help(A,K-1); &#125; public int help(int[] A, int K)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; int ans = 0; for(int j = 0 ; j &lt; A.length ;j++)&#123; if (map.getOrDefault(A[j], 0) == 0) K--; map.put(A[j],map.getOrDefault(A[j],0)+1); while(K&lt;0)&#123; map.put(A[i],map.get(A[i])-1); if(map.get(A[i]) == 0)K++; i++; &#125; ans += j-i+1; &#125; return ans; &#125;&#125; æ­£å¥½æœ‰Kä¸ª = æœ€å¤šKä¸ªçš„æƒ…å†µå‡å»æœ€å¤šK-1çš„æƒ…å†µã€‚ 15. 3Sum ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; nums.length ;i++)&#123; if(i == 0 || i&gt;0 &amp;&amp; nums[i] != nums[i-1])&#123; int low = i+1; int high = nums.length -1; int target = 0 - nums[i]; while(low &lt; high)&#123; if(nums[low] + nums[high] == target)&#123; res.add(Arrays.asList(nums[low],nums[high],nums[i])); while(low &lt; high &amp;&amp; nums[low]==nums[low + 1])low++; while(low &lt; high &amp;&amp; nums[high ] == nums[high-1])high--; low++; high--; &#125;else if(nums[low] + nums[high] &lt; target)&#123; while(low &lt; high &amp;&amp; nums[low] == nums[low]+1)low++; low++; &#125;else&#123; while(low &lt; high &amp;&amp; nums[high] == nums[high-1])high--; high--; &#125; &#125; &#125; &#125; return res; &#125;&#125; ç¬¬å››éã€‚two pointersåŸºæœ¬æ€è·¯ã€‚æ³¨æ„åˆ¤æ–­æœ‰é‡å¤æ•°å­—çš„æƒ…å†µã€‚ 167. Two Sum II - Input array is sorted ğŸ”—Question Link class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int[] res = new int[2]; if(numbers == null || numbers.length&lt;2)return res; int left = 0; int right = numbers.length-1; while(left &lt;= right)&#123; int temp = numbers[left] + numbers[right]; if(temp == target)&#123; res[0] = left+1; res[1] = right+1; return res; &#125; if(temp&lt;target)&#123; left++; &#125;else&#123; right--; &#125; &#125; return res; &#125;&#125; two pointersã€‚æ³¨æ„æœ€åè¿”å›indexè¦+1. 16. 3Sum Closest ğŸ”—Question Link class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int sum = nums[0] + nums[1] + nums[nums.length-1]; int closetsum = sum; for(int i = 0 ; i &lt;nums.length-2 ; i++)&#123; if(i == 0 || i&gt;0 &amp;&amp; nums[i] != nums[i-1])&#123; int left = i+1; int right = nums.length -1; while(left&lt;right)&#123; sum = nums[i] + nums[left] + nums[right]; if(sum &lt; target)&#123; while(left &lt; right &amp;&amp; nums[left] == nums[left+1])left++; left++; &#125;else if(sum &gt; target)&#123; while(left &lt; right &amp;&amp; nums[right] == nums[right-1])right--; right--; &#125;else&#123; return sum; &#125; if(Math.abs(target - closetsum) &gt; Math.abs(target-sum))&#123; closetsum = sum; &#125; &#125; &#125; &#125; return closetsum; &#125;&#125; 3 sumå˜ç§ã€‚åªéœ€è¦å¤šç»´æŠ¤ä¸€ä¸ªä¸´æ—¶çš„sumå€¼ï¼Œå’Œclosetsumæ¯”è¾ƒæ›´æ–°å°±å¯ä»¥äº†ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"}]},{"title":"Leetcode EveryDay 86 ğŸ’ª","slug":"chin-up-24","date":"2020-03-05T16:13:23.000Z","updated":"2020-03-13T23:02:39.027Z","comments":true,"path":"2020/03/05/chin-up-24/","link":"","permalink":"WangHngLeee.github.io/2020/03/05/chin-up-24/","excerpt":"4. Median of Two Sorted Arrays ğŸ”—Question Link class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] arr = new int[m+n]; for(int i = 0 ;i&lt;m ;i++)&#123; arr[i] = nums1[i]; &#125; for(int j = 0 ;j&lt;n;j++)&#123; arr[m+j] = nums2[j]; &#125; Arrays.sort(arr); int k = arr.length; if(k%2 != 0)return (double)arr[k/2]; else return ((double)(arr[(k/2) - 1] + arr[(k/2)])/2); &#125;&#125; two array åŠ åˆ°ä¸€èµ·sortã€‚","text":"4. Median of Two Sorted Arrays ğŸ”—Question Link class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] arr = new int[m+n]; for(int i = 0 ;i&lt;m ;i++)&#123; arr[i] = nums1[i]; &#125; for(int j = 0 ;j&lt;n;j++)&#123; arr[m+j] = nums2[j]; &#125; Arrays.sort(arr); int k = arr.length; if(k%2 != 0)return (double)arr[k/2]; else return ((double)(arr[(k/2) - 1] + arr[(k/2)])/2); &#125;&#125; two array åŠ åˆ°ä¸€èµ·sortã€‚ 378. Kth Smallest Element in a Sorted Matrix ğŸ”—Question Link class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a); for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0;j&lt;n ;j++)&#123; pq.add(matrix[i][j]); if(pq.size() &gt; k)pq.poll(); &#125; &#125; return pq.poll(); &#125;&#125; ç»å…¸kthé—®é¢˜ã€‚ç»´æŠ¤å¤§å°ä¸ºkçš„max/min heapå³å¯ã€‚ 668. Kth Smallest Number in Multiplication Table ğŸ”—Question Link class Solution &#123; public int findKthNumber(int m, int n, int k) &#123; int lo=1, hi=m*n; while(lo&lt;hi)&#123; int mid= (lo+hi)/2, cnt=0; for (int i=1,j=n; i&lt;=m; i++)&#123; while(j&gt;=1 &amp;&amp; i*j&gt;mid) j--; cnt+=j; &#125; if (cnt&gt;=k) hi=mid; else lo=mid+1; &#125; return lo; &#125;&#125; binary searchæŠŠnumåˆ†æˆä¸¤éƒ¨åˆ†æ¥æ‰¾ã€‚ 917. Reverse Only Letters ğŸ”—Question Link class Solution &#123; public String reverseOnlyLetters(String S) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); if(S == null || S.length() == 0)return \"\"; for(int i = 0 ; i&lt;S.length() ;i++)&#123; if(Character.isLetter(S.charAt(i)))&#123; stack.push(S.charAt(i)); &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; S.length() ;i++)&#123; if(!Character.isLetter(S.charAt(i)))&#123; sb.append(S.charAt(i)); &#125;else&#123; sb.append(stack.pop()); &#125; &#125; return sb.toString(); &#125;&#125; stacké€†åºè¾“å‡ºã€‚æ³¨æ„æ ‡ç‚¹ç¬¦å·ä¸åªæœ‰â€˜-â€™ã€‚ 925. Long Pressed Name ğŸ”—Question Link class Solution &#123; public boolean isLongPressedName(String name, String typed) &#123; int m = name.length(); int n = typed.length(); int i = 0 ; for(int j = 0 ; j &lt; n ; j++)&#123; if(i&lt;m &amp;&amp; name.charAt(i) == typed.charAt(j))&#123; i++; &#125;else if(j == 0 || typed.charAt(j) != typed.charAt(j-1))&#123; return false; &#125; &#125; return i == m; &#125;&#125; two pointer.åªéœ€è¦å¯¹typedè‡ªèº«æ£€æŸ¥æœ‰æ— ç›¸åŒé‡å¤å³å¯ã€‚å¦‚æœä¸¤ä¸ªä½ç½®å…ƒç´ ç›¸åŒï¼Œåˆ™name çš„index++ï¼Œå¦‚æœä¸åŒå¹¶ä¸”typedçš„å‰ä¸€ä¸ªå’Œè¯¥å…ƒç´ ä¸ä¸€æ ·ï¼Œåˆ™ç›´æ¥è¿”å›falseã€‚ abc-aabc-true abc-adbc-false 986. Interval List Intersections ğŸ”—Question Link class Solution &#123; public int[][] intervalIntersection(int[][] A, int[][] B) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int a = 0; int b = 0; while(a&lt;A.length &amp; b&lt;B.length)&#123; int start = Math.max(A[a][0],B[b][0]); int end = Math.min(A[a][1],B[b][1]); if(start &lt;= end)&#123; res.add(new int[]&#123;start,end&#125;); &#125; if(A[a][1] &gt; B[b][1])b++; else a++; &#125; int[][] ans = new int[res.size()][2]; int i = 0; for(int[] num : res)&#123; ans[i] = num; i++; &#125; return ans; &#125;&#125; intervalçš„é¢˜ã€‚startå–æœ€å¤§ï¼Œendå–æœ€å°ï¼Œå¦‚æœstart&lt;end è¯´æ˜æœ‰æœ‰äº¤é›†ï¼ŒåŠ å…¥resã€‚å¦‚æœæ²¡æœ‰ï¼ŒAçš„ç»“å°¾æ¯”Bçš„å¤§ï¼Œåˆ™bå¾€åéå†ä¸€ä¸ªï¼Œç›¸åï¼ŒAå¾€åå¾ªç¯ä¸€ä¸ªã€‚ 855. Exam Room ğŸ”—Question Link class ExamRoom &#123; int n; List&lt;Integer&gt; L; public ExamRoom(int N) &#123; L = new ArrayList&lt;&gt;(); n = N; &#125; public int seat() &#123; if (L.size() == 0) &#123; L.add(0); return 0; // empty we set seat at 0; &#125; int d = Math.max(L.get(0), n - 1 - L.get(L.size() - 1)); for (int i = 0; i &lt; L.size() - 1; ++i) d = Math.max(d, (L.get(i + 1) - L.get(i)) / 2); if (L.get(0) == d) &#123;//d == 0 we also set seat at 0 L.add(0, 0); return 0; &#125; for (int i = 0; i &lt; L.size() - 1; ++i)//try to find the minimum index that match d. if ((L.get(i + 1) - L.get(i)) / 2 == d) &#123; L.add(i + 1, (L.get(i + 1) + L.get(i)) / 2); return L.get(i + 1); &#125; L.add(n- 1); // no match we add at last position return n - 1; &#125; public void leave(int p) &#123; // find the p and remove it for (int i = 0; i &lt; L.size(); ++i) if (L.get(i) == p) L.remove(i); &#125;&#125; æœ‰æ„æ€çš„designé¢˜ã€‚ç”¨listå­˜seatçš„ä½ç½®ï¼Œç„¶åæ¯æ¬¡éå†æ‰¾æœ€å¤§çš„distï¼Œç„¶åå†é‡å¤´å¼€å§‹æ‰¾æœ€å°èƒ½å¤ŸåŒ¹é…distçš„indexï¼ŒæŠŠseatæ’å…¥è¯¥indexã€‚ å¦åˆ™ç›´æ¥å®‰æ’åœ¨æœ€åé¢ã€‚leaveçš„æ—¶å€™åªéœ€è¦remove pæ‰€åœ¨çš„list indexå³å¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"}]},{"title":"Front-end Interview Note 3 ğŸ’ª","slug":"frontend-interview-js","date":"2020-03-05T13:05:35.000Z","updated":"2020-05-19T15:45:40.502Z","comments":true,"path":"2020/03/05/frontend-interview-js/","link":"","permalink":"WangHngLeee.github.io/2020/03/05/frontend-interview-js/","excerpt":"JS é—­åŒ… é—­åŒ…å°±æ˜¯èƒ½å¤Ÿè¯»å–å…¶ä»–å‡½æ•°å†…éƒ¨å˜é‡çš„å‡½æ•°ï¼Œæˆ–è€…å­å‡½æ•°åœ¨å¤–è°ƒç”¨ï¼Œå­å‡½æ•°æ‰€åœ¨çš„çˆ¶å‡½æ•°çš„ä½œç”¨åŸŸä¸ä¼šè¢«é‡Šæ”¾ã€‚ åº”ç”¨åœºæ™¯ï¼Ÿå‡½æ•°é˜²æŠ–ï¼Œä½¿ç”¨é—­åŒ…è®¾è®¡å•ä¾‹æ¨¡å¼ï¼Œä¸ºå¤šä¸ªç»„ä»¶ç‹¬ç«‹å±æ€§ï¼Œè®¾ç½®ç§æœ‰å˜é‡ï¼Œå–åˆ°æ­£ç¡®å€¼ã€‚ ç±»çš„åˆ›å»ºå’Œç»§æ‰¿ åˆ›å»ºï¼šnewä¸€ä¸ªfunctionï¼Œåœ¨è¿™ä¸ªfunctionçš„prototypeé‡Œé¢å¢åŠ å±æ€§å’Œæ–¹æ³•ã€‚ 1ã€åŸå‹é“¾ç»§æ‰¿ï¼Œå°†çˆ¶ç±»çš„å®ä¾‹ä½œä¸ºå­ç±»çš„åŸå‹ï¼Œä»–çš„ç‰¹ç‚¹æ˜¯å®ä¾‹æ˜¯å­ç±»çš„å®ä¾‹ä¹Ÿæ˜¯çˆ¶ç±»çš„å®ä¾‹ï¼Œçˆ¶ç±»æ–°å¢çš„åŸå‹æ–¹æ³•/å±æ€§ï¼Œå­ç±»éƒ½èƒ½å¤Ÿè®¿é—®ï¼Œå¹¶ä¸”åŸå‹é“¾ç»§æ‰¿ç®€å•æ˜“äºå®ç°ï¼Œç¼ºç‚¹æ˜¯æ¥è‡ªåŸå‹å¯¹è±¡çš„æ‰€æœ‰å±æ€§è¢«æ‰€æœ‰å®ä¾‹å…±äº«ï¼Œæ— æ³•å®ç°å¤šç»§æ‰¿ï¼Œæ— æ³•å‘çˆ¶ç±»æ„é€ å‡½æ•°ä¼ å‚ã€‚ 2ã€æ„é€ ç»§æ‰¿ï¼Œä½¿ç”¨çˆ¶ç±»çš„æ„é€ å‡½æ•°æ¥å¢å¼ºå­ç±»å®ä¾‹ï¼Œå³å¤åˆ¶çˆ¶ç±»çš„å®ä¾‹å±æ€§ç»™å­ç±»ï¼Œ æ„é€ ç»§æ‰¿å¯ä»¥å‘çˆ¶ç±»ä¼ é€’å‚æ•°ï¼Œå¯ä»¥å®ç°å¤šç»§æ‰¿ï¼Œé€šè¿‡callå¤šä¸ªçˆ¶ç±»å¯¹è±¡ã€‚ä½†æ˜¯æ„é€ ç»§æ‰¿åªèƒ½ç»§æ‰¿çˆ¶ç±»çš„å®ä¾‹å±æ€§å’Œæ–¹æ³•ï¼Œä¸èƒ½ç»§æ‰¿åŸå‹å±æ€§å’Œæ–¹æ³•ï¼Œæ— æ³•å®ç°å‡½æ•°æœç”¨ï¼Œæ¯ä¸ªå­ç±»éƒ½æœ‰çˆ¶ç±»å®ä¾‹å‡½æ•°çš„å‰¯æœ¬ï¼Œå½±å“æ€§èƒ½ 3ã€å®ä¾‹ç»§æ‰¿ï¼Œä¸ºçˆ¶ç±»å®ä¾‹æ·»åŠ æ–°ç‰¹æ€§ï¼Œä½œä¸ºå­ç±»å®ä¾‹è¿”å›ï¼Œå®ä¾‹ç»§æ‰¿çš„ç‰¹ç‚¹æ˜¯ä¸é™åˆ¶è°ƒç”¨æ–¹æ³•ï¼Œä¸ç®¡æ˜¯new å­ç±»ï¼ˆï¼‰è¿˜æ˜¯å­ç±»ï¼ˆï¼‰è¿”å›çš„å¯¹è±¡å…·æœ‰ç›¸åŒçš„æ•ˆæœï¼Œç¼ºç‚¹æ˜¯å®ä¾‹æ˜¯çˆ¶ç±»çš„å®ä¾‹ï¼Œä¸æ˜¯å­ç±»çš„å®ä¾‹ï¼Œä¸æ”¯æŒå¤šç»§æ‰¿ 4ã€æ‹·è´ç»§æ‰¿ï¼šç‰¹ç‚¹ï¼šæ”¯æŒå¤šç»§æ‰¿ï¼Œç¼ºç‚¹ï¼šæ•ˆç‡è¾ƒä½ï¼Œå†…å­˜å ç”¨é«˜ï¼ˆå› ä¸ºè¦æ‹·è´çˆ¶ç±»çš„å±æ€§ï¼‰æ— æ³•è·å–çˆ¶ç±»ä¸å¯æšä¸¾çš„æ–¹æ³•ï¼ˆä¸å¯æšä¸¾æ–¹æ³•ï¼Œä¸èƒ½ä½¿ç”¨for in è®¿é—®åˆ°ï¼‰ 5ã€ç»„åˆç»§æ‰¿ï¼šé€šè¿‡è°ƒç”¨çˆ¶ç±»æ„é€ ï¼Œç»§æ‰¿çˆ¶ç±»çš„å±æ€§å¹¶ä¿ç•™ä¼ å‚çš„ä¼˜ç‚¹ï¼Œç„¶åé€šè¿‡å°†çˆ¶ç±»å®ä¾‹ä½œä¸ºå­ç±»åŸå‹ï¼Œå®ç°å‡½æ•°å¤ç”¨ 6ã€å¯„ç”Ÿç»„åˆç»§æ‰¿ï¼šé€šè¿‡å¯„ç”Ÿæ–¹å¼ï¼Œç æ‰çˆ¶ç±»çš„å®ä¾‹å±æ€§ï¼Œè¿™æ ·ï¼Œåœ¨è°ƒç”¨ä¸¤æ¬¡çˆ¶ç±»çš„æ„é€ çš„æ—¶å€™ï¼Œå°±ä¸ä¼šåˆå§‹åŒ–ä¸¤æ¬¡å®ä¾‹æ–¹æ³•/å±æ€§ï¼Œé¿å…çš„ç»„åˆç»§æ‰¿çš„ç¼ºç‚¹ Javascript çš„ä½œç”¨åŸŸé“¾ï¼Ÿ ä½œç”¨åŸŸé“¾çš„ä½œç”¨æ˜¯ä¿è¯å¯¹æ‰§è¡Œç¯å¢ƒæœ‰æƒè®¿é—®çš„æ‰€æœ‰å˜é‡å’Œå‡½æ•°çš„æœ‰åºè®¿é—®ï¼Œé€šè¿‡ä½œç”¨åŸŸé“¾ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®åˆ°å¤–å±‚ç¯å¢ƒçš„å˜é‡å’Œ å‡½æ•°ã€‚ä½œç”¨åŸŸé“¾çš„æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæŒ‡å‘å˜é‡å¯¹è±¡çš„æŒ‡é’ˆåˆ—è¡¨ã€‚å˜é‡å¯¹è±¡æ˜¯ä¸€ä¸ªåŒ…å«äº†æ‰§è¡Œç¯å¢ƒä¸­æ‰€æœ‰å˜é‡å’Œå‡½æ•°çš„å¯¹è±¡ã€‚ä½œç”¨åŸŸé“¾çš„å‰ ç«¯å§‹ç»ˆéƒ½æ˜¯å½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡çš„å˜é‡å¯¹è±¡ã€‚å…¨å±€æ‰§è¡Œä¸Šä¸‹æ–‡çš„å˜é‡å¯¹è±¡ï¼ˆä¹Ÿå°±æ˜¯å…¨å±€å¯¹è±¡ï¼‰å§‹ç»ˆæ˜¯ä½œç”¨åŸŸé“¾çš„æœ€åä¸€ä¸ªå¯¹è±¡ã€‚ å½“æˆ‘ä»¬æŸ¥æ‰¾ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¦‚æœå½“å‰æ‰§è¡Œç¯å¢ƒä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥æ²¿ç€ä½œç”¨åŸŸé“¾å‘åæŸ¥æ‰¾ã€‚","text":"JS é—­åŒ… é—­åŒ…å°±æ˜¯èƒ½å¤Ÿè¯»å–å…¶ä»–å‡½æ•°å†…éƒ¨å˜é‡çš„å‡½æ•°ï¼Œæˆ–è€…å­å‡½æ•°åœ¨å¤–è°ƒç”¨ï¼Œå­å‡½æ•°æ‰€åœ¨çš„çˆ¶å‡½æ•°çš„ä½œç”¨åŸŸä¸ä¼šè¢«é‡Šæ”¾ã€‚ åº”ç”¨åœºæ™¯ï¼Ÿå‡½æ•°é˜²æŠ–ï¼Œä½¿ç”¨é—­åŒ…è®¾è®¡å•ä¾‹æ¨¡å¼ï¼Œä¸ºå¤šä¸ªç»„ä»¶ç‹¬ç«‹å±æ€§ï¼Œè®¾ç½®ç§æœ‰å˜é‡ï¼Œå–åˆ°æ­£ç¡®å€¼ã€‚ ç±»çš„åˆ›å»ºå’Œç»§æ‰¿ åˆ›å»ºï¼šnewä¸€ä¸ªfunctionï¼Œåœ¨è¿™ä¸ªfunctionçš„prototypeé‡Œé¢å¢åŠ å±æ€§å’Œæ–¹æ³•ã€‚ 1ã€åŸå‹é“¾ç»§æ‰¿ï¼Œå°†çˆ¶ç±»çš„å®ä¾‹ä½œä¸ºå­ç±»çš„åŸå‹ï¼Œä»–çš„ç‰¹ç‚¹æ˜¯å®ä¾‹æ˜¯å­ç±»çš„å®ä¾‹ä¹Ÿæ˜¯çˆ¶ç±»çš„å®ä¾‹ï¼Œçˆ¶ç±»æ–°å¢çš„åŸå‹æ–¹æ³•/å±æ€§ï¼Œå­ç±»éƒ½èƒ½å¤Ÿè®¿é—®ï¼Œå¹¶ä¸”åŸå‹é“¾ç»§æ‰¿ç®€å•æ˜“äºå®ç°ï¼Œç¼ºç‚¹æ˜¯æ¥è‡ªåŸå‹å¯¹è±¡çš„æ‰€æœ‰å±æ€§è¢«æ‰€æœ‰å®ä¾‹å…±äº«ï¼Œæ— æ³•å®ç°å¤šç»§æ‰¿ï¼Œæ— æ³•å‘çˆ¶ç±»æ„é€ å‡½æ•°ä¼ å‚ã€‚ 2ã€æ„é€ ç»§æ‰¿ï¼Œä½¿ç”¨çˆ¶ç±»çš„æ„é€ å‡½æ•°æ¥å¢å¼ºå­ç±»å®ä¾‹ï¼Œå³å¤åˆ¶çˆ¶ç±»çš„å®ä¾‹å±æ€§ç»™å­ç±»ï¼Œ æ„é€ ç»§æ‰¿å¯ä»¥å‘çˆ¶ç±»ä¼ é€’å‚æ•°ï¼Œå¯ä»¥å®ç°å¤šç»§æ‰¿ï¼Œé€šè¿‡callå¤šä¸ªçˆ¶ç±»å¯¹è±¡ã€‚ä½†æ˜¯æ„é€ ç»§æ‰¿åªèƒ½ç»§æ‰¿çˆ¶ç±»çš„å®ä¾‹å±æ€§å’Œæ–¹æ³•ï¼Œä¸èƒ½ç»§æ‰¿åŸå‹å±æ€§å’Œæ–¹æ³•ï¼Œæ— æ³•å®ç°å‡½æ•°æœç”¨ï¼Œæ¯ä¸ªå­ç±»éƒ½æœ‰çˆ¶ç±»å®ä¾‹å‡½æ•°çš„å‰¯æœ¬ï¼Œå½±å“æ€§èƒ½ 3ã€å®ä¾‹ç»§æ‰¿ï¼Œä¸ºçˆ¶ç±»å®ä¾‹æ·»åŠ æ–°ç‰¹æ€§ï¼Œä½œä¸ºå­ç±»å®ä¾‹è¿”å›ï¼Œå®ä¾‹ç»§æ‰¿çš„ç‰¹ç‚¹æ˜¯ä¸é™åˆ¶è°ƒç”¨æ–¹æ³•ï¼Œä¸ç®¡æ˜¯new å­ç±»ï¼ˆï¼‰è¿˜æ˜¯å­ç±»ï¼ˆï¼‰è¿”å›çš„å¯¹è±¡å…·æœ‰ç›¸åŒçš„æ•ˆæœï¼Œç¼ºç‚¹æ˜¯å®ä¾‹æ˜¯çˆ¶ç±»çš„å®ä¾‹ï¼Œä¸æ˜¯å­ç±»çš„å®ä¾‹ï¼Œä¸æ”¯æŒå¤šç»§æ‰¿ 4ã€æ‹·è´ç»§æ‰¿ï¼šç‰¹ç‚¹ï¼šæ”¯æŒå¤šç»§æ‰¿ï¼Œç¼ºç‚¹ï¼šæ•ˆç‡è¾ƒä½ï¼Œå†…å­˜å ç”¨é«˜ï¼ˆå› ä¸ºè¦æ‹·è´çˆ¶ç±»çš„å±æ€§ï¼‰æ— æ³•è·å–çˆ¶ç±»ä¸å¯æšä¸¾çš„æ–¹æ³•ï¼ˆä¸å¯æšä¸¾æ–¹æ³•ï¼Œä¸èƒ½ä½¿ç”¨for in è®¿é—®åˆ°ï¼‰ 5ã€ç»„åˆç»§æ‰¿ï¼šé€šè¿‡è°ƒç”¨çˆ¶ç±»æ„é€ ï¼Œç»§æ‰¿çˆ¶ç±»çš„å±æ€§å¹¶ä¿ç•™ä¼ å‚çš„ä¼˜ç‚¹ï¼Œç„¶åé€šè¿‡å°†çˆ¶ç±»å®ä¾‹ä½œä¸ºå­ç±»åŸå‹ï¼Œå®ç°å‡½æ•°å¤ç”¨ 6ã€å¯„ç”Ÿç»„åˆç»§æ‰¿ï¼šé€šè¿‡å¯„ç”Ÿæ–¹å¼ï¼Œç æ‰çˆ¶ç±»çš„å®ä¾‹å±æ€§ï¼Œè¿™æ ·ï¼Œåœ¨è°ƒç”¨ä¸¤æ¬¡çˆ¶ç±»çš„æ„é€ çš„æ—¶å€™ï¼Œå°±ä¸ä¼šåˆå§‹åŒ–ä¸¤æ¬¡å®ä¾‹æ–¹æ³•/å±æ€§ï¼Œé¿å…çš„ç»„åˆç»§æ‰¿çš„ç¼ºç‚¹ Javascript çš„ä½œç”¨åŸŸé“¾ï¼Ÿ ä½œç”¨åŸŸé“¾çš„ä½œç”¨æ˜¯ä¿è¯å¯¹æ‰§è¡Œç¯å¢ƒæœ‰æƒè®¿é—®çš„æ‰€æœ‰å˜é‡å’Œå‡½æ•°çš„æœ‰åºè®¿é—®ï¼Œé€šè¿‡ä½œç”¨åŸŸé“¾ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®åˆ°å¤–å±‚ç¯å¢ƒçš„å˜é‡å’Œ å‡½æ•°ã€‚ä½œç”¨åŸŸé“¾çš„æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªæŒ‡å‘å˜é‡å¯¹è±¡çš„æŒ‡é’ˆåˆ—è¡¨ã€‚å˜é‡å¯¹è±¡æ˜¯ä¸€ä¸ªåŒ…å«äº†æ‰§è¡Œç¯å¢ƒä¸­æ‰€æœ‰å˜é‡å’Œå‡½æ•°çš„å¯¹è±¡ã€‚ä½œç”¨åŸŸé“¾çš„å‰ ç«¯å§‹ç»ˆéƒ½æ˜¯å½“å‰æ‰§è¡Œä¸Šä¸‹æ–‡çš„å˜é‡å¯¹è±¡ã€‚å…¨å±€æ‰§è¡Œä¸Šä¸‹æ–‡çš„å˜é‡å¯¹è±¡ï¼ˆä¹Ÿå°±æ˜¯å…¨å±€å¯¹è±¡ï¼‰å§‹ç»ˆæ˜¯ä½œç”¨åŸŸé“¾çš„æœ€åä¸€ä¸ªå¯¹è±¡ã€‚ å½“æˆ‘ä»¬æŸ¥æ‰¾ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¦‚æœå½“å‰æ‰§è¡Œç¯å¢ƒä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œæˆ‘ä»¬å¯ä»¥æ²¿ç€ä½œç”¨åŸŸé“¾å‘åæŸ¥æ‰¾ã€‚ äº‹ä»¶æµå’Œäº‹ä»¶æ¨¡å‹ äº‹ä»¶æ˜¯ç”¨æˆ·æ“ä½œç½‘é¡µæ—¶å‘ç”Ÿçš„äº¤äº’åŠ¨ä½œæˆ–è€…ç½‘é¡µæœ¬èº«çš„ä¸€äº›æ“ä½œï¼Œç°ä»£æµè§ˆå™¨ä¸€å…±æœ‰ä¸‰ç§äº‹ä»¶æ¨¡å‹ã€‚ 1.DOM0 çº§æ¨¡å‹ï¼Œè¿™ç§æ¨¡å‹ä¸ä¼šä¼ æ’­ï¼Œæ‰€ä»¥æ²¡æœ‰äº‹ä»¶æµçš„æ¦‚å¿µï¼Œä½†æ˜¯ç°åœ¨æœ‰çš„æµè§ˆå™¨æ”¯æŒä»¥å†’æ³¡çš„æ–¹å¼å® ç°ï¼Œå®ƒå¯ä»¥åœ¨ç½‘é¡µä¸­ç›´æ¥å®šä¹‰ç›‘å¬å‡½æ•°ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ js å±æ€§æ¥æŒ‡å®šç›‘å¬å‡½æ•°ã€‚è¿™ç§æ–¹å¼æ˜¯æ‰€æœ‰æµè§ˆå™¨éƒ½å…¼å®¹çš„ã€‚ 2.IE äº‹ä»¶æ¨¡å‹ï¼Œåœ¨è¯¥äº‹ä»¶æ¨¡å‹ä¸­ï¼Œä¸€æ¬¡äº‹ä»¶å…±æœ‰ä¸¤ä¸ªè¿‡ç¨‹ï¼Œäº‹ä»¶å¤„ç†é˜¶æ®µï¼Œå’Œäº‹ä»¶å†’æ³¡é˜¶æ®µã€‚äº‹ä»¶å¤„ç†é˜¶æ®µä¼š é¦–å…ˆæ‰§è¡Œç›®æ ‡å…ƒç´ ç»‘å®šçš„ç›‘å¬äº‹ä»¶ã€‚ç„¶åæ˜¯äº‹ä»¶å†’æ³¡é˜¶æ®µï¼Œå†’æ³¡æŒ‡çš„æ˜¯äº‹ä»¶ä»ç›®æ ‡å…ƒç´ å†’æ³¡åˆ° documentï¼Œä¾æ¬¡æ£€æŸ¥ç»è¿‡çš„èŠ‚ç‚¹ æ˜¯å¦ç»‘å®šäº†äº‹ä»¶ç›‘å¬å‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™æ‰§è¡Œã€‚è¿™ç§æ¨¡å‹é€šè¿‡ attachEvent æ¥æ·»åŠ ç›‘å¬å‡½æ•°ï¼Œå¯ä»¥æ·»åŠ å¤šä¸ªç›‘å¬å‡½æ•°ï¼Œä¼šæŒ‰é¡ºåºä¾ æ¬¡æ‰§è¡Œã€‚ 3.DOM2 çº§äº‹ä»¶æ¨¡å‹ï¼Œåœ¨è¯¥äº‹ä»¶æ¨¡å‹ä¸­ï¼Œä¸€æ¬¡äº‹ä»¶å…±æœ‰ä¸‰ä¸ªè¿‡ç¨‹ï¼Œäº‹ä»¶æ•è·é˜¶æ®µã€‚æ•è·æŒ‡çš„æ˜¯äº‹ä»¶ä» docu ment ä¸€ç›´å‘ä¸‹ä¼ æ’­åˆ°ç›®æ ‡å…ƒç´ ï¼Œä¾æ¬¡æ£€æŸ¥ç»è¿‡çš„èŠ‚ç‚¹æ˜¯å¦ç»‘å®šäº†äº‹ä»¶ç›‘å¬å‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™æ‰§è¡Œã€‚åé¢ä¸¤ä¸ªé˜¶æ®µå’Œ IE äº‹ä»¶æ¨¡å‹ çš„ä¸¤ä¸ªé˜¶æ®µç›¸åŒã€‚è¿™ç§äº‹ä»¶æ¨¡å‹ï¼Œäº‹ä»¶ç»‘å®šçš„å‡½æ•°æ˜¯ addEventListenerï¼Œå…¶ä¸­ç¬¬ä¸‰ä¸ªå‚æ•°å¯ä»¥æŒ‡å®šäº‹ä»¶æ˜¯å¦åœ¨æ•è·é˜¶æ®µæ‰§è¡Œã€‚ äº‹ä»¶æµï¼šäº‹ä»¶æµæè¿°çš„æ˜¯ä»é¡µé¢ä¸­æ¥æ”¶äº‹ä»¶çš„é¡ºåº,DOM2çº§äº‹ä»¶æµåŒ…æ‹¬ä¸‹é¢å‡ ä¸ªé˜¶æ®µã€‚äº‹ä»¶æ•è·é˜¶æ®µï¼Œå¤„äºç›®æ ‡é˜¶æ®µï¼Œäº‹ä»¶å†’æ³¡é˜¶æ®µ å¦‚ä½•è®©äº‹ä»¶å…ˆå†’æ³¡åæ•è· åœ¨DOMæ ‡å‡†äº‹ä»¶æ¨¡å‹ä¸­ï¼Œæ˜¯å…ˆæ•è·åå†’æ³¡ã€‚ä½†æ˜¯å¦‚æœè¦å®ç°å…ˆå†’æ³¡åæ•è·çš„æ•ˆæœï¼Œå¯¹äºåŒä¸€ä¸ªäº‹ä»¶ï¼Œç›‘å¬æ•è·å’Œå†’æ³¡ï¼Œåˆ†åˆ«å¯¹åº”ç›¸åº”çš„å¤„ç†å‡½æ•°ï¼Œç›‘å¬åˆ°æ•è·äº‹ä»¶ï¼Œå…ˆæš‚ç¼“æ‰§è¡Œï¼Œç›´åˆ°å†’æ³¡äº‹ä»¶è¢«æ•è·åå†æ‰§è¡Œæ•è·ä¹‹é—´ã€‚ æ ¹æ®w3cæ ‡å‡†ï¼Œåº”å…ˆæ•è·å†å†’æ³¡ã€‚è‹¥è¦å®ç°å…ˆå†’æ³¡åæ•è·ï¼Œç»™ä¸€ä¸ªå…ƒç´ ç»‘å®šä¸¤ä¸ªaddEventListenerï¼Œå…¶ä¸­ä¸€ä¸ªç¬¬ä¸‰ä¸ªå‚æ•°è®¾ç½®ä¸ºfalseï¼ˆå³å†’æ³¡ï¼‰ï¼Œå¦ä¸€ä¸ªç¬¬ä¸‰ä¸ªå‚æ•°è®¾ç½®ä¸ºtrueï¼ˆå³æ•è·ï¼‰ï¼Œè°ƒæ•´å®ƒä»¬çš„ä»£ç é¡ºåºï¼Œå°†è®¾ç½®ä¸ºfalseçš„ç›‘å¬äº‹ä»¶æ”¾åœ¨è®¾ç½®ä¸ºtrueçš„ç›‘å¬äº‹ä»¶å‰é¢å³å¯ã€‚ äº‹ä»¶å§”æ‰˜ä¸å†’æ³¡åŸç† äº‹ä»¶å§”æ‰˜æŒ‡çš„æ˜¯ï¼Œä¸åœ¨äº‹ä»¶çš„å‘ç”Ÿåœ°ï¼ˆç›´æ¥domï¼‰ä¸Šè®¾ç½®ç›‘å¬å‡½æ•°ï¼Œè€Œæ˜¯åœ¨å…¶çˆ¶å…ƒç´ ä¸Šè®¾ç½®ç›‘å¬å‡½æ•°ï¼Œé€šè¿‡äº‹ä»¶å†’æ³¡ï¼Œçˆ¶å…ƒç´ å¯ä»¥ç›‘å¬åˆ°å­å…ƒç´ ä¸Šäº‹ä»¶çš„è§¦å‘ï¼Œé€šè¿‡åˆ¤æ–­äº‹ä»¶å‘ç”Ÿå…ƒç´ DOMçš„ç±»å‹ï¼Œæ¥åšå‡ºä¸åŒçš„å“åº”ã€‚ äº‹ä»¶å†’æ³¡ï¼Œå°±æ˜¯å…ƒç´ è‡ªèº«çš„äº‹ä»¶è¢«è§¦å‘åï¼Œå¦‚æœçˆ¶å…ƒç´ æœ‰ç›¸åŒçš„äº‹ä»¶ï¼Œå¦‚onclickäº‹ä»¶ï¼Œé‚£ä¹ˆå…ƒç´ æœ¬èº«çš„è§¦å‘çŠ¶æ€å°±ä¼šä¼ é€’ï¼Œä¹Ÿå°±æ˜¯å†’åˆ°çˆ¶å…ƒç´ ï¼Œçˆ¶å…ƒç´ çš„ç›¸åŒäº‹ä»¶ä¹Ÿä¼šä¸€çº§ä¸€çº§æ ¹æ®åµŒå¥—å…³ç³»å‘å¤–è§¦å‘ï¼Œç›´åˆ°document/windowï¼Œå†’æ³¡è¿‡ç¨‹ç»“æŸã€‚ ä¸¾ä¾‹ï¼šæœ€ç»å…¸çš„å°±æ˜¯ulå’Œliæ ‡ç­¾çš„äº‹ä»¶ç›‘å¬ï¼Œæ¯”å¦‚æˆ‘ä»¬åœ¨æ·»åŠ äº‹ä»¶æ—¶å€™ï¼Œé‡‡ç”¨äº‹ä»¶å§”æ‰˜æœºåˆ¶ï¼Œä¸ä¼šåœ¨liæ ‡ç­¾ä¸Šç›´æ¥æ·»åŠ ï¼Œè€Œæ˜¯åœ¨ulçˆ¶å…ƒç´ ä¸Šæ·»åŠ ã€‚å¥½å¤„ï¼šæ¯”è¾ƒåˆé€‚åŠ¨æ€å…ƒç´ çš„ç»‘å®šï¼Œæ–°æ·»åŠ çš„å­å…ƒç´ ä¹Ÿä¼šæœ‰ç›‘å¬å‡½æ•°ï¼Œä¹Ÿå¯ä»¥æœ‰äº‹ä»¶è§¦å‘æœºåˆ¶ã€‚ å¦‚ä½•é˜»æ­¢å†’æ³¡ï¼Ÿ w3cçš„æ–¹æ³•æ˜¯e.stopPropagation()ï¼ŒIEåˆ™æ˜¯ä½¿ç”¨e.cancelBubble = true æ·±æ‹·è´ æµ…æ‹·è´ æµ…æ‹·è´æŒ‡çš„æ˜¯å°†ä¸€ä¸ªå¯¹è±¡çš„å±æ€§å€¼å¤åˆ¶åˆ°å¦ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚æœæœ‰çš„å±æ€§çš„å€¼ä¸ºå¼•ç”¨ç±»å‹çš„è¯ï¼Œé‚£ä¹ˆä¼šå°†è¿™ä¸ªå¼•ç”¨çš„åœ°å€å¤åˆ¶ç»™å¯¹è±¡ï¼Œå› æ­¤ ä¸¤ä¸ªå¯¹è±¡ä¼šæœ‰åŒä¸€ä¸ªå¼•ç”¨ç±»å‹çš„å¼•ç”¨ã€‚æµ…æ‹·è´å¯ä»¥ä½¿ç”¨ Object.assign å’Œå±•å¼€è¿ç®—ç¬¦æ¥å®ç°ã€‚ æ·±æ‹·è´ç›¸å¯¹æµ…æ‹·è´è€Œè¨€ï¼Œå¦‚æœé‡åˆ°å±æ€§å€¼ä¸ºå¼•ç”¨ç±»å‹çš„æ—¶å€™ï¼Œå®ƒæ–°å»ºä¸€ä¸ªå¼•ç”¨ç±»å‹å¹¶å°†å¯¹åº”çš„å€¼å¤åˆ¶ç»™å®ƒï¼Œå› æ­¤å¯¹è±¡è·å¾—çš„ä¸€ä¸ªæ–°çš„å¼• ç”¨ç±»å‹è€Œä¸æ˜¯ä¸€ä¸ªåŸæœ‰ç±»å‹çš„å¼•ç”¨ã€‚æ·±æ‹·è´å¯¹äºä¸€äº›å¯¹è±¡å¯ä»¥ä½¿ç”¨ JSON çš„ä¸¤ä¸ªå‡½æ•°æ¥å®ç°ï¼Œä½†æ˜¯ç”±äº JSON çš„å¯¹è±¡æ ¼å¼æ¯” js çš„å¯¹ è±¡æ ¼å¼æ›´åŠ ä¸¥æ ¼ï¼Œæ‰€ä»¥å¦‚æœå±æ€§å€¼é‡Œè¾¹å‡ºç°å‡½æ•°æˆ–è€… Symbol ç±»å‹çš„å€¼æ—¶ï¼Œä¼šè½¬æ¢å¤±è´¥ã€‚ æ‡’åŠ è½½å’Œé¢„åŠ è½½ é¢„åŠ è½½ï¼šæå‰åŠ è½½å›¾ç‰‡ï¼Œå½“ç”¨æˆ·éœ€è¦æŸ¥çœ‹æ—¶å¯ç›´æ¥ä»æœ¬åœ°ç¼“å­˜ä¸­æ¸²æŸ“ã€‚ æ‡’åŠ è½½ï¼šæ‡’åŠ è½½çš„ä¸»è¦ç›®çš„æ˜¯ä½œä¸ºæœåŠ¡å™¨å‰ç«¯çš„ä¼˜åŒ–ï¼Œå‡å°‘è¯·æ±‚æ•°æˆ–å»¶è¿Ÿè¯·æ±‚æ•°ã€‚ ä¸¤ç§æŠ€æœ¯çš„æœ¬è´¨ï¼šä¸¤è€…çš„è¡Œä¸ºæ˜¯ç›¸åçš„ï¼Œä¸€ä¸ªæ˜¯æå‰åŠ è½½ï¼Œä¸€ä¸ªæ˜¯è¿Ÿç¼“ç”šè‡³ä¸åŠ è½½ã€‚ æ‡’åŠ è½½å¯¹æœåŠ¡å™¨å‰ç«¯æœ‰ä¸€å®šçš„ç¼“è§£å‹åŠ›ä½œç”¨ï¼Œé¢„åŠ è½½åˆ™ä¼šå¢åŠ æœåŠ¡å™¨å‰ç«¯å‹åŠ›ã€‚ æ”¹å˜å‡½æ•°å†…éƒ¨thisæŒ‡é’ˆçš„æŒ‡å‘å‡½æ•°ï¼ˆbindï¼Œapplyï¼Œcallçš„åŒºåˆ«ï¼‰ Callï¼Œapplyå®ƒä»¬çš„å…±åŒç‚¹æ˜¯ï¼Œéƒ½èƒ½å¤Ÿæ”¹å˜å‡½æ•°æ‰§è¡Œæ—¶çš„ä¸Šä¸‹æ–‡ï¼Œå°†ä¸€ä¸ªå¯¹è±¡çš„æ–¹æ³•äº¤ç»™å¦ä¸€ä¸ªå¯¹è±¡æ¥æ‰§è¡Œï¼Œå¹¶ä¸”æ˜¯ç«‹å³æ‰§è¡Œçš„ã€‚ bind æ–¹æ³• ä¸ apply å’Œ call æ¯”è¾ƒç±»ä¼¼ï¼Œä¹Ÿèƒ½æ”¹å˜å‡½æ•°ä½“å†…çš„ this æŒ‡å‘ã€‚ä¸åŒçš„æ˜¯ï¼Œbind æ–¹æ³•çš„è¿”å›å€¼æ˜¯å‡½æ•°ï¼Œå¹¶ä¸”éœ€è¦ç¨åè°ƒç”¨ï¼Œæ‰ä¼šæ‰§è¡Œã€‚è€Œ apply å’Œ call åˆ™æ˜¯ç«‹å³è°ƒç”¨ JSèŠ‚æµä¸é˜²æŠ– å‡½æ•°èŠ‚æµ: æŒ‡å®šæ—¶é—´é—´éš”å†…åªä¼šæ‰§è¡Œä¸€æ¬¡ä»»åŠ¡ï¼› å‡½æ•°é˜²æŠ–: ä»»åŠ¡é¢‘ç¹è§¦å‘çš„æƒ…å†µä¸‹ï¼Œåªæœ‰ä»»åŠ¡è§¦å‘çš„é—´éš”è¶…è¿‡æŒ‡å®šé—´éš”çš„æ—¶å€™ï¼Œä»»åŠ¡æ‰ä¼šæ‰§è¡Œã€‚ iframe &amp;&amp; iframeçš„ç¼ºç‚¹ å®šä¹‰ï¼šiframeå…ƒç´ ä¼šåˆ›å»ºåŒ…å«å¦ä¸€ä¸ªæ–‡æ¡£çš„å†…è”æ¡†æ¶ æç¤ºï¼šå¯ä»¥å°†æç¤ºæ–‡å­—æ”¾åœ¨ä¹‹é—´ï¼Œæ¥æç¤ºæŸäº›ä¸æ”¯æŒiframeçš„æµè§ˆå™¨ ç¼ºç‚¹ï¼šiframe ä¼šé˜»å¡ä¸»é¡µé¢çš„ onload äº‹ä»¶ã€‚window çš„ onload äº‹ä»¶éœ€è¦åœ¨æ‰€æœ‰ iframe åŠ è½½å®Œæ¯•åï¼ˆåŒ…å«é‡Œé¢çš„å…ƒç´ ï¼‰æ‰ ä¼šè§¦å‘ã€‚åœ¨ Safari å’Œ Chrome é‡Œï¼Œé€šè¿‡ JavaScript åŠ¨æ€è®¾ç½® iframe çš„ src å¯ä»¥é¿å…è¿™ç§é˜»å¡æƒ…å†µã€‚ ï¼ˆ2ï¼‰ æœç´¢å¼•æ“çš„æ£€ç´¢ç¨‹åºæ— æ³•è§£è¯»è¿™ç§é¡µé¢ï¼Œä¸åˆ©äºç½‘é¡µçš„ SEO ã€‚ ï¼ˆ3ï¼‰ iframe å’Œä¸»é¡µé¢å…±äº«è¿æ¥æ± ï¼Œè€Œæµè§ˆå™¨å¯¹ç›¸åŒåŸŸçš„è¿æ¥æœ‰é™åˆ¶ï¼Œæ‰€ä»¥ä¼šå½±å“é¡µé¢çš„å¹¶è¡ŒåŠ è½½ã€‚ ï¼ˆ4ï¼‰ æµè§ˆå™¨çš„åé€€æŒ‰é’®å¤±æ•ˆã€‚ ï¼ˆ5ï¼‰ å°å‹çš„ç§»åŠ¨è®¾å¤‡æ— æ³•å®Œå…¨æ˜¾ç¤ºæ¡†æ¶ã€‚ JSä¸­çš„åƒåœ¾å›æ”¶æœºåˆ¶ åƒåœ¾å›æ”¶æœ‰ä¸¤ç§å®ç°æ–¹å¼ï¼Œåˆ†åˆ«æ˜¯æ ‡è®°æ¸…é™¤å’Œå¼•ç”¨è®¡æ•° æ ‡è®°æ¸…é™¤ï¼šå½“å˜é‡è¿›å…¥æ‰§è¡Œç¯å¢ƒæ—¶æ ‡è®°ä¸ºâ€œè¿›å…¥ç¯å¢ƒâ€ï¼Œå½“å˜é‡ç¦»å¼€æ‰§è¡Œç¯å¢ƒæ—¶åˆ™æ ‡è®°ä¸ºâ€œç¦»å¼€ç¯å¢ƒâ€ï¼Œè¢«æ ‡è®°ä¸ºâ€œè¿›å…¥ç¯å¢ƒâ€çš„å˜é‡æ˜¯ä¸èƒ½è¢«å›æ”¶çš„ï¼Œå› ä¸ºå®ƒä»¬æ­£åœ¨è¢«ä½¿ç”¨ï¼Œè€Œæ ‡è®°ä¸ºâ€œç¦»å¼€ç¯å¢ƒâ€çš„å˜é‡åˆ™å¯ä»¥è¢«å›æ”¶ã€‚ å¼•ç”¨è®¡æ•°ï¼šç»Ÿè®¡å¼•ç”¨ç±»å‹å˜é‡å£°æ˜åè¢«å¼•ç”¨çš„æ¬¡æ•°ï¼Œå½“æ¬¡æ•°ä¸º 0 æ—¶ï¼Œè¯¥å˜é‡å°†è¢«å›æ”¶ã€‚ common.js Commonjsï¼šå¼€å§‹äºæœåŠ¡å™¨ç«¯çš„æ¨¡å—åŒ–ï¼ŒåŒæ­¥å®šä¹‰çš„æ¨¡å—åŒ–ï¼Œæ¯ä¸ªæ¨¡å—éƒ½æ˜¯ä¸€ä¸ªå•ç‹¬çš„ä½œç”¨åŸŸï¼Œæ¨¡å—è¾“å‡ºï¼Œmodules.exportsï¼Œæ¨¡å—åŠ è½½require()å¼•å…¥æ¨¡å—ã€‚ æ•°ç»„å»é‡ æ³•ä¸€ï¼šindexOfå¾ªç¯å»é‡ æ³•äºŒï¼šES6 Setå»é‡ï¼›Array.from(new Set(array)) æ³•ä¸‰ï¼šObject é”®å€¼å¯¹å»é‡ï¼›æŠŠæ•°ç»„çš„å€¼å­˜æˆ Object çš„ key å€¼ï¼Œæ¯”å¦‚ Object[value1] = trueï¼Œåœ¨åˆ¤æ–­å¦ä¸€ä¸ªå€¼çš„æ—¶å€™ï¼Œå¦‚æœ Object[value2]å­˜åœ¨çš„è¯ï¼Œå°±è¯´æ˜è¯¥å€¼æ˜¯é‡å¤çš„ã€‚ åˆ¤æ–­æ•°æ®ç±»å‹ï¼ˆæ˜¯æ•°ç»„ï¼‰ï¼Ÿ Object.prototype.call.toString() Instanceof è·¨åŸŸï¼Ÿå®ç°æ–¹æ³• è·¨åŸŸï¼Œæ˜¯æŒ‡æµè§ˆå™¨ä¸èƒ½æ‰§è¡Œå…¶ä»–ç½‘ç«™çš„è„šæœ¬ã€‚å®ƒæ˜¯ç”±æµè§ˆå™¨çš„åŒæºç­–ç•¥é€ æˆçš„ï¼Œæ˜¯æµè§ˆå™¨å¯¹JavaScriptå®æ–½çš„å®‰å…¨é™åˆ¶ï¼Œé‚£ä¹ˆåªè¦åè®®ã€åŸŸåã€ç«¯å£æœ‰ä»»ä½•ä¸€ä¸ªä¸åŒï¼Œéƒ½è¢«å½“ä½œæ˜¯ä¸åŒçš„åŸŸã€‚è·¨åŸŸåŸç†ï¼Œå³æ˜¯é€šè¿‡å„ç§æ–¹å¼ï¼Œé¿å¼€æµè§ˆå™¨çš„å®‰å…¨é™åˆ¶ã€‚ JSONPï¼šé€šè¿‡åŠ¨æ€åˆ›å»ºscriptï¼Œå†è¯·æ±‚ä¸€ä¸ªå¸¦å‚ç½‘å€å®ç°è·¨åŸŸé€šä¿¡ã€‚document.domain + iframeè·¨åŸŸï¼šä¸¤ä¸ªé¡µé¢éƒ½é€šè¿‡jså¼ºåˆ¶è®¾ç½®document.domainä¸ºåŸºç¡€ä¸»åŸŸï¼Œå°±å®ç°äº†åŒåŸŸã€‚ location.hash + iframeè·¨åŸŸï¼šaæ¬²ä¸bè·¨åŸŸç›¸äº’é€šä¿¡ï¼Œé€šè¿‡ä¸­é—´é¡µcæ¥å®ç°ã€‚ ä¸‰ä¸ªé¡µé¢ï¼Œä¸åŒåŸŸä¹‹é—´åˆ©ç”¨iframeçš„location.hashä¼ å€¼ï¼Œç›¸åŒåŸŸä¹‹é—´ç›´æ¥jsè®¿é—®æ¥é€šä¿¡ã€‚ window.name + iframeè·¨åŸŸï¼šé€šè¿‡iframeçš„srcå±æ€§ç”±å¤–åŸŸè½¬å‘æœ¬åœ°åŸŸï¼Œè·¨åŸŸæ•°æ®å³ç”±iframeçš„window.nameä»å¤–åŸŸä¼ é€’åˆ°æœ¬åœ°åŸŸã€‚ postMessageè·¨åŸŸï¼šå¯ä»¥è·¨åŸŸæ“ä½œçš„windowå±æ€§ä¹‹ä¸€ã€‚ CORSï¼šæœåŠ¡ç«¯è®¾ç½®Access-Control-Allow-Originå³å¯ï¼Œå‰ç«¯æ— é¡»è®¾ç½®ï¼Œè‹¥è¦å¸¦cookieè¯·æ±‚ï¼Œå‰åç«¯éƒ½éœ€è¦è®¾ç½®ã€‚ ä»£ç†è·¨åŸŸï¼šèµ·ä¸€ä¸ªä»£ç†æœåŠ¡å™¨ï¼Œå®ç°æ•°æ®çš„è½¬å‘ é‡æ’å’Œé‡ç»˜ é‡ç»˜ï¼šå½“ç›’å­çš„ä½ç½®ã€å¤§å°ä»¥åŠå…¶ä»–å±æ€§ï¼Œé¢œè‰²ã€å­—ä½“å¤§å°ç­‰éƒ½ç¡®å®šä¸‹æ¥ä¹‹åï¼Œæµè§ˆå™¨ä¾¿æŠŠè¿™äº›åŸè‰²éƒ½æŒ‰ç…§å„è‡ªçš„ç‰¹æ€§ç»˜åˆ¶ä¸€éï¼Œå°†å†…å®¹å‘ˆç°åœ¨é¡µé¢ä¸Šã€‚é‡ç»˜æ˜¯æŒ‡ä¸€ä¸ªå…ƒç´ å¤–è§‚çš„æ”¹å˜æ‰€è§¦å‘çš„æµè§ˆå™¨è¡Œä¸ºï¼Œæµè§ˆå™¨ä¼šæ ¹æ®å…ƒç´ çš„æ–°å±æ€§é‡æ–°ç»˜åˆ¶ï¼Œä½¿å…ƒç´ å‘ˆç°æ–°çš„å¤–è§‚ã€‚ é‡æ’ï¼šå½“æ¸²æŸ“æ ‘ä¸­çš„ä¸€éƒ¨åˆ†(æˆ–å…¨éƒ¨)å› ä¸ºå…ƒç´ çš„è§„æ¨¡å°ºå¯¸ï¼Œå¸ƒå±€ï¼Œéšè—ç­‰æ”¹å˜è€Œéœ€è¦é‡æ–°æ„å»º, è¿™å°±ç§°ä¸ºå›æµ(reflow)ã€‚æ¯ä¸ªé¡µé¢è‡³å°‘éœ€è¦ä¸€æ¬¡å›æµï¼Œå°±æ˜¯åœ¨é¡µé¢ç¬¬ä¸€æ¬¡åŠ è½½çš„æ—¶å€™ã€‚ é‡ç»˜å’Œé‡æ’çš„å…³ç³»ï¼šåœ¨å›æµçš„æ—¶å€™ï¼Œæµè§ˆå™¨ä¼šä½¿æ¸²æŸ“æ ‘ä¸­å—åˆ°å½±å“çš„éƒ¨åˆ†å¤±æ•ˆï¼Œå¹¶é‡æ–°æ„é€ è¿™éƒ¨åˆ†æ¸²æŸ“æ ‘ï¼Œå®Œæˆå›æµåï¼Œæµè§ˆå™¨ä¼šé‡æ–°ç»˜åˆ¶å—å½±å“çš„éƒ¨åˆ†åˆ°å±å¹•ä¸­ï¼Œè¯¥è¿‡ç¨‹ç§°ä¸ºé‡ç»˜ã€‚æ‰€ä»¥ï¼Œé‡æ’å¿…å®šä¼šå¼•å‘é‡ç»˜ï¼Œä½†é‡ç»˜ä¸ä¸€å®šä¼šå¼•å‘é‡æ’ã€‚ è™šæ‹Ÿvirtual dom ç”¨JavaScript å¯¹è±¡ç»“æ„è¡¨ç¤º DOM æ ‘çš„ç»“æ„ï¼›ç„¶åç”¨è¿™ä¸ªæ ‘æ„å»ºä¸€ä¸ªçœŸæ­£çš„ DOM æ ‘ï¼Œæ’åˆ°æ–‡æ¡£å½“ä¸­ å½“çŠ¶æ€å˜æ›´çš„æ—¶å€™ï¼Œé‡æ–°æ„é€ ä¸€æ£µæ–°çš„å¯¹è±¡æ ‘ã€‚ç„¶åç”¨æ–°çš„æ ‘å’Œæ—§çš„æ ‘è¿›è¡Œæ¯”è¾ƒï¼Œè®°å½•ä¸¤æ£µæ ‘å·®å¼‚ æŠŠæ‰€è®°å½•çš„å·®å¼‚åº”ç”¨åˆ°æ‰€æ„å»ºçš„çœŸæ­£çš„DOMæ ‘ä¸Šï¼Œè§†å›¾å°±æ›´æ–°äº†ã€‚Virtual DOM æœ¬è´¨ä¸Šå°±æ˜¯åœ¨ JS å’Œ DOM ä¹‹é—´åšäº†ä¸€ä¸ªç¼“å­˜ã€‚ webpackï¼Ÿ cssæ–‡ä»¶ webpack æ˜¯ä¸€ä¸ªç°ä»£ JavaScript åº”ç”¨ç¨‹åºçš„é™æ€æ¨¡å—æ‰“åŒ…å™¨(module bundler)ã€‚å½“ webpack å¤„ç†åº”ç”¨ç¨‹åºæ—¶ï¼Œå®ƒä¼šé€’å½’åœ°æ„å»ºä¸€ä¸ªä¾èµ–å…³ç³»å›¾(dependency graph)ï¼Œå…¶ä¸­åŒ…å«åº”ç”¨ç¨‹åºéœ€è¦çš„æ¯ä¸ªæ¨¡å—ï¼Œç„¶åå°†æ‰€æœ‰è¿™äº›æ¨¡å—æ‰“åŒ…æˆä¸€ä¸ªæˆ–å¤šä¸ªbundleã€‚ promise ES6æ–°è¯­æ³•ï¼ŒPromiseæ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œä¿å­˜ç€æœªæ¥å°†è¦ç»“æŸçš„äº‹ä»¶ï¼Œå¥¹æœ‰ä¸¤ä¸ªç‰¹å¾: 1ã€å¯¹è±¡çš„çŠ¶æ€ä¸å—å¤–éƒ¨å½±å“ï¼ŒPromiseå¯¹è±¡ä»£è¡¨ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼Œæœ‰ä¸‰ç§çŠ¶æ€ï¼Œpendingè¿›è¡Œä¸­ï¼Œfulfilledå·²æˆåŠŸï¼Œrejectedå·²å¤±è´¥ï¼Œåªæœ‰å¼‚æ­¥æ“ä½œçš„ç»“æœï¼Œæ‰å¯ä»¥å†³å®šå½“å‰æ˜¯å“ªä¸€ç§çŠ¶æ€ï¼Œä»»ä½•å…¶ä»–æ“ä½œéƒ½æ— æ³•æ”¹å˜è¿™ä¸ªçŠ¶æ€ï¼Œè¿™ä¹Ÿå°±æ˜¯promiseåå­—çš„ç”±æ¥ 2ã€ä¸€æ—¦çŠ¶æ€æ”¹å˜ï¼Œå°±ä¸ä¼šå†å˜ï¼Œpromiseå¯¹è±¡çŠ¶æ€æ”¹å˜åªæœ‰ä¸¤ç§å¯èƒ½ï¼Œä»pendingæ”¹åˆ°fulfilledæˆ–è€…ä»pendingæ”¹åˆ°rejectedï¼Œåªè¦è¿™ä¸¤ç§æƒ…å†µå‘ç”Ÿï¼ŒçŠ¶æ€å°±å‡å›ºäº†ï¼Œä¸ä¼šå†æ”¹å˜ï¼Œè¿™ä¸ªæ—¶å€™å°±ç§°ä¸ºå®šå‹resolved, vueç”Ÿå‘½å‘¨æœŸ Vueå®ä¾‹æœ‰ä¸€ä¸ªå®Œæ•´çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¹Ÿå°±æ˜¯ä»å¼€å§‹åˆ›å»ºã€åˆå§‹åŒ–æ•°æ®ã€ç¼–è¯‘æ¨¡æ¿ã€æŒ‚è½½Domã€æ¸²æŸ“â†’æ›´æ–°â†’æ¸²æŸ“ã€é”€æ¯ç­‰ä¸€ç³»åˆ—è¿‡ç¨‹ï¼Œæˆ‘ä»¬ç§°è¿™æ˜¯Vueçš„ç”Ÿå‘½å‘¨æœŸã€‚é€šä¿—è¯´å°±æ˜¯Vueå®ä¾‹ä»åˆ›å»ºåˆ°é”€æ¯çš„è¿‡ç¨‹ï¼Œå°±æ˜¯ç”Ÿå‘½å‘¨æœŸã€‚ es6ç®­å¤´å‡½æ•°ç‰¹æ€§ 1ã€ç®­å¤´å‡½æ•°æ²¡æœ‰thisï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡æŸ¥æ‰¾ä½œç”¨åŸŸé“¾æ¥ç¡®å®šthisçš„å€¼ï¼Œè¿™å°±æ„å‘³ç€å¦‚æœç®­å¤´å‡½æ•°è¢«éç®­å¤´å‡½æ•°åŒ…å«ï¼Œthisç»‘å®šçš„å°±æ˜¯æœ€è¿‘ä¸€å±‚éç®­å¤´å‡½æ•°çš„thisï¼Œ 2ã€ç®­å¤´å‡½æ•°æ²¡æœ‰è‡ªå·±çš„argumentså¯¹è±¡ï¼Œä½†æ˜¯å¯ä»¥è®¿é—®å¤–å›´å‡½æ•°çš„argumentså¯¹è±¡ 3ã€ä¸èƒ½é€šè¿‡newå…³é”®å­—è°ƒç”¨ï¼ŒåŒæ ·ä¹Ÿæ²¡æœ‰new.targetå€¼å’ŒåŸå‹ es6æ–°ç‰¹æ€§ å—çº§ä½œç”¨åŸŸï¼šES5åªæœ‰å…¨å±€ä½œç”¨åŸŸå’Œå‡½æ•°ä½œç”¨åŸŸï¼Œå—çº§ä½œç”¨åŸŸçš„å¥½å¤„æ˜¯ä¸å†éœ€è¦ç«‹å³æ‰§è¡Œçš„å‡½æ•°è¡¨è¾¾å¼ï¼Œå¾ªç¯ä½“ä¸­çš„é—­åŒ…ä¸å†æœ‰é—®é¢˜ restå‚æ•°ï¼šç”¨äºè·å–å‡½æ•°çš„å¤šä½™å‚æ•°ï¼Œè¿™æ ·å°±ä¸éœ€è¦ä½¿ç”¨argumentså¯¹è±¡äº†ï¼Œ promise:ä¸€ç§å¼‚æ­¥ç¼–ç¨‹çš„è§£å†³æ–¹æ¡ˆï¼Œæ¯”ä¼ ç»Ÿçš„è§£å†³æ–¹æ¡ˆå›è°ƒå‡½æ•°å’Œäº‹ä»¶æ›´åˆç†å¼ºå¤§ æ¨¡å—åŒ–ï¼šå…¶æ¨¡å—åŠŸèƒ½ä¸»è¦æœ‰ä¸¤ä¸ªå‘½ä»¤æ„æˆï¼Œexportå’Œimportï¼Œexportå‘½ä»¤ç”¨äºè§„å®šæ¨¡å—çš„å¯¹å¤–æ¥å£ï¼Œimportå‘½ä»¤ç”¨äºè¾“å…¥å…¶ä»–æ¨¡å—æä¾›çš„åŠŸèƒ½ åŒæºç­–ç•¥ å¦‚æœæ²¡æœ‰åŒæºç­–ç•¥ï¼Œä¸åŒæºçš„æ•°æ®å’Œèµ„æºï¼ˆå¦‚HTTPå¤´ã€Cookieã€DOMã€localStorageç­‰ï¼‰å°±èƒ½ç›¸äº’éšæ„è®¿é—®ï¼Œæ ¹æœ¬æ²¡æœ‰éšç§å’Œå®‰å…¨å¯è¨€ã€‚ä¸ºäº†å®‰å…¨èµ·è§å’Œèµ„æºçš„æœ‰æ•ˆç®¡ç†ï¼Œæµè§ˆå™¨å½“ç„¶è¦é‡‡ç”¨è¿™ç§ç­–ç•¥ã€‚ PWA PWAå…¨ç§°Progressive Web Appï¼Œå³æ¸è¿›å¼WEBåº”ç”¨ã€‚ä¸€ä¸ª PWA åº”ç”¨é¦–å…ˆæ˜¯ä¸€ä¸ªç½‘é¡µ, å¯ä»¥é€šè¿‡ Web æŠ€æœ¯ç¼–å†™å‡ºä¸€ä¸ªç½‘é¡µåº”ç”¨. éšåæ·»åŠ ä¸Š App Manifest å’Œ Service Worker æ¥å®ç° PWA çš„å®‰è£…å’Œç¦»çº¿ç­‰åŠŸèƒ½ Redux åœ¨ç»„ä»¶åŒ–çš„åº”ç”¨ä¸­ï¼Œä¼šæœ‰ç€å¤§é‡çš„ç»„ä»¶å±‚çº§å…³ç³»ï¼Œæ·±åµŒå¥—çš„ç»„ä»¶ä¸æµ…å±‚çˆ¶ç»„ä»¶è¿›è¡Œæ•°æ®äº¤äº’ï¼Œå˜å¾—ååˆ†ç¹çå›°éš¾ã€‚è€Œreduxï¼Œç«™åœ¨ä¸€ä¸ªæœåŠ¡çº§åˆ«çš„è§’åº¦ï¼Œå¯ä»¥æ¯«æ— é˜»ç¢åœ°å°†åº”ç”¨çš„çŠ¶æ€ä¼ é€’åˆ°æ¯ä¸€ä¸ªå±‚çº§çš„ç»„ä»¶ä¸­ã€‚reduxå°±ç›¸å½“äºæ•´ä¸ªåº”ç”¨çš„ç®¡å®¶ã€‚ reduxé‡Œå¸¸ç”¨æ–¹æ³• æä¾› getState() æ–¹æ³•è·å– stateï¼› æä¾› dispatch(action) æ–¹æ³•æ›´æ–° stateï¼› é€šè¿‡ subscribe(listener) æ³¨å†Œç›‘å¬å™¨; vueåŒå‘ç»‘å®šåŸç†ï¼š vueæ•°æ®åŒå‘ç»‘å®šæ˜¯é€šè¿‡æ•°æ®åŠ«æŒç»“åˆå‘å¸ƒè€…-è®¢é˜…è€…æ¨¡å¼çš„æ–¹å¼æ¥å®ç°çš„ã€‚åˆ©ç”¨äº† Object.defineProperty() è¿™ä¸ªæ–¹æ³•é‡æ–°å®šä¹‰äº†å¯¹è±¡è·å–å±æ€§å€¼(get)å’Œè®¾ç½®å±æ€§å€¼(set)ã€‚ ä»€ä¹ˆæ˜¯ DOM å’Œ BOMï¼Ÿ DOM æŒ‡çš„æ˜¯æ–‡æ¡£å¯¹è±¡æ¨¡å‹ï¼Œå®ƒæŒ‡çš„æ˜¯æŠŠæ–‡æ¡£å½“åšä¸€ä¸ªå¯¹è±¡æ¥å¯¹å¾…ï¼Œè¿™ä¸ªå¯¹è±¡ä¸»è¦å®šä¹‰äº†å¤„ç†ç½‘é¡µå†…å®¹çš„æ–¹æ³•å’Œæ¥å£ã€‚ BOM æŒ‡çš„æ˜¯æµè§ˆå™¨å¯¹è±¡æ¨¡å‹ï¼Œå®ƒæŒ‡çš„æ˜¯æŠŠæµè§ˆå™¨å½“åšä¸€ä¸ªå¯¹è±¡æ¥å¯¹å¾…ï¼Œè¿™ä¸ªå¯¹è±¡ä¸»è¦å®šä¹‰äº†ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’çš„æ³•å’Œæ¥å£ã€‚BOM çš„æ ¸å¿ƒæ˜¯ windowï¼Œè€Œ window å¯¹è±¡å…·æœ‰åŒé‡è§’è‰²ï¼Œå®ƒæ—¢æ˜¯é€šè¿‡ js è®¿é—®æµè§ˆå™¨çª—å£çš„ä¸€ä¸ªæ¥å£ï¼Œåˆæ˜¯ä¸€ä¸ª Globalï¼ˆå…¨å±€ï¼‰å¯¹è±¡ã€‚ Ajax æˆ‘å¯¹ ajax çš„ç†è§£æ˜¯ï¼Œå®ƒæ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡çš„æ–¹æ³•ï¼Œé€šè¿‡ç›´æ¥ç”± js è„šæœ¬å‘æœåŠ¡å™¨å‘èµ· http é€šä¿¡ï¼Œç„¶åæ ¹æ®æœåŠ¡å™¨è¿”å›çš„æ•°æ®ï¼Œ æ›´æ–°ç½‘é¡µçš„ç›¸åº”éƒ¨åˆ†ï¼Œè€Œä¸ç”¨åˆ·æ–°æ•´ä¸ªé¡µé¢çš„ä¸€ç§æ–¹æ³•ã€‚","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"JS","slug":"Interview/JS","permalink":"WangHngLeee.github.io/categories/Interview/JS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 2 ğŸ’ª","slug":"front-end-interview-css","date":"2020-03-04T13:05:35.000Z","updated":"2020-05-19T15:45:51.561Z","comments":true,"path":"2020/03/04/front-end-interview-css/","link":"","permalink":"WangHngLeee.github.io/2020/03/04/front-end-interview-css/","excerpt":"CSS ç¯‡ ç›’æ¨¡å‹ CSSä¸­çš„ç›’å­æ¨¡å‹åŒ…æ‹¬IEç›’å­æ¨¡å‹å’Œæ ‡å‡†çš„W3Cç›’å­æ¨¡å‹ã€‚ box-sizing(æœ‰3ä¸ªå€¼å“¦)ï¼šborder-box,padding-box,content-box. æ ‡å‡†çš„ç›’å­æ¨¡å‹ï¼šwidthæŒ‡contentéƒ¨åˆ†çš„å®½åº¦ åœ¨IEç›’å­æ¨¡å‹ä¸­ï¼šwidthè¡¨ç¤ºcontent+padding+border æ ‡å‡†ç›’å­æ¨¡å‹çš„ç›’å­å®½åº¦ï¼šå·¦å³border+å·¦å³padding+width IEç›’å­æ¨¡å‹çš„ç›’å­å®½åº¦ï¼šwidth flex Flexæ˜¯Flexible Boxçš„ç¼©å†™ï¼Œæ„ä¸º&quot;å¼¹æ€§å¸ƒå±€&quot;ï¼Œç”¨æ¥ä¸ºç›’çŠ¶æ¨¡å‹æä¾›æœ€å¤§çš„çµæ´»æ€§ã€‚ å¸ƒå±€çš„ä¼ ç»Ÿè§£å†³æ–¹æ¡ˆï¼ŒåŸºäºç›’çŠ¶æ¨¡å‹ï¼Œä¾èµ–displayå±æ€§ + positionå±æ€§ + floatå±æ€§ã€‚ å®¹å™¨é»˜è®¤å­˜åœ¨ä¸¤æ ¹è½´ï¼šæ°´å¹³çš„ä¸»è½´ï¼ˆmain axisï¼‰å’Œå‚ç›´çš„äº¤å‰è½´ï¼ˆcross axisï¼‰ã€‚ä¸»è½´çš„å¼€å§‹ä½ç½®ï¼ˆä¸è¾¹æ¡†çš„äº¤å‰ç‚¹ï¼‰å«åšmain startï¼Œç»“æŸä½ç½®å«åšmain endï¼›äº¤å‰è½´çš„å¼€å§‹ä½ç½®å«åšcross startï¼Œç»“æŸä½ç½®å«åšcross endã€‚é¡¹ç›®é»˜è®¤æ²¿ä¸»è½´æ’åˆ—ã€‚å•ä¸ªé¡¹ç›®å æ®çš„ä¸»è½´ç©ºé—´å«åšmain sizeï¼Œå æ®çš„äº¤å‰è½´ç©ºé—´å«åšcross sizeã€‚ cssé€‰æ‹©å™¨ id é€‰æ‹©å™¨ï¼Œclass é€‰æ‹©å™¨ï¼Œæ ‡ç­¾é€‰æ‹©å™¨ï¼Œä¼ªå…ƒç´ é€‰æ‹©å™¨ï¼Œä¼ªç±»é€‰æ‹©å™¨ç­‰ åŒä¸€å…ƒç´ å¼•ç”¨äº†å¤šä¸ªæ ·å¼æ—¶ï¼Œæ’åœ¨åé¢çš„æ ·å¼å±æ€§çš„ä¼˜å…ˆçº§é«˜ï¼› æ ·å¼é€‰æ‹©å™¨çš„ç±»å‹ä¸åŒæ—¶ï¼Œä¼˜å…ˆçº§é¡ºåºä¸ºï¼šid é€‰æ‹©å™¨ &gt; class é€‰æ‹©å™¨ &gt; æ ‡ç­¾é€‰æ‹©å™¨ï¼› æ ‡ç­¾ä¹‹é—´å­˜åœ¨å±‚çº§åŒ…å«å…³ç³»æ—¶ï¼Œåä»£å…ƒç´ ä¼šç»§æ‰¿ç¥–å…ˆå…ƒç´ çš„æ ·å¼ã€‚å¦‚æœåä»£å…ƒç´ å®šä¹‰äº†ä¸ç¥–å…ˆå…ƒç´ ç›¸åŒçš„æ ·å¼ï¼Œåˆ™ç¥–å…ˆå…ƒç´ çš„ç›¸åŒçš„æ ·å¼å±æ€§ä¼šè¢«è¦†ç›–ã€‚ç»§æ‰¿çš„æ ·å¼çš„ä¼˜å…ˆçº§æ¯”è¾ƒä½ï¼Œè‡³å°‘æ¯”æ ‡ç­¾é€‰æ‹©å™¨çš„ä¼˜å…ˆçº§ä½ï¼› å¸¦æœ‰!important æ ‡è®°çš„æ ·å¼å±æ€§çš„ä¼˜å…ˆçº§æœ€é«˜ï¼› æ ·å¼è¡¨çš„æ¥æºä¸åŒæ—¶ï¼Œä¼˜å…ˆçº§é¡ºåºä¸ºï¼šå†…è”æ ·å¼&gt; å†…éƒ¨æ ·å¼ &gt; å¤–éƒ¨æ ·å¼ &gt; æµè§ˆå™¨ç”¨æˆ·è‡ªå®šä¹‰æ ·å¼ &gt; æµè§ˆå™¨é»˜è®¤æ ·å¼","text":"CSS ç¯‡ ç›’æ¨¡å‹ CSSä¸­çš„ç›’å­æ¨¡å‹åŒ…æ‹¬IEç›’å­æ¨¡å‹å’Œæ ‡å‡†çš„W3Cç›’å­æ¨¡å‹ã€‚ box-sizing(æœ‰3ä¸ªå€¼å“¦)ï¼šborder-box,padding-box,content-box. æ ‡å‡†çš„ç›’å­æ¨¡å‹ï¼šwidthæŒ‡contentéƒ¨åˆ†çš„å®½åº¦ åœ¨IEç›’å­æ¨¡å‹ä¸­ï¼šwidthè¡¨ç¤ºcontent+padding+border æ ‡å‡†ç›’å­æ¨¡å‹çš„ç›’å­å®½åº¦ï¼šå·¦å³border+å·¦å³padding+width IEç›’å­æ¨¡å‹çš„ç›’å­å®½åº¦ï¼šwidth flex Flexæ˜¯Flexible Boxçš„ç¼©å†™ï¼Œæ„ä¸º&quot;å¼¹æ€§å¸ƒå±€&quot;ï¼Œç”¨æ¥ä¸ºç›’çŠ¶æ¨¡å‹æä¾›æœ€å¤§çš„çµæ´»æ€§ã€‚ å¸ƒå±€çš„ä¼ ç»Ÿè§£å†³æ–¹æ¡ˆï¼ŒåŸºäºç›’çŠ¶æ¨¡å‹ï¼Œä¾èµ–displayå±æ€§ + positionå±æ€§ + floatå±æ€§ã€‚ å®¹å™¨é»˜è®¤å­˜åœ¨ä¸¤æ ¹è½´ï¼šæ°´å¹³çš„ä¸»è½´ï¼ˆmain axisï¼‰å’Œå‚ç›´çš„äº¤å‰è½´ï¼ˆcross axisï¼‰ã€‚ä¸»è½´çš„å¼€å§‹ä½ç½®ï¼ˆä¸è¾¹æ¡†çš„äº¤å‰ç‚¹ï¼‰å«åšmain startï¼Œç»“æŸä½ç½®å«åšmain endï¼›äº¤å‰è½´çš„å¼€å§‹ä½ç½®å«åšcross startï¼Œç»“æŸä½ç½®å«åšcross endã€‚é¡¹ç›®é»˜è®¤æ²¿ä¸»è½´æ’åˆ—ã€‚å•ä¸ªé¡¹ç›®å æ®çš„ä¸»è½´ç©ºé—´å«åšmain sizeï¼Œå æ®çš„äº¤å‰è½´ç©ºé—´å«åšcross sizeã€‚ cssé€‰æ‹©å™¨ id é€‰æ‹©å™¨ï¼Œclass é€‰æ‹©å™¨ï¼Œæ ‡ç­¾é€‰æ‹©å™¨ï¼Œä¼ªå…ƒç´ é€‰æ‹©å™¨ï¼Œä¼ªç±»é€‰æ‹©å™¨ç­‰ åŒä¸€å…ƒç´ å¼•ç”¨äº†å¤šä¸ªæ ·å¼æ—¶ï¼Œæ’åœ¨åé¢çš„æ ·å¼å±æ€§çš„ä¼˜å…ˆçº§é«˜ï¼› æ ·å¼é€‰æ‹©å™¨çš„ç±»å‹ä¸åŒæ—¶ï¼Œä¼˜å…ˆçº§é¡ºåºä¸ºï¼šid é€‰æ‹©å™¨ &gt; class é€‰æ‹©å™¨ &gt; æ ‡ç­¾é€‰æ‹©å™¨ï¼› æ ‡ç­¾ä¹‹é—´å­˜åœ¨å±‚çº§åŒ…å«å…³ç³»æ—¶ï¼Œåä»£å…ƒç´ ä¼šç»§æ‰¿ç¥–å…ˆå…ƒç´ çš„æ ·å¼ã€‚å¦‚æœåä»£å…ƒç´ å®šä¹‰äº†ä¸ç¥–å…ˆå…ƒç´ ç›¸åŒçš„æ ·å¼ï¼Œåˆ™ç¥–å…ˆå…ƒç´ çš„ç›¸åŒçš„æ ·å¼å±æ€§ä¼šè¢«è¦†ç›–ã€‚ç»§æ‰¿çš„æ ·å¼çš„ä¼˜å…ˆçº§æ¯”è¾ƒä½ï¼Œè‡³å°‘æ¯”æ ‡ç­¾é€‰æ‹©å™¨çš„ä¼˜å…ˆçº§ä½ï¼› å¸¦æœ‰!important æ ‡è®°çš„æ ·å¼å±æ€§çš„ä¼˜å…ˆçº§æœ€é«˜ï¼› æ ·å¼è¡¨çš„æ¥æºä¸åŒæ—¶ï¼Œä¼˜å…ˆçº§é¡ºåºä¸ºï¼šå†…è”æ ·å¼&gt; å†…éƒ¨æ ·å¼ &gt; å¤–éƒ¨æ ·å¼ &gt; æµè§ˆå™¨ç”¨æˆ·è‡ªå®šä¹‰æ ·å¼ &gt; æµè§ˆå™¨é»˜è®¤æ ·å¼ BFC BFCï¼Œå—çº§æ ¼å¼åŒ–ä¸Šä¸‹æ–‡ï¼Œç”¨äºæ¸…æ¥šæµ®åŠ¨ï¼Œé˜²æ­¢marginé‡å ç­‰ã€‚è¿™æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„æ¸²æŸ“åŒºåŸŸï¼Œè§„å®šäº†å†…éƒ¨å¦‚ä½•å¸ƒå±€ï¼Œå¹¶ä¸”è¿™ä¸ªåŒºåŸŸçš„å­å…ƒç´ ä¸ä¼šå½±å“åˆ°å¤–é¢çš„å…ƒç´ ï¼Œå…¶ä¸­æ¯”è¾ƒé‡è¦çš„å¸ƒå±€è§„åˆ™æœ‰å†…éƒ¨boxå‚ç›´æ”¾ç½®ï¼Œè®¡ç®—BFCçš„é«˜åº¦çš„æ—¶å€™ï¼Œæµ®åŠ¨å…ƒç´ ä¹Ÿå‚ä¸è®¡ç®—ï¼Œè§¦å‘BFCçš„è§„åˆ™æœ‰æ ¹å…ƒç´ ï¼Œæµ®åŠ¨å…ƒç´ ï¼Œpositionä¸ºabsoluteæˆ–fixedçš„å…ƒç´ ï¼Œdisplayä¸ºinline-blockï¼Œtable-cellï¼Œtable-captionï¼Œflexï¼Œinline-flexï¼Œoverflowä¸ä¸ºvisibleçš„å…ƒç´  æ¸…é™¤æµ®åŠ¨ï¼š bfcæ¸…é™¤æµ®åŠ¨ ç»™è¦æ¸…é™¤æµ®åŠ¨çš„å…ƒç´ æ·»åŠ æ ·å¼clear ï¼ˆ clearçš„åŸç†æ˜¯ä½¿æµ®åŠ¨å…ƒç´ ä¸å½±å“åˆ«çš„å…ƒç´ ï¼Œè€Œä¸æ˜¯æ¶ˆç­æµ®åŠ¨ï¼‰ çˆ¶å…ƒç´ ç»“æŸæ ‡ç­¾é’±æ’å…¥æ¸…é™¤æµ®åŠ¨çš„å—çº§å…ƒç´ ï¼Œç»™è¯¥å…ƒç´ æ·»åŠ æ ·å¼clear æ·»åŠ ä¼ªå…ƒç´ ï¼Œåœ¨çˆ¶çº§å…ƒç´ çš„æœ€åï¼Œæ·»åŠ ä¸€ä¸ªä¼ªå…ƒç´ ï¼Œé€šè¿‡æ¸…é™¤ä¼ªå…ƒç´ çš„æµ®åŠ¨ï¼Œæ³¨æ„è¯¥ä¼ªå…ƒç´ çš„displayä¸ºblockï¼Œ çˆ¶å…ƒç´ æ·»åŠ æ ·å¼overflowæ¸…é™¤æµ®åŠ¨ï¼Œoverflowè®¾ç½®é™¤visibleä»¥å¤–çš„ä»»ä½•ä½ç½® å±‚å ä¸Šä¸‹æ–‡ å±‚å ä¸Šä¸‹æ–‡ï¼Œstacking contextï¼Œ æ˜¯HTMLä¸­çš„ä¸€ä¸ªä¸‰ç»´çš„æ¦‚å¿µã€‚z-index é¡ºåºæ ¹æ®z-indexä»å¤§åˆ°å°æ˜¾ç¤ºï¼Œé¦–å…ˆçœ‹çˆ¶ç±»å®¹å™¨çš„z-indexã€‚divçš„z-indexå†³å®šäº†å­å…ƒç´ çš„æ˜¾ç¤ºé¡ºåºã€‚ CSS ä¸­å“ªäº›å±æ€§å¯ä»¥ç»§æ‰¿ï¼Ÿ æ¯ä¸€ä¸ªå±æ€§åœ¨å®šä¹‰ä¸­éƒ½ç»™å‡ºäº†è¿™ä¸ªå±æ€§æ˜¯å¦å…·æœ‰ç»§æ‰¿æ€§ï¼Œä¸€ä¸ªå…·æœ‰ç»§æ‰¿æ€§çš„å±æ€§ä¼šåœ¨æ²¡æœ‰æŒ‡å®šå€¼çš„æ—¶å€™ï¼Œä¼šä½¿ç”¨çˆ¶å…ƒç´ çš„åŒå±æ€§çš„å€¼ æ¥ä½œä¸ºè‡ªå·±çš„å€¼ã€‚ ä¸€èˆ¬å…·æœ‰ç»§æ‰¿æ€§çš„å±æ€§æœ‰ï¼Œå­—ä½“ç›¸å…³çš„å±æ€§ï¼Œfont-size å’Œ font-weight ç­‰ã€‚æ–‡æœ¬ç›¸å…³çš„å±æ€§ï¼Œcolor å’Œ text-align ç­‰ã€‚ è¡¨æ ¼çš„ä¸€äº›å¸ƒå±€å±æ€§ã€åˆ—è¡¨å±æ€§å¦‚ list-style ç­‰ã€‚ è¿˜æœ‰å…‰æ ‡å±æ€§ cursorã€å…ƒç´ å¯è§æ€§ visibility ã€‚ å½“ä¸€ä¸ªå±æ€§ä¸æ˜¯ç»§æ‰¿å±æ€§çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡å°†å®ƒçš„å€¼è®¾ç½®ä¸º inherit æ¥ä½¿å®ƒä»çˆ¶å…ƒç´ é‚£è·å–åŒåçš„å±æ€§å€¼æ¥ç»§æ‰¿ã€‚ å‚ç›´å±…ä¸­é—®é¢˜ï¼š å¯¹äºå®½é«˜å›ºå®šçš„å…ƒç´  ï¼ˆ1ï¼‰æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ margin:0 auto æ¥å®ç°å…ƒç´ çš„æ°´å¹³å±…ä¸­ã€‚ ï¼ˆ2ï¼‰åˆ©ç”¨ç»å¯¹å®šä½ï¼Œè®¾ç½®å››ä¸ªæ–¹å‘çš„å€¼éƒ½ä¸º0ï¼Œå¹¶å°† margin è®¾ç½®ä¸º auto ï¼Œç”±äºå®½é«˜å›ºå®šï¼Œå› æ­¤å¯¹åº”æ–¹å‘å®ç°å¹³åˆ†ï¼Œå¯ä»¥å®ç°æ°´ å¹³å’Œå‚ç›´æ–¹å‘ä¸Šçš„å±…ä¸­ã€‚ ï¼ˆ3ï¼‰åˆ©ç”¨ç»å¯¹å®šä½ï¼Œå…ˆå°†å…ƒç´ çš„å·¦ä¸Šè§’é€šè¿‡ top: 50% å’Œ left: 50% å®šä½åˆ°é¡µé¢çš„ä¸­å¿ƒï¼Œç„¶åå†é€šè¿‡ margin è´Ÿå€¼æ¥è°ƒæ•´å…ƒç´  çš„ä¸­å¿ƒç‚¹åˆ°é¡µé¢çš„ä¸­å¿ƒã€‚ ï¼ˆ4ï¼‰åˆ©ç”¨ç»å¯¹å®šä½ï¼Œå…ˆå°†å…ƒç´ çš„å·¦ä¸Šè§’é€šè¿‡ top: 50% å’Œ left: 50% å®šä½åˆ°é¡µé¢çš„ä¸­å¿ƒï¼Œç„¶åå†é€šè¿‡ translate æ¥è°ƒæ•´å…ƒç´  çš„ä¸­å¿ƒç‚¹åˆ°é¡µé¢çš„ä¸­å¿ƒã€‚ ï¼ˆ5ï¼‰ä½¿ç”¨ flex å¸ƒå±€ï¼Œé€šè¿‡ align-items: center å’Œ justify-content: center è®¾ç½®å®¹å™¨çš„å‚ç›´å’Œæ°´å¹³æ–¹å‘ä¸Šä¸ºå±…ä¸­å¯¹ é½ï¼Œç„¶åå®ƒçš„å­å…ƒç´ ä¹Ÿå¯ä»¥å®ç°å‚ç›´å’Œæ°´å¹³çš„å±…ä¸­ã€‚ å¯¹äºå®½é«˜ä¸å®šçš„å…ƒç´ ï¼Œä¸Šé¢çš„åé¢ä¸¤ç§æ–¹æ³•ï¼Œå¯ä»¥å®ç°å…ƒç´ çš„å‚ç›´å’Œæ°´å¹³çš„å±…ä¸­ã€‚ CSS positionç§ç±»&amp;å±æ€§ï¼Ÿ å›ºå®šå®šä½fixedï¼šå…ƒç´ çš„ä½ç½®ç›¸å¯¹äºæµè§ˆå™¨çª—å£æ˜¯å›ºå®šä½ç½®ï¼Œå³ä½¿çª—å£æ˜¯æ»šåŠ¨çš„å®ƒä¹Ÿä¸ä¼šç§»åŠ¨ã€‚Fixedå®šä½ä½¿å…ƒç´ çš„ä½ç½®ä¸æ–‡æ¡£æµæ— å…³ï¼Œå› æ­¤ä¸å æ®ç©ºé—´ã€‚ Fixedå®šä½çš„å…ƒç´ å’Œå…¶ä»–å…ƒç´ é‡å ã€‚ ç›¸å¯¹å®šä½relativeï¼šå¦‚æœå¯¹ä¸€ä¸ªå…ƒç´ è¿›è¡Œç›¸å¯¹å®šä½ï¼Œå®ƒå°†å‡ºç°åœ¨å®ƒæ‰€åœ¨çš„ä½ç½®ä¸Šã€‚ç„¶åï¼Œå¯ä»¥é€šè¿‡è®¾ç½®å‚ç›´æˆ–æ°´å¹³ä½ç½®ï¼Œè®©è¿™ä¸ªå…ƒç´ â€œç›¸å¯¹äºâ€å®ƒçš„èµ·ç‚¹è¿›è¡Œç§»åŠ¨ã€‚ åœ¨ä½¿ç”¨ç›¸å¯¹å®šä½æ—¶ï¼Œæ— è®ºæ˜¯å¦è¿›è¡Œç§»åŠ¨ï¼Œå…ƒç´ ä»ç„¶å æ®åŸæ¥çš„ç©ºé—´ã€‚å› æ­¤ï¼Œç§»åŠ¨å…ƒç´ ä¼šå¯¼è‡´å®ƒè¦†ç›–å…¶å®ƒæ¡†ã€‚ ç»å¯¹å®šä½absoluteï¼šç»å¯¹å®šä½çš„å…ƒç´ çš„ä½ç½®ç›¸å¯¹äºæœ€è¿‘çš„å·²å®šä½çˆ¶å…ƒç´ ï¼Œå¦‚æœå…ƒç´ æ²¡æœ‰å·²å®šä½çš„çˆ¶å…ƒç´ ï¼Œé‚£ä¹ˆå®ƒçš„ä½ç½®ç›¸å¯¹äºã€‚ absolute å®šä½ä½¿å…ƒç´ çš„ä½ç½®ä¸æ–‡æ¡£æµæ— å…³ï¼Œå› æ­¤ä¸å æ®ç©ºé—´ã€‚ absolute å®šä½çš„å…ƒç´ å’Œå…¶ä»–å…ƒç´ é‡å ã€‚ ç²˜æ€§å®šä½stickyï¼šå…ƒç´ å…ˆæŒ‰ç…§æ™®é€šæ–‡æ¡£æµå®šä½ï¼Œç„¶åç›¸å¯¹äºè¯¥å…ƒç´ åœ¨æµä¸­çš„flow rootï¼ˆBFCï¼‰å’Œ containing blockï¼ˆæœ€è¿‘çš„å—çº§ç¥–å…ˆå…ƒç´ ï¼‰å®šä½ã€‚è€Œåï¼Œå…ƒç´ å®šä½è¡¨ç°ä¸ºåœ¨è·¨è¶Šç‰¹å®šé˜ˆå€¼å‰ä¸ºç›¸å¯¹å®šä½ï¼Œä¹‹åä¸ºå›ºå®šå®šä½ã€‚ é»˜è®¤å®šä½Staticï¼šé»˜è®¤å€¼ã€‚æ²¡æœ‰å®šä½ï¼Œå…ƒç´ å‡ºç°åœ¨æ­£å¸¸çš„æµä¸­ï¼ˆå¿½ç•¥top, bottom, left, right æˆ–è€… z-index å£°æ˜ï¼‰ã€‚ inherit:è§„å®šåº”è¯¥ä»çˆ¶å…ƒç´ ç»§æ‰¿position å±æ€§çš„å€¼ã€‚ å¸¸è§é¡µé¢å¸ƒå±€ ä¼ ç»Ÿç›’æ¨¡å‹å¸ƒå±€ï¼šæ–‡æ¡£æµå¸ƒå±€ï¼Œæµ®åŠ¨å¸ƒå±€ï¼Œå®šä½å¸ƒå±€ å¼¹æ€§ç›’å­flexå¸ƒå±€ï¼š Gridç½‘æ ¼å¸ƒå±€ åœ£æ¯ï¼ˆå¤šåˆ—ï¼‰å¸ƒå±€ åŒé£ç¿¼å¸ƒå±€ å“åº”å¼å¸ƒå±€ 1.åª’ä½“æŸ¥è¯¢ï¼šCSS3åª’ä½“æŸ¥è¯¢å¯ä»¥è®©æˆ‘ä»¬é’ˆå¯¹ä¸åŒçš„åª’ä½“ç±»å‹å®šä¹‰ä¸åŒçš„æ ·å¼ï¼Œå½“é‡ç½®æµè§ˆå™¨çª—å£å¤§å°çš„è¿‡ç¨‹ä¸­ï¼Œé¡µé¢ä¹Ÿä¼šæ ¹æ®æµè§ˆå™¨çš„å®½åº¦å’Œé«˜åº¦é‡æ–°æ¸²æŸ“é¡µé¢ã€‚ 2.ç™¾åˆ†æ¯”å¸ƒå±€ï¼šé€šè¿‡ç™¾åˆ†æ¯”å•ä½ï¼Œå¯ä»¥ä½¿å¾—æµè§ˆå™¨ä¸­ç»„ä»¶çš„å®½å’Œé«˜éšç€æµè§ˆå™¨çš„é«˜åº¦çš„å˜åŒ–è€Œå˜åŒ–ï¼Œä»è€Œå®ç°å“åº”å¼çš„æ•ˆæœ 3.remå¸ƒå±€ï¼šremå•ä½éƒ½æ˜¯ç›¸å¯¹äºæ ¹å…ƒç´ htmlçš„font-sizeæ¥å†³å®šå¤§å°çš„ã€‚é€šè¿‡remæ¥å®ç°å“åº”å¼çš„å¸ƒå±€ï¼Œåªéœ€è¦æ ¹æ®è§†å›¾å®¹å™¨çš„å¤§å°ï¼ŒåŠ¨æ€çš„æ”¹å˜font-sizeå³å¯ 4.è§†å£å•ä½ 5.å›¾ç‰‡å“åº”å¼ï¼š å¤§å°è‡ªé€‚åº” ï½œï½œ æ ¹æ®åˆ†è¾¨ç‡å°½å¯èƒ½é€‰æ‹©åˆ†è¾¨ç‡é«˜çš„å›¾ç‰‡ã€‚ cssé¢„å¤„ç†ï¼Œåå¤„ç† é¢„å¤„ç†ï¼šå¹¿ä¹‰ä¸Šè¯´ï¼Œç›®æ ‡æ ¼å¼ä¸º CSS çš„ é¢„å¤„ç†å™¨ æ˜¯ CSS é¢„å¤„ç†å™¨ï¼Œä½†æœ¬æ–‡ ç‰¹æŒ‡ ä»¥æœ€ç»ˆç”Ÿæˆ CSS ä¸ºç›®çš„çš„ é¢†åŸŸç‰¹å®šè¯­è¨€ã€‚Sassã€LESSã€Stylus æ˜¯ç›®å‰æœ€ä¸»æµçš„ CSS é¢„å¤„ç†å™¨ã€‚ å®ç°åŸç†ï¼šå–åˆ° DSL æºä»£ç  çš„ åˆ†ææ ‘ï¼Œå°†å«æœ‰ åŠ¨æ€ç”Ÿæˆ ç›¸å…³èŠ‚ç‚¹çš„ åˆ†ææ ‘ è½¬æ¢ä¸º é™æ€åˆ†ææ ‘ï¼Œå°† é™æ€åˆ†ææ ‘ è½¬æ¢ä¸º CSS çš„ é™æ€åˆ†ææ ‘ï¼Œå°† CSS çš„ é™æ€åˆ†ææ ‘ è½¬æ¢ä¸º CSS ä»£ç  åå¤„ç†ï¼šå¯¹ CSS è¿›è¡Œå¤„ç†ï¼Œå¹¶æœ€ç»ˆç”Ÿæˆ CSS çš„ é¢„å¤„ç†å™¨ï¼Œå®ƒå±äºå¹¿ä¹‰ä¸Šçš„ CSS é¢„å¤„ç†å™¨ã€‚ CSS å‹ç¼©å·¥å…·ï¼ˆå¦‚ clean-cssï¼‰ å®ç°åŸç†ï¼šå°† æºä»£ç  åšä¸º CSS è§£æï¼Œè·å¾—åˆ†ææ ‘ï¼Œå¯¹CSSçš„åˆ†ææ ‘è¿›è¡Œåå¤„ç†ï¼Œ css3æ–°ç‰¹æ€§ Transition:å¯ä»¥åœ¨å½“å…ƒç´ ä»ä¸€ç§æ ·å¼å˜æ¢ä¸ºå¦ä¸€ç§æ ·å¼æ—¶ä¸ºå…ƒç´ æ·»åŠ æ•ˆæœï¼Œè€Œä¸ç”¨ä½¿ç”¨FlashåŠ¨ç”»æˆ–JavaScript Transformï¼šTransformç”¨æ¥å‘å…ƒç´ åº”ç”¨å„ç§2Då’Œ3Dè½¬æ¢ï¼Œè¯¥å±æ€§å…è®¸æˆ‘ä»¬å¯¹å…ƒç´ è¿›è¡Œæ—‹è½¬ã€ç¼©æ”¾ã€ç§»åŠ¨æˆ–å€¾æ–œç­‰ Animationï¼šAnimationè®©CSSæ‹¥æœ‰äº†å¯ä»¥åˆ¶ä½œåŠ¨ç”»çš„åŠŸèƒ½ã€‚ä½¿ç”¨Animationåˆ¶ä½œåŠ¨ç”»å¯ä»¥çœå»å¤æ‚çš„jsä»£ç  displayå“ªäº›å–å€¼ noneï¼šéšè—ï¼Œä¸ä¼šå ç”¨æ–‡æ¡£æµä½ç½®ï¼ˆå…¶ä»–å…ƒç´ ä¼šå ç”¨ä»–çš„ä½ç½®ï¼‰ inlineï¼šè¡Œå†…å…ƒç´  inline-blockï¼šè¡Œå†…å—å…ƒç´ ï¼Œä¹Ÿå³æœ‰å—å…ƒç´ çš„ä¸€äº›ç‰¹æ€§ï¼Œå¯ä»¥è®¾ç½®å®½é«˜åº¦è¾¹è·ç­‰ç­‰ã€‚ blockï¼šå—å…ƒç´ ï¼Œç‹¬å ä¸€è¡Œï¼Œå¯ä»¥è®¾ç½®å®½é«˜è¾¹è·ç­‰ç­‰ã€‚ tableï¼šç›¸å…³ï¼Œä¼—æ‰€å‘¨çŸ¥tableåŸŸæœ‰ä¸€äº›ç‰¹å®šçš„æ ‡ç­¾ï¼štableã€trã€thã€tdã€tfootç­‰ç­‰ã€‚é‚£ä¹ˆå¯ä»¥ç”¨divç­‰å…ƒç´ çš„æ¥å®ç°å—ï¼Ÿå¯ä»¥ï¼Œå°†è¿™äº›å…ƒç´ çš„displayè®¾ç½®æˆtable-*å°±è¡Œã€‚ inheritï¼šå³ç»§æ‰¿ã€‚ ç›¸é‚»çš„ä¸¤ä¸ªinline-blockèŠ‚ç‚¹ä¸ºä»€ä¹ˆä¼šå‡ºç°é—´éš”ï¼Œè¯¥å¦‚ä½•è§£å†³ ä¸¤ä¸ªIn line block èŠ‚ç‚¹ä¹‹é—´æœ‰ç©ºéš™åŸå› ï¼šè‹±æ–‡æœ‰ç©ºæ ¼ä½œä¸ºè¯åˆ†ç•Œï¼Œè€Œä¸­æ–‡åˆ™æ²¡æœ‰ã€‚ï¼ˆè¿™èƒŒåå»¶ä¼¸å‡ºä¸€ä¸ªä¸­æ–‡åˆ†è¯çš„é—®é¢˜ï¼‰è¿™ä¸ªé—®é¢˜çš„åŸå› å¯ä»¥ä¸Šè¿°åˆ°SGML(æ ‡å‡†é€šç”¨æ ‡è®°è¯­è¨€)å’ŒTeX(æ’ç‰ˆå·¥å…·)ï¼Œå®ƒå®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡Œå†…ï¼ˆinlineï¼‰çš„é—®é¢˜ï¼Œå®ƒç”±ç©ºæ ¼ã€æ¢è¡Œæˆ–å›è½¦æ‰€äº§ç”Ÿç©ºç™½ç¬¦æ‰€è‡´ æ–¹æ³•1. æ”¹å˜ä¹¦å†™æ–¹å¼ å»æ‰htmlä¸­çš„ç©ºæ ¼ï¼Œæˆ–è€…æ’åˆ—åœ¨ä¸€è¡Œï¼Œä½†æ˜¯å¯è¯»æ€§å·® æ–¹æ³•2ï¼šfont-size æ–¹æ³•3ï¼šä½¿ç”¨marginè´Ÿå€¼ æ–¹æ³•4ï¼šä½¿ç”¨word-spacingæˆ–letter-spacing meta viewport ç§»åŠ¨ç«¯é€‚é… æ‰€åšçš„é€‚é…ï¼Œå°±æ˜¯è¦è°ƒæ•´layout viewportçš„å¤§å°ï¼Œè€Œç”¨metaæ ‡ç­¾å°±å¯ä»¥è°ƒæ•´layout viewportçš„å¤§å°ã€‚ remå¸ƒå±€çš„ä¼˜ç¼ºç‚¹ remå¯ä»¥è®©æˆ‘ä»¬çš„é¡µé¢æ›´çµæ´»ï¼Œæ›´å¥å£®ï¼Œæ¯”èµ·åˆ°å¤„å†™æ­»çš„pxå€¼ï¼Œemä¼¼ä¹æ›´æœ‰å¼ åŠ›ï¼Œæ”¹åŠ¨çˆ¶å…ƒç´ çš„å­—ä½“å¤§å°ï¼Œå­å…ƒç´ ä¼šç­‰æ¯”ä¾‹å˜åŒ–ï¼Œè¿™ä¸€å˜åŒ–ä¼¼ä¹é¢„ç¤ºäº†æ— é™å¯èƒ½ remæ˜¯å¼¹æ€§å¸ƒå±€çš„ä¸€ç§ï¼Œå¼¹æ€§å¸ƒå±€æ˜¯å“åº”å¼å¸ƒå±€çš„ä¸€ç§ï¼Œä½†æ˜¯å“åº”å¼å¸ƒå±€ä¸æ˜¯å¼¹æ€§å¸ƒå±€ã€‚å¼¹æ€§å¸ƒå±€å¼ºè°ƒç­‰æ¯”ç¼©æ”¾ï¼Œå¼ºè°ƒç™¾åˆ†ç™¾è¿˜åŸï¼Œå“åº”å¼å¸ƒå±€å¼ºè°ƒä¸åŒè®¾å¤‡æœ‰ä¸åŒçš„å±•ç°ã€‚ Remè¿‡äºæ­»æ¿ï¼Œå“åº”å¼å¸ƒå±€å¯ä»¥å¤šè®¾å¤‡è‡ªé€‚åº”ï¼Œ linkæ ‡ç­¾å’Œimportæ ‡ç­¾çš„åŒºåˆ«ï¼š linkå±äºhtmlæ ‡ç­¾ï¼Œè€Œ@importæ˜¯cssæä¾›çš„ é¡µé¢è¢«åŠ è½½æ—¶ï¼Œlinkä¼šåŒæ—¶è¢«åŠ è½½ï¼Œè€Œ@importå¼•ç”¨çš„cssä¼šç­‰åˆ°é¡µé¢åŠ è½½ç»“æŸååŠ è½½ã€‚ linkæ˜¯htmlæ ‡ç­¾ï¼Œå› æ­¤æ²¡æœ‰å…¼å®¹æ€§ï¼Œè€Œ@importåªæœ‰IE5ä»¥ä¸Šæ‰èƒ½è¯†åˆ«ã€‚ linkæ–¹å¼æ ·å¼çš„æƒé‡é«˜äº@importçš„ã€‚ 1åƒç´ è¾¹æ¡†é—®é¢˜ï¼š 1ï¼‰border-image å›¾ç‰‡ å®ç° ç¼ºç‚¹æ˜¯åˆ¶ä½œå›¾ç‰‡çš„åœ†è§’æ—¶å€™ä¼šå‡ºç°æ¨¡ç³Šã€‚ .border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(\"image_url\") 2 0 stretch;&#125; background-image æ¸å˜å®ç° é™¤å•¦ç”¨å›¾ç‰‡ï¼Œéš¾é“çº¯ç²¹çš„csså°±ä¸èƒ½å®ç°å—ï¼Ÿæˆ‘çš„ç¡®ä¸æƒ³ä½¿ç”¨å›¾ç‰‡ï¼Œæ„Ÿè§‰åˆ¶ä½œèµ·æ¥å¾ˆéº»çƒ¦ï¼Œå…¶å®ç™¾åº¦ç³¯ç±³å›¢é¦–é¡µå°±æ˜¯è¿™ä¹ˆåšçš„ä½†æ˜¯è¿™ç§æ–¹æ³•æœ‰ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯ä¸èƒ½å®ç°åœ†è§’ .border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; &#125; viewport+remå®ç° box-shadow å®ç° åˆ©ç”¨é˜´å½±æˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¥çœ‹çœ‹é˜´å½±ï¼Œä¼˜ç‚¹æ˜¯åœ†è§’ä¸æ˜¯é—®é¢˜ï¼Œç¼ºç‚¹æ˜¯é¢œè‰²ä¸å¥½æ§åˆ¶ã€‚ div&#123; -webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; transform: scale(0.5) å®ç° æ¨èç›¸å½“çµæ´» å…¶å®æˆ‘ä»¬åˆšæ‰åˆ—ä¸¾äº†é‚£ä¹ˆå¤šä¾‹å­ï¼Œæ— éå°±æ˜¯æŠŠ1pxç¼©æ”¾éƒ½0.5pxçš„çŠ¶æ€ä¸‹ï¼Œè€Œ0.5pxå¹¶ä¸æ˜¯æ‰€æœ‰éƒ½æ”¯æŒï¼Œå†æ ¹æ®åª’ä½“æŸ¥è¯¢è®¾ç½®ä¸åŒçš„ç¼©æ”¾æ¯”ä¾‹å°±å¯ä»¥äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¼€å§‹ç©å„¿ç¼©æ”¾å§ã€‚ 1.ç”¨heightï¼š1pxçš„divï¼Œç„¶åæ ¹æ®åª’ä½“æŸ¥è¯¢è®¾ç½®transform: scaleY(0.5);ï¼Œ div&#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; 2.ç”¨::afterå’Œ::befor,è®¾ç½®border-bottomï¼š1px solid #000,ç„¶ååœ¨ç¼©æ”¾-webkit-transform: scaleY(0.5);å¯ä»¥å®ç°ä¸¤æ ¹è¾¹çº¿çš„éœ€æ±‚ div::after&#123; content:'';width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125; 3.ç”¨::afterè®¾ç½®borderï¼š1px solid #000; width:200%; height:200%,ç„¶åå†ç¼©æ”¾scaleY(0.5); ä¼˜ç‚¹å¯ä»¥å®ç°åœ†è§’ï¼Œäº¬ä¸œå°±æ˜¯è¿™ä¹ˆå®ç°çš„ï¼Œç¼ºç‚¹æ˜¯æŒ‰é’®æ·»åŠ activeæ¯”è¾ƒéº»çƒ¦ã€‚ .div::after &#123; content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125;","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 1 ğŸ’ª","slug":"frontent-interview-html","date":"2020-03-04T13:05:35.000Z","updated":"2020-05-19T15:46:03.506Z","comments":true,"path":"2020/03/04/frontent-interview-html/","link":"","permalink":"WangHngLeee.github.io/2020/03/04/frontent-interview-html/","excerpt":"HTMLç¯‡ è¯­ä¹‰åŒ– HTML5è¯­ä¹‰åŒ–æ ‡ç­¾æ˜¯æŒ‡æ­£ç¡®çš„æ ‡ç­¾åŒ…å«äº†æ­£ç¡®çš„å†…å®¹ï¼Œç»“æ„è‰¯å¥½ï¼Œä¾¿äºé˜…è¯»ï¼Œæ¯”å¦‚navè¡¨ç¤ºå¯¼èˆªæ¡ï¼Œç±»ä¼¼çš„è¿˜æœ‰articleã€headerã€footerç­‰ç­‰æ ‡ç­¾ã€‚ ç§»åŠ¨è®¾å¤‡å¿½ç•¥å°†é¡µé¢ä¸­çš„æ•°å­—è¯†åˆ«ä¸ºç”µè¯å·ç çš„æ–¹æ³• å¦‚æœå¿½ç•¥é¡µé¢ä¸­çš„æ•°å­—è¯†åˆ«ä¸ºç”µè¯å·ç , åªè¦æŠŠè¿™ä¸ªé»˜è®¤è¡Œä¸ºå…³é—­å°±è¡Œï¼Œåªè¦ä¸€è¡Œä»£ç : &lt;meta name = \"format-detection\" content = \"telephone=no\"&gt; http vs https : å®šä¹‰ï¼š http: è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œæ˜¯äº’è”ç½‘ä¸Šåº”ç”¨æœ€ä¸ºå¹¿æ³›çš„ä¸€ç§ç½‘ç»œåè®®ï¼Œæ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯è¯·æ±‚å’Œåº”ç­”çš„æ ‡å‡†ï¼ˆTCPï¼‰ï¼Œç”¨äºä»WWWæœåŠ¡å™¨ä¼ è¾“è¶…æ–‡æœ¬åˆ°æœ¬åœ°æµè§ˆå™¨çš„ä¼ è¾“åè®®ï¼Œå®ƒå¯ä»¥ä½¿æµè§ˆå™¨æ›´åŠ é«˜æ•ˆï¼Œä½¿ç½‘ç»œä¼ è¾“å‡å°‘ã€‚ https: æ˜¯ä»¥å®‰å…¨ä¸ºç›®æ ‡çš„HTTPé€šé“ï¼Œç®€å•è®²æ˜¯HTTPçš„å®‰å…¨ç‰ˆï¼Œå³HTTPä¸‹åŠ å…¥SSLå±‚ï¼ŒHTTPSçš„å®‰å…¨åŸºç¡€æ˜¯SSLï¼Œå› æ­¤åŠ å¯†çš„è¯¦ç»†å†…å®¹å°±éœ€è¦SSLã€‚ åŒºåˆ«ï¼š Httpsåè®®éœ€è¦caè¯ä¹¦ï¼Œè´¹ç”¨è¾ƒé«˜ã€‚ httpæ˜¯è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œä¿¡æ¯æ˜¯æ˜æ–‡ä¼ è¾“ï¼Œhttpsåˆ™æ˜¯å…·æœ‰å®‰å…¨æ€§çš„sslåŠ å¯†ä¼ è¾“åè®®ã€‚ ä½¿ç”¨ä¸åŒçš„é“¾æ¥æ–¹å¼ï¼Œç«¯å£ä¹Ÿä¸åŒï¼Œä¸€èˆ¬è€Œè¨€ï¼Œhttpåè®®çš„ç«¯å£ä¸º80ï¼Œhttpsçš„ç«¯å£ä¸º443 httpçš„è¿æ¥å¾ˆç®€å•ï¼Œæ˜¯æ— çŠ¶æ€çš„ï¼›HTTPSåè®®æ˜¯ç”±SSL+HTTPåè®®æ„å»ºçš„å¯è¿›è¡ŒåŠ å¯†ä¼ è¾“ã€èº«ä»½è®¤è¯çš„ç½‘ç»œåè®®ï¼Œæ¯”httpåè®®å®‰å…¨ã€‚ websocket WebSocketæ˜¯HTML5ä¸­çš„åè®®ï¼Œæ”¯æŒæŒä¹…è¿ç»­ï¼Œhttpåè®®ä¸æ”¯æŒæŒä¹…æ€§è¿æ¥ã€‚Http1.0å’ŒHTTP1.1éƒ½ä¸æ”¯æŒæŒä¹…æ€§çš„é“¾æ¥ï¼ŒHTTP1.1ä¸­çš„keep-aliveï¼Œå°†å¤šä¸ªhttpè¯·æ±‚åˆå¹¶ä¸º1ä¸ª Cookieã€sessionStorageã€localStorageçš„åŒºåˆ« å…±åŒç‚¹ï¼šéƒ½æ˜¯ä¿å­˜åœ¨æµè§ˆå™¨ç«¯ï¼Œå¹¶ä¸”æ˜¯åŒæºçš„ cookieæ•°æ®å§‹ç»ˆåœ¨åŒæºçš„httpè¯·æ±‚ä¸­æºå¸¦(å³ä½¿ä¸éœ€è¦)ï¼Œå³cookieåœ¨æµè§ˆå™¨å’ŒæœåŠ¡å™¨é—´æ¥å›ä¼ é€’ cookieæ•°æ®è¿˜æœ‰è·¯å¾„ï¼ˆpathï¼‰çš„æ¦‚å¿µï¼Œå¯ä»¥é™åˆ¶ã€‚cookieåªå±äºæŸä¸ªè·¯å¾„ä¸‹ å­˜å‚¨å¤§å°é™åˆ¶ä¹Ÿä¸åŒâ€“cookieæ•°æ®ä¸èƒ½è¶…è¿‡4Kï¼ŒåŒæ—¶å› ä¸ºæ¯æ¬¡httpè¯·æ±‚éƒ½ä¼šæºå¸¦cookieï¼Œæ‰€ä»¥cookieåªé€‚åˆä¿å­˜å¾ˆå°çš„æ•°æ®ï¼Œå¦‚å›è¯æ ‡è¯†ã€‚ webStorageè™½ç„¶ä¹Ÿæœ‰å­˜å‚¨å¤§å°çš„é™åˆ¶ï¼Œä½†æ˜¯æ¯”cookieå¤§å¾—å¤šï¼Œå¯ä»¥è¾¾åˆ°5Mæˆ–æ›´å¤§ æ•°æ®çš„æœ‰æ•ˆæœŸä¸åŒ --sessionStorageï¼šä»…åœ¨å½“å‰çš„æµè§ˆå™¨çª—å£å…³é—­æœ‰æ•ˆï¼›localStorageï¼šå§‹ç»ˆæœ‰æ•ˆï¼Œçª—å£æˆ–æµè§ˆå™¨å…³é—­ä¹Ÿä¸€ç›´ä¿å­˜ï¼Œå› æ­¤ç”¨ä½œæŒä¹…æ•°æ®ï¼›cookieï¼šåªåœ¨è®¾ç½®çš„cookieè¿‡æœŸæ—¶é—´ä¹‹å‰ä¸€ç›´æœ‰æ•ˆï¼Œå³ä½¿çª—å£å’Œæµè§ˆå™¨å…³é—­ ä½œç”¨åŸŸä¸åŒâ€“sessionStorageï¼šä¸åœ¨ä¸åŒçš„æµè§ˆå™¨çª—å£ä¸­å…±äº«ï¼Œå³ä½¿æ˜¯åŒä¸€ä¸ªé¡µé¢ï¼›localStorageï¼šåœ¨æ‰€æœ‰åŒæºçª—å£éƒ½æ˜¯å…±äº«çš„ï¼›cookieï¼šä¹Ÿæ˜¯åœ¨æ‰€æœ‰åŒæºçª—å£ä¸­å…±äº«çš„","text":"HTMLç¯‡ è¯­ä¹‰åŒ– HTML5è¯­ä¹‰åŒ–æ ‡ç­¾æ˜¯æŒ‡æ­£ç¡®çš„æ ‡ç­¾åŒ…å«äº†æ­£ç¡®çš„å†…å®¹ï¼Œç»“æ„è‰¯å¥½ï¼Œä¾¿äºé˜…è¯»ï¼Œæ¯”å¦‚navè¡¨ç¤ºå¯¼èˆªæ¡ï¼Œç±»ä¼¼çš„è¿˜æœ‰articleã€headerã€footerç­‰ç­‰æ ‡ç­¾ã€‚ ç§»åŠ¨è®¾å¤‡å¿½ç•¥å°†é¡µé¢ä¸­çš„æ•°å­—è¯†åˆ«ä¸ºç”µè¯å·ç çš„æ–¹æ³• å¦‚æœå¿½ç•¥é¡µé¢ä¸­çš„æ•°å­—è¯†åˆ«ä¸ºç”µè¯å·ç , åªè¦æŠŠè¿™ä¸ªé»˜è®¤è¡Œä¸ºå…³é—­å°±è¡Œï¼Œåªè¦ä¸€è¡Œä»£ç : &lt;meta name = \"format-detection\" content = \"telephone=no\"&gt; http vs https : å®šä¹‰ï¼š http: è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œæ˜¯äº’è”ç½‘ä¸Šåº”ç”¨æœ€ä¸ºå¹¿æ³›çš„ä¸€ç§ç½‘ç»œåè®®ï¼Œæ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯è¯·æ±‚å’Œåº”ç­”çš„æ ‡å‡†ï¼ˆTCPï¼‰ï¼Œç”¨äºä»WWWæœåŠ¡å™¨ä¼ è¾“è¶…æ–‡æœ¬åˆ°æœ¬åœ°æµè§ˆå™¨çš„ä¼ è¾“åè®®ï¼Œå®ƒå¯ä»¥ä½¿æµè§ˆå™¨æ›´åŠ é«˜æ•ˆï¼Œä½¿ç½‘ç»œä¼ è¾“å‡å°‘ã€‚ https: æ˜¯ä»¥å®‰å…¨ä¸ºç›®æ ‡çš„HTTPé€šé“ï¼Œç®€å•è®²æ˜¯HTTPçš„å®‰å…¨ç‰ˆï¼Œå³HTTPä¸‹åŠ å…¥SSLå±‚ï¼ŒHTTPSçš„å®‰å…¨åŸºç¡€æ˜¯SSLï¼Œå› æ­¤åŠ å¯†çš„è¯¦ç»†å†…å®¹å°±éœ€è¦SSLã€‚ åŒºåˆ«ï¼š Httpsåè®®éœ€è¦caè¯ä¹¦ï¼Œè´¹ç”¨è¾ƒé«˜ã€‚ httpæ˜¯è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼Œä¿¡æ¯æ˜¯æ˜æ–‡ä¼ è¾“ï¼Œhttpsåˆ™æ˜¯å…·æœ‰å®‰å…¨æ€§çš„sslåŠ å¯†ä¼ è¾“åè®®ã€‚ ä½¿ç”¨ä¸åŒçš„é“¾æ¥æ–¹å¼ï¼Œç«¯å£ä¹Ÿä¸åŒï¼Œä¸€èˆ¬è€Œè¨€ï¼Œhttpåè®®çš„ç«¯å£ä¸º80ï¼Œhttpsçš„ç«¯å£ä¸º443 httpçš„è¿æ¥å¾ˆç®€å•ï¼Œæ˜¯æ— çŠ¶æ€çš„ï¼›HTTPSåè®®æ˜¯ç”±SSL+HTTPåè®®æ„å»ºçš„å¯è¿›è¡ŒåŠ å¯†ä¼ è¾“ã€èº«ä»½è®¤è¯çš„ç½‘ç»œåè®®ï¼Œæ¯”httpåè®®å®‰å…¨ã€‚ websocket WebSocketæ˜¯HTML5ä¸­çš„åè®®ï¼Œæ”¯æŒæŒä¹…è¿ç»­ï¼Œhttpåè®®ä¸æ”¯æŒæŒä¹…æ€§è¿æ¥ã€‚Http1.0å’ŒHTTP1.1éƒ½ä¸æ”¯æŒæŒä¹…æ€§çš„é“¾æ¥ï¼ŒHTTP1.1ä¸­çš„keep-aliveï¼Œå°†å¤šä¸ªhttpè¯·æ±‚åˆå¹¶ä¸º1ä¸ª Cookieã€sessionStorageã€localStorageçš„åŒºåˆ« å…±åŒç‚¹ï¼šéƒ½æ˜¯ä¿å­˜åœ¨æµè§ˆå™¨ç«¯ï¼Œå¹¶ä¸”æ˜¯åŒæºçš„ cookieæ•°æ®å§‹ç»ˆåœ¨åŒæºçš„httpè¯·æ±‚ä¸­æºå¸¦(å³ä½¿ä¸éœ€è¦)ï¼Œå³cookieåœ¨æµè§ˆå™¨å’ŒæœåŠ¡å™¨é—´æ¥å›ä¼ é€’ cookieæ•°æ®è¿˜æœ‰è·¯å¾„ï¼ˆpathï¼‰çš„æ¦‚å¿µï¼Œå¯ä»¥é™åˆ¶ã€‚cookieåªå±äºæŸä¸ªè·¯å¾„ä¸‹ å­˜å‚¨å¤§å°é™åˆ¶ä¹Ÿä¸åŒâ€“cookieæ•°æ®ä¸èƒ½è¶…è¿‡4Kï¼ŒåŒæ—¶å› ä¸ºæ¯æ¬¡httpè¯·æ±‚éƒ½ä¼šæºå¸¦cookieï¼Œæ‰€ä»¥cookieåªé€‚åˆä¿å­˜å¾ˆå°çš„æ•°æ®ï¼Œå¦‚å›è¯æ ‡è¯†ã€‚ webStorageè™½ç„¶ä¹Ÿæœ‰å­˜å‚¨å¤§å°çš„é™åˆ¶ï¼Œä½†æ˜¯æ¯”cookieå¤§å¾—å¤šï¼Œå¯ä»¥è¾¾åˆ°5Mæˆ–æ›´å¤§ æ•°æ®çš„æœ‰æ•ˆæœŸä¸åŒ --sessionStorageï¼šä»…åœ¨å½“å‰çš„æµè§ˆå™¨çª—å£å…³é—­æœ‰æ•ˆï¼›localStorageï¼šå§‹ç»ˆæœ‰æ•ˆï¼Œçª—å£æˆ–æµè§ˆå™¨å…³é—­ä¹Ÿä¸€ç›´ä¿å­˜ï¼Œå› æ­¤ç”¨ä½œæŒä¹…æ•°æ®ï¼›cookieï¼šåªåœ¨è®¾ç½®çš„cookieè¿‡æœŸæ—¶é—´ä¹‹å‰ä¸€ç›´æœ‰æ•ˆï¼Œå³ä½¿çª—å£å’Œæµè§ˆå™¨å…³é—­ ä½œç”¨åŸŸä¸åŒâ€“sessionStorageï¼šä¸åœ¨ä¸åŒçš„æµè§ˆå™¨çª—å£ä¸­å…±äº«ï¼Œå³ä½¿æ˜¯åŒä¸€ä¸ªé¡µé¢ï¼›localStorageï¼šåœ¨æ‰€æœ‰åŒæºçª—å£éƒ½æ˜¯å…±äº«çš„ï¼›cookieï¼šä¹Ÿæ˜¯åœ¨æ‰€æœ‰åŒæºçª—å£ä¸­å…±äº«çš„ cookie sessionåŒºåˆ« 1.cookieæ•°æ®å­˜æ”¾åœ¨å®¢æˆ·çš„æµè§ˆå™¨ä¸Šï¼Œsessionæ•°æ®æ”¾åœ¨æœåŠ¡å™¨ä¸Šã€‚ 2.cookieä¸æ˜¯å¾ˆå®‰å…¨ï¼Œåˆ«äººå¯ä»¥åˆ†æå­˜æ”¾åœ¨æœ¬åœ°çš„COOKIEå¹¶è¿›è¡ŒCOOKIEæ¬ºéª—ï¼Œè€ƒè™‘åˆ°å®‰å…¨åº”å½“ä½¿ç”¨sessionã€‚ 3.sessionä¼šåœ¨ä¸€å®šæ—¶é—´å†…ä¿å­˜åœ¨æœåŠ¡å™¨ä¸Šã€‚å½“è®¿é—®å¢å¤šï¼Œä¼šæ¯”è¾ƒå ç”¨ä½ æœåŠ¡å™¨çš„æ€§èƒ½ï¼Œè€ƒè™‘åˆ°å‡è½»æœåŠ¡å™¨æ€§èƒ½æ–¹é¢ï¼Œåº”å½“ä½¿ç”¨COOKIEã€‚ 4.å•ä¸ªcookieä¿å­˜çš„æ•°æ®ä¸èƒ½è¶…è¿‡4Kï¼Œå¾ˆå¤šæµè§ˆå™¨éƒ½é™åˆ¶ä¸€ä¸ªç«™ç‚¹æœ€å¤šä¿å­˜20ä¸ªcookie Doctypeä½œç”¨?ä¸¥æ ¼æ¨¡å¼ä¸æ··æ‚æ¨¡å¼å¦‚ä½•åŒºåˆ†ï¼Ÿå®ƒä»¬æœ‰ä½•æ„ä¹‰? Doctypeå£°æ˜äºæ–‡æ¡£æœ€å‰é¢ï¼Œå‘Šè¯‰æµè§ˆå™¨ä»¥ä½•ç§æ–¹å¼æ¥æ¸²æŸ“é¡µé¢ï¼Œè¿™é‡Œæœ‰ä¸¤ç§æ¨¡å¼ï¼Œä¸¥æ ¼æ¨¡å¼å’Œæ··æ‚æ¨¡å¼ã€‚ ä¸¥æ ¼æ¨¡å¼çš„æ’ç‰ˆå’ŒJS è¿ä½œæ¨¡å¼æ˜¯ ä»¥è¯¥æµè§ˆå™¨æ”¯æŒçš„æœ€é«˜æ ‡å‡†è¿è¡Œã€‚ æ··æ‚æ¨¡å¼ï¼Œå‘åå…¼å®¹ï¼Œæ¨¡æ‹Ÿè€å¼æµè§ˆå™¨ï¼Œé˜²æ­¢æµè§ˆå™¨æ— æ³•å…¼å®¹é¡µé¢ã€‚ æµè§ˆå™¨ç¼“å­˜ï¼Œå¼º/åå•†ç¼“å­˜ æµè§ˆå™¨ç¼“å­˜æ˜¯æµè§ˆå™¨åœ¨æœ¬åœ°ç£ç›˜å¯¹ç”¨æˆ·æœ€è¿‘è¯·æ±‚è¿‡çš„æ–‡æ¡£è¿›è¡Œå­˜å‚¨ï¼Œå½“è®¿é—®è€…å†æ¬¡è®¿é—®åŒä¸€é¡µé¢æ—¶ï¼Œæµè§ˆå™¨å°±å¯ä»¥ç›´æ¥ä»æœ¬åœ°ç£ç›˜åŠ è½½æ–‡æ¡£ã€‚ ç¼“å­˜åˆ†ä¸ºä¸¤ç§ï¼šå¼ºç¼“å­˜å’Œåå•†ç¼“å­˜ï¼Œæ ¹æ®å“åº”çš„headerå†…å®¹æ¥å†³å®šã€‚ å¼ºç¼“å­˜ç›¸å…³å­—æ®µæœ‰expiresï¼Œcache-controlã€‚å¦‚æœcache-controlä¸expiresåŒæ—¶å­˜åœ¨çš„è¯ï¼Œcache-controlçš„ä¼˜å…ˆçº§é«˜äºexpiresã€‚ åå•†ç¼“å­˜ç›¸å…³å­—æ®µæœ‰Last-Modified/If-Modified-Sinceï¼ŒEtag/If-None-Match ç¼“å­˜ç±»å‹ è·å–èµ„æºå½¢å¼ çŠ¶æ€ç  å‘é€è¯·æ±‚åˆ°æœåŠ¡å™¨ åå•†ç¼“å­˜ ä»ç¼“å­˜å– 200(from cache) å¦ï¼Œç›´æ¥ä»ç¼“å­˜å– å¼ºç¼“å­˜ ä»ç¼“å­˜å– 304(undefined) æ˜¯ï¼Œé€šè¿‡æœåŠ¡å™¨æ¥å‘ŠçŸ¥ç¼“å­˜æ˜¯å¦å¯ç”¨ ä»€ä¹ˆæ—¶å€™ç”¨å“ªä¸ªï¼Ÿ å› ä¸ºæœåŠ¡å™¨ä¸Šçš„èµ„æºä¸æ˜¯ä¸€ç›´å›ºå®šä¸å˜çš„ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹å®ƒä¼šæ›´æ–°ï¼Œè¿™ä¸ªæ—¶å€™å¦‚æœæˆ‘ä»¬è¿˜è®¿é—®æœ¬åœ°ç¼“å­˜ï¼Œé‚£ä¹ˆå¯¹ç”¨æˆ·æ¥è¯´ï¼Œé‚£å°±ç›¸å½“äºèµ„æºæ²¡æœ‰æ›´æ–°ï¼Œç”¨æˆ·çœ‹åˆ°çš„è¿˜æ˜¯æ—§çš„èµ„æºï¼›æ‰€ä»¥æˆ‘ä»¬å¸Œæœ›æœåŠ¡å™¨ä¸Šçš„èµ„æºæ›´æ–°äº†æµè§ˆå™¨å°±è¯·æ±‚æ–°çš„èµ„æºï¼Œæ²¡æœ‰æ›´æ–°å°±ä½¿ç”¨æœ¬åœ°çš„ç¼“å­˜ï¼Œä»¥æœ€å¤§ç¨‹åº¦çš„å‡å°‘å› ç½‘ç»œè¯·æ±‚è€Œäº§ç”Ÿçš„èµ„æºæµªè´¹ã€‚ 304çŠ¶æ€ç  304ï¼šå¦‚æœå®¢æˆ·ç«¯å‘é€äº†ä¸€ä¸ªå¸¦æ¡ä»¶çš„GET è¯·æ±‚ä¸”è¯¥è¯·æ±‚å·²è¢«å…è®¸ï¼Œè€Œæ–‡æ¡£çš„å†…å®¹ï¼ˆè‡ªä¸Šæ¬¡è®¿é—®ä»¥æ¥æˆ–è€…æ ¹æ®è¯·æ±‚çš„æ¡ä»¶ï¼‰å¹¶æ²¡æœ‰æ”¹å˜ï¼Œåˆ™æœåŠ¡å™¨åº”å½“è¿”å›è¿™ä¸ª304çŠ¶æ€ç ã€‚ å‰ç«¯ä¼˜åŒ– é™ä½è¯·æ±‚é‡ï¼šåˆå¹¶èµ„æºï¼Œå‡å°‘HTTP è¯·æ±‚æ•°ï¼Œminify / gzip å‹ç¼©ï¼ŒwebPï¼ŒlazyLoadã€‚ åŠ å¿«è¯·æ±‚é€Ÿåº¦ï¼šé¢„è§£æDNSï¼Œå‡å°‘åŸŸåæ•°ï¼Œå¹¶è¡ŒåŠ è½½ï¼ŒCDN åˆ†å‘ã€‚ ç¼“å­˜ï¼šHTTP åè®®ç¼“å­˜è¯·æ±‚ï¼Œç¦»çº¿ç¼“å­˜ manifestï¼Œç¦»çº¿æ•°æ®ç¼“å­˜localStorageã€‚ æ¸²æŸ“ï¼šJS/CSSä¼˜åŒ–ï¼ŒåŠ è½½é¡ºåºï¼ŒæœåŠ¡ç«¯æ¸²æŸ“ï¼Œpipelineã€‚ GETå’ŒPOSTçš„åŒºåˆ« getå‚æ•°é€šè¿‡urlä¼ é€’ï¼Œpostæ”¾åœ¨request bodyä¸­ã€‚ getè¯·æ±‚åœ¨urlä¸­ä¼ é€’çš„å‚æ•°æ˜¯æœ‰é•¿åº¦é™åˆ¶çš„ï¼Œè€Œpostæ²¡æœ‰ã€‚ getæ¯”postæ›´ä¸å®‰å…¨ï¼Œå› ä¸ºå‚æ•°ç›´æ¥æš´éœ²åœ¨urlä¸­ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨æ¥ä¼ é€’æ•æ„Ÿä¿¡æ¯ã€‚ getè¯·æ±‚åªèƒ½è¿›è¡Œurlç¼–ç ï¼Œè€Œpostæ”¯æŒå¤šç§ç¼–ç æ–¹å¼ getè¯·æ±‚ä¼šæµè§ˆå™¨ä¸»åŠ¨cacheï¼Œè€Œpostæ”¯æŒå¤šç§ç¼–ç æ–¹å¼ã€‚ getè¯·æ±‚å‚æ•°ä¼šè¢«å®Œæ•´ä¿ç•™åœ¨æµè§ˆå†å²è®°å½•é‡Œï¼Œè€Œpostä¸­çš„å‚æ•°ä¸ä¼šè¢«ä¿ç•™ã€‚ GETå’ŒPOSTæœ¬è´¨ä¸Šå°±æ˜¯TCPé“¾æ¥ï¼Œå¹¶æ— å·®åˆ«ã€‚ä½†æ˜¯ç”±äºHTTPçš„è§„å®šå’Œæµè§ˆå™¨/æœåŠ¡å™¨çš„é™åˆ¶ï¼Œå¯¼è‡´ä»–ä»¬åœ¨åº”ç”¨è¿‡ç¨‹ä¸­ä½“ç°å‡ºä¸€äº›ä¸åŒã€‚ GETäº§ç”Ÿä¸€ä¸ªTCPæ•°æ®åŒ…ï¼›POSTäº§ç”Ÿä¸¤ä¸ªTCPæ•°æ®åŒ…ã€‚ æµè§ˆå™¨æ¸²æŸ“åŸç†ï¼Ÿ 1ï¼‰é¦–å…ˆè§£ææ”¶åˆ°çš„æ–‡æ¡£ï¼Œæ ¹æ®æ–‡æ¡£å®šä¹‰æ„å»ºä¸€æ£µ DOM æ ‘ï¼ŒDOM æ ‘æ˜¯ç”± DOM å…ƒç´ åŠå±æ€§èŠ‚ç‚¹ç»„æˆçš„ã€‚ 2ï¼‰ç„¶åå¯¹ CSS è¿›è¡Œè§£æï¼Œç”Ÿæˆ CSSOM è§„åˆ™æ ‘ã€‚ ï¼ˆ3ï¼‰æ ¹æ® DOM æ ‘å’Œ CSSOM è§„åˆ™æ ‘æ„å»ºæ¸²æŸ“æ ‘ã€‚æ¸²æŸ“æ ‘çš„èŠ‚ç‚¹è¢«ç§°ä¸ºæ¸²æŸ“å¯¹è±¡ï¼Œæ¸²æŸ“å¯¹è±¡æ˜¯ä¸€ä¸ªåŒ…å«æœ‰é¢œè‰²å’Œå¤§å°ç­‰å±æ€§çš„çŸ© å½¢ï¼Œæ¸²æŸ“å¯¹è±¡å’Œ DOM å…ƒç´ ç›¸å¯¹åº”ï¼Œä½†è¿™ç§å¯¹åº”å…³ç³»ä¸æ˜¯ä¸€å¯¹ä¸€çš„ï¼Œä¸å¯è§çš„ DOM å…ƒç´ ä¸ä¼šè¢«æ’å…¥æ¸²æŸ“æ ‘ã€‚è¿˜æœ‰ä¸€äº› DOM å…ƒç´ å¯¹åº”å‡ ä¸ªå¯è§å¯¹è±¡ï¼Œå®ƒä»¬ä¸€èˆ¬æ˜¯ä¸€äº›å…·æœ‰å¤æ‚ç»“æ„çš„å…ƒç´ ï¼Œæ— æ³•ç”¨ä¸€ä¸ªçŸ©å½¢æ¥æè¿°ã€‚ ï¼ˆ4ï¼‰å½“æ¸²æŸ“å¯¹è±¡è¢«åˆ›å»ºå¹¶æ·»åŠ åˆ°æ ‘ä¸­ï¼Œå®ƒä»¬å¹¶æ²¡æœ‰ä½ç½®å’Œå¤§å°ï¼Œæ‰€ä»¥å½“æµè§ˆå™¨ç”Ÿæˆæ¸²æŸ“æ ‘ä»¥åï¼Œå°±ä¼šæ ¹æ®æ¸²æŸ“æ ‘æ¥è¿›è¡Œå¸ƒå±€ï¼ˆä¹Ÿ å¯ä»¥å«åšå›æµï¼‰ã€‚è¿™ä¸€é˜¶æ®µæµè§ˆå™¨è¦åšçš„äº‹æƒ…æ˜¯è¦å¼„æ¸…æ¥šå„ä¸ªèŠ‚ç‚¹åœ¨é¡µé¢ä¸­çš„ç¡®åˆ‡ä½ç½®å’Œå¤§å°ã€‚é€šå¸¸è¿™ä¸€è¡Œä¸ºä¹Ÿè¢«ç§°ä¸ºâ€œè‡ªåŠ¨ é‡æ’â€ã€‚ ï¼ˆ5ï¼‰å¸ƒå±€é˜¶æ®µç»“æŸåæ˜¯ç»˜åˆ¶é˜¶æ®µï¼Œéå†æ¸²æŸ“æ ‘å¹¶è°ƒç”¨æ¸²æŸ“å¯¹è±¡çš„ paint æ–¹æ³•å°†å®ƒä»¬çš„å†…å®¹æ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼Œç»˜åˆ¶ä½¿ç”¨ UI åŸºç¡€ç»„ ä»¶ã€‚ è¾“å…¥urlä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ DNSè§£æâ€“TCPè¿æ¥â€“å‘é€HTTPè¯·æ±‚â€“æœåŠ¡å™¨å¤„ç†è¯·æ±‚å¹¶è¿”å›HTTPæŠ¥æ–‡â€“æµè§ˆå™¨è§£ææ¸²æŸ“é¡µé¢â€“è¿æ¥ç»“æŸ è¾“å…¥urlåï¼Œé¦–å…ˆéœ€è¦æ‰¾åˆ°è¿™ä¸ªurlåŸŸåçš„æœåŠ¡å™¨ip,ä¸ºäº†å¯»æ‰¾è¿™ä¸ªipï¼Œæµè§ˆå™¨é¦–å…ˆä¼šå¯»æ‰¾ç¼“å­˜ï¼ŒæŸ¥çœ‹ç¼“å­˜ä¸­æ˜¯å¦æœ‰è®°å½•ï¼Œç¼“å­˜çš„æŸ¥æ‰¾è®°å½•ä¸ºï¼šæµè§ˆå™¨ç¼“å­˜-ã€‹ç³»ç»Ÿç¼“å­˜-ã€‹è·¯ç”±å™¨ç¼“å­˜ï¼Œç¼“å­˜ä¸­æ²¡æœ‰åˆ™æŸ¥æ‰¾ç³»ç»Ÿçš„hostsæ–‡ä»¶ä¸­æ˜¯å¦æœ‰è®°å½•ï¼Œå¦‚æœæ²¡æœ‰åˆ™æŸ¥è¯¢DNSæœåŠ¡å™¨ï¼Œå¾—åˆ°æœåŠ¡å™¨çš„ipåœ°å€åï¼Œæµè§ˆå™¨æ ¹æ®è¿™ä¸ªipä»¥åŠç›¸åº”çš„ç«¯å£å·ï¼Œæ„é€ ä¸€ä¸ªhttpè¯·æ±‚ï¼Œè¿™ä¸ªè¯·æ±‚æŠ¥æ–‡ä¼šåŒ…æ‹¬è¿™æ¬¡è¯·æ±‚çš„ä¿¡æ¯ï¼Œä¸»è¦æ˜¯è¯·æ±‚æ–¹æ³•ï¼Œè¯·æ±‚è¯´æ˜å’Œè¯·æ±‚é™„å¸¦çš„æ•°æ®ï¼Œå¹¶å°†è¿™ä¸ªhttpè¯·æ±‚å°è£…åœ¨ä¸€ä¸ªtcpåŒ…ä¸­ï¼Œè¿™ä¸ªtcpåŒ…ä¼šä¾æ¬¡ç»è¿‡ä¼ è¾“å±‚ï¼Œç½‘ç»œå±‚ï¼Œæ•°æ®é“¾è·¯å±‚ï¼Œç‰©ç†å±‚åˆ°è¾¾æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨è§£æè¿™ä¸ªè¯·æ±‚æ¥ä½œå‡ºå“åº”ï¼Œè¿”å›ç›¸åº”çš„htmlç»™æµè§ˆå™¨ï¼Œå› ä¸ºhtmlæ˜¯ä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œæµè§ˆå™¨æ ¹æ®è¿™ä¸ªhtmlæ¥æ„å»ºDOMæ ‘ï¼Œåœ¨domæ ‘çš„æ„å»ºè¿‡ç¨‹ä¸­å¦‚æœé‡åˆ°JSè„šæœ¬å’Œå¤–éƒ¨JSè¿æ¥ï¼Œåˆ™ä¼šåœæ­¢æ„å»ºDOMæ ‘æ¥æ‰§è¡Œå’Œä¸‹è½½ç›¸åº”çš„ä»£ç ï¼Œè¿™ä¼šé€ æˆé˜»å¡ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæ¨èJSä»£ç åº”è¯¥æ”¾åœ¨htmlä»£ç çš„åé¢ï¼Œä¹‹åæ ¹æ®å¤–éƒ¨å¤®è§†ï¼Œå†…éƒ¨å¤®è§†ï¼Œå†…è”æ ·å¼æ„å»ºä¸€ä¸ªCSSå¯¹è±¡æ¨¡å‹æ ‘CSSOMæ ‘ï¼Œæ„å»ºå®Œæˆåå’ŒDOMæ ‘åˆå¹¶ä¸ºæ¸²æŸ“æ ‘ï¼Œè¿™é‡Œä¸»è¦åšçš„æ˜¯æ’é™¤éè§†è§‰èŠ‚ç‚¹ï¼Œæ¯”å¦‚scriptï¼Œmetaæ ‡ç­¾å’Œæ’é™¤displayä¸ºnoneçš„èŠ‚ç‚¹ï¼Œä¹‹åè¿›è¡Œå¸ƒå±€ï¼Œå¸ƒå±€ä¸»è¦æ˜¯ç¡®å®šå„ä¸ªå…ƒç´ çš„ä½ç½®å’Œå°ºå¯¸ï¼Œä¹‹åæ˜¯æ¸²æŸ“é¡µé¢ï¼Œå› ä¸ºhtmlæ–‡ä»¶ä¸­ä¼šå«æœ‰å›¾ç‰‡ï¼Œè§†é¢‘ï¼ŒéŸ³é¢‘ç­‰èµ„æºï¼Œåœ¨è§£æDOMçš„è¿‡ç¨‹ä¸­ï¼Œé‡åˆ°è¿™äº›éƒ½ä¼šè¿›è¡Œå¹¶è¡Œä¸‹è½½ï¼Œæµè§ˆå™¨å¯¹æ¯ä¸ªåŸŸçš„å¹¶è¡Œä¸‹è½½æ•°é‡æœ‰ä¸€å®šçš„é™åˆ¶ï¼Œä¸€èˆ¬æ˜¯4-6ä¸ªï¼Œå½“ç„¶åœ¨è¿™äº›æ‰€æœ‰çš„è¯·æ±‚ä¸­æˆ‘ä»¬è¿˜éœ€è¦å…³æ³¨çš„å°±æ˜¯ç¼“å­˜ï¼Œç¼“å­˜ä¸€èˆ¬é€šè¿‡Cache-Controlã€Last-Modifyã€Expiresç­‰é¦–éƒ¨å­—æ®µæ§åˆ¶ã€‚ Cache-Controlå’ŒExpiresçš„åŒºåˆ«åœ¨äºCache-Controlä½¿ç”¨ç›¸å¯¹æ—¶é—´ï¼ŒExpiresä½¿ç”¨çš„æ˜¯åŸºäºæœåŠ¡å™¨ ç«¯çš„ç»å¯¹æ—¶é—´ï¼Œå› ä¸ºå­˜åœ¨æ—¶å·®é—®é¢˜ï¼Œä¸€èˆ¬é‡‡ç”¨Cache-Controlï¼Œåœ¨è¯·æ±‚è¿™äº›æœ‰è®¾ç½®äº†ç¼“å­˜çš„æ•°æ®æ—¶ï¼Œä¼šå…ˆ æŸ¥çœ‹æ˜¯å¦è¿‡æœŸï¼Œå¦‚æœæ²¡æœ‰è¿‡æœŸåˆ™ç›´æ¥ä½¿ç”¨æœ¬åœ°ç¼“å­˜ï¼Œè¿‡æœŸåˆ™è¯·æ±‚å¹¶åœ¨æœåŠ¡å™¨æ ¡éªŒæ–‡ä»¶æ˜¯å¦ä¿®æ”¹ï¼Œå¦‚æœä¸Šä¸€æ¬¡ å“åº”è®¾ç½®äº†ETagå€¼ä¼šåœ¨è¿™æ¬¡è¯·æ±‚çš„æ—¶å€™ä½œä¸ºIf-None-Matchçš„å€¼äº¤ç»™æœåŠ¡å™¨æ ¡éªŒï¼Œå¦‚æœä¸€è‡´ï¼Œç»§ç»­æ ¡éªŒ Last-Modifiedï¼Œæ²¡æœ‰è®¾ç½®ETagåˆ™ç›´æ¥éªŒè¯Last-Modifiedï¼Œå†å†³å®šæ˜¯å¦è¿”å›304 æè¿°ä¸€ä¸‹XSSå’ŒCRSFæ”»å‡»ï¼Ÿé˜²å¾¡æ–¹æ³•ï¼Ÿ XSS, å³ä¸ºï¼ˆCross Site Scriptingï¼‰, ä¸­æ–‡åä¸ºè·¨ç«™è„šæœ¬, æ˜¯å‘ç”Ÿåœ¨ç›®æ ‡ç”¨æˆ·çš„æµè§ˆå™¨å±‚é¢ä¸Šçš„ï¼Œå½“æ¸²æŸ“DOMæ ‘çš„è¿‡ç¨‹æˆå‘ç”Ÿäº†ä¸åœ¨é¢„æœŸå†…æ‰§è¡Œçš„JSä»£ç æ—¶ï¼Œå°±å‘ç”Ÿäº†XSSæ”»å‡»ã€‚å¤§å¤šæ•°XSSæ”»å‡»çš„ä¸»è¦æ–¹å¼æ˜¯åµŒå…¥ä¸€æ®µè¿œç¨‹æˆ–è€…ç¬¬ä¸‰æ–¹åŸŸä¸Šçš„JSä»£ç ã€‚å®é™…ä¸Šæ˜¯åœ¨ç›®æ ‡ç½‘ç«™çš„ä½œç”¨åŸŸä¸‹æ‰§è¡Œäº†è¿™æ®µjsä»£ç ã€‚ CSRFï¼ˆCross Site Request Forgeryï¼Œè·¨ç«™è¯·æ±‚ä¼ªé€ ï¼‰ï¼Œå­—é¢ç†è§£æ„æ€å°±æ˜¯åœ¨åˆ«çš„ç«™ç‚¹ä¼ªé€ äº†ä¸€ä¸ªè¯·æ±‚ã€‚ä¸“ä¸šæœ¯è¯­æ¥è¯´å°±æ˜¯åœ¨å—å®³è€…è®¿é—®ä¸€ä¸ªç½‘ç«™æ—¶ï¼Œå…¶ Cookie è¿˜æ²¡æœ‰è¿‡æœŸçš„æƒ…å†µä¸‹ï¼Œæ”»å‡»è€…ä¼ªé€ ä¸€ä¸ªé“¾æ¥åœ°å€å‘é€å—å®³è€…å¹¶æ¬ºéª—è®©å…¶ç‚¹å‡»ï¼Œä»è€Œå½¢æˆ CSRF æ”»å‡»ã€‚ XSSé˜²å¾¡çš„æ€»ä½“æ€è·¯æ˜¯ï¼šå¯¹è¾“å…¥(å’ŒURLå‚æ•°)è¿›è¡Œè¿‡æ»¤ï¼Œå¯¹è¾“å‡ºè¿›è¡Œç¼–ç ã€‚ä¹Ÿå°±æ˜¯å¯¹æäº¤çš„æ‰€æœ‰å†…å®¹è¿›è¡Œè¿‡æ»¤ï¼Œå¯¹urlä¸­çš„å‚æ•°è¿›è¡Œè¿‡æ»¤ï¼Œè¿‡æ»¤æ‰ä¼šå¯¼è‡´è„šæœ¬æ‰§è¡Œçš„ç›¸å…³å†…å®¹ï¼›ç„¶åå¯¹åŠ¨æ€è¾“å‡ºåˆ°é¡µé¢çš„å†…å®¹è¿›è¡Œhtmlç¼–ç ï¼Œä½¿è„šæœ¬æ— æ³•åœ¨æµè§ˆå™¨ä¸­æ‰§è¡Œã€‚è™½ç„¶å¯¹è¾“å…¥è¿‡æ»¤å¯ä»¥è¢«ç»•è¿‡ï¼Œä½†æ˜¯ä¹Ÿè¿˜æ˜¯ä¼šæ‹¦æˆªå¾ˆå¤§ä¸€éƒ¨åˆ†çš„XSSæ”»å‡»ã€‚ é˜²å¾¡CSRF æ”»å‡»ä¸»è¦æœ‰ä¸‰ç§ç­–ç•¥ï¼šéªŒè¯ HTTP Referer å­—æ®µï¼›åœ¨è¯·æ±‚åœ°å€ä¸­æ·»åŠ  token å¹¶éªŒè¯ï¼›åœ¨ HTTP å¤´ä¸­è‡ªå®šä¹‰å±æ€§å¹¶éªŒè¯ã€‚","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Weekly Contest 178 ğŸ†","slug":"contest04","date":"2020-03-01T04:02:09.000Z","updated":"2020-03-01T05:12:12.726Z","comments":true,"path":"2020/02/29/contest04/","link":"","permalink":"WangHngLeee.github.io/2020/02/29/contest04/","excerpt":"1351. Count Negative Numbers in a Sorted Matrix ğŸ”—Question Link My solution class Solution &#123; public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] res = new int[nums.length]; if(nums == null || nums.length == 0)return res; for(int i = 0 ;i&lt;nums.length;i++)&#123; int count = 0; for(int j = 0;j&lt;nums.length;j++)&#123; if(j == i)continue; if(nums[j]&lt;nums[i])count++; &#125; res[i] = count; &#125; return res; &#125;&#125; brute forceã€‚","text":"1351. Count Negative Numbers in a Sorted Matrix ğŸ”—Question Link My solution class Solution &#123; public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] res = new int[nums.length]; if(nums == null || nums.length == 0)return res; for(int i = 0 ;i&lt;nums.length;i++)&#123; int count = 0; for(int j = 0;j&lt;nums.length;j++)&#123; if(j == i)continue; if(nums[j]&lt;nums[i])count++; &#125; res[i] = count; &#125; return res; &#125;&#125; brute forceã€‚ 1366. Rank Teams by Votes ğŸ”—Question Link class Solution &#123; public String rankTeams(String[] votes) &#123; Map&lt;Character, int[]&gt; map = new HashMap&lt;&gt;(); int len = votes[0].length(); for(String vote : votes)&#123; for(int i = 0; i &lt; len; i++)&#123; if(!map.containsKey(vote.charAt(i)))&#123; map.put(vote.charAt(i), new int[len]); &#125; map.get(vote.charAt(i))[i]++; &#125; &#125; PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt; &#123; for(int i = 0 ;i&lt;len ;i++)&#123; if(map.get(a)[i] != map.get(b)[i])&#123; return map.get(b)[i] - map.get(a)[i]; &#125; &#125; return a-b; &#125;); for(Character ch : map.keySet())&#123; pq.add(ch); &#125; StringBuilder sb = new StringBuilder(); while(!pq.isEmpty())&#123; sb.append(pq.poll()); &#125; return sb.toString(); &#125;&#125; ä¸ºæ¯ä¸ªcharå»ºä¸€ä¸ªé•¿åº¦ä¸ºvote.length()çš„æ•°ç»„ï¼Œç”¨æ¥å­˜è¯¥charåœ¨æ¯ä¸ªpositionçš„freqã€‚ç„¶åç”¨pqæ¥matchæœ€åˆé€‚çš„ï¼Œæ”¾åˆ°æœ€å‰ï¼Œç„¶åä¾æ¬¡pollåŠ å…¥stringbuilderè¿”å›ã€‚ 1367. Linked List in Binary Tree ğŸ”—Question Link class Solution &#123; public boolean isSubPath(ListNode head, TreeNode root) &#123; if(root == null)return false; return check(root,head) || isSubPath(head,root.left) || isSubPath(head,root.right); &#125; public boolean check(TreeNode root, ListNode head)&#123; if(head == null)return true; if(head == null || root == null)return false; if(head == null &amp;&amp; root == null)return true; if(head.val != root.val)return false; return check(root.left,head.next) || check(root.right,head.next); &#125;&#125; å’Œ542ä¸€æ ·çš„æ€è·¯ã€‚åªæœ‰å½“headå’Œrootéƒ½ä¸ºnullæ—¶å¯ä»¥ä¸ºtrueï¼Œå…ˆæ£€æŸ¥å½“å‰rootå’Œheadæˆ–è€…å¯¹leftå’Œrightåˆ†åˆ«è¿›è¡Œé€’å½’è°ƒç”¨ã€‚åœ¨checkå‡½æ•°é‡Œä¹Ÿæ˜¯è¦å¯¹leftå’Œrightä¸¤ç§æƒ…å†µéƒ½è€ƒè™‘ï¼Œè¿”å›ï½œï½œå€¼å°±å¯ä»¥äº†ã€‚","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 85 ğŸ’ª","slug":"chin-up-23","date":"2020-02-29T16:13:23.000Z","updated":"2020-02-29T21:37:14.536Z","comments":true,"path":"2020/02/29/chin-up-23/","link":"","permalink":"WangHngLeee.github.io/2020/02/29/chin-up-23/","excerpt":"875. Koko Eating Bananas ğŸ”—Question Link class Solution &#123; public int minEatingSpeed(int[] piles, int H) &#123; if(piles == null || piles.length == 0)return -1; int start = 1; int end = getmax(piles); while(start + 1 &lt; end)&#123; int mid = start + ( end - start)/2; if(caneatall(piles,H,mid))end = mid; else&#123; start = mid; &#125; &#125; if(caneatall(piles,H,start))return start; else return end; &#125; public boolean caneatall(int[] piles, int H, int start)&#123; int count = 0; for(int pile : piles)&#123; count+=pile/start; if(pile%start!=0)count++; &#125; return count&lt;= H; &#125; public int getmax(int[]piles)&#123; int max = Integer.MIN_VALUE; for(int pile : piles)&#123; if(pile &gt; max)&#123; max = pile; &#125; &#125; return max; &#125;&#125; äºŒåˆ†å‘æ‰¾per hourçš„æ¶ˆè€—é‡ã€‚å…ˆæ‰¾åˆ°pilesé‡Œæœ€å¤§å€¼ä½œä¸ºæ¶ˆè€—é€Ÿç‡ï¼Œåˆ¤æ–­å½“å‰rateèƒ½å¦åœ¨ç»™å®šå°æ—¶å†…æ¶ˆè€—å®Œæ‰€æœ‰pilesã€‚å¦‚æœå¯ä»¥åˆ™å°†rateé™ä½1ï¼Œå¦‚æ­¤å¾ªç¯æ‰¾åˆ°æœ€å°å€¼ã€‚","text":"875. Koko Eating Bananas ğŸ”—Question Link class Solution &#123; public int minEatingSpeed(int[] piles, int H) &#123; if(piles == null || piles.length == 0)return -1; int start = 1; int end = getmax(piles); while(start + 1 &lt; end)&#123; int mid = start + ( end - start)/2; if(caneatall(piles,H,mid))end = mid; else&#123; start = mid; &#125; &#125; if(caneatall(piles,H,start))return start; else return end; &#125; public boolean caneatall(int[] piles, int H, int start)&#123; int count = 0; for(int pile : piles)&#123; count+=pile/start; if(pile%start!=0)count++; &#125; return count&lt;= H; &#125; public int getmax(int[]piles)&#123; int max = Integer.MIN_VALUE; for(int pile : piles)&#123; if(pile &gt; max)&#123; max = pile; &#125; &#125; return max; &#125;&#125; äºŒåˆ†å‘æ‰¾per hourçš„æ¶ˆè€—é‡ã€‚å…ˆæ‰¾åˆ°pilesé‡Œæœ€å¤§å€¼ä½œä¸ºæ¶ˆè€—é€Ÿç‡ï¼Œåˆ¤æ–­å½“å‰rateèƒ½å¦åœ¨ç»™å®šå°æ—¶å†…æ¶ˆè€—å®Œæ‰€æœ‰pilesã€‚å¦‚æœå¯ä»¥åˆ™å°†rateé™ä½1ï¼Œå¦‚æ­¤å¾ªç¯æ‰¾åˆ°æœ€å°å€¼ã€‚ 1011. Capacity To Ship Packages Within D Days ğŸ”—Question Link class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; if(weights == null || weights.length == 0)return -1; int left= 0; int right = 0; for(int w : weights)&#123; left = Math.max(left,w); right+=w; &#125; while(left &lt; right)&#123; int mid = left + (right-left)/2; int cur = 0; int need = 1; for(int w : weights)&#123; if(cur+w &gt; mid)&#123; need++; cur = 0; &#125; cur+=w; &#125; if(need &gt; D)left = mid + 1; else right = mid; &#125; return left; &#125;&#125; æœ‰è¶£çš„ä¸€é“é¢˜ã€‚rightä¸Šé™ä¸ºè´§ç‰©æ€»é‡ï¼Œç„¶åäºŒåˆ†æ‰¾åœ¨ç»™å®šå¤©æ•°å†…æ¬å®Œæ‰€æœ‰çš„æœ€å°æ—¥å‡é‡ã€‚é¦–å…ˆå®šä¹‰curæ¥å­˜æš‚æ—¶çš„æ€»æ¬è¿é‡ï¼Œå¦‚æœå¤§äºäº†å‡å®šçš„midå€¼ï¼Œåˆ™éœ€è¦å¤šä¸€å¤©ï¼Œå¹¶ä¸”é‡æ–°å½’é›¶curå€¼ï¼Œè¿›è¡Œä¸‹ä¸€æ¬¡ï¼Œå¦åˆ™curä¸€ç›´å¢åŠ ã€‚æœ€ååˆ¤æ–­éœ€è¦çš„å¤©æ•°å’ŒDçš„å…³ç³»å³å¯ã€‚ 33. Search in Rotated Sorted Array ğŸ”—Question Link class Solution &#123; public int search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int len = nums.length; int left = 0; int right = len-1; while(left+1 &lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &gt;= nums[left])&#123; if(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125;else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if (nums[mid] == target) return mid; &#125; if(nums[left] == target)return left; else if (nums[right] == target) return right; else return -1; &#125;&#125; ç¬¬å››éã€‚ç”¨æ–°äºŒåˆ†æ¨¡ç‰ˆå†™ä¸€ä¸‹ã€‚ 81. Search in Rotated Sorted Array II ğŸ”—Question Link class Solution &#123; public boolean search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return false; int len = nums.length; int left = 0; int right = len-1; while(left+1 &lt; right)&#123; int mid = left + (right - left)/2; if (nums[mid] == target) return true; else if(nums[mid] &gt; nums[left])&#123; if(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125;else if(nums[left]==nums[mid])&#123; left++; &#125; else if(nums[right] == nums[mid])&#123; right--; &#125;else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; &#125; if(nums[left] == target)return true; else if (nums[right] == target) return true; else return false; &#125;&#125; å¤šäº†é‡å¤çš„æ•°å­—ï¼Œè¦æ£€æŸ¥midå’Œleft rightã€‚å…¶ä»–ä¸å˜ã€‚ 153. Find Minimum in Rotated Sorted Array ğŸ”—Question Link class Solution &#123; public int findMin(int[] nums) &#123; if(nums == null || nums.length == 0)return -1; int start = 0; int end = nums.length -1; while(start + 1 &lt;end)&#123; int mid = start + (end - start)/2; if(nums[mid] &gt; nums[end])&#123; start = mid; &#125;else&#123; end = mid; &#125; &#125; if(nums[start] &lt; nums[end])return nums[start]; else&#123; return nums[end]; &#125; &#125;&#125; æ¯æ¬¡åˆ°æ›´å°çš„ä¸€éƒ¨åˆ†ç»§ç»­äºŒåˆ†ã€‚ 154. Find Minimum in Rotated Sorted Array II ğŸ”—Question Link class Solution &#123; public int findMin(int[] nums) &#123; int left = 0; int right = nums.length -1; while(left + 1 &lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else if (nums[mid] &gt; nums[right])&#123; left = mid; &#125;else&#123; right--; &#125; &#125; if(nums[left] &lt; nums[right])return nums[left]; else return nums[right]; &#125;&#125; duplicateå­˜åœ¨ã€‚ç”±äºsortedï¼Œæ‰€ä»¥æ¯æ¬¡åªå¯¹nums[right]æ£€æŸ¥ã€‚ 162. Find Peak Element ğŸ”—Question Link 852. Peak Index in a Mountain Array ğŸ”—Question Link class Solution &#123; public int findPeakElement(int[] nums) &#123; if(nums == null || nums.length == 0)return -1; int left = 0; int right = nums.length -1; while(left + 1&lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[mid + 1])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if(nums[left]&gt;nums[right])return left; else return right; &#125;&#125; è¿™ä¸¤é“é¢˜ä¸€æ ·çš„solutionã€‚æ”¾ä¸€èµ·äº†ã€‚ æ¯æ¬¡å¯¹midå’Œmid+1æ¯”è¾ƒã€‚æ›´æ–°å·¦å³è¾¹ç•Œå³å¯ã€‚ 74. Search a 2D Matrix ğŸ”—Question Link class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length == 0)return false; if(matrix[0].length == 0)return false; int row = matrix.length; int col = matrix[0].length; int start = 0; int end = row*col-1; while(start + 1&lt; end)&#123; int mid = start + (end - start)/2; if(matrix[mid/col][mid%col] == target)return true; else if (matrix[mid/col][mid%col] &lt; target)start = mid; else&#123; end = mid; &#125; &#125; if(matrix[start/col][start%col] == target)return true; else if (matrix[end/col][end%col] == target)return true; else return false; &#125;&#125; ç¬¬äº”éã€‚å½“æˆä¸€ä¸ªæ•°ç»„äºŒåˆ†æŸ¥æ‰¾ã€‚æ³¨æ„colå’Œæ•°ç»„indexçš„å…³ç³»ã€‚éƒ½ç”¨colæ¥æ¯”è¾ƒã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"}]},{"title":"Leetcode EveryDay 84 ğŸ’ª","slug":"chin-up-22","date":"2020-02-28T18:13:23.000Z","updated":"2020-02-29T19:56:47.102Z","comments":true,"path":"2020/02/28/chin-up-22/","link":"","permalink":"WangHngLeee.github.io/2020/02/28/chin-up-22/","excerpt":"ğŸ“Œç…ç†¬çš„midtermå‘¨è¿‡å»äº†ï¼Œåˆå¯ä»¥å¼€å¿ƒçš„åˆ·é¢˜äº†(å¹¶æ²¡æœ‰) 784. Letter Case Permutation ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String str : queue)&#123; res.add(str); &#125; return res; &#125;&#125; å›æº¯ï¼Œæ¯æ¬¡æ”¹å®Œä¸€ä¸ªå­—æ¯è¦æŠŠåŸæ¥ä½†å˜ä¼šå°å†™åŠ å›queueã€‚","text":"ğŸ“Œç…ç†¬çš„midtermå‘¨è¿‡å»äº†ï¼Œåˆå¯ä»¥å¼€å¿ƒçš„åˆ·é¢˜äº†(å¹¶æ²¡æœ‰) 784. Letter Case Permutation ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String str : queue)&#123; res.add(str); &#125; return res; &#125;&#125; å›æº¯ï¼Œæ¯æ¬¡æ”¹å®Œä¸€ä¸ªå­—æ¯è¦æŠŠåŸæ¥ä½†å˜ä¼šå°å†™åŠ å›queueã€‚ 301. Remove Invalid Parentheses ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); Set&lt;String&gt; seen = new HashSet&lt;&gt;(); queue.add(s); seen.add(s); boolean found = false; while(!queue.isEmpty())&#123; String str = queue.poll(); if(isvalid(str))&#123; res.add(str); found = true; &#125; if(found)continue; for(int i = 0 ;i&lt;str.length();i++)&#123; if(str.charAt(i) != ')' &amp;&amp; str.charAt(i) != '(')continue; String temp = str.substring(0,i) + str.substring(i); if(!seen.contains(temp))&#123; queue.add(temp); seen.add(temp); &#125; &#125; &#125; return res; &#125; public boolean isvalid(String s)&#123; int count = 0; for(int i=0 ;i&lt;s.length();i++)&#123; char c = s.charAt(i); if (c == '(') count++; if (c == ')' &amp;&amp; count-- == 0) return false; &#125; return count == 0; &#125;&#125; BFSæ€è·¯ã€‚æ³¨æ„isvalidçš„åˆ¤æ–­æ¡ä»¶ã€‚ 35. Search Insert Position ğŸ”—Question Link class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int start = 0; int end = nums.length -1; while(start + 1&lt; end)&#123; int mid = start + (end - start)/2; if(nums[mid] == target)return mid; else if(nums[mid] &lt; target)&#123; start = mid; &#125;else&#123; end = mid; &#125; &#125; if(nums[start] &gt;= target)return start; else if (nums[end] &gt;= target)return end; else return end + 1; &#125;&#125; ç»å…¸äºŒåˆ†æ¨¡ç‰ˆã€‚ 34. Find First and Last Position of Element in Sorted Array ğŸ”—Question Link class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return new int[]&#123;-1,-1&#125;; int[] res = new int[2]; int start = 0; int end = nums.length-1; while(start + 1&lt; end)&#123; int mid = start + ( end - start )/2 ; if(nums[mid] == target)end = mid; else if(nums[mid] &gt; target)end = mid; else if(nums[mid] &lt; target)start = mid; &#125; if(nums[start] == target)res[0] = start; else if(nums[end] == target)res[0] = end; else&#123; res[0] = -1; res[1] = -1; return res; &#125; start = 0; end = nums.length-1; while(start + 1&lt; end)&#123; int mid = start + ( end - start )/2 ; if(nums[mid] == target)start = mid; else if(nums[mid] &gt; target)end = mid; else if(nums[mid] &lt; target)start = mid; &#125; if(nums[end] == target)res[1] = end; else if(nums[start] == target)res[1] = start; else&#123; res[0] = -1; res[1] = -1; return res; &#125; return res; &#125;&#125; ä¸¤æ¬¡äºŒåˆ†ï¼Œæ‰¾ä¸¤ä¸ªä½ç½®ã€‚æ³¨æ„äºŒåˆ†æ–°å†™æ³•æœ€ååˆ¤æ–­startå’Œendçš„é¡ºåºã€‚ 981. Time Based Key-Value Store ğŸ”—Question Link class TimeMap &#123; Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map; /** Initialize your data structure here. */ public TimeMap() &#123; map = new HashMap&lt;&gt;(); &#125; public void set(String key, String value, int timestamp) &#123; if(!map.containsKey(key))&#123; map.put(key,new TreeMap&lt;&gt;()); &#125; map.get(key).put(timestamp,value); &#125; public String get(String key, int timestamp) &#123; TreeMap&lt;Integer,String&gt; treemap = map.get(key); if(treemap == null)return \"\"; Integer floor = treemap.floorKey(timestamp); if(floor == null)return \"\"; return treemap.get(floor); &#125;&#125; map + treemapã€‚mapç”¨keyåškeyvalueï¼Œtreemapé‡Œç”¨timestampä½œä¸ºkeyvalueã€‚ treemapé‡ŒfloorKeyè¿”å›&lt;=å½“å‰å€¼çš„keyã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"}]},{"title":"Leetcode EveryDay 83 ğŸ’ª","slug":"chin-up-21","date":"2020-02-21T15:13:23.000Z","updated":"2020-02-28T21:11:47.126Z","comments":true,"path":"2020/02/21/chin-up-21/","link":"","permalink":"WangHngLeee.github.io/2020/02/21/chin-up-21/","excerpt":"968. Binary Tree Cameras ğŸ”—Question Link class Solution &#123; int res = 0; public int minCameraCover(TreeNode root) &#123; return (dfs(root) == 0 ? 1 : 0) + res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 2; int left = dfs(root.left); int right = dfs(root.right); if(left == 0 || right == 0)&#123; res++; return 1; &#125; if(left == 1 || right == 1)&#123; return 2; &#125;else return 0; &#125;&#125; 0 : å¶èŠ‚ç‚¹ã€‚ 1 ï¼š cameraçš„ä½ç½®ã€‚ 2 ï¼š å·¦å³å­æ ‘ä¸­æœ‰cameraï¼Œè¿™ä¸ªä½ç½®è¢«coveräº†ã€‚ å¦‚æœå·¦å³ä¸­æœ‰2ï¼Œåˆ™è¡¨æ˜è¯¥nodeçš„å­©å­ä¸­å·²ç»è¢«coveräº†ï¼Œåˆ™è¯¥nodeå˜ä¸ºæ–°çš„å¶èŠ‚ç‚¹ã€‚","text":"968. Binary Tree Cameras ğŸ”—Question Link class Solution &#123; int res = 0; public int minCameraCover(TreeNode root) &#123; return (dfs(root) == 0 ? 1 : 0) + res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 2; int left = dfs(root.left); int right = dfs(root.right); if(left == 0 || right == 0)&#123; res++; return 1; &#125; if(left == 1 || right == 1)&#123; return 2; &#125;else return 0; &#125;&#125; 0 : å¶èŠ‚ç‚¹ã€‚ 1 ï¼š cameraçš„ä½ç½®ã€‚ 2 ï¼š å·¦å³å­æ ‘ä¸­æœ‰cameraï¼Œè¿™ä¸ªä½ç½®è¢«coveräº†ã€‚ å¦‚æœå·¦å³ä¸­æœ‰2ï¼Œåˆ™è¡¨æ˜è¯¥nodeçš„å­©å­ä¸­å·²ç»è¢«coveräº†ï¼Œåˆ™è¯¥nodeå˜ä¸ºæ–°çš„å¶èŠ‚ç‚¹ã€‚ 337. House Robber III ğŸ”—Question Link class Solution &#123; public int rob(TreeNode root) &#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); return help(root,map); &#125; public int help(TreeNode root, Map&lt;TreeNode,Integer&gt; map)&#123; if(root == null)return 0; int val =0; if(map.containsKey(root))return map.get(root); // memoå‰ªæ if(root.left!=null)&#123; val= val + help(root.left.left,map) + help(root.left.right,map); &#125; if(root.right!=null)&#123; val = val + help(root.right.left,map) + help(root.right.right,map); &#125; val = Math.max(root.val + val,help(root.left,map) + help(root.right,map)); map.put(root,val); return val; &#125;&#125; dfs + memoã€‚å¯¹å½“å‰rootåˆ†ä¸¤ç§æƒ…å†µè®¨è®ºã€‚ å·²ç»è¢«robed ï¼Œåˆ™è·³è¿‡å·¦å³ç›´æ¥å­©å­ï¼Œå»grand nodeï¼Œ root.left.left,root.left.right,root.right.left,root.right.rightã€‚ æœªè¢«robedï¼Œåˆ™å·¦å³ç›´æ¥å­©å­å¯ä»¥ç”¨ã€‚ç›´æ¥æ“ä½œroot.left root.rightå³å¯ã€‚ æœ€åæ¯”è¾ƒä¸¤ç§æƒ…å†µè¿”å›çš„valå€¼å’Œï¼Œå–è¾ƒå¤§å­˜å…¥mapã€‚ åŠ å…¥memoå‰ªæã€‚ 979. Distribute Coins in Binary Tree ğŸ”—Question Link class Solution &#123; int res = 0; public int distributeCoins(TreeNode root) &#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null)return 0; int left = dfs(root.left); int right =dfs(root.right); res += Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; è¦æ±‚å°†æ¯ä¸ªä½ç½®éƒ½å˜ä¸º1ï¼Œå¹¶ä¸”æ¯æ¬¡å˜åŠ¨åªèƒ½ä¼ 1ä¸ªç¡¬å¸ï¼Œæ±‚å˜åŠ¨æ¬¡æ•°ã€‚å…¶å®åè¿‡æ¥æƒ³ï¼Œå¦‚æœæŸä¸ªèŠ‚ç‚¹åŸæ¥ä¸ºx,è¦å˜ä¸º1ï¼Œé‚£ä¹ˆå˜åŠ¨çš„æ•°å€¼å°±æ˜¯x-1çš„ç»å¯¹å€¼ï¼Œä¹Ÿå°±æ˜¯å‘çˆ¶èŠ‚ç‚¹ä¼ é€çš„å€¼æˆ–è€…å‘çˆ¶èŠ‚ç‚¹ç´¢è¦çš„å€¼ï¼Œå³å˜åŠ¨æ¬¡æ•°ï¼Œæœ€åè¿˜è¦ä¿è¯è¯¥èŠ‚ç‚¹å‰©ä¸‹ä¸€ä¸ªç¡¬å¸ï¼Œæ‰€ä»¥è¦æŠŠå·¦å³å­©å­å¯ä»¥åˆ©ç”¨çš„ç¡¬å¸æ•°å…¨éƒ¨ç›¸åŠ ç„¶å-1ï¼Œè¿™äº›å°±æ˜¯è¯¥nodeçš„çˆ¶èŠ‚ç‚¹èƒ½å¤Ÿç”¨åˆ°çš„ç¡¬å¸æ€»æ•°ã€‚ 221. Maximal Square ğŸ”—Question Link class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m+1][n+1]; int max = 0; for(int i=1; i&lt;=m ;i++)&#123; for(int j =1 ; j&lt;=n ;j++)&#123; if(matrix[i-1][j-1] == '1')&#123; dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i][j-1], dp[i-1][j]))+1; max = Math.max(max,dp[i][j]); &#125; &#125; &#125; return max*max; &#125;&#125; dpå­˜å³ä¸‹è§’ä¸º1çš„ä½ç½®é‡Œï¼Œæœ€å¤§çš„æ­£æ–¹å½¢è¾¹é•¿ã€‚ä»1å¼€å§‹å¾ªç¯ï¼Œä¸Šå·¦ä¸‹ä¸‰ä¸ªæ–¹ä½æ‰¾æœ€å°çš„è¾¹é•¿ï¼Œå› ä¸ºå¦‚æœä¸‰ä¸ªæ–¹ä½ä¸æ˜¯1åˆ™æœ€å°çš„ä¸º0ï¼Œä¹Ÿå°±å¤Ÿä¸æˆæ›´å¤§çš„æ­£æ–¹å½¢ã€‚æœ€åæ›´æ–°maxã€‚ 1277. Count Square Submatrices with All Ones ğŸ”—Question Link class Solution &#123; public int countSquares(int[][] matrix) &#123; int res = 0; int m = matrix.length; int n = matrix[0].length; for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0; j&lt;n ;j++)&#123; if(matrix[i][j] == 1)&#123; if(i&gt;0 &amp;&amp; j &gt;0)&#123; matrix[i][j] = Math.min(matrix[i-1][j-1], Math.min(matrix[i][j-1],matrix[i-1][j]))+1; &#125; res+=matrix[i][j]; &#125;else&#123; continue; &#125; &#125; &#125; return res; &#125;&#125; å’Œ221ç±»ä¼¼çš„æ€è·¯ã€‚è¿™é‡Œä»0å¼€å§‹éå†ï¼Œin placeæ”¹å˜matrixã€‚matrix[i][j]å­˜æœ€å¤§çš„æ­£æ–¹å½¢è¾¹é•¿ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä»¥è¯¥ä½ç½®ä¸ºå³ä¸‹è§’çš„æ­£æ–¹å½¢ä¸ªæ•°ã€‚ 1 11 1 æ­¤æ—¶å³ä¸‹è§’çš„matrixå€¼ä¸º2ï¼Œè€Œäºæ­¤åŒæ—¶ä»¥å³ä¸‹è§’çš„1ä¸ºæ­£æ–¹å½¢çš„ä¸ªæ•°ä¹Ÿæ˜¯2ï¼šä¸€ä¸ªå•ç‹¬çš„å³ä¸‹è§’1ï¼Œè‡ªå·±æ„æˆå°æ­£æ–¹å½¢ï¼›ä¸€ä¸ªè¾¹é•¿ä¸º2çš„squareã€‚ 70. Climbing Stairs ğŸ”—Question Link class Solution &#123; public int climbStairs(int n) &#123; int[] dp = new int[n+1]; if(n == 1)return 1; if(n == 2)return 2; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3 ; i&lt;= n ;i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125;&#125; ç»å…¸è´¹çº³æ³¢åˆ‡æ•°åˆ—dpã€‚ 746. Min Cost Climbing Stairs ğŸ”—Question Link class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int first = cost[0]; int second = cost[1]; for(int i = 2; i&lt;cost.length ;i++)&#123; cost[i] = Math.min(first, second) + cost[i]; first = second; second = cost[i]; &#125; return Math.min(first,second); &#125;&#125; ç”±äºæ¯æ¬¡åªèƒ½èµ°1or2ä¸ªï¼Œæ‰€ä»¥ä»ç¬¬ä¸‰ä¸ªå¼€å§‹ï¼Œé€‰å‰é¢ä¸¤ä¸ªä¸­æœ€å°‘çš„ä¸€ä¸ªï¼Œæ›´æ–°firstå’Œsecondçš„å€¼ï¼Œæœ€åè¿”å›äºŒè€…ä¸­çš„minã€‚ 1137. N-th Tribonacci Number ğŸ”—Question Link class Solution &#123; public int tribonacci(int n) &#123; int first = 0, second = 1 , third = 1; for(int i=0;i&lt;n;i++)&#123; int next = first + second + third; first = second; second = third; third = next; &#125; return first; &#125;&#125; æ€è·¯å’Œä¸Šä¸€é“é¢˜å¾ˆåƒï¼Œéƒ½æ˜¯åªèƒ½èµ°å›ºå®šæ­¥æ•°ã€‚ç„¶åä¸æ–­è¿­ä»£æ›´æ–°å€¼ï¼Œæœ€åè¿”å›firstã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Leetcode EveryDay 82 ğŸ’ª","slug":"chin-up-20","date":"2020-02-18T17:13:23.000Z","updated":"2020-02-18T19:53:12.899Z","comments":true,"path":"2020/02/18/chin-up-20/","link":"","permalink":"WangHngLeee.github.io/2020/02/18/chin-up-20/","excerpt":"297. Serialize and Deserialize Binary Tree ğŸ”—Question Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial (TreeNode root, StringBuilder sb)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(root.left,sb); serial(root.right,sb); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue); &#125; public TreeNode deserial(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"n\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = deserial(queue); node.right = deserial(queue); return node; &#125;&#125; preorderæ–¹å¼serialã€‚splitä¹‹åå†preorder deserialã€‚","text":"297. Serialize and Deserialize Binary Tree ğŸ”—Question Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial (TreeNode root, StringBuilder sb)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(root.left,sb); serial(root.right,sb); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue); &#125; public TreeNode deserial(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"n\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = deserial(queue); node.right = deserial(queue); return node; &#125;&#125; preorderæ–¹å¼serialã€‚splitä¹‹åå†preorder deserialã€‚ 449. Serialize and Deserialize BST ğŸ”—Question Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial(TreeNode root, StringBuilder sb)&#123; if(root == null)return; sb.append(root.val).append(\" \"); serial(root.left, sb); serial(root.right, sb); &#125; public TreeNode deserialize(String data)&#123; if(data.isEmpty())return null; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue,Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; public TreeNode deserial(Queue&lt;String&gt; queue,int min, int max)&#123; if(queue.isEmpty())return null; String s = queue.peek(); int val = Integer.parseInt(s); if(val &lt; min || val &gt; max)return null; queue.poll(); TreeNode node = new TreeNode(val); node.left = deserial(queue, min, val); node.right = deserial(queue,val,max); return node; &#125;&#125; ç”±äºæ˜¯BSTï¼Œå¯ä»¥è®¾ç½®ä¸Šä¸‹ç•Œæ¥åœ¨deserialçš„æ—¶å€™åˆ¤å®šæ˜¯å¦ä¸ºnullã€‚å…¶ä½™çš„å’Œä¸Šä¸€é“BTçš„ä¸€æ ·ã€‚ 508. Most Frequent Subtree Sum ğŸ”—Question Link class Solution &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; public int[] findFrequentTreeSum(TreeNode root) &#123; if(root == null)return new int[]&#123;&#125;; dfs(root); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int key : map.keySet())&#123; if(map.get(key) == max)&#123; list.add(key); &#125; &#125; int[] res = new int[list.size()]; for(int i= 0; i&lt; list.size();i++)&#123; res[i] = list.get(i); &#125; return res; &#125; public int dfs(TreeNode root)&#123; if(root == null)return 0; int s = dfs(root.left) + dfs(root.right) + root.val; map.put(s,map.getOrDefault(s,0)+1); max = Math.max(max,map.get(s)); return s; &#125;&#125; map + dfsã€‚mapå­˜sumå’Œæ¬¡æ•°ï¼Œdfséå†æ‰€æœ‰rootå¾—åˆ°æ‰€æœ‰çš„sumæƒ…å†µã€‚ 124. Binary Tree Maximum Path Sum ğŸ”—Question Link class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; ç¬¬å››éã€‚æ³¨æ„leftå’Œrightåœ¨dfsçš„æ—¶å€™è¦è€ƒè™‘è´Ÿæ•°æƒ…å†µï¼Œæ‰€ä»¥è¦å’Œ0å–maxã€‚ 543. Diameter of Binary Tree ğŸ”—Question Link class Solution &#123; int max = 0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return -1; int left = help(root.left) + 1; int right = help(root.right) + 1; max = Math.max(max,left+right); return Math.max(left,right); &#125;&#125; ç¬¬å››éã€‚é¢˜ç›®çš„æ„æ€å°±æ˜¯è¦æ±‚æ‰¾å·¦å³å­æ ‘æœ€å¤§æ·±åº¦å’Œã€‚maxè¦å’Œå·¦å³å’Œæ¯”è¾ƒï¼Œç„¶åè¿”å›å·¦å³çš„æœ€å¤§å€¼ã€‚ 687. Longest Univalue Path ğŸ”—Question Link class Solution &#123; int max = 0; public int longestUnivaluePath(TreeNode root) &#123; if(root == null)return 0; help(root,root.val); return max; &#125; public int help(TreeNode root, int val)&#123; if(root == null)return 0; int left = help(root.left,root.val); int right = help(root.right,root.val); max = Math.max(left+right,max); // we need find the max edges instead of node, so we dont have to +1. if(val == root.val)return Math.max(left,right)+1; else return 0; &#125;&#125; å’Œä¹‹å‰çš„ä¸ä¸€æ ·ï¼Œè¿™é“é¢˜æ˜¯æ‰¾ç›¸åŒçš„nodeä¹‹é—´æœ€å¤§çš„edgeï¼Œæ‰€ä»¥åœ¨æ›´æ–°maxçš„æ—¶å€™left+rightä¸éœ€è¦å†+1äº†ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Weekly Contest 176 ğŸ†","slug":"contest03","date":"2020-02-16T04:02:09.000Z","updated":"2020-03-01T05:12:23.593Z","comments":true,"path":"2020/02/15/contest03/","link":"","permalink":"WangHngLeee.github.io/2020/02/15/contest03/","excerpt":"ğŸ“Œ ä»Šå¤©åšå‡ºæ¥ä¸‰é¢˜ï¼Œä½†æ˜¯æœ€åä¸€é¢˜æ­£å¥½å¡åœ¨æ—¶é—´ç‚¹ä¸Šï¼Œæ²¡æœ‰ç®—è¿›å»ï¼Œä¸è¿‡æ— æ‰€è°“äº†ï¼Œç»§ç»­åŠªåŠ›ã€‚ 1354. Construct Target Array With Multiple Sums ğŸ”—Question Link è¿™é“é¢˜æˆ‘å†™çš„é¢˜è§£voteæ•°é‡åœ¨discussåŒºæ’å‰ä¸‰ My Discuss LinkğŸ”—[Java] Think the problem from the end to start. æ„Ÿè§‰è¿˜æ˜¯æŒºæœ‰æ”¶è·çš„ï¼Œæ€è·¯æŒºæœ‰è¶£ã€‚ My solution class Solution &#123; public boolean isPossible(int[] target) &#123; int max = 0; int index = 0; for(int i= 0; i&lt; target.length ;i++)&#123; if(target[i] &gt; max)&#123; max = target[i]; index = i; &#125; &#125; if(max == 1) return true; for(int i = 0 ;i&lt; target.length ;i++)&#123; if(i == index)continue; if(target[i] &gt; max)return false; max = max - target[i]; &#125; target[index] = max; return isPossible(target); &#125;&#125; æ•´ä½“æ€è·¯å°±æ˜¯é€†å‘æ€è€ƒã€‚æ¯æ¬¡æ‰¾arrayé‡Œæœ€å¤§çš„ä¸€ä¸ªæ•°ï¼Œç”¨å®ƒå‡å»å‰©ä¸‹çš„æ‰€æœ‰numï¼Œå¾—åˆ°çš„å€¼å°±æ˜¯ä¸Šä¸€è½®è¯¥ä½ç½®è¢«æ›´æ”¹å‰çš„å€¼ã€‚æ¥ç€æˆ‘ä»¬æŠŠè¿™ä¸ªä½ç½®çš„æ›¿æ¢æ‰ï¼Œç»§ç»­å¾ªç¯ã€‚åœ¨ç¬¬äºŒä¸ªå¾ªç¯é‡Œï¼Œéœ€è¦è·³è¿‡æœ€å¤§å€¼çš„indexï¼Œå¹¶ä¸”è¦æ£€æŸ¥å‰©ä¸‹çš„æ‰€æœ‰numæ˜¯å¦éƒ½å°äºæœ€å¤§å€¼ï¼Œå¦‚æœä¸æ˜¯åˆ™ç›´æ¥è¿”å›falseã€‚è¯¦ç»†è§£æåœ¨discussã€‚","text":"ğŸ“Œ ä»Šå¤©åšå‡ºæ¥ä¸‰é¢˜ï¼Œä½†æ˜¯æœ€åä¸€é¢˜æ­£å¥½å¡åœ¨æ—¶é—´ç‚¹ä¸Šï¼Œæ²¡æœ‰ç®—è¿›å»ï¼Œä¸è¿‡æ— æ‰€è°“äº†ï¼Œç»§ç»­åŠªåŠ›ã€‚ 1354. Construct Target Array With Multiple Sums ğŸ”—Question Link è¿™é“é¢˜æˆ‘å†™çš„é¢˜è§£voteæ•°é‡åœ¨discussåŒºæ’å‰ä¸‰ My Discuss LinkğŸ”—[Java] Think the problem from the end to start. æ„Ÿè§‰è¿˜æ˜¯æŒºæœ‰æ”¶è·çš„ï¼Œæ€è·¯æŒºæœ‰è¶£ã€‚ My solution class Solution &#123; public boolean isPossible(int[] target) &#123; int max = 0; int index = 0; for(int i= 0; i&lt; target.length ;i++)&#123; if(target[i] &gt; max)&#123; max = target[i]; index = i; &#125; &#125; if(max == 1) return true; for(int i = 0 ;i&lt; target.length ;i++)&#123; if(i == index)continue; if(target[i] &gt; max)return false; max = max - target[i]; &#125; target[index] = max; return isPossible(target); &#125;&#125; æ•´ä½“æ€è·¯å°±æ˜¯é€†å‘æ€è€ƒã€‚æ¯æ¬¡æ‰¾arrayé‡Œæœ€å¤§çš„ä¸€ä¸ªæ•°ï¼Œç”¨å®ƒå‡å»å‰©ä¸‹çš„æ‰€æœ‰numï¼Œå¾—åˆ°çš„å€¼å°±æ˜¯ä¸Šä¸€è½®è¯¥ä½ç½®è¢«æ›´æ”¹å‰çš„å€¼ã€‚æ¥ç€æˆ‘ä»¬æŠŠè¿™ä¸ªä½ç½®çš„æ›¿æ¢æ‰ï¼Œç»§ç»­å¾ªç¯ã€‚åœ¨ç¬¬äºŒä¸ªå¾ªç¯é‡Œï¼Œéœ€è¦è·³è¿‡æœ€å¤§å€¼çš„indexï¼Œå¹¶ä¸”è¦æ£€æŸ¥å‰©ä¸‹çš„æ‰€æœ‰numæ˜¯å¦éƒ½å°äºæœ€å¤§å€¼ï¼Œå¦‚æœä¸æ˜¯åˆ™ç›´æ¥è¿”å›falseã€‚è¯¦ç»†è§£æåœ¨discussã€‚ 1351. Count Negative Numbers in a Sorted Matrix ğŸ”—Question Link First Solution class Solution &#123; public int countNegatives(int[][] grid) &#123; int sum = 0; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; for(int i= 0; i&lt; m;i++)&#123; for(int j= 0;j&lt;n ;j++)&#123; if(grid[i][j] &lt; 0)sum++; &#125; &#125; return sum; &#125;&#125; ç»å…¸çš„éå†graphã€‚O(N^2)å¤æ‚åº¦ã€‚ Optimized Solution ++++++++++--++++--+++---+-----+----- graphæ­£è´Ÿæƒ…å†µå¦‚ä¸Šå›¾ï¼Œå…¶å®å¾ˆåƒsearch 2D matrix IIè¿™é“é¢˜ï¼Œä»å·¦ä¸Šæˆ–è€…å³ä¸Šæ‰«æï¼Œä¿è¯æ˜¯O(N)çš„å¤æ‚åº¦ã€‚ class Solution&#123; public int countNegatives(int[][] grid) &#123; int m = grid.length, n = grid[0].length, r = m - 1, c = 0, cnt = 0; while (r &gt;= 0 &amp;&amp; c &lt; n) &#123; if (grid[r][c] &lt; 0) &#123; --r; cnt += n - c; // there are n - c negative numbers in current row. &#125;else &#123; ++c; &#125; &#125; return cnt; &#125;&#125; 1352. Product of the Last K Numbers ğŸ”—Question Link class ProductOfNumbers &#123; List&lt;Integer&gt; list; public ProductOfNumbers() &#123; list = new ArrayList&lt;&gt;(); &#125; public void add(int num) &#123; list.add(num); &#125; public int getProduct(int k) &#123; int len = list.size()-1; int sum = 1; for(int i= 0;i&lt;k;i++)&#123; sum = sum * list.get(len-i); &#125; return sum; &#125;&#125; Using list to store the nums. Then we make k loops from the tail.","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 81 ğŸ’ª","slug":"chin-up-19","date":"2020-02-15T17:13:23.000Z","updated":"2020-02-18T18:12:10.598Z","comments":true,"path":"2020/02/15/chin-up-19/","link":"","permalink":"WangHngLeee.github.io/2020/02/15/chin-up-19/","excerpt":"128. Longest Consecutive Sequence ğŸ”—Question Link class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; // corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();// num --&gt; è¿ç»­é•¿åº¦ int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.containsKey(num-1) ? map.get(num-1) : 0;//å·¦è¾¹è¿ç»­é•¿åº¦ int right = map.containsKey(num + 1) ? map.get(num + 1) : 0;//å³è¾¹è¿ç»­é•¿åº¦ sum+= left + right + 1; //æ›´æ–°æ€»é•¿åº¦ // change the current num's maxlen è¿ç»­é•¿åº¦ map.put(num,sum); max = Math.max(max,sum);//æ›´æ–°max map.put(num - left, sum);//æ›´æ–°æœ€å·¦è¾¹numçš„é•¿åº¦ map.put(num + right, sum);//æ›´æ–°æœ€å³è¾¹numé•¿åº¦ &#125;else&#123; continue;// duplicate case &#125; &#125; return max; &#125;&#125; å†™åœ¨æ³¨é‡Šé‡Œã€‚","text":"128. Longest Consecutive Sequence ğŸ”—Question Link class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; // corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();// num --&gt; è¿ç»­é•¿åº¦ int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.containsKey(num-1) ? map.get(num-1) : 0;//å·¦è¾¹è¿ç»­é•¿åº¦ int right = map.containsKey(num + 1) ? map.get(num + 1) : 0;//å³è¾¹è¿ç»­é•¿åº¦ sum+= left + right + 1; //æ›´æ–°æ€»é•¿åº¦ // change the current num's maxlen è¿ç»­é•¿åº¦ map.put(num,sum); max = Math.max(max,sum);//æ›´æ–°max map.put(num - left, sum);//æ›´æ–°æœ€å·¦è¾¹numçš„é•¿åº¦ map.put(num + right, sum);//æ›´æ–°æœ€å³è¾¹numé•¿åº¦ &#125;else&#123; continue;// duplicate case &#125; &#125; return max; &#125;&#125; å†™åœ¨æ³¨é‡Šé‡Œã€‚ 112. Path Sum ğŸ”—Question Link class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null)return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)return true; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum - root.val); &#125;&#125; æ­£å¸¸é€’å½’ã€‚ 113. Path Sum II ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res,sum,templist); return res; &#125; public void help(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int sum, List&lt;Integer&gt; templist)&#123; if(root == null)return; templist.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)res.add(new ArrayList&lt;&gt;(templist)); else&#123; help(root.left,res,sum - root.val, templist); help(root.right,res,sum - root.val, templist); &#125; templist.remove(templist.size() -1); &#125;&#125; dfs + backtrackingã€‚ 437. Path Sum III ğŸ”—Question Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,sum,0,map); return total; &#125; public void help(TreeNode root, int sum, int cursum, Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - sum))&#123; total+=map.get(cursum - sum); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,sum,cursum,map); help(root.right,sum,cursum,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; dfs + backtracking + presumã€‚ 129. Sum Root to Leaf Numbers ğŸ”—Question Link class Solution &#123; public int sumNumbers(TreeNode root) &#123; if(root == null)return 0; int res = help(root,0); return res; &#125; public int help(TreeNode root,int sum)&#123; if(root == null)return 0; sum = sum*10 + root.val; if(root.left == null &amp;&amp; root.right == null)return sum; int leftsum = help(root.left,sum); int rightsum = help(root.right,sum); return leftsum + rightsum; &#125;&#125; recursioné‡Œè®¡ç®—sumå¹¶ä¸”ä¼ ä¸‹å»ã€‚ä¸€å¼€å§‹ç”¨dfs+backtracking+è½¬numå’Œéº»çƒ¦äº†ï¼Œè¿™ä¸ªç®€å•ã€‚ 257. Binary Tree Paths ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; StringBuilder sb = new StringBuilder(); help(root,sb,res); return res; &#125; public void help(TreeNode root, StringBuilder sb, List&lt;String&gt; res)&#123; if(root == null)return; int len = sb.length(); sb.append(root.val); if(root.left == null &amp;&amp; root.right == null)&#123; res.add(sb.toString()); &#125; sb.append(\"-&gt;\"); help(root.left,sb,res); help(root.right,sb,res); sb.setLength(len); &#125;&#125; dfs + backtracking.æ³¨æ„sb appendçš„é¡ºåºã€‚ä¸€èˆ¬éƒ½æ˜¯å…ˆåŠ å…¥listä¹‹ååœ¨åˆ¤æ–­æ˜¯å¦ä¸ºå¶èŠ‚ç‚¹ã€‚å¦åˆ™å®¹æ˜“æ¼æ‰ã€‚ 437. Path Sum III ğŸ”—Question Link class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; return root; &#125;&#125; ç”±äºæ˜¯BSTï¼Œæ‰€ä»¥åªéœ€è¦é€šè¿‡å¤§å°åˆ¤æ–­å°±å¯ä»¥é€‰æ‹©å·¦å³å­æ ‘ã€‚å¦‚æœå½“å‰rootå…¨éƒ¨å°äºp,qåˆ™è¯´æ˜lcaåœ¨å³è¾¹çš„treeã€‚è‹¥å…¨å°äºpï¼Œqåˆ™åœ¨å·¦è¾¹ã€‚å¦‚æœå¤§äºpå°äºqåˆ™ä»–è‡ªå·±æœ¬èº«å°±æ˜¯ï¼Œå¦‚æœå°äºpå¤§äºqåˆ™æ˜¯ä¸å¯èƒ½äº‹ä»¶ï¼Œè¿”å›rootã€‚ 257. Binary Tree Paths ğŸ”—Question Link class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; return root; &#125;&#125; ä¸æ˜¯BSTï¼Œåªæ˜¯å•çº¯çš„äºŒå‰æ ‘äº†ã€‚ä¸èƒ½ç”¨å¤§å°è¾¹ç•Œæ¥åˆ¤æ–­äº†ã€‚è¦åˆ†æƒ…å†µé€’å½’è®¨è®ºã€‚ rootä¸ºç©ºæˆ–è€… rootåªä¸ºpqä¸­çš„ä¸€è€…ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›å½“å‰rootã€‚ é€’å½’æ‰¾å·¦å³å­æ ‘ä¸­pqçš„lcaï¼Œå¦‚æœleftä¸ºç©ºï¼Œè¯´æ˜åªèƒ½åœ¨rightï¼Œè¿”å›rightã€‚ åä¹‹è¿”å›leftã€‚ å¦‚æœleftå’Œright1éƒ½ä¸ä¸ºnullï¼Œè¯´æ˜p q äºŒè€…å„è‡ªåˆ†å¸ƒåœ¨å·¦å³ä¸­ï¼Œæ‰€ä»¥è¿”å›å½“å‰rootã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 80 ğŸ’ª","slug":"chin-up-18","date":"2020-02-14T17:13:23.000Z","updated":"2020-02-14T21:37:55.471Z","comments":true,"path":"2020/02/14/chin-up-18/","link":"","permalink":"WangHngLeee.github.io/2020/02/14/chin-up-18/","excerpt":"872. Leaf-Similar Trees ğŸ”—Question Link class Solution &#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root1); stack2.push(root2); while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())&#123; if(getleaf(stack1) != getleaf(stack2))return false; &#125; return true; &#125; public int getleaf(Stack&lt;TreeNode&gt; stack)&#123; while(true)&#123; TreeNode node = stack.pop(); if(node.left != null)stack.push(node.left); if(node.right != null)stack.push(node.right); if(node.left == null &amp;&amp; node.right == null)return node.val; &#125; &#125;&#125; ä¸¤ä¸ªstack dfsæ‰¾å¶èŠ‚ç‚¹ï¼Œç”±äºåŒæ—¶æ‰¾æ‰€ä»¥æ¯”è¾ƒçš„ä¹Ÿæ˜¯åŒä¸€ä¸ªä½ç½®çš„å¶èŠ‚ç‚¹ã€‚æ³¨æ„while(true)çš„å†™æ³•ã€‚","text":"872. Leaf-Similar Trees ğŸ”—Question Link class Solution &#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root1); stack2.push(root2); while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())&#123; if(getleaf(stack1) != getleaf(stack2))return false; &#125; return true; &#125; public int getleaf(Stack&lt;TreeNode&gt; stack)&#123; while(true)&#123; TreeNode node = stack.pop(); if(node.left != null)stack.push(node.left); if(node.right != null)stack.push(node.right); if(node.left == null &amp;&amp; node.right == null)return node.val; &#125; &#125;&#125; ä¸¤ä¸ªstack dfsæ‰¾å¶èŠ‚ç‚¹ï¼Œç”±äºåŒæ—¶æ‰¾æ‰€ä»¥æ¯”è¾ƒçš„ä¹Ÿæ˜¯åŒä¸€ä¸ªä½ç½®çš„å¶èŠ‚ç‚¹ã€‚æ³¨æ„while(true)çš„å†™æ³•ã€‚ 669. Trim a Binary Search Tree ğŸ”—Question Link class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root == null)return root; if(root.val &lt; L)return trimBST(root.right,L,R); if(root.val &gt; R)return trimBST(root.left,L,R); root.left = trimBST(root.left,L,R); root.right = trimBST(root.right,L,R); return root; &#125;&#125; åˆ æ‰è¶…å‡ºLï¼ŒRèŒƒå›´å†…çš„èŠ‚ç‚¹ã€‚é€’å½’å°±å¯ä»¥äº†ã€‚ 1325. Delete Leaves With a Given Value ğŸ”—Question Link class Solution &#123; public TreeNode removeLeafNodes(TreeNode root, int target) &#123; if(root == null)return root; if(root.left != null)root.left = removeLeafNodes(root.left,target); if(root.right != null)root.right = removeLeafNodes(root.right,target); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target)return null; else&#123; return root; &#125; &#125;&#125; recursiveã€‚ æ³¨æ„æœ€åè¿”å›å€¼ï¼Œå¦‚æœå½“å‰æ˜¯leafå¹¶ä¸”valç­‰äºtargetï¼Œè¦è¿”å›nullï¼Œå¦åˆ™è¿”å›åŸnodeã€‚ 814. Binary Tree Pruning ğŸ”—Question Link class Solution &#123; public TreeNode pruneTree(TreeNode root) &#123; if(root == null)return null; if(root.left != null)root.left = pruneTree(root.left); if(root.right!= null)root.right = pruneTre(root.right); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0)return null; else return root; &#125;&#125; ä»£ç å…¶å®å’Œ1325ä¸€æ ·ã€‚1325æ˜¯å»æ‰æŒ‡å®šå€¼çš„æ‰€æœ‰targetï¼Œè¿™é“é¢˜æ˜¯è¦åˆ æ‰æ‰€æœ‰0çš„subtreeï¼Œå…¶å®æ€§è´¨æ˜¯ä¸€æ ·çš„ï¼Œcollect nodeä¹‹ååˆ æ‰ã€‚ä»å¶èŠ‚ç‚¹å‘ä¸Šå‰¥æ´‹è‘±ã€‚ 684. Redundant Connection ğŸ”—Question Link class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int[] parents = new int[edges.length+1]; for(int i = 0 ;i&lt;edges.length ;i++)&#123; parents[i] = i; &#125; for(int[] link : edges)&#123; int root1 = find(parents,link[0]); int root2 = find(parents,link[1]); if(root1 == root2)&#123; return link; &#125; parents[root1] = root2; &#125; return new int[]&#123;&#125;; &#125; public int find(int[] parents, int i)&#123; if(i == parents[i])return i; return parents[i] = find(parents,parents[i]); &#125;&#125; union find ã€‚ å¦‚æœæ‰¾åˆ°ä¸¤ä¸ªç‚¹rootä¸€æ ·ï¼Œåˆ™è¯´æ˜ä¹‹å‰å·²ç»linkè¿‡ï¼Œæ˜¯å¤šä½™çš„ï¼Œç›´æ¥è¿”å›ã€‚ 1319. Number of Operations to Make Network Connected ğŸ”—Question Link class Solution &#123; public int makeConnected(int n, int[][] connections) &#123; if(connections.length == 0 || connections == null)return -1; if(connections.length &lt; n-1)return -1; int[] parents = new int[n]; for(int i =0;i&lt;parents.length ;i++)&#123; parents[i] = i; &#125; int remain = n; for(int[] link : connections)&#123; int root1 = find(parents,link[0]); int root2 = find(parents, link[1]); if( root1 != root2)&#123; remain--; parents[root1] = root2; &#125; &#125; return remain -1; &#125; public int find(int[] parents, int a)&#123; if(parents[a] == a)return a; return parents[a] = find(parents, parents[a]); &#125;&#125; union findã€‚è®°å½•remainså‰©ä¸‹æ²¡è¿æ¥çš„ä¸ªæ•°ï¼Œæ‰€ä»¥æœ€åæœ€å°‘æ•°é‡æ˜¯å‰©ä¸‹çš„ä¸ªæ•°-ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"}]},{"title":"Leetcode EveryDay 79 ğŸ’ª","slug":"chin-up-17","date":"2020-02-12T18:13:23.000Z","updated":"2020-02-13T02:44:13.480Z","comments":true,"path":"2020/02/12/chin-up-17/","link":"","permalink":"WangHngLeee.github.io/2020/02/12/chin-up-17/","excerpt":"","text":"99. Recover Binary Search Tree ğŸ”—Question Link class Solution &#123; public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null; TreeNode second = null; if(root == null)return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root!=null)&#123; stack.push(root); root = root.left; &#125; while(!stack.isEmpty())&#123; TreeNode temp = stack.pop(); if(pre!=null)&#123; if(pre.val &gt; temp.val)&#123; if(first == null)&#123; first = pre; &#125; second = temp; &#125; &#125; pre = temp; if(temp.right!=null)&#123; temp = temp.right; while(temp!=null)&#123; stack.push(temp); temp = temp.left; &#125; &#125; &#125; int temp = first.val; first.val = second.val; second.val = temp; &#125;&#125; in-orderæ·±åº¦éå†ã€‚ç„¶åä¾æ¬¡popï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªpreå¤§äºcurçš„ï¼Œåˆ™preæ˜¯ç¬¬ä¸€ä¸ªé”™è¯¯çš„åœ°æ–¹ï¼Œç´§æ¥ç€æ‰¾ç¬¬äºŒä¸ªï¼Œå¦‚æœä¹‹å‰firstä¸ä¸ºç©ºï¼Œè¯´æ˜æ‰¾åˆ°äº†ï¼Œåˆ™æŠŠå½“å‰çš„ç»™secondã€‚æœ€åswapä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ 450. Delete Node in a BST ğŸ”—Question Link class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if(root == null)return null; if(root.val &gt; key)root.left = deleteNode(root.left,key); else if(root.val &lt; key)root.right = deleteNode(root.right,key); else&#123; if(root.left == null)return root.right; if(root.right == null)return root.left; TreeNode smallest = root.right; while(smallest.left!=null)&#123; smallest = smallest.left; &#125; smallest.left = root.left; return root.right; &#125; return root; &#125;&#125; recursive.æ‰¾åˆ°keyåï¼Œåˆ¤æ–­å·¦å³æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœéƒ½ä¸ä¸ºç©ºï¼Œåˆ™å»å³å­æ ‘æ‰¾æœ€å°å€¼ï¼Œæ‰¾åˆ°åæŠŠå½“å‰rootå·¦æ ‘ç»™åˆ°æœ€å°å€¼çš„å·¦æ ‘ï¼Œè¿”å›æœ€å°å€¼çš„å³æ ‘ã€‚ Time : O(h) -&gt; h is the height of tree. 501. Find Mode in Binary Search Tree ğŸ”—Question Link class Solution &#123; int max = 0; public int[] findMode(TreeNode root) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; TreeNode temp = queue.poll(); if(temp!=null)&#123; map.put(temp.val,map.getOrDefault(temp.val,0)+1); max = Math.max(max,map.get(temp.val)); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int key : map.keySet())&#123; if(map.get(key) == max)&#123; res.add(key); &#125; &#125; int[] ans = new int[res.size()]; int i=0; for(int a : res)&#123; ans[i] = a; i++; &#125; return ans; &#125;&#125; level traversal + mapã€‚ keep max to store the max frequency. 1302. Deepest Leaves Sum ğŸ”—Question Link class Solution &#123; public int deepestLeavesSum(TreeNode root) &#123; if(root == null)return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int res = 0; while(!queue.isEmpty())&#123; int size = queue.size(); res = 0; for(int i=0 ;i&lt;size ;i++)&#123; TreeNode temp = queue.poll(); res += temp.val; if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; å…¸å‹level traversalé‡ŒåŠ ä¸€ä¸ªresæ¥è®¡ç®—å½“å‰popå‡ºçš„æ‰€æœ‰èŠ‚ç‚¹çš„å’Œï¼Œä½†æ˜¯æ¯æ¬¡è¦å½’é›¶ï¼Œæœ€åè¿”å›çš„æ‰æ˜¯æœ€åä¸€å±‚çš„nodeçš„å’Œã€‚ 429. N-ary Tree Level Order Traversal ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i=0 ;i&lt;size ;i++)&#123; Node temp = queue.poll(); templist.add(temp.val); for(Node child : temp.children)&#123; if(child!=null)&#123; queue.add(child); &#125; &#125; &#125; res.add(templist); &#125; return res; &#125;&#125; å…¸å‹å±‚æ¬¡éå†ï¼Œåªä¸è¿‡åˆ¤æ–­å·¦å³å­©å­çš„æ—¶å€™å˜æˆäº†å¯¹childrençš„éå†ã€‚ 589. N-ary Tree Preorder Traversal ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public void help(Node root, List&lt;Integer&gt; res)&#123; if(root == null)return; res.add(root.val); for(Node child : root.children)&#123; help(child,res); &#125; &#125;&#125; preorderé¡ºåºã€‚æ ¹ - å·¦ -å³ã€‚å…ˆå¯¹æ ¹åŠ å…¥resï¼Œå†å¯¹å·¦å³å­©å­æ“ä½œã€‚ 590. N-ary Tree Postorder Traversal ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public void help(Node root, List&lt;Integer&gt; res)&#123; if(root == null)return; for(Node child : root.children)&#123; help(child,res); &#125; res.add(root.val); &#125;&#125; postorderé¡ºåºã€‚ 987. Vertical Order Traversal of a Binary Tree ğŸ”—Question Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; public pair(int x, int y, TreeNode n)&#123; this.x = x; this.y = y; node = n; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(0,0,root)); int min = 0; int max = 0; while(!queue.isEmpty())&#123; pair temp = queue.poll(); min = Math.min(min,temp.x); max = Math.max(max,temp.x); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(new pair(temp.x,temp.y,temp.node)); if(temp.node.left!=null)queue.add(new pair(temp.x-1,temp.y+1,temp.node.left)); if(temp.node.right!=null)queue.add(new pair(temp.x+1,temp.y+1,temp.node.right)); &#125; for(int i= min ;i&lt;= max; i++)&#123; Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : 0); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j = 0; j&lt;map.get(i).size() ;j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; new ä¸€ä¸ªclass å­˜ x,y,nodeã€‚ mapå­˜ç›¸å¯¹åº”xçš„nodeï¼Œç„¶åä»å·¦åˆ°å³ï¼Œä»min-maxå¯¹mapé‡Œå¯¹nodeè¿›è¡Œæ’åºï¼Œå¦‚æœåŒä¸€åˆ—çš„node yåæ ‡ä¹Ÿç›¸åŒï¼Œåˆ™æŒ‰å°åˆ°å¤§æ’ï¼Œå¦‚æœä¸æ˜¯åˆ™ä¸æ”¹å˜é¡ºåºã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 78 ğŸ’ª","slug":"chin-up-16","date":"2020-02-11T18:13:23.000Z","updated":"2020-02-13T02:44:04.831Z","comments":true,"path":"2020/02/11/chin-up-16/","link":"","permalink":"WangHngLeee.github.io/2020/02/11/chin-up-16/","excerpt":"990. Satisfiability of Equality Equations ğŸ”—Question Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26 ;i++)&#123; UF[i] = i; // initialiaze uf array &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; // == case, the same as link between the two å­—æ¯ UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a'); &#125; &#125; for(String str : equations)&#123; if( str.charAt(1) == '!')&#123; // != case, means cut off the link between two å­—æ¯ if ( find(str.charAt(0)-'a') == find( str.charAt(3) -'a')) &#123; // only if the two char has been linked before but it is in != case then we can return false return false; &#125; &#125; &#125; return true; &#125; public int find(int a)&#123; // classic find function if( a!= UF[a]) UF[a] = find(UF[a]); return UF[a]; &#125;&#125; ufæŠŠ==çš„ä¸¤ä¸ªå­—æ¯è¿èµ·æ¥ã€‚ç„¶åå»åˆ¤æ–­ï¼=çš„æƒ…å†µé‡Œï¼Œå¦‚æœä¸¤ä¸ªå­—æ¯å·²ç»æ˜¯unionçš„äº†ï¼Œä½†æ˜¯å¤„åœ¨ï¼=æƒ…å†µé‡Œï¼Œåˆ™è¿”å›falseï¼Œè¡¨æ˜è¿™ä¸ªæ–¹ç¨‹ç»„æ— è§£ã€‚","text":"990. Satisfiability of Equality Equations ğŸ”—Question Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26 ;i++)&#123; UF[i] = i; // initialiaze uf array &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; // == case, the same as link between the two å­—æ¯ UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a'); &#125; &#125; for(String str : equations)&#123; if( str.charAt(1) == '!')&#123; // != case, means cut off the link between two å­—æ¯ if ( find(str.charAt(0)-'a') == find( str.charAt(3) -'a')) &#123; // only if the two char has been linked before but it is in != case then we can return false return false; &#125; &#125; &#125; return true; &#125; public int find(int a)&#123; // classic find function if( a!= UF[a]) UF[a] = find(UF[a]); return UF[a]; &#125;&#125; ufæŠŠ==çš„ä¸¤ä¸ªå­—æ¯è¿èµ·æ¥ã€‚ç„¶åå»åˆ¤æ–­ï¼=çš„æƒ…å†µé‡Œï¼Œå¦‚æœä¸¤ä¸ªå­—æ¯å·²ç»æ˜¯unionçš„äº†ï¼Œä½†æ˜¯å¤„åœ¨ï¼=æƒ…å†µé‡Œï¼Œåˆ™è¿”å›falseï¼Œè¡¨æ˜è¿™ä¸ªæ–¹ç¨‹ç»„æ— è§£ã€‚ 98. Validate Binary Search Tree ğŸ”—Question Link class Solution &#123; public boolean isValidBST(TreeNode root)&#123; if(root == null) return true; return help(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean help(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val &lt;= min || root.val &gt;= max)return false; return help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max); &#125;&#125; recursive. BST ç»å¸¸è¦ç”¨è®¾ç½®ä¸Šä¸‹ç•Œæ¥è§£å†³ã€‚ 530. Minimum Absolute Difference in BST ğŸ”—Question Link Recursive class Solution &#123; int res = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; if(root == null)return 0; help(root,Integer.MIN_VALUE,Integer.MAX_VALUE); return res; &#125; public void help(TreeNode root , int min, int max)&#123; if(root == null)return; if(min != Integer.MIN_VALUE)res=Math.min(res,root.val - min); if(max != Integer.MAX_VALUE)res=Math.min(res,max - root.val); help(root.left,min,root.val); help(root.right,root.val,max); &#125;&#125; å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œè®¾ç½®ä¸¤ä¸ªè¾¹ç•Œï¼Œæ›´æ–°resä¸ºæœ€å°å€¼å³å¯ã€‚ Stack Iteraive class Solution&#123; public int getMinimumDifference(TreeNode root)&#123; Stack&lt;TreeNode&gt;stack = new Stack&lt;&gt;(); int min = Integer.MAX_VALUE; TreeNode cur = root; TreeNode prev = null; while(cur!=null || !stack.isEmpty())&#123; if(cur!=null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); if(prev!=null)&#123; min = Math.min(min,cur.val - prev.val); &#125; prev = cur; cur = cur.right; &#125; &#125; return min; &#125;&#125; deep in-order traversalã€‚ BSTåˆ™æ·±åº¦ä¸­åºéå†å°±å¯ä»¥è§£å†³ã€‚è®°ä½stack traversalæ¨¡ç‰ˆã€‚ 700. Search in a Binary Search Tree ğŸ”—Question Link class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if(root == null)return null; if(root.val &gt; val)return searchBST(root.left,val); if(root.val &lt; val)return searchBST(root.right,val); if(root.val == val)return root; return null; &#125;&#125; simple recursive with different cases with val and root.val. 701. Insert into a Binary Search Tree ğŸ”—Question Link class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if(root == null)return new TreeNode(val); if(root.val &lt; val)&#123; root.right = insertIntoBST(root.right,val); &#125; if(root.val &gt; val)&#123; root.left = insertIntoBST(root.left,val); &#125; return root; &#125;&#125; recursive. BSTç»å¸¸ç”¨ä¸¤ä¸ªup / downçš„boundaryæ¥åˆ¤æ–­æ“ä½œæ¡ä»¶ã€‚ 230. Kth Smallest Element in a BST ğŸ”—Question Link class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null)return 0; TreeNode cur = root; while(cur!=null || !stack.isEmpty())&#123; if(cur!=null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); k--; if(k==0)return cur.val; cur = cur.right; &#125; &#125; return -1; &#125;&#125; åˆæ˜¯ä¸€é“BSTæ·±åº¦in-orderçš„æ€è·¯ã€‚Kth smallestçš„é¢˜ã€‚ä»æœ€å·¦å¼€å§‹ï¼Œå¤„ç†åˆ°ç¬¬kä¸ªå°±æ˜¯ç¬¬kå°ã€‚å¦‚æœæ”¹æˆkth largestï¼Œåˆ™å°±æ˜¯å¤„ç†åˆ°ç¬¬number of nodes -kä¸ªã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"}]},{"title":"Leetcode EveryDay 77 ğŸ’ª","slug":"chin-up-15","date":"2020-02-10T19:13:23.000Z","updated":"2020-02-11T17:44:56.361Z","comments":true,"path":"2020/02/10/chin-up-15/","link":"","permalink":"WangHngLeee.github.io/2020/02/10/chin-up-15/","excerpt":"1267. Count Servers that Communicate ğŸ”—Question Link class Solution &#123; public int countServers(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int[] row = new int[m]; int[] col = new int[n]; int total = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; row[i]+=1; col[j]+=1; total++; &#125; &#125; &#125; for(int i=0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; if(row[i] == 1 &amp;&amp; col[j] == 1)&#123; total--; &#125; &#125; &#125; &#125; return total; &#125;&#125; col å’Œ rowç”¨æ¥è®°å½•è¿™ä¸€è¡Œæœ‰å¤šå°‘ä¸ªç”µè„‘ï¼Œå¦‚æœæœ€åæŸä¸ªä½ç½®ä¸ºç”µè„‘å¹¶ä¸”æ‰€åœ¨çš„è¡Œå’Œåˆ—éƒ½åªæœ‰1ä¸ªï¼Œé‚£ä¹ˆå°±æ˜¯æ²¡æœ‰è¿æ¥çš„ï¼Œè¦ä»totalé‡Œå‡å»ã€‚","text":"1267. Count Servers that Communicate ğŸ”—Question Link class Solution &#123; public int countServers(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int[] row = new int[m]; int[] col = new int[n]; int total = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; row[i]+=1; col[j]+=1; total++; &#125; &#125; &#125; for(int i=0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; if(row[i] == 1 &amp;&amp; col[j] == 1)&#123; total--; &#125; &#125; &#125; &#125; return total; &#125;&#125; col å’Œ rowç”¨æ¥è®°å½•è¿™ä¸€è¡Œæœ‰å¤šå°‘ä¸ªç”µè„‘ï¼Œå¦‚æœæœ€åæŸä¸ªä½ç½®ä¸ºç”µè„‘å¹¶ä¸”æ‰€åœ¨çš„è¡Œå’Œåˆ—éƒ½åªæœ‰1ä¸ªï¼Œé‚£ä¹ˆå°±æ˜¯æ²¡æœ‰è¿æ¥çš„ï¼Œè¦ä»totalé‡Œå‡å»ã€‚ 207. Course Schedule ğŸ”—Question Link class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i=0 ;i&lt;indegree.length ;i++)&#123; if(indegree[i] == 0)queue.add(i); &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); numCourses--; for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]] == 0)&#123; queue.add(pair[0]); &#125; &#125; &#125; &#125; return numCourses == 0; &#125;&#125; toplogical sort.æŒ‰ç…§è¯¾ç¨‹é¡ºåºå¢åŠ indegreeã€‚ç„¶åä»indegree0çš„å¼€å§‹éå†ã€‚åˆ¤æ–­æœ€åè¯¾ç¨‹æ˜¯å¦ä¸ºé›¶ã€‚ 210. Course Schedule II ğŸ”—Question Link class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int index = 0; for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i = 0 ;i&lt;indegree.length ;i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); res[index] = i; index++; &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]] == 0)&#123; queue.add(pair[0]); res[index] = pair[0]; index++; &#125; &#125; &#125; &#125; return index == numCourses ? res : new int[]&#123;&#125;; &#125;&#125; å’Œcourse schedule ä¸€æ ·çš„æ€è·¯ã€‚åªä¸è¿‡è¿™é“é¢˜è¦æ±‚æŒ‰é¡ºåºè¾“å‡ºè¯¾ç¨‹é¡ºåºï¼Œåªéœ€è¦ç»´æŠ¤ä¸€ä¸ªreså¹¶ä¸”æ›´æ–°indexï¼Œä¸æ–­åŠ å…¥indegreeä¸º0çš„è¯¾ç¨‹å³å¯ã€‚ 802. Find Eventual Safe States ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int size = graph.length; int[] state = new int[size]; for(int i=0 ;i&lt;size ;i++)&#123; if(dfs(graph,i,state))res.add(i); &#125; return res; &#125; public boolean dfs(int[][] graph, int num, int[] state)&#123; if(state[num] != 0)return state[num] == 1; state[num] = 2; for(int n : graph[num])&#123; if(!dfs(graph,n,state))return false; &#125; state[num] = 1; return true; &#125;&#125; dfs. ç›®çš„æ˜¯æ‰¾åˆ°ä¸€ä¸ªnumï¼Œå®ƒä¸èƒ½è·³è½¬åˆ°åˆ«çš„æ•°å­—ã€‚æ–¹æ³•æ˜¯æ‰¾æ•°ç»„é‡Œçš„cycleã€‚æ¯ä¸ªæ•°æœ‰ä¸‰ç§stateï¼Œ1-unvisited, 2- safe, 3-unsafe. å¦‚æœå½“å‰çš„numå­˜åœ¨cycleæˆ–è€…numèƒ½åˆ°è¾¾çš„æ•°é‡Œå­˜åœ¨cycleï¼Œåˆ™è¯¥æ•°ä¸å®‰å…¨ï¼ŒçŠ¶æ€ä¸º2. å¦‚æœæ²¡æœ‰cycleï¼Œåˆ™æ˜¯å®‰å…¨çš„ã€‚dfsé€’å½’åšå°±å¯ä»¥ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"Topological","slug":"Topological","permalink":"WangHngLeee.github.io/tags/Topological/"}]},{"title":"Leetcode EveryDay 76 ğŸ’ª","slug":"chin-up-14","date":"2020-02-09T18:13:23.000Z","updated":"2020-02-10T02:13:15.543Z","comments":true,"path":"2020/02/09/chin-up-14/","link":"","permalink":"WangHngLeee.github.io/2020/02/09/chin-up-14/","excerpt":"1162. As Far from Land as Possible ğŸ”—Question Link class Solution &#123; public int maxDistance(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] seen = new boolean[m][n]; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; queue.add(new int[]&#123;i,j&#125;); seen[i][j] = true; &#125; &#125; &#125; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int steps = -1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt; size ;i++)&#123; int[] temp = queue.poll(); for(int[] move : moves)&#123; int x = temp[0] + move[0]; int y = temp[1] + move[1]; if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; grid[x][y] == 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; steps++; &#125; return steps&lt;=0?-1:steps; &#125;&#125; BFS.Store all 1 in to queue. Then try to explore out to 0, then level by level. When the iteration stop, we can find the max distacne.","text":"1162. As Far from Land as Possible ğŸ”—Question Link class Solution &#123; public int maxDistance(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] seen = new boolean[m][n]; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; queue.add(new int[]&#123;i,j&#125;); seen[i][j] = true; &#125; &#125; &#125; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int steps = -1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt; size ;i++)&#123; int[] temp = queue.poll(); for(int[] move : moves)&#123; int x = temp[0] + move[0]; int y = temp[1] + move[1]; if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; grid[x][y] == 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; steps++; &#125; return steps&lt;=0?-1:steps; &#125;&#125; BFS.Store all 1 in to queue. Then try to explore out to 0, then level by level. When the iteration stop, we can find the max distacne. 841. Keys and Rooms ğŸ”—Question Link Iterative Solution class Solution &#123; public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(rooms == null || rooms.size() == 9)return false; stack.push(0); set.add(0); while(!stack.isEmpty())&#123; int temp = stack.pop(); for(int key : rooms.get(temp))&#123; if(!set.contains(key))&#123; set.add(key); stack.push(key); if(set.size() == rooms.size())return true; &#125; &#125; &#125; return set.size() == rooms.size(); &#125;&#125; Using set to store all rooms we can visit, and then iterative to visit every key that current rooms has. We only need to check whether the size of seen is equal to the total rooms. Recursive Solution class Solution &#123; //recursive solution public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; seen = new HashSet&lt;&gt;(); help(0,rooms,seen); return rooms.size() == seen.size(); &#125; public void help(int room, List&lt;List&lt;Integer&gt;&gt; rooms, Set&lt;Integer&gt; seen)&#123; seen.add(room); for(int key : rooms.get(room))&#123; if(!seen.contains(key))help(key,rooms,seen); &#125; return; &#125;&#125; Change the iterative solution to recursive. The idea is the same. 1202. Smallest String With Swaps ğŸ”—Question Link class Solution &#123; public int[] parent; public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) &#123; parent = new int[s.length()]; if(s == null || s.length() == 0)return null; for(int i=0 ;i&lt;s.length() ;i++)&#123; parent[i] = i; &#125; for(List&lt;Integer&gt; pair : pairs)&#123; union(pair.get(0),pair.get(1)); &#125; Map&lt;Integer,PriorityQueue&lt;Character&gt;&gt; map = new HashMap&lt;&gt;(); char[] chs = s.toCharArray(); for(int i=0 ;i&lt;s.length() ;i++)&#123; int root = find(i); if(map.get(root) == null)map.put(root, new PriorityQueue&lt;&gt;()); map.get(root).add(chs[i]); &#125; StringBuilder sb = new StringBuilder(); for(int i=0 ;i&lt;chs.length;i++)&#123; char temp = map.get(parent[i]).poll(); sb.append(temp); &#125; return sb.toString(); &#125; public int find(int i)&#123; while(parent[i]!=i)&#123; parent[i] = parent[parent[i]]; i = parent[i]; &#125; return i; &#125; public void union(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 &lt; root2)&#123; parent[root2] = root1; &#125;else&#123; parent[root1] = root2; &#125; &#125;&#125; ç¬¬ä¸€æ¬¡é‡åˆ°stringçš„union findé¢˜ã€‚ç”±äºå¯ä»¥swapå¾ˆå¤šæ¬¡ï¼Œæ‰€ä»¥ç›´æ¥å¯¹swapçš„ä¸¤ä¸ªindexå»ºç«‹parent graphï¼Œä¿è¯æ¯ä¸ªè¿é€špardçš„rootæœ€å°ï¼Œå„ä¸ªéƒ¨åˆ†ä»å°åˆ°å¤§ã€‚ç„¶åé’ˆå¯¹æ¯ä¸ªæœ€å°çš„å¼€å§‹rootå»ºç«‹pqï¼Œç”¨æ¥å¯¹charæ’åºã€‚ä¿è¯è¿é€šå›¾é‡Œrootéƒ½æ˜¯ä»å°åˆ°å¤§é“¾æ¥ï¼Œå¹¶ä¸”charä¹Ÿæ˜¯ä»å°åˆ°å¤§ã€‚ç”¨mapå­˜å„ä¸ªcharå’Œå„è‡ªèµ·å§‹ç‚¹å¯¹åº”çš„char pqã€‚æœ€åç›´æ¥æŒ‰é¡ºåºappendè¿”å›ã€‚ 842. Split Array into Fibonacci Sequence ğŸ”—Question Link class Solution &#123; public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(S,res,0); return res; &#125; public boolean dfs(String s, List&lt;Integer&gt; res, int start)&#123; if(start == s.length() &amp;&amp; res.size() &gt; 2)return true; for(int i = start ;i&lt;s.length() ;i++)&#123; if(s.charAt(start)== '0' &amp;&amp; i&gt;start)break; long num = Long.parseLong(s.substring(start,i+1)); if(num &gt; Integer.MAX_VALUE)break; int size = res.size(); if(size &gt;= 2 &amp;&amp; num&gt;res.get(size-1) + res.get(size-2))break; if(size&lt;=1 || num == res.get(size-1) + res.get(size-2))&#123; res.add((int)num); if(dfs(s,res,i+1))&#123; return true; &#125; res.remove(res.size()-1); &#125; &#125; return false; &#125;&#125; ç»å…¸dfsã€‚è¦æ±‚æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œæ‰€ä»¥resçš„å¤§å°è‡³å°‘ä¸º2çš„æ—¶å€™ï¼Œå¾…åŠ å…¥çš„numå¿…é¡»ä¸ºå‰ä¸¤ä¸ªä¹‹å’Œã€‚å¹¶ä¸”0åªèƒ½ä½œä¸º0å•ç‹¬ä½¿ç”¨ï¼Œå¦‚æœs charat startæ˜¯0ï¼Œé‚£å¿…é¡»åªèƒ½è¯¥ä½ç½®å¯ä»¥ç”¨ï¼Œåé¢çš„ä½ç½®éƒ½ä¸èƒ½ç”¨0ã€‚æ³¨æ„éšè—æ¡ä»¶ï¼Œnumè¿˜ä¸èƒ½å¤§äºInteger.MAX_VALUEã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"Tricky","slug":"Tricky","permalink":"WangHngLeee.github.io/tags/Tricky/"}]},{"title":"Weekly Contest 175 ğŸ†","slug":"contest02","date":"2020-02-09T04:02:09.000Z","updated":"2020-02-09T19:26:27.436Z","comments":true,"path":"2020/02/08/contest02/","link":"","permalink":"WangHngLeee.github.io/2020/02/08/contest02/","excerpt":"1346. Check If N and Its Double Exist ğŸ”—Question Link First Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; if(arr == null || arr.length == 0)return false; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0 ;i&lt;arr.length;i++)&#123; set.add(arr[i]); &#125; if(set.size() == 1 &amp;&amp; !set.add(0))return true; if(set.size() == 1) return false; for(int num : arr)&#123; if(num %2 != 0 || num == 0)&#123; continue; &#125; else if(set.contains(num/2))&#123; return true; &#125; &#125; return false; &#125;&#125; å½“æ—¶æ€è·¯ï¼š ç”¨setå­˜æ¯ä¸ªnumã€‚ç„¶åéå†arrï¼Œæ‰¾æ˜¯å¦æœ‰å½“å‰numäºŒå€æ•°çš„å­˜åœ¨ã€‚æ³¨æ„é›¶çš„å­˜åœ¨ã€‚ Optimized Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : arr)&#123; if(set.contains(num * 2 ) || num % 2 == 0 &amp;&amp; set.contains(num/2))return true; set.add(num); &#125; return false; &#125;&#125; Trickyã€‚ç›´æ¥åœ¨åŠ å…¥numä¹‹å‰å…ˆåˆ¤æ–­seté‡Œæœ‰æ— å®ƒçš„äºŒå€æ•°æˆ–è€…å®ƒçš„1/2æ•°ã€‚å¦‚æœæ²¡æœ‰åˆ™åŠ å…¥ï¼Œæœ‰åˆ™ç›´æ¥è¿”å›trueã€‚","text":"1346. Check If N and Its Double Exist ğŸ”—Question Link First Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; if(arr == null || arr.length == 0)return false; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0 ;i&lt;arr.length;i++)&#123; set.add(arr[i]); &#125; if(set.size() == 1 &amp;&amp; !set.add(0))return true; if(set.size() == 1) return false; for(int num : arr)&#123; if(num %2 != 0 || num == 0)&#123; continue; &#125; else if(set.contains(num/2))&#123; return true; &#125; &#125; return false; &#125;&#125; å½“æ—¶æ€è·¯ï¼š ç”¨setå­˜æ¯ä¸ªnumã€‚ç„¶åéå†arrï¼Œæ‰¾æ˜¯å¦æœ‰å½“å‰numäºŒå€æ•°çš„å­˜åœ¨ã€‚æ³¨æ„é›¶çš„å­˜åœ¨ã€‚ Optimized Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : arr)&#123; if(set.contains(num * 2 ) || num % 2 == 0 &amp;&amp; set.contains(num/2))return true; set.add(num); &#125; return false; &#125;&#125; Trickyã€‚ç›´æ¥åœ¨åŠ å…¥numä¹‹å‰å…ˆåˆ¤æ–­seté‡Œæœ‰æ— å®ƒçš„äºŒå€æ•°æˆ–è€…å®ƒçš„1/2æ•°ã€‚å¦‚æœæ²¡æœ‰åˆ™åŠ å…¥ï¼Œæœ‰åˆ™ç›´æ¥è¿”å›trueã€‚ 1347. Minimum Number of Steps to Make Two Strings Anagram ğŸ”—Question Link First Solution class Solution &#123; public int minSteps(String s, String t) &#123; int n = s.length(); int sum = 0; int[] arr = new int[26]; for(int i = 0; i &lt; n; i++) &#123; arr[s.charAt(i) - 'a']++; arr[t.charAt(i) - 'a']--; &#125; for(int i = 0; i &lt; arr.length; i++) if(arr[i] &gt; 0) sum += arr[i]; return sum; &#125;&#125; å½“æ—¶æ€è·¯ï¼šarrå­˜æ¯ä¸ªå­—æ¯çš„ä¸ªæ•°ï¼Œç¬¬ä¸€ä¸ª++ï¼Œç¬¬äºŒä¸ªâ€“ï¼Œéå†arrï¼Œåªè¦æŠŠ&gt;0çš„å…¨éƒ¨åŠ èµ·æ¥å°±æ˜¯ç»“æœã€‚å½“ç¬¬äºŒä¸ªå»â€“çš„æ—¶å€™ï¼Œç›¸åŒçš„ä¸ªæ•°è‚¯å®šä»arrä¸­å‡å»ï¼Œå‰©ä¸‹çš„æ˜¯å·®ç¼ºçš„ã€‚ Optimized Solution discussé«˜ç¥¨ç­”æ¡ˆå’Œæˆ‘å·®ä¸å¤šæ€è·¯ã€‚ å‰©ä¸‹å¾…æ›´æ–°","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 75 ğŸ’ª","slug":"chin-up-13","date":"2020-02-07T19:45:35.000Z","updated":"2020-02-09T21:34:44.846Z","comments":true,"path":"2020/02/07/chin-up-13/","link":"","permalink":"WangHngLeee.github.io/2020/02/07/chin-up-13/","excerpt":"133. Clone Graph ğŸ”—Question Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); map.put(node,dummy); while(!queue.isEmpty())&#123; Node temp = queue.poll(); for(Node nb : temp.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb, new Node(nb.val)); queue.add(nb); &#125; map.get(temp).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; Using map to store the node and its copy. Creating dummy node to keep track of the head. Using queue to make bfs of each node in the graph.","text":"133. Clone Graph ğŸ”—Question Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); map.put(node,dummy); while(!queue.isEmpty())&#123; Node temp = queue.poll(); for(Node nb : temp.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb, new Node(nb.val)); queue.add(nb); &#125; map.get(temp).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; Using map to store the node and its copy. Creating dummy node to keep track of the head. Using queue to make bfs of each node in the graph. 138. Copy List with Random Pointer ğŸ”—Question Link class Solution&#123; public Node copyRandomList(Node head) &#123; if(head == null)return null; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node node = head; while(node!=null)&#123; map.put(node,new Node(node.val)); node = node.next; &#125; node = head; while(node!=null)&#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head); &#125;&#125; Using map to store node and its copy, then we iteratively arrange the correct next node and random node to its copy.Loop the map for two times, one for store, another for arrangement. 200. Number of Islands ğŸ”—Question Link class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid == null || grid.length == 0)return 0; // corner case int m = grid.length; int n = grid[0].length; int sum = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == '1')&#123; dfs(grid,i,j,m,n); //dfs sum++;// if dfs end, it means we find an island. &#125; &#125; &#125; return sum; &#125; public void dfs(char[][] grid, int i, int j, int m, int n)&#123; if(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp;grid[i][j] == '1')&#123; grid[i][j] = '0'; // try for different directions. dfs(grid,i+1,j,m,n); dfs(grid,i,j+1,m,n); dfs(grid,i-1,j,m,n); dfs(grid,i,j-1,m,n); &#125; &#125;&#125; Using DFS . When we meet 1, we using dfs to find 1 in four directions. If it stop, it means we find an island and we can not move to the other 1. So we increase sum. THen we try the other position of 1 in the grid. 547. Friend Circles ğŸ”—Question Link class Solution &#123; public int findCircleNum(int[][] M) &#123; if(M == null || M.length == 0)return 0;// corner case int sum = 0; boolean[] seen = new boolean[M.length]; for(int person = 0 ; person&lt;M.length ;person++)&#123; if(!seen[person])&#123; dfs(M,person,seen); sum++; &#125; &#125; return sum; &#125; public void dfs(int[][] M, int person ,boolean[] seen)&#123; for(int i = 0 ;i&lt;M[0].length ;i++)&#123; if(M[person][i] == 1 &amp;&amp; !seen[i])&#123; seen[i] = true; dfs(M,i,seen); &#125; &#125; &#125;&#125; ç±»ä¼¼islandçš„é¢˜ï¼Œç”±äºæ˜¯æ¯ä¸ªåæ ‡ä»£è¡¨ä¸€ä¸ªäººï¼Œè¿™æ¬¡åªéœ€è¦ä¸€è¡Œä¸€è¡Œdfså°±å¯ä»¥ã€‚seenæ£€æŸ¥æ˜¯å¦è®¿é—®è¿‡è¯¥äººã€‚å¯¹åæ ‡å€¼ä¸º1çš„åœ°æ–¹ä¸€å±‚å±‚é€’å½’dfså³å¯ã€‚æ³¨æ„åµŒå¥—å†…dfsçš„ æ–°person å€¼æ˜¯å½“å‰ person çš„ friendã€‚ 695. Max Area of Island ğŸ”—Question Link class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; int area = dfs(grid,i,j,m,n,0); max = Math.max(max,area); &#125; &#125; &#125; return max; &#125; public int dfs(int[][] grid, int i, int j, int m, int n,int area)&#123; if(i &lt;0 || i&gt;=m || j&lt;0 ||j&gt;=n || grid[i][j] == 0)return area; grid[i][j] = 0; area++; area = dfs(grid,i+1,j,m,n,area); area = dfs(grid,i,j+1,m,n,area); area = dfs(grid,i-1,j,m,n,area); area = dfs(grid,i,j-1,m,n,area); return area; &#125;&#125; å’Œ200é¢˜ä¸€æ ·çš„æ€è·¯ã€‚dfsæ›´æ–°areaï¼Œä¿æŒä¸€ä¸ªmaxè®°å½•æœ€å¤§å€¼ã€‚dfsä¸­å¦‚æœé‡åˆ°0æˆ–è€…è¾¹ç•Œé—®é¢˜ç›´æ¥è¿”å›areaã€‚ 733. Flood Fill ğŸ”—Question Link class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if(image == null || image.length == 0)return image; if(image[sr][sc] == newColor)return image; int m = image.length; int n = image[0].length; dfs(image,sr,sc,newColor,m,n,image[sr][sc]); return image; &#125; public void dfs(int[][] image, int sr, int sc, int newColor,int m ,int n,int color)&#123; if(sr &gt;=0 &amp;&amp; sc &gt;=0 &amp;&amp; sr&lt;m &amp;&amp; sc&lt;n &amp;&amp; image[sr][sc] == color)&#123; image[sr][sc] = newColor; dfs(image,sr+1,sc,newColor,m,n,color); dfs(image,sr,sc+1,newColor,m,n,color); dfs(image,sr-1,sc,newColor,m,n,color); dfs(image,sr,sc-1,newColor,m,n,color); &#125; &#125;&#125; dfsã€‚æ³¨æ„æ£€æŸ¥ä¸€å¼€å§‹sr scä½ç½®çš„coloræ˜¯å¦å·²ç»å’Œnewcolorç›¸åŒï¼Œå¦‚æœæ˜¯ç›´æ¥è¿”å›imageï¼Œå°±ä¸ä¼šstack overflowã€‚ä¸æ˜¯ç›´æ¥ä»sr scå¼€å§‹æ‰©æ•£dfsã€‚åªå¯¹å½“å‰ä¸æ˜¯newcolorçš„è¿›è¡Œå˜è‰²ã€‚ 827. Making A Large Island ğŸ”—Question Link class Solution &#123; public int largestIsland(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int max = Integer.MIN_VALUE; for(int i=0;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 0)&#123; grid[i][j] = 1; max = Math.max(max,dfs(i,j,grid,new boolean[m][n])); if(max == m*n)return max; grid[i][j] = 0; &#125; &#125; &#125; return max == Integer.MIN_VALUE ? m*n : max; &#125; public int dfs(int i, int j,int[][] grid, boolean[][] seen)&#123; if(i&gt;=0 &amp;&amp; j &gt;=0 &amp;&amp; i&lt;grid.length &amp;&amp;j&lt;grid[0].length &amp;&amp;!seen[i][j] &amp;&amp; grid[i][j]==1)&#123; seen[i][j] = true; int res = 1 + dfs(i+1,j,grid,seen) + dfs(i,j+1,grid,seen) + dfs(i-1,j,grid,seen) + dfs(i,j-1,grid,seen); return res; &#125;else&#123; return 0; &#125; &#125;&#125; dfs + backtracking. æ€è·¯ç±»ä¼¼island 200. æ‰¾0å¹¶ä¸”backtrackingå›1ã€‚æ³¨æ„boolweanæ•°ç»„ä¸€å®šè¦åœ¨dfsä¸­å®šä¹‰ï¼Œå› ä¸ºæ¯æ¬¡dfsä¿è¯éœ€è¦åªè§åˆ°ä¸€æ¬¡çš„ä½ç½®ä¸åŒã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Leetcode EveryDay 74 ğŸ’ª","slug":"chin-up-12","date":"2020-02-07T18:05:35.000Z","updated":"2020-02-08T20:56:29.388Z","comments":true,"path":"2020/02/07/chin-up-12/","link":"","permalink":"WangHngLeee.github.io/2020/02/07/chin-up-12/","excerpt":"BFS é¢˜ç›® 675. Cut Off Trees for Golf Event ğŸ”—Question Link class Solution &#123; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; if(forest == null || forest.get(0).size() == 0)return 0;//corner case PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(); int n = forest.get(0).size(); int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; for(int i= 0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;);//add all num that &gt; 1 to pq. &#125; &#125; &#125; int sum = 0; int[] start = new int[2]; while(!pq.isEmpty())&#123;// iterate for each num int[] tree = pq.poll(); int step = getmin(forest,start,tree,m,n,moves);// start bfs iterate to find minstep to get to the tree. if(step == -1)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; public int getmin(List&lt;List&lt;Integer&gt;&gt; forest, int[] start, int[] tree, int m, int n, int[][]moves)&#123; // normal bfs to find the min step. boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; int step = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; int[] temp = queue.poll(); if(temp[0] == tree[0] &amp;&amp; temp[1] == tree[1])return step; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125;&#125; pqå­˜æ¯ä¸ªä½ç½®çš„å¤§å°ï¼Œå¹¶ä¸”æŒ‰ç…§ä»å°åˆ°å¤§pollå‡ºã€‚æŠŠå¤§äº1çš„ç‚¹å­˜è¿›pqï¼Œpollå‡ºç¬¬ä¸€ä¸ªç‚¹æ˜¯è¦åˆ°è¾¾çš„treeï¼Œä¸€å¼€å§‹é»˜è®¤startä¸º0ï¼Œ0 ã€‚bfså†™æ³•è™½ç„¶ç†Ÿç»ƒä½†æ˜¯ç»†èŠ‚è¿˜æ˜¯è¦æ³¨æ„ã€‚","text":"BFS é¢˜ç›® 675. Cut Off Trees for Golf Event ğŸ”—Question Link class Solution &#123; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; if(forest == null || forest.get(0).size() == 0)return 0;//corner case PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(); int n = forest.get(0).size(); int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; for(int i= 0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;);//add all num that &gt; 1 to pq. &#125; &#125; &#125; int sum = 0; int[] start = new int[2]; while(!pq.isEmpty())&#123;// iterate for each num int[] tree = pq.poll(); int step = getmin(forest,start,tree,m,n,moves);// start bfs iterate to find minstep to get to the tree. if(step == -1)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; public int getmin(List&lt;List&lt;Integer&gt;&gt; forest, int[] start, int[] tree, int m, int n, int[][]moves)&#123; // normal bfs to find the min step. boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; int step = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; int[] temp = queue.poll(); if(temp[0] == tree[0] &amp;&amp; temp[1] == tree[1])return step; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125;&#125; pqå­˜æ¯ä¸ªä½ç½®çš„å¤§å°ï¼Œå¹¶ä¸”æŒ‰ç…§ä»å°åˆ°å¤§pollå‡ºã€‚æŠŠå¤§äº1çš„ç‚¹å­˜è¿›pqï¼Œpollå‡ºç¬¬ä¸€ä¸ªç‚¹æ˜¯è¦åˆ°è¾¾çš„treeï¼Œä¸€å¼€å§‹é»˜è®¤startä¸º0ï¼Œ0 ã€‚bfså†™æ³•è™½ç„¶ç†Ÿç»ƒä½†æ˜¯ç»†èŠ‚è¿˜æ˜¯è¦æ³¨æ„ã€‚ 127. Word Ladder ğŸ”—Question Link class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(beginWord); int step = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; String temp = queue.poll(); for(int j=0 ;j &lt;endWord.length();j++)&#123; char[] chs = temp.toCharArray(); for(char c = 'a' ; c&lt;='z' ;c++)&#123; chs[j] = c; String newone = new String(chs); if(set.contains(newone))&#123; if(endWord.equals(newone))return step+1; set.remove(newone); queue.add(newone); &#125; &#125; &#125; &#125; step++; &#125; return 0; &#125;&#125; BFSã€‚æ¯ä¸ªcharæ”¹å˜åè®°å¾—newä¸€ä¸ªstringæ¥æ£€æŸ¥ã€‚å¦‚æœå­˜åœ¨seté‡Œï¼Œåˆ™è¦removeæ‰ï¼Œé¿å…é‡å¤ç”¨ã€‚ Partition é¢˜ç›® 698. Partition to K Equal Sum Subsets ğŸ”—Question Link class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for(int num : nums)sum+=num; if( sum % k != 0 || k&lt;=0)return false; boolean[] seen = new boolean[nums.length]; return check(nums,seen,0,k,0,sum/k); &#125; public boolean check(int[] nums, boolean[]seen, int start, int k, int cursum,int target)&#123; if(k == 1)return true; if(cursum == target)return check(nums,seen,0,k-1,0,target); for(int i=start; i&lt;nums.length;i++)&#123; if(!seen[i])&#123; seen[i] = true; if(check(nums,seen,i+1, k ,cursum + nums[i], target))return true; seen[i] = false; &#125; &#125; return false; &#125;&#125; dfsã€‚kä¸ªsumç›¸åŒçš„substetï¼Œå³æ¯ä¸ªçš„suméƒ½ä¸ºnumsçš„å’Œ/kã€‚é€’å½’å¯»æ‰¾ï¼Œå¦‚æœå½“å‰cursumç­‰äºç›®æ ‡å€¼targetï¼Œè¿”å›ä¸Šä¸€å±‚é€’å½’ï¼Œæ‰¾å‰©ä¸‹çš„k-1ä¸ªã€‚å¦åˆ™å¯¹æ¯ä¸ªæ²¡é‡åˆ°çš„æ•°è¿›è¡Œdfs+backtrackingï¼Œä¹‹åæŠŠè¯¥æ•°å˜ä¸ºæœªè§è¿‡ã€‚ 93. Restore IP Addresses ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int len = s.length(); for(int i=1;i&lt;4 &amp;&amp; i&lt;len-2;i++)&#123; for(int j=i+1;j&lt;i+4 &amp;&amp; j&lt;len-1;j++)&#123; for(int k=j+1;k&lt;j+4 &amp;&amp; k&lt;len;k++)&#123; String s1 = s.substring(0,i); String s2 = s.substring(i,j); String s3 = s.substring(j,k); String s4 = s.substring(k,len); if(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123; res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4); &#125; &#125; &#125; &#125; return res; &#125; public boolean check(String a)&#123; if(a.length()&gt;3||a.length()==0||(a.charAt(0)=='0' &amp;&amp; a.length()&gt;1))return false; if(Integer.parseInt(a) &gt; 255)return false; return true; &#125;&#125; åˆ†partè®¨è®ºã€‚å…·ä½“è§£æä¹‹å‰çš„æ¯æ—¥ç¬”è®°å†™è¿‡ã€‚ 131. Palindrome Partitioning ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;String&gt; templist = new ArrayList&lt;&gt;(); if(s == null || s.length() == 0)return res; help(res,templist,0,s); return res; &#125; public void help(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; templist, int start, String s)&#123; if(start == s.length())res.add(new ArrayList&lt;&gt;(templist)); else&#123; for(int i = start ;i &lt; s.length() ; i++)&#123; if(valid(s,start,i))&#123; templist.add(s.substring(start,i+1)); help(res,templist,i+1,s); templist.remove(templist.size()-1); &#125; &#125; &#125; &#125; public boolean valid(String s, int left, int right)&#123; while( left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right))return false; left++; right--; &#125; return true; &#125;&#125; dfs + backtracking. Add one function to check whether the string is Palindrome. Remember we start from the left most and right most, itâ€™s different from the previous questions which start from the center to two sides. 241. Different Ways to Add Parentheses ğŸ”—Question Link class Solution &#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(input == null || input.length() == 0)return res; for(int i=0 ;i&lt;input.length();i++)&#123; char c = input.charAt(i); if(c == '+' || c== '-' || c=='*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; list1 = map.getOrDefault(part1,diffWaysToCompute(part1)); List&lt;Integer&gt; list2 = map.getOrDefault(part2,diffWaysToCompute(part2)); for(int num1 : list1)&#123; for(int num2 : list2)&#123; int cursum = 0; switch(c)&#123; case '+': cursum = num1 + num2; break; case '-': cursum = num1 - num2; break; case '*': cursum = num1 * num2; break; &#125; res.add(cursum); &#125; &#125; &#125; &#125; if(res.size() == 0)res.add(Integer.valueOf(input)); map.put(input,res); return res; &#125;&#125; Recursive + Memo. Using map to store the correspond total possible answers to the current part of string. This way can help reduce the total time because we have already store the key-value of them. In terms of different operation symbol, we have to add different number to the resã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"Partition","slug":"Partition","permalink":"WangHngLeee.github.io/tags/Partition/"}]},{"title":"Leetcode EveryDay 73 ğŸ’ª","slug":"chin-up-11","date":"2020-02-06T19:01:53.000Z","updated":"2020-02-07T00:39:23.490Z","comments":true,"path":"2020/02/06/chin-up-11/","link":"","permalink":"WangHngLeee.github.io/2020/02/06/chin-up-11/","excerpt":"451. N-Queens ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] chess = new char[n][n]; for(int i=0 ;i&lt;n;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; chess[i][j] = '.'; // used to created new chess board. &#125; &#125; dfs(chess,0,res); return res; &#125; public void dfs(char[][] chess, int row, List&lt;List&lt;String&gt;&gt; res)&#123; if(row == chess.length)&#123; res.add(build(chess)); return; &#125; for(int col = 0; col &lt; chess.length;col++)&#123; if(valid(row,col,chess))&#123; chess[row][col] = 'Q'; // æ”¹æˆQ dfs(chess,row+1,res); // dfsåˆ°ä¸‹ä¸€è¡Œ chess[row][col] = '.'; //æ”¹å› â€™.' &#125; &#125; &#125; public boolean valid(int row ,int col, char[][]chess)&#123; for(int i=0;i&lt;row; i++)&#123; // æ£€æŸ¥åŒä¸€åˆ—æœ‰æ— Qï¼Œè¡Œä¸ç”¨æ£€æŸ¥å› ä¸ºæ ¹æ®è¡Œéå†ã€‚ if(chess[i][col] == 'Q')return false; &#125; for(int i = row-1,j=col+1;i&gt;=0 &amp;&amp;j&lt;chess.length;i--,j++)&#123; if(chess[i][j] == 'Q')return false;//æ£€æŸ¥æ­£å¯¹è§’çº¿æœ‰æ— Q &#125; for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0 ;i--,j--)&#123; if(chess[i][j] =='Q')return false; &#125;//æ£€æŸ¥é€†å¯¹è§’çº¿æœ‰æ— Q return true; &#125; public List&lt;String&gt; build(char[][] chess)&#123; List&lt;String&gt; path = new ArrayList&lt;&gt;();//æœ€åæŠŠchessæ ¹æ®æ¯ä¸€è¡ŒåŠ å…¥resã€‚ for(int i=0 ;i&lt;chess.length;i++)&#123; path.add(new String(chess[i])); &#125; return path; &#125;&#125; DFSã€‚queenæ¸¸æˆè§„åˆ™æ˜¯åŒä¸€åˆ—/åŒä¸€è¡Œ/æ­£å¯¹è§’/æ–œå¯¹è§’ä¸èƒ½æœ‰Qå­˜åœ¨ï¼Œç”±äºæˆ‘ä»¬æ ¹æ®è¡Œæ•°æ¥éå†dfsï¼Œæ‰€ä»¥æ£€æŸ¥validå‡½æ•°è¦è€ƒè™‘ï¼ˆåˆ—/æ­£å¯¹è§’/æ–œå¯¹è§’ï¼‰ä¸‰ç§æƒ…å†µã€‚","text":"451. N-Queens ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] chess = new char[n][n]; for(int i=0 ;i&lt;n;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; chess[i][j] = '.'; // used to created new chess board. &#125; &#125; dfs(chess,0,res); return res; &#125; public void dfs(char[][] chess, int row, List&lt;List&lt;String&gt;&gt; res)&#123; if(row == chess.length)&#123; res.add(build(chess)); return; &#125; for(int col = 0; col &lt; chess.length;col++)&#123; if(valid(row,col,chess))&#123; chess[row][col] = 'Q'; // æ”¹æˆQ dfs(chess,row+1,res); // dfsåˆ°ä¸‹ä¸€è¡Œ chess[row][col] = '.'; //æ”¹å› â€™.' &#125; &#125; &#125; public boolean valid(int row ,int col, char[][]chess)&#123; for(int i=0;i&lt;row; i++)&#123; // æ£€æŸ¥åŒä¸€åˆ—æœ‰æ— Qï¼Œè¡Œä¸ç”¨æ£€æŸ¥å› ä¸ºæ ¹æ®è¡Œéå†ã€‚ if(chess[i][col] == 'Q')return false; &#125; for(int i = row-1,j=col+1;i&gt;=0 &amp;&amp;j&lt;chess.length;i--,j++)&#123; if(chess[i][j] == 'Q')return false;//æ£€æŸ¥æ­£å¯¹è§’çº¿æœ‰æ— Q &#125; for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0 ;i--,j--)&#123; if(chess[i][j] =='Q')return false; &#125;//æ£€æŸ¥é€†å¯¹è§’çº¿æœ‰æ— Q return true; &#125; public List&lt;String&gt; build(char[][] chess)&#123; List&lt;String&gt; path = new ArrayList&lt;&gt;();//æœ€åæŠŠchessæ ¹æ®æ¯ä¸€è¡ŒåŠ å…¥resã€‚ for(int i=0 ;i&lt;chess.length;i++)&#123; path.add(new String(chess[i])); &#125; return path; &#125;&#125; DFSã€‚queenæ¸¸æˆè§„åˆ™æ˜¯åŒä¸€åˆ—/åŒä¸€è¡Œ/æ­£å¯¹è§’/æ–œå¯¹è§’ä¸èƒ½æœ‰Qå­˜åœ¨ï¼Œç”±äºæˆ‘ä»¬æ ¹æ®è¡Œæ•°æ¥éå†dfsï¼Œæ‰€ä»¥æ£€æŸ¥validå‡½æ•°è¦è€ƒè™‘ï¼ˆåˆ—/æ­£å¯¹è§’/æ–œå¯¹è§’ï¼‰ä¸‰ç§æƒ…å†µã€‚ 52. N-Queens II ğŸ”—Question Link class Solution &#123; int res = 0; public int totalNQueens(int n) &#123; boolean[] col = new boolean[n*2-1]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; public void solve (int row, int n, boolean[] col, boolean[] diag1, boolean[]diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0 ;j&lt;n;j++)&#123; if(!col[j] &amp;&amp; !diag1[j + row] &amp;&amp; !diag2[j-row+n-1])&#123; col[j] = diag1[j+row] = diag2[j-row+n-1] = true; solve(row+1,n,col,diag1,diag2); col[j] = diag1[j+row] = diag2[j-row+n-1] = false; &#125; &#125; &#125;&#125; DFSã€‚å’ŒIä¸åŒä¹‹å¤„æ˜¯è¦è¿”å›å¯èƒ½çš„æƒ…å†µä¸ªæ•°ï¼Œä½†æ˜¯ä¸ç”¨åƒIä¸€æ ·éº»çƒ¦ã€‚æ€è·¯ä¸€æ ·ï¼Œå¯¹ä¸‰ä¸ªæ–¹å‘æ£€æŸ¥ï¼Œtrueè¡¨æ˜æœ‰Qï¼Œfalseè¡¨æ˜æ²¡æœ‰Qï¼Œåˆ›å»ºä¸‰ä¸ªæ–¹å‘çš„booleanæ•°ç»„ï¼Œè¿™é‡Œè¦æ³¨æ„æ­£/æ–œå¯¹è§’çš„ä¸ªæ•°ä»¥åŠindexå’Œrowï¼Œcolçš„å…³ç³»ï¼Œç”»ä¸ªå›¾å°±èƒ½æ˜ç™½ã€‚ 37. Sudoku Solver ğŸ”—Question Link class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0)return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0 ;i&lt;board.length;i++)&#123; for(int j=0 ;j&lt;board[0].length ;j++)&#123; if(board[i][j] =='.')&#123; for(char c = '1' ; c&lt;='9' ;c++)&#123; if(valid(board,i,j,c))&#123; board[i][j] = c; if(solve(board))return true; else&#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean valid(char[][] board, int row, int col, char c)&#123; for(int i=0 ;i&lt;9 ;i++)&#123; if(board[i][col] != '.' &amp;&amp; board[i][col] == c)return false; // check each col; if(board[row][i] != '.' &amp;&amp; board[row][i] == c)return false; //check each row; if(board[3*(row /3)+i/3][3*(col/3)+i%3]!='.'&amp;&amp;board[3*(row/3)+i/3][3*(col/3)+i%3]==c)return false; &#125; return true; &#125;&#125; DFSã€‚ç±»ä¼¼queençš„é¢˜ã€‚éå†å›¾ï¼Œå¯¹â€˜.â€˜çš„ç‚¹è¿›è¡Œdfsã€‚ä»1-9è¿›è¡Œé€‰æ‹©ï¼Œç„¶åæ£€æŸ¥å½“å‰é€‰æ‹©çš„æ•°æ˜¯å¦å¯ä»¥æ”¾ï¼Œå¦‚æœå¯ä»¥åˆ™è°ƒç”¨solveå‡½æ•°ç»§ç»­dfsã€‚å¦‚æœä¸è¡Œåˆ™æŠŠå½“å‰ä½ç½®å˜å›â€™.â€™ã€‚ éš¾ç‚¹åœ¨validå‡½æ•°é‡Œå¯¹æ¯ä¸€ä¸ª3x3æ–¹æ ¼çš„æ£€æŸ¥ã€‚è¡Œç”¨/ åˆ—ç”¨%ã€‚ 22. Generate Parentheses ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(n == 0)return res; dfs(\"\",res,0,0,n); return res; &#125; public void dfs(String cur, List&lt;String&gt; res, int left, int right, int n)&#123; if(left == n &amp;&amp; right == n)res.add(cur); if(left &lt; n)&#123; dfs(cur+\"(\",res,left+1,right,n); &#125; if(right &lt; left)&#123; dfs(cur+\")\",res,left,right+1,n); &#125; &#125;&#125; dfsã€‚leftå’Œrightéƒ½ä¸ºnä¸ªï¼Œåˆ™æŠŠliståŠ å…¥resã€‚åªæœ‰å½“right&lt;leftæ—¶æ‰é€’å½’åŠ å…¥å³æ‹¬å·ã€‚ 542. 01 Matrix ğŸ”—Question Link class Solution &#123; public int[][] updateMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return null; Queue&lt;int[]&gt; queue = new LinkedList(); int m = matrix.length; int n = matrix[0].length; int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; for(int i=0 ;i&lt;m;i++)&#123; for(int j = 0; j&lt;n;j++)&#123; if(matrix[i][j] == 1)&#123; matrix[i][j] = -1; &#125;else&#123; queue.add(new int[]&#123;i,j&#125;); &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] cur = queue.poll(); for(int[] move : moves)&#123; int x = cur[0] + move[0]; int y = cur[1] + move[1]; if(x&lt;0 || y&lt;0 || x&gt;=m ||y&gt;=n || matrix[x][y] !=-1 )continue; queue.add(new int[]&#123;x,y&#125;); matrix[x][y] = matrix[cur[0]][cur[1]]+1; &#125; &#125; return matrix; &#125;&#125; bfsã€‚å…ˆæŠŠ0çš„åæ ‡åŠ è¿›queueï¼ŒæŠŠä¸ä¸ºé›¶çš„ä½ç½®å€¼å˜ä¸º-1ã€‚ä»å¤–å›´å¾€é‡Œæ‰«æï¼Œå¦‚æœæ›´æ–°åçš„ä½ç½®ä¸ä¸º-1ï¼Œè¯´æ˜æ²¡æœ‰æ‰¾åˆ°ä¸ä¸ºé›¶çš„ä½ç½®ï¼Œç»§ç»­æ‰«æã€‚å¦‚æœæ›´æ–°åçš„ä½ç½®ä¸º-1ï¼Œè¯´æ˜å½“å‰ä½ç½®æ˜¯0ï¼Œæ‰€ä»¥æŠŠæ›´æ–°åä½ç½®çš„å€¼å˜ä¸ºå½“å‰ä½ç½®+1ï¼Œä¾æ¬¡ç±»æ¨ã€‚ 934. Shortest Bridge ğŸ”—Question Link class Solution &#123; public int shortestBridge(int[][] A) &#123; int m = A.length, n = A[0].length; boolean[][] visited = new boolean[m][n]; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); boolean found = false; // dfs to find the whole index of first island. for (int i = 0; i &lt; m; i++) &#123; if (found) &#123; break; &#125; for (int j = 0; j &lt; n; j++) &#123; if (A[i][j] == 1) &#123; dfs(A, visited, q, i, j, dirs); found = true; break; &#125; &#125; &#125; // using bfs to find the step to connect another island int step = 0; while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; int[] cur = q.poll(); for (int[] dir : dirs) &#123; int i = cur[0] + dir[0]; int j = cur[1] + dir[1]; if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n &amp;&amp; !visited[i][j]) &#123; if (A[i][j] == 1) &#123; return step; &#125; q.offer(new int[]&#123;i, j&#125;); visited[i][j] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125; private void dfs(int[][] A, boolean[][] visited, Queue&lt;int[]&gt; q, int i, int j, int[][] dirs) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= A.length || j &gt;= A[0].length || visited[i][j] || A[i][j] == 0) &#123; return; &#125; visited[i][j] = true; q.offer(new int[]&#123;i, j&#125;); for (int[] dir : dirs) &#123; dfs(A, visited, q, i + dir[0], j + dir[1], dirs); &#125; &#125;&#125; dfs + bfsã€‚ dfsæ¥æ‰¾ä»»æ„ä¸€ä¸ª1æ‰€å±çš„islandçš„æ‰€æœ‰1çš„åæ ‡ã€‚bfsåˆ™ç”¨æ¥æ ¹æ®å½“å‰æ‰¾åˆ°çš„islandæ‰€æœ‰åæ ‡ï¼Œæ¥æ‰¾èƒ½è¿æ¥åˆ°å¦å¤–ä¸€ä¸ªå²›çš„1æ‰€éœ€è¦çš„stepsã€‚dfsè¿‡ç¨‹ä¸­éœ€å®šä¹‰ä¸€ä¸ªbooleanå€¼æ¥åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°å…¨éƒ¨çš„å²›ï¼Œå¦‚æœtrueåˆ™ç›´æ¥è¿›å…¥bfsã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 72 ğŸ’ª","slug":"chin-up-10","date":"2020-02-05T19:27:43.000Z","updated":"2020-02-06T05:22:26.822Z","comments":true,"path":"2020/02/05/chin-up-10/","link":"","permalink":"WangHngLeee.github.io/2020/02/05/chin-up-10/","excerpt":"752. Open the Lock ğŸ”—Question Link class Solution &#123; public int openLock(String[] deadends, String target)&#123; Set&lt;String&gt; deads = new HashSet&lt;&gt;(); for(String str: deadends)&#123; deads.add(str); &#125; Set&lt;String&gt; seen = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(\"0000\"); seen.add(\"0000\"); int steps = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; String temp = queue.poll(); if(deads.contains(temp))continue; if(temp.equals(target))return steps; for(int j=0 ;j&lt;4;j++)&#123; char c = temp.charAt(j); String s1 = temp.substring(0,j) + ( c =='9' ? 0:c-'0'+1 ) + temp.substring(j+1); String s2 = temp.substring(0,j) + ( c =='0' ? 9:c-'0'-1 ) + temp.substring(j+1); if(!seen.contains(s1) &amp;&amp;!deads.contains(s1))&#123; queue.add(s1); seen.add(s1); &#125; if(!seen.contains(s2) &amp;&amp;!deads.contains(s2))&#123; queue.add(s2); seen.add(s2); &#125; &#125; &#125; steps++; &#125; return -1; &#125;&#125; ç»å…¸BFSã€‚æ³¨æ„å¯¹å››ä½åˆ†åˆ«è¿›è¡Œé¡ºæ—¶é’ˆ+1å’Œ é€†æ—¶é’ˆ+1æ“ä½œï¼Œå¹¶ä¸”åˆ¤æ–­æ–°çš„stringæ˜¯å¦åœ¨deadså’Œseené‡Œï¼Œç„¶ååŠ å…¥queueã€‚æ³¨æ„ä¸¤ä¸ªstringåªèƒ½equalsæ¯”è¾ƒæ˜¯å¦ç›¸åŒï¼Œ==æ²¡ç”¨ï¼Œä¼šä¸€ç›´ä¸æˆåŠŸã€‚","text":"752. Open the Lock ğŸ”—Question Link class Solution &#123; public int openLock(String[] deadends, String target)&#123; Set&lt;String&gt; deads = new HashSet&lt;&gt;(); for(String str: deadends)&#123; deads.add(str); &#125; Set&lt;String&gt; seen = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(\"0000\"); seen.add(\"0000\"); int steps = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; String temp = queue.poll(); if(deads.contains(temp))continue; if(temp.equals(target))return steps; for(int j=0 ;j&lt;4;j++)&#123; char c = temp.charAt(j); String s1 = temp.substring(0,j) + ( c =='9' ? 0:c-'0'+1 ) + temp.substring(j+1); String s2 = temp.substring(0,j) + ( c =='0' ? 9:c-'0'-1 ) + temp.substring(j+1); if(!seen.contains(s1) &amp;&amp;!deads.contains(s1))&#123; queue.add(s1); seen.add(s1); &#125; if(!seen.contains(s2) &amp;&amp;!deads.contains(s2))&#123; queue.add(s2); seen.add(s2); &#125; &#125; &#125; steps++; &#125; return -1; &#125;&#125; ç»å…¸BFSã€‚æ³¨æ„å¯¹å››ä½åˆ†åˆ«è¿›è¡Œé¡ºæ—¶é’ˆ+1å’Œ é€†æ—¶é’ˆ+1æ“ä½œï¼Œå¹¶ä¸”åˆ¤æ–­æ–°çš„stringæ˜¯å¦åœ¨deadså’Œseené‡Œï¼Œç„¶ååŠ å…¥queueã€‚æ³¨æ„ä¸¤ä¸ªstringåªèƒ½equalsæ¯”è¾ƒæ˜¯å¦ç›¸åŒï¼Œ==æ²¡ç”¨ï¼Œä¼šä¸€ç›´ä¸æˆåŠŸã€‚ 33. Search in Rotated Sorted Array ğŸ”—Question Link class Solution &#123; public int search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int len = nums.length-1; int left=0; int right = len; while(left + 1 &lt; right)&#123; int mid = left + (right-left)/2; if(nums[mid] &gt;= nums[left])&#123; if(target&lt;= nums[mid] &amp;&amp; target &gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125; else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[len])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if(nums[mid] == target)return mid; &#125; if(nums[left] == target)return left; else if(nums[right] == target)return right; return -1; &#125;&#125; sortçš„æ•°ç»„è¢«rotateåè‚¯å®šæœ‰ä¸¤éƒ¨åˆ†é€’å¢çš„åŒºåŸŸã€‚mid&gt;leftè¯´æ˜midåœ¨è¾ƒå¤§çš„é€’å¢ä¸€ä¾§ï¼Œå¦åˆ™æ˜¯åœ¨è¾ƒå°çš„é€’å¢åŒºã€‚é’ˆå¯¹æ¯ä¸ªåŒºï¼Œè¿›è¡Œæ­£å¸¸çš„binary searchæ“ä½œï¼Œå¯¹leftå’Œrightæ“ä½œã€‚ ç”±äºç”¨çš„æ˜¯while left + 1 &lt; rightçš„å†™æ³•ï¼Œæ‰€ä»¥æœ€åè¦å…ˆæ£€æŸ¥leftæ˜¯å¦ç­‰äºtargetï¼Œç„¶åå†æ£€æŸ¥rightã€‚ 79. Word Search ğŸ”—Question Link class Solution &#123; public boolean exist(char[][] board, String word) &#123; if(board == null || board.length == 0)return false; int m = board.length; int n = board[0].length; for(int i=0 ; i&lt;m ;i++)&#123; for(int j=0 ; j&lt;n; j++)&#123; if(find(board,i,j,word,0))return true; &#125; &#125; return false; &#125; public boolean find(char[][] board, int i, int j,String word, int index)&#123; if(index == word.length())return true; if(i&lt;0 || i&gt;=board.length || j&lt;0 || j&gt;=board[0].length || board[i][j] != word.charAt(index))return false; board[i][j] = '*'; boolean res = find(board,i+1,j,word,index+1) || find(board,i,j+1,word,index+1) || find(board,i,j-1,word,index+1) || find(board,i-1,j,word,index+1); board[i][j] = word.charAt(index); return res; &#125;&#125; dfs + backtracking. æ³¨æ„dfsä¹‹å‰æŠŠæ”¹ä¸ºå€¼çš„å­—ç¬¦å˜ä¸º*ï¼Œdfsä¹‹åå†æ¢å¤ã€‚æœ¬è´¨å°±æ˜¯åœ¨æœç´¢æ ‘çš„æ‰€æœ‰æƒ…å†µé‡Œæ‰¾æ˜¯å¦å­˜åœ¨wordè¿™ä¸ªæ’åˆ—ç»„åˆã€‚ 784. Letter Case Permutation ğŸ”—Question Link BFS Solution class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String s : queue)&#123; res.add(s); &#125; return res; &#125;&#125; æŠŠæ¯ä¸ªå­—æ¯å¤§å°å†™æƒ…å†µå…¨åŠ è¿›queueï¼Œç„¶åä¾æ¬¡å¾€åå¾ªç¯éå†ï¼Œæœ€åæŠŠSä¸­æ¯ä¸ªå­—æ¯å¤§å°å†™çš„æ‰€æœ‰æƒ…å†µå…¨éƒ¨åŠ å…¥äº†queueã€‚æ³¨æ„è·³è¿‡ä¸ºæ•°å­—çš„charã€‚æœ€åqueueä¸­çš„ä¸ªæ•°åº”è¯¥æ˜¯Så­—æ¯é•¿åº¦çš„é˜¶ä¹˜ã€‚ DFS Solution class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; char[] s = S.toCharArray(); help(s,res,0); return res; &#125; public void help(char[] s, List&lt;String&gt; res, int pos)&#123; if(pos == s.length)&#123; res.add(new String(s)); return; &#125; // ignore digit case if(s[pos]&gt;='0' &amp;&amp; s[pos]&lt;='9')&#123; help(s,res,pos+1); return; &#125; //upper case s[pos] = Character.toUpperCase(s[pos]); help(s,res,pos+1); // lower case s[pos] = Character.toLowerCase(s[pos]); help(s,res,pos+1); &#125;&#125; upper å’Œ lowerçš„æƒ…å†µéƒ½è¦å„è‡ªè¿›è¡Œdfsã€‚ 560. Subarray Sum Equals K ğŸ”—Question Link class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if(nums == null || nums.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int sum = 0; int count = 0; for(int num : nums)&#123; sum+=num; if(map.containsKey(sum - k))&#123; count += map.get(sum- k); &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; ç¬¬ä¸‰éã€‚Presumæ–¹æ³•ã€‚sumä¸€ç›´ç´¯åŠ ï¼Œmapå­˜å„ä¸ªsumå€¼çš„æ¬¡æ•°ã€‚countåŠ ä¸Šsum-kå°±æ˜¯ç›®å‰çš„subarrayæ•°é‡ã€‚ 55. Jump Game ğŸ”—Question Link class Solution &#123; public boolean canJump(int[] nums) &#123; int dist = 0; for(int i = 0 ;i&lt;nums.length;i++)&#123; if(i&gt;dist)return false; dist = Math.max(dist,i+nums[i]); &#125; return true; &#125;&#125; greedyã€‚ 45. Jump Game II ğŸ”—Question Link class Solution &#123; public int jump(int[] nums) &#123; int curend = 0, fast = 0, steps = 0; for(int i = 0 ;i&lt;nums.length-1;i++)&#123; fast = Math.max(fast,i+nums[i]); if(i == curend)&#123; curend = fast; steps++; &#125; &#125; return steps; &#125;&#125; curendæ˜¯ä¸Šä¸€æ­¥æœ€è¿œè·ç¦»ï¼Œå¦‚æœåˆ°è¾¾äº†curendï¼Œåˆ™step++ï¼Œè¯´æ˜ä¸Šä¸€æ­¥çš„èµ·è·³å·²ç»ç»“æŸã€‚å°†ä¸‹ä¸€ä¸ªcurendæ›´æ–°ä¸ºfastã€‚ 1306. Jump Game III ğŸ”—Question Link Recursive Soluiton class Solution &#123; public boolean canReach(int[] arr, int start) &#123; if(start&gt;= 0 &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;=0 &amp;&amp; arr[start] &lt; arr.length)&#123; int jumpto = arr[start]; arr[start] = -1; if(jumpto == 0)&#123; return true; &#125;else&#123; return canReach(arr,start + jumpto) || canReach(arr,start - jumpto); &#125; &#125; return false; &#125;&#125; jumpæ˜¯å½“å‰èƒ½è·³çš„æ­¥æ•°ï¼Œç„¶åå°†å…¶å˜ä¸º-1ã€‚å¦‚æœjumptoæ˜¯0ï¼Œåˆ™ç›´æ¥è¿”å›trueã€‚å¦åˆ™é€’å½’è°ƒç”¨å‘å·¦æˆ–å‘å³è·³çš„æƒ…å†µã€‚ Iterative Solution class Solution &#123; public boolean canReach(int[] arr, int start) &#123; if(arr == null || arr.length == 0)return false; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); HashSet&lt;Integer&gt; seen = new HashSet&lt;&gt;(); while(!queue.isEmpty())&#123; int idx = queue.poll(); if(arr[idx] == 0)return true; if(seen.contains(idx))continue; seen.add(idx); if(idx + arr[idx]&lt;arr.length)&#123; queue.add(idx + arr[idx]); &#125; if(idx - arr[idx] &gt;=0)&#123; queue.add(idx - arr[idx]); &#125; &#125; return false; &#125;&#125; queue bfsã€‚ seenåˆ¤æ–­æ˜¯å¦èµ°è¿‡ã€‚ä¿è¯å½“å‰åæ ‡åŠ ä¸Šæœ€å¤§æ­¥æ•°å°äºarr.length ä»¥åŠ &gt;=0ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"Presum","slug":"Presum","permalink":"WangHngLeee.github.io/tags/Presum/"}]},{"title":"Study Go Day 1 ğŸš©","slug":"go1","date":"2020-02-05T04:11:20.000Z","updated":"2020-02-05T23:57:17.486Z","comments":true,"path":"2020/02/04/go1/","link":"","permalink":"WangHngLeee.github.io/2020/02/04/go1/","excerpt":"ä»Šå¤©å­¦ä¹ äº†Goçš„åŸºæœ¬è¯­æ³•å’Œæ•°æ®ç»“æ„ã€‚æ„Ÿè§‰å’ŒRubyæœ‰ç‚¹åƒâ€¦ ä»¥ä¸‹æ˜¯å’Œä»¥å¾€å­¦ä¹ çš„è¯­è¨€æœ‰å¾ˆå¤§ä¸åŒçš„åœ°æ–¹ã€‚ å£°æ˜ç±»å‹ GOå’Œjavaçš„ç±»å‹å£°æ˜æ­£å¥½ç›¸åï¼Œjavaç±»å‹å†™åœ¨å˜é‡å‰é¢ï¼Œè€ŒGoå†™åœ¨å˜é‡åé¢ã€‚var name type = xxx. ä¾‹å¦‚ï¼švar a int = avar a float64 = 1.3423","text":"ä»Šå¤©å­¦ä¹ äº†Goçš„åŸºæœ¬è¯­æ³•å’Œæ•°æ®ç»“æ„ã€‚æ„Ÿè§‰å’ŒRubyæœ‰ç‚¹åƒâ€¦ ä»¥ä¸‹æ˜¯å’Œä»¥å¾€å­¦ä¹ çš„è¯­è¨€æœ‰å¾ˆå¤§ä¸åŒçš„åœ°æ–¹ã€‚ å£°æ˜ç±»å‹ GOå’Œjavaçš„ç±»å‹å£°æ˜æ­£å¥½ç›¸åï¼Œjavaç±»å‹å†™åœ¨å˜é‡å‰é¢ï¼Œè€ŒGoå†™åœ¨å˜é‡åé¢ã€‚var name type = xxx. ä¾‹å¦‚ï¼švar a int = avar a float64 = 1.3423 Goè¯­è¨€çš„åŸºæœ¬ç±»å‹æœ‰ï¼š bool string intã€int8ã€int16ã€int32ã€int64 uintã€uint8ã€uint16ã€uint32ã€uint64ã€uintptr byte // uint8 çš„åˆ«å rune // int32 çš„åˆ«å ä»£è¡¨ä¸€ä¸ª Unicode ç  float32ã€float64 complex64ã€complex128 æ‰¹é‡æ ¼å¼ æ¯è¡Œéƒ½ç”¨ var å£°æ˜å˜é‡æ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜å¯ä»¥æ‰¹é‡å®šä¹‰å˜é‡ï¼š var ( a int b string c []float32 d func() bool e struct &#123; x int &#125;) ä½¿ç”¨å…³é”®å­— var å’Œæ‹¬å·ï¼Œå¯ä»¥å°†ä¸€ç»„å˜é‡å®šä¹‰æ”¾åœ¨ä¸€èµ·ã€‚ ç®€çŸ­æ ¼å¼ é™¤ var å…³é”®å­—å¤–ï¼Œè¿˜å¯ä½¿ç”¨æ›´åŠ ç®€çŸ­çš„å˜é‡å®šä¹‰å’Œåˆå§‹åŒ–è¯­æ³•ã€‚ åå­— := è¡¨è¾¾å¼ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç®€çŸ­æ¨¡å¼ï¼ˆshort variable declarationï¼‰æœ‰ä»¥ä¸‹é™åˆ¶ï¼š å®šä¹‰å˜é‡ï¼ŒåŒæ—¶æ˜¾å¼åˆå§‹åŒ–ã€‚ ä¸èƒ½æä¾›æ•°æ®ç±»å‹ã€‚åªèƒ½ç”¨åœ¨å‡½æ•°å†…éƒ¨ã€‚ å’Œ var å½¢å¼å£°æ˜è¯­å¥ä¸€æ ·ï¼Œç®€çŸ­å˜é‡å£°æ˜è¯­å¥ä¹Ÿå¯ä»¥ç”¨æ¥å£°æ˜å’Œåˆå§‹åŒ–ä¸€ç»„å˜é‡ï¼š i := 0j := 1a := falseb := \"ewarwar\"","categories":[{"name":"Language","slug":"Language","permalink":"WangHngLeee.github.io/categories/Language/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"WangHngLeee.github.io/tags/Golang/"}]},{"title":"Leetcode EveryDay 71 ğŸ’ª","slug":"chin-up-09","date":"2020-02-04T15:23:15.000Z","updated":"2020-02-05T23:57:14.555Z","comments":true,"path":"2020/02/04/chin-up-09/","link":"","permalink":"WangHngLeee.github.io/2020/02/04/chin-up-09/","excerpt":"11. Container With Most Water ğŸ”—Question Link class Solution &#123; public int maxArea(int[] height)&#123; int left = 0; int right = height.length-1; int max = Integer.MIN_VALUE; while(left &lt; right)&#123; max = Math.max(max,Math.min(height[left],height[right]) * (right - left )); if(height[left] &lt; height[right])&#123; left++; &#125;else&#123; right--; &#125; &#125; return max; &#125;&#125; åŒæŒ‡é’ˆã€‚å–å½“å‰height[left] height[right]çš„æœ€å°å€¼ä¸ºé«˜ï¼Œrightå’Œleftçš„å·®ä¸ºé•¿ï¼Œç›¸ä¹˜ä¸ºå½“å‰areaï¼Œä¸maxæ¯”è¾ƒã€‚å¦‚æœleftçš„heightå°äºrightï¼Œåˆ™left++ï¼Œå¦åˆ™rightâ€“ã€‚ç›®çš„æ˜¯ä¿è¯ä¸€ä¾§ä¸ºæœ€å¤§é«˜åº¦ã€‚","text":"11. Container With Most Water ğŸ”—Question Link class Solution &#123; public int maxArea(int[] height)&#123; int left = 0; int right = height.length-1; int max = Integer.MIN_VALUE; while(left &lt; right)&#123; max = Math.max(max,Math.min(height[left],height[right]) * (right - left )); if(height[left] &lt; height[right])&#123; left++; &#125;else&#123; right--; &#125; &#125; return max; &#125;&#125; åŒæŒ‡é’ˆã€‚å–å½“å‰height[left] height[right]çš„æœ€å°å€¼ä¸ºé«˜ï¼Œrightå’Œleftçš„å·®ä¸ºé•¿ï¼Œç›¸ä¹˜ä¸ºå½“å‰areaï¼Œä¸maxæ¯”è¾ƒã€‚å¦‚æœleftçš„heightå°äºrightï¼Œåˆ™left++ï¼Œå¦åˆ™rightâ€“ã€‚ç›®çš„æ˜¯ä¿è¯ä¸€ä¾§ä¸ºæœ€å¤§é«˜åº¦ã€‚ 42. Trapping Rain Water ğŸ”—Question Link class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; ç¬¬å››éã€‚åŒæŒ‡é’ˆã€‚ç»´æŠ¤æœ€å·¦å’Œæœ€å³è¾¹çš„æœ€å¤§é«˜åº¦ï¼Œå¦‚æœæœ€å·¦è¾¹æœ€é«˜å°äºæœ€å³è¾¹æœ€é«˜ï¼Œé€šè¿‡çŸ­æ¿æœ¨æ¡¶åŸç†ï¼Œå¯çŸ¥å½“å‰æœ€å¤§å­˜æ°´åªèƒ½åœ¨æœ€å·¦è¾¹ï¼Œæ‰€ä»¥ç”¨height[left]å’Œleftmostæ¯”è¾ƒï¼Œä»–ä¿©çš„å·®å°±æ˜¯å·¦è¾¹åŒºåŸŸå¯ä»¥å­˜çš„æ°´é‡ã€‚å³è¾¹åŒç†ã€‚ 986. Interval List Intersections ğŸ”—Question Link class Solution &#123; public int[][] intervalIntersection(int[][] A, int[][] B) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int a= 0, b = 0; while(a &lt; A.length &amp;&amp; b &lt; B.length)&#123; int start = Math.max( A[a][0] , B[b][0] ); int end = Math.min( A[a][1] , B[b][1] ); if(start &lt;= end)res.add(new int[]&#123;start,end&#125;); if( A[a][1] &lt; B[b][1] ) a++; else b++; &#125; int[][] ans = new int[res.size()][2]; int i= 0; for(int[] num : res)&#123; ans[i] = num; i++; &#125; return ans; &#125;&#125; two pointerã€‚åªæœ‰å½“ä¸¤ä¸ªintervalçš„å¼€å¤´æœ€å¤§å€¼ å°äº ç»“æŸæœ€å°å€¼æ—¶ï¼Œæ‰ä¼šæœ‰overlapã€‚æ¥ç€ï¼Œä¸è®ºæœ‰æ²¡æœ‰overlapï¼Œå¦‚æœç¬¬ä¸€ä¸ªçš„ç»“å°¾å°äºç¬¬äºŒä¸ªçš„ç»“å°¾ï¼Œå°†ç¬¬ä¸€ä¸ªå‘åç§»åŠ¨ï¼Œå¦åˆ™ç¬¬äºŒä¸ªå‘åç§»åŠ¨ï¼Œç»§ç»­éå†ã€‚ 209. Minimum Size Subarray Sum ğŸ”—Question Link class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0)return 0;//corner case int start = 0, sum = 0, min = Integer.MAX_VALUE; for(int i = 0;i&lt;nums.length ;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-start+1); sum-=nums[start]; start++; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; two pointerã€‚å½“sum &gt; sçš„æ—¶å€™ï¼Œä»startå¼€å§‹å‡ã€‚ç»´æŠ¤ä¸€ä¸ªminæœ€åè¿”å›ã€‚ 75. Sort Color ğŸ”—Question Link class Solution &#123; public void sortColors(int[] nums) &#123; int[] bucket = new int[3]; for(int num : nums)&#123; bucket[num]++; &#125; int pos = 0; for(int i=0;i&lt;bucket.length;i++)&#123; for(int count = 0; count &lt; bucket[i] ;count++)&#123; nums[pos] = i; pos++; &#125; &#125; &#125;&#125; bucket sort. 349. Intersection of Two Arrays ğŸ”—Question Link class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(); for(int num : nums1)&#123; set1.add(num); &#125; for(int num : nums2)&#123; if(set1.contains(num))&#123; set2.add(num); &#125; &#125; int[] res = new int[set2.size()]; int i=0; for(int num : set2)&#123; res[i] = num; i++; &#125; return res; &#125;&#125; ä¸¤ä¸ªsetæ£€æŸ¥é‡å¤å…ƒç´ ï¼Œæœ€åè¿”å›set2. 350. Intersection of Two Arrays II ğŸ”—Question Link class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums1)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; for(int num : nums2)&#123; if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0)&#123; temp.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] ans = new int[temp.size()]; for(int i=0 ;i&lt;temp.size();i++)&#123; ans[i] = temp.get(i); &#125; return ans; &#125;&#125; å’Œä¸Šä¸€é“é¢˜ä¸åŒç‚¹åœ¨äºè¦è¿”å›æ‰€æœ‰é‡å¤éƒ¨åˆ†çš„æ•°å­—ï¼Œä¸å•å•æ˜¯ä¸€ä¸ªä»£è¡¨äº†ã€‚æ‰€ä»¥è¦ç”¨åˆ°mapæ¥å­˜å‡ºç°æ¬¡æ•°ã€‚æ¬¡æ•°ä¸ºé›¶ or æ¬¡æ•°ä¸ä¸ºé›¶ä½†æ˜¯ä¸å†å‡ºç°è¯¥æ•°å­—æ—¶ï¼Œæ‰¾ä¸‹ä¸€ä¸ªæ•°å­—ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"WangHngLeee.github.io/tags/TwoPointers/"},{"name":"BucketSort","slug":"BucketSort","permalink":"WangHngLeee.github.io/tags/BucketSort/"}]},{"title":"Leetcode EveryDay 70 ğŸ’ª","slug":"chin-up-08","date":"2020-02-03T16:39:28.000Z","updated":"2020-02-04T03:53:05.706Z","comments":true,"path":"2020/02/03/chin-up-08/","link":"","permalink":"WangHngLeee.github.io/2020/02/03/chin-up-08/","excerpt":"437. Path Sum III ğŸ”—Question Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,0,sum,map); return total; &#125; public void help(TreeNode root, int cursum, int target,Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - target))&#123; total+=map.get(cursum - target); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,cursum,target,map); help(root.right,cursum,target,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; presum + backtrackingã€‚ä¸€å®šè¦è®°ä½æœ€åbacktrackå‡1ã€‚","text":"437. Path Sum III ğŸ”—Question Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,0,sum,map); return total; &#125; public void help(TreeNode root, int cursum, int target,Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - target))&#123; total+=map.get(cursum - target); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,cursum,target,map); help(root.right,cursum,target,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; presum + backtrackingã€‚ä¸€å®šè¦è®°ä½æœ€åbacktrackå‡1ã€‚ 95. Unique Binary Search Trees II ğŸ”—Question Link class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n == 0)return new ArrayList&lt;&gt;(); return help(1,n); &#125; public List&lt;TreeNode&gt; help(int start, int end)&#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if(start &gt; end)res.add(null); for(int i=start ;i&lt;=end;i++)&#123; List&lt;TreeNode&gt; leftset = help(start,i-1); List&lt;TreeNode&gt; rightset = help(i+1,end); for(TreeNode left : leftset)&#123; for(TreeNode right : rightset)&#123; TreeNode node = new TreeNode(i); node.left = left; node.right = right; res.add(node); &#125; &#125; &#125; return res; &#125;&#125; ä»1-&gt;næ˜¯èŠ‚ç‚¹1åˆ°nçš„ä»»ä½•BSTçš„in-orderéå†ã€‚å› æ­¤ï¼Œå¦‚æœé€‰æ‹©ç¬¬iä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹ï¼Œåˆ™å·¦å­æ ‘å°†åŒ…å«å…ƒç´ 1è‡³ï¼ˆi-1ï¼‰ï¼Œè€Œå³å­æ ‘å°†åŒ…å«å…ƒç´ ï¼ˆi + 1ï¼‰è‡³nã€‚ä½¿ç”¨é€’å½’è°ƒç”¨æ¥è·å–å·¦å³å­æ ‘çš„æ‰€æœ‰å¯èƒ½æ ‘ï¼Œå¹¶å°†æ‰€æœ‰å¯èƒ½çš„æ–¹å¼å°†ä¸æ ¹ç»„åˆã€‚ 114. Flatten Binary Tree to Linked List ğŸ”—Question Link class Solution &#123; public TreeNode pre = null; public void flatten(TreeNode root) &#123; if(root == null)return ; flatten(root.right); flatten(root.left); root.right = pre; root.left=null; pre = root; &#125;&#125; å…ˆé€’å½’åˆ°æœ€å³èŠ‚ç‚¹ï¼Œä¾æ¬¡è¿æ¥èŠ‚ç‚¹ï¼Œç„¶ååœ¨ä»å·¦å­æ ‘å¼€å§‹ç»§ç»­å‘å³é€’å½’ï¼Œpreä¿å­˜åˆ°æ˜¯ä¸Šä¸€æ¬¡é€’å½’ç»“æŸæ—¶çš„nodeï¼ŒæŠŠnodeè¿åˆ°å½“å‰rootåˆ°rightï¼Œç„¶åleftå˜nullï¼Œç»§ç»­é€’å½’ã€‚è§†é¢‘è®²è§£â¬‡ï¸ 116. Populating Next Right Pointers in Each Node ğŸ”—Question Link class Solution &#123; public Node connect(Node root) &#123; if(root == null)return root; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; Node node = queue.poll(); node.next = i&lt;size-1 ? queue.peek() : null; if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; &#125; return root; &#125;&#125; ç¬¬ä¸‰éã€‚å¸¸è§„level traversalå†™æ³•ï¼Œåªåœ¨å½“å‰å±‚æœ€åä¸€ä¸ªnodeæ—¶æŠŠnextç»™åˆ°nullï¼Œå…¶ä»–çš„nextéƒ½æ˜¯queueé‡Œçš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå³æ¨ªå‘å³è¾¹çš„nodeã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"}]},{"title":"Leetcode EveryDay 69 ğŸ’ª","slug":"chin-up-07","date":"2020-02-02T15:32:17.000Z","updated":"2020-02-04T03:50:02.365Z","comments":true,"path":"2020/02/02/chin-up-07/","link":"","permalink":"WangHngLeee.github.io/2020/02/02/chin-up-07/","excerpt":"163. Missing Ranges ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int next = lower; for (int i = 0; i &lt; nums.length; i++) &#123; if (next == nums[i]) &#123; next++; &#125; else if(nums[i]&lt;next)continue; else &#123; res.add(range(next, nums[i] - 1)); next = nums[i] + 1; &#125; if (next == Integer.MIN_VALUE)return res; &#125; if (next &lt;= upper) res.add(range(next, upper)); return res; &#125; public String range(int low, int high) &#123; return low == high ? String.valueOf(low) : (low + \"-&gt;\" + high); &#125;&#125; éå†numsï¼Œæ›´æ–°nextï¼Œå¦‚æœnext &lt; &gt;nums[i]åˆ™å­˜åœ¨gapï¼ŒåŠ å…¥resï¼Œä¹‹åæ›´æ–°nextä¸ºå½“å‰nums[i]+1ç»§ç»­éå†ã€‚","text":"163. Missing Ranges ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int next = lower; for (int i = 0; i &lt; nums.length; i++) &#123; if (next == nums[i]) &#123; next++; &#125; else if(nums[i]&lt;next)continue; else &#123; res.add(range(next, nums[i] - 1)); next = nums[i] + 1; &#125; if (next == Integer.MIN_VALUE)return res; &#125; if (next &lt;= upper) res.add(range(next, upper)); return res; &#125; public String range(int low, int high) &#123; return low == high ? String.valueOf(low) : (low + \"-&gt;\" + high); &#125;&#125; éå†numsï¼Œæ›´æ–°nextï¼Œå¦‚æœnext &lt; &gt;nums[i]åˆ™å­˜åœ¨gapï¼ŒåŠ å…¥resï¼Œä¹‹åæ›´æ–°nextä¸ºå½“å‰nums[i]+1ç»§ç»­éå†ã€‚ 168. Excel Sheet Column Title ğŸ”—Question Link class Solution &#123; public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while(n&gt;0)&#123; n--; sb.append((char)('A' + n%26)); n = n/26; &#125; sb.reverse(); return sb.toString(); &#125;&#125; ä»åå¾€å‰æ‰¾ï¼Œå…ˆå–ä½™æ•°å†å–æ‘¸ï¼Œæœ€åreverseä¸€ä¸‹å°±æ˜¯æ­£ç¡®é¡ºåºçš„resã€‚ Time Complexity : O(N) 93. Restore IP Addresses ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int len = s.length(); for(int i=1;i&lt;4 &amp;&amp; i&lt;len-2;i++)&#123; for(int j=i+1;j&lt;i+4 &amp;&amp; j&lt;len-1;j++)&#123; for(int k=j+1;k&lt;j+4 &amp;&amp; k&lt;len;k++)&#123; String s1 = s.substring(0,i); String s2 = s.substring(i,j); String s3 = s.substring(j,k); String s4 = s.substring(k,len); if(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123; res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4); &#125; &#125; &#125; &#125; return res; &#125; public boolean check(String a)&#123; if(a.length()&gt;3||a.length()==0||(a.charAt(0)=='0' &amp;&amp; a.length()&gt;1))return false; if(Integer.parseInt(a) &gt; 255)return false; return true; &#125;&#125; åˆæ ¼IPåœ°å€ ï¼šæœ€å¤š3ä½ï¼Œæœ€å¤§255ï¼Œå¦‚æœæ˜¯0åªæœ‰ä¸€ä½ã€‚ä¸‰å±‚å¾ªç¯æŠŠsåˆ†æˆå››éƒ¨åˆ†ï¼Œä¾æ¬¡å¾ªç¯æ¯”è¾ƒã€‚ Time Complexityï¼šO(N) 32. Longest Valid Parentheses ğŸ”—Question Link class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;len;i++)&#123; if(s.charAt(i) == '(')open++; else if(open &gt;0 &amp;&amp; s.charAt(i) == ')')&#123; dp[i] = dp[i-1] + 2; if(i-dp[i]&gt;0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; dpã€‚open&gt;0æ—¶æ‰å¯¹ ï¼‰æ“ä½œã€‚æ³¨æ„é¢˜ç›®è¦æ±‚æœ€é•¿è¿ç»­validï¼Œæ‰€ä»¥è¦æ£€æŸ¥ä¸€ä¸‹i-dp[i]ï¼Œå³ï¼šåœ¨å½“å‰åˆæ ¼çš„æ‹¬å·é•¿åº¦ä¹‹å‰ï¼Œæœ‰æ— åˆæ ¼çš„é•¿åº¦å­˜åœ¨ï¼Œæœ‰çš„è¯åŠ èµ·æ¥ï¼Œæ²¡æœ‰åˆ™ç»§ç»­dpã€‚ 125. Valid Palindrome ğŸ”—Question Link class Solution &#123; public boolean isPalindrome(String s)&#123; if(s == null || s.length() == 0)return true; int left = 0; int right = s.length()-1; while(left &lt;= right)&#123; char l = s.charAt(left); char r = s.charAt(right); if(!Character.isLetterOrDigit(l))&#123; left++; &#125; else if(!Character.isLetterOrDigit(r))&#123; right--; &#125;else&#123; if(Character.toLowerCase(l) != Character.toLowerCase(r))return false; right--; left++; &#125; &#125; return true; &#125;&#125; åŒæŒ‡é’ˆã€‚æ³¨æ„isLetterOrDigitå’ŒtoLowerCaseçš„ç”¨æ³•ã€‚ 819. Most Common Word ğŸ”—Question Link class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; String res = \"\"; if(paragraph == null || paragraph.length() == 0)return res; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; ban = new HashSet&lt;&gt;(); String[] strs = paragraph.toLowerCase().split(\"\\\\W++\"); for(String str : banned)&#123; ban.add(str); &#125; for(String str : strs)&#123; if(ban.contains(str))continue; else map.put(str,map.getOrDefault(str,0)+1); &#125; int max = 0; for(String key : map.keySet())&#123; if(map.get(key) &gt; max)&#123; max = map.get(key); res = key; &#125; &#125; return res; &#125;&#125; ç¬¬å››éã€‚setå­˜banned wordï¼Œ mapå­˜ä¸åœ¨seté‡Œçš„wordæ¬¡æ•°ã€‚ç»´æŠ¤maxå’Œresä¸æ–­éå†mapçš„keysetã€‚æœ€åè¿”å›resã€‚ 72. Edit Distance ğŸ”—Question Link class Solution &#123; public int minDistance(String word1, String word2) &#123; int len1 = word1.length(); int len2 = word2.length(); int[][] edit = new int[len1+1][len2+1]; for(int i=0 ;i&lt;=len1 ;i++)&#123; edit[i][0] = i; &#125; for(int i=0 ;i&lt;=len2 ;i++)&#123; edit[0][i] = i; &#125; for(int i=0 ;i&lt;len1 ;i++)&#123; for(int j=0 ;j&lt;len2 ;j++)&#123; if(word1.charAt(i) == word2.charAt(j))&#123; edit[i+1][j+1] = edit[i][j]; &#125;else&#123; int replace = edit[i][j]; int delete = edit[i+1][j]; int insert = edit[i][j+1]; edit[i+1][j+1] = Math.min(replace,Math.min(delete,insert))+1; &#125; &#125; &#125; return edit[len1][len2]; &#125;&#125; ç¬¬å››éã€‚å…ˆåˆå§‹åŒ–editä¸¤ä¸ªè¾¹ç¼˜çš„å€¼ã€‚ç„¶åä¸€ä¸€éå†ã€‚é™¤äº†ç›¸åŒä»¥å¤–ï¼Œæœ‰ä¸‰ç§æ“ä½œï¼Œæ‰€ä»¥å½“å‰æ“ä½œæ¬¡æ•°ä¸ºä¸‰ç§æœ€å°å€¼+1ã€‚ 13. Roman to Integer ğŸ”—Question Link class Solution: def romanToInt(self, s: str) -&gt; int: roman = &#123;'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000&#125; z = 0; for i in range(0,len(s)-1): if roman[s[i]] &lt; roman[s[i+1]]: z-=roman[s[i]] else: z+=roman[s[i]] return z + roman[s[-1]] pythonã€‚å»ºmapå­˜å¯¹åº”å€¼ã€‚IV è¿™ç§æƒ…å†µå‡æ³•æ“ä½œï¼ŒVIè¿™ç§æƒ…å†µåŠ æ³•æ“ä½œã€‚ 97. Interleaving String ğŸ”—Question Link class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if((s1.length() + s2.length())!= s3.length())return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1]; matrix[0][0] = true; for(int i = 1;i&lt;matrix[0].length;i++)&#123; matrix[0][i] = matrix[0][i-1] &amp;&amp; (s1.charAt(i-1) == s3.charAt(i-1)); &#125; for(int i =1;i&lt;matrix.length;i++)&#123; matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i-1)); &#125; for(int i = 1; i&lt;matrix.length;i++)&#123; for(int j = 1; j&lt;matrix[0].length;j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1)== s3.charAt(i+j-1))); &#125; &#125; return matrix[s2.length()][s1.length()]; &#125;&#125; DPè¡¨è¡¨ç¤ºå½“s1åœ¨ç¬¬iä¸ªä½ç½®å¹¶ä¸”s2åœ¨ç¬¬jä¸ªä½ç½®æ—¶ï¼Œs3æ˜¯å¦åœ¨ç¬¬ï¼ˆi + jï¼‰ä¸ªä½ç½®äº¤ç»‡ã€‚ç¬¬0ä½è¡¨ç¤ºç©ºå­—ç¬¦ä¸²ã€‚ å› æ­¤ï¼Œå¦‚æœs1å’Œs2å½“å‰éƒ½ä¸ºç©ºï¼Œåˆ™s3ä¹Ÿä¸ºç©ºï¼Œå¹¶ä¸”è¢«è®¤ä¸ºæ˜¯äº¤ç»‡çš„ã€‚å¦‚æœåªæœ‰s1ä¸ºç©ºï¼Œåˆ™å¦‚æœå…ˆå‰çš„s2ä½ç½®æ­£åœ¨äº¤ç»‡å¹¶ä¸”å½“å‰s2ä½ç½®charç­‰äºs3å½“å‰ä½ç½®charï¼Œåˆ™è®¤ä¸ºæ˜¯äº¤ç»‡ã€‚ç±»ä¼¼çš„æƒ³æ³•ä¹Ÿé€‚ç”¨äºs2ä¸ºç©ºçš„æƒ…å†µã€‚å½“s1å’Œs2éƒ½ä¸ä¸ºç©ºæ—¶ï¼Œå¦‚æœæˆ‘ä»¬ä»i-1ï¼Œjåˆ°è¾¾iï¼Œjï¼Œåˆ™å¦‚æœi-1ï¼Œjå·²ç»äº¤ç»‡å¹¶ä¸”iå’Œå½“å‰s3ä½ç½®ç›¸ç­‰ï¼Œåˆ™ä¸ºäº¤ç»‡ã€‚å¦‚æœæˆ‘ä»¬ä»iï¼Œj-1åˆ°è¾¾iï¼Œjï¼Œåˆ™å¦‚æœiï¼Œj-1å·²ç»äº¤ç»‡å¹¶ä¸”jå’Œå½“å‰s3ä½ç½®ç›¸ç­‰ã€‚å®ƒæ˜¯äº¤é”™çš„ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Weekly Contest 174 ğŸ†","slug":"contest01","date":"2020-02-02T04:01:09.000Z","updated":"2020-03-16T00:11:02.703Z","comments":true,"path":"2020/02/01/contest01/","link":"","permalink":"WangHngLeee.github.io/2020/02/01/contest01/","excerpt":"ğŸ“Œ ä»Šå¤©èµ·æ¯å‘¨çš„lc contestä¹Ÿæ€»ç»“ä¸€ä¸‹ã€‚è‡ªå·±çš„ç­”æ¡ˆå’Œä¼˜ç§€ç­”æ¡ˆå†™åœ¨ä¸€èµ·ã€‚ 5328. The K Weakest Rows in a Matrix ğŸ”—Question Link First Solution class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; if(mat == null || mat.length == 0)return null; int[] res = new int[k]; int m = mat.length; int n = mat[0].length; int[][] arr = new int[m][2]; for(int i=0 ;i&lt;m;i++)&#123; int num = 0; for(int j=0 ;j&lt;n;j++)&#123; if(mat[i][j] == 1)&#123; num++; &#125; &#125; arr[i]=new int[]&#123;num,i&#125;; &#125; Arrays.sort(arr,(a,b)-&gt;a[0]-b[0]); for(int i=0 ;i&lt;k;i++)&#123; res[i] = arr[i][1]; &#125; return res; &#125;&#125; å½“æ—¶æ€è·¯ï¼šäºŒç»´æ•°ç»„å­˜1çš„ä¸ªæ•°ä»¥åŠè¡Œçš„indexã€‚ç„¶åç”¨numå¯¹arrè¿›è¡Œsortï¼Œæœ€åæŒ‰åºå°†å›ºå®škä¸ªiå­˜å…¥resã€‚ Optimized Solution çœ‹äº†ä¸€åœˆdisscussåŸºæœ¬æ€è·¯å’Œæˆ‘ä¸€æ ·ã€‚åªä¸è¿‡æœ‰äººç”¨priorityqueue é‡å†™sortï¼Œæ ¸å¿ƒæ²¡å˜ã€‚","text":"ğŸ“Œ ä»Šå¤©èµ·æ¯å‘¨çš„lc contestä¹Ÿæ€»ç»“ä¸€ä¸‹ã€‚è‡ªå·±çš„ç­”æ¡ˆå’Œä¼˜ç§€ç­”æ¡ˆå†™åœ¨ä¸€èµ·ã€‚ 5328. The K Weakest Rows in a Matrix ğŸ”—Question Link First Solution class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; if(mat == null || mat.length == 0)return null; int[] res = new int[k]; int m = mat.length; int n = mat[0].length; int[][] arr = new int[m][2]; for(int i=0 ;i&lt;m;i++)&#123; int num = 0; for(int j=0 ;j&lt;n;j++)&#123; if(mat[i][j] == 1)&#123; num++; &#125; &#125; arr[i]=new int[]&#123;num,i&#125;; &#125; Arrays.sort(arr,(a,b)-&gt;a[0]-b[0]); for(int i=0 ;i&lt;k;i++)&#123; res[i] = arr[i][1]; &#125; return res; &#125;&#125; å½“æ—¶æ€è·¯ï¼šäºŒç»´æ•°ç»„å­˜1çš„ä¸ªæ•°ä»¥åŠè¡Œçš„indexã€‚ç„¶åç”¨numå¯¹arrè¿›è¡Œsortï¼Œæœ€åæŒ‰åºå°†å›ºå®škä¸ªiå­˜å…¥resã€‚ Optimized Solution çœ‹äº†ä¸€åœˆdisscussåŸºæœ¬æ€è·¯å’Œæˆ‘ä¸€æ ·ã€‚åªä¸è¿‡æœ‰äººç”¨priorityqueue é‡å†™sortï¼Œæ ¸å¿ƒæ²¡å˜ã€‚ 5329. Reduce Array Size to The Half ğŸ”—Question Link First Solution class Solution &#123; public int minSetSize(int[] arr) &#123; if(arr == null || arr.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt;map.get(b)-map.get(a)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int len = arr.length; int halflen = len/2; if(arr == null || arr.length == 0)return 0; for(int num : arr)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; for(int a : arr)&#123; if(!set.contains(a))&#123; queue.add(a); set.add(a); &#125; &#125; int res = 0; while(!queue.isEmpty())&#123; int temp = queue.poll(); int templen = map.get(temp); res++; len-=templen; if(len &lt;= halflen)return res; &#125; return -1; &#125;&#125; mapå­˜å…ƒç´ ä¸ªæ•°ï¼Œpqä»å¤§åˆ°å°æ’åºï¼Œsetä¿è¯åŠ å…¥queueçš„æ˜¯å”¯ä¸€æ•°å­—ã€‚æ¯æ¬¡pollå‡ºæ¬¡æ•°æœ€å¤šçš„æ•°å­—ï¼Œæ›´æ–°lenï¼Œå’Œhalflenæ¯”è¾ƒï¼Œå¦‚æœå°äºåˆ™ç›´æ¥è¿”å›resã€‚å¦åˆ™ç»§ç»­pollã€‚ PS: å½“æ—¶ä¸€ç›´æŠ¥é”™å› ä¸ºå­˜åœ¨queueä¼šåŠ å…¥é‡å¤æ•°å­—çš„æƒ…å†µï¼ŒåŠ å…¥setä¹‹åå®Œç¾Acceptedã€‚ Optimized Solution class Solution&#123; public int minSetSize(int[] arr) &#123; int n = arr.length; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((e1, e2) -&gt; (e2.getValue() - e1.getValue())); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; map.put(arr[i], map.getOrDefault(arr[i], 0) + 1); &#125; pq.addAll(map.entrySet()); int count = 0, res = 0; while (true) &#123; count += pq.poll().getValue(); res++; if (count &gt;= n / 2) &#123; break; &#125; &#125; return res; &#125;&#125; æ€è·¯ä¸€æ‘¸ä¸€æ ·ã€‚å†™æ³•ç®€æ´äº†è®¸å¤šã€‚ä»¥åçš„codeå°½é‡ä¸€è¡Œå¤šoperationã€‚ 1343. Maximum Product of Splitted Binary Tree ğŸ”—Question Link Optimized Solution class Solution &#123; long sum; long max; public int maxProduct(TreeNode root) &#123; sum = 0; max = 0; dfs(root); check(root); return (int)(max%((int)Math.pow(10,9)+7)); &#125; public void dfs(TreeNode root)&#123; if(root == null)return; sum+=root.val; dfs(root.left); dfs(root.right); &#125; public long check(TreeNode root)&#123; if(root == null)return 0; long l = check(root.left); long r = check(root.right); max = Math.max(max,(l+r+root.val) * (sum - l - r - root.val)); return l + r + root.val; &#125;&#125; å…ˆdfså¾—åˆ°treeçš„total sum é€’å½’æ‰¾maxproductã€‚checké‡Œè¿”å›çš„æ˜¯å·¦å³å­æ ‘çš„sumå’Œï¼Œæ›´æ–°maxæ—¶æ³¨æ„æŠŠtotal sumåˆ†æˆä¸¤éƒ¨åˆ†ä¹˜ç§¯å³å¯ã€‚","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 68 ğŸ’ª","slug":"chin-up-06","date":"2020-02-01T18:02:38.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/02/01/chin-up-06/","link":"","permalink":"WangHngLeee.github.io/2020/02/01/chin-up-06/","excerpt":"56. Merge Intervals Question Link &gt;&gt;&gt; class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0)return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] time : intervals)&#123; if(end &gt;= time[0])&#123; end = Math.max(end,time[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = time[0]; end = time[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125;&#125; æŒ‰ç…§start sortä¸€ä¸‹ã€‚åªæœ‰endå¤§äºå½“å‰timeçš„startæ—¶ï¼Œä¸¤ä¸ªintervalæ‰å­˜åœ¨overlapã€‚æ›´æ–°endä¸ºæœ€å¤§çš„ã€‚å¦åˆ™å°†å½“å‰startï¼ŒendåŠ å…¥resã€‚æ›´æ–°startå’Œendä¸ºtime[0] å’Œtime[1]ã€‚","text":"56. Merge Intervals Question Link &gt;&gt;&gt; class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0)return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] time : intervals)&#123; if(end &gt;= time[0])&#123; end = Math.max(end,time[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = time[0]; end = time[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125;&#125; æŒ‰ç…§start sortä¸€ä¸‹ã€‚åªæœ‰endå¤§äºå½“å‰timeçš„startæ—¶ï¼Œä¸¤ä¸ªintervalæ‰å­˜åœ¨overlapã€‚æ›´æ–°endä¸ºæœ€å¤§çš„ã€‚å¦åˆ™å°†å½“å‰startï¼ŒendåŠ å…¥resã€‚æ›´æ–°startå’Œendä¸ºtime[0] å’Œtime[1]ã€‚ 253. Meeting Rooms II Question Link &gt;&gt;&gt; class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if(intervals == null || intervals.length == 0)return 0; int[] start = new int[intervals.length]; int[] end = new int[intervals.length]; int rooms = 0; for(int i=0 ;i&lt;intervals.length;i++)&#123; start[i] = intervals[i][0]; end[i] = intervals[i][1]; &#125; Arrays.sort(start); Arrays.sort(end); int endidx = 0; for(int i=0 ;i&lt;start.length;i++)&#123; if(start[i] &lt; end[endidx])rooms++; else&#123; endidx++; &#125; &#125; return rooms; &#125;&#125; start å’Œ end å…¨éƒ¨sortã€‚éå†startï¼Œé‡åˆ°å°äºend[]endidx]çš„startåˆ™+1ï¼Œå¦åˆ™æ›´æ–°endidxã€‚ 973. K Closest Points to Origin Question Link &gt;&gt;&gt; class Solution &#123; public int[][] kClosest(int[][] points, int K) &#123; int[][] res = new int[K][2]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt;getdist(a)-getdist(b)); for(int[] point : points)&#123; queue.add(point); &#125; for(int i=0 ;i&lt;K;i++)&#123; res[i] = queue.poll(); &#125; return res; &#125; public int getdist(int[] point)&#123; return point[0]*point[0] + point[1]*point[1]; &#125;&#125; ä¸€èˆ¬top kçš„é¢˜éƒ½ç”¨pq + é‡å†™sortï¼Œç„¶åç»´æŠ¤kå¤§çš„pqï¼Œæœ€åè¦ä¹ˆè¿”å›peekè¦ä¹ˆpoll kæ¬¡å°±å¯ä»¥ã€‚è¿™é“é¢˜å†™æ³•æ²¡æœ‰ç»´æŠ¤kå¤§ã€‚æœ€åpoll kæ¬¡å³å¯ã€‚ 57. Insert Interval Question Link &gt;&gt;&gt; class Solution &#123; public int[][] insert(int[][] intervals, int[] newInterval) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); for(int[] interval : intervals)&#123; if(newInterval[1] &lt; interval[0])&#123; res.add(newInterval); newInterval = interval; &#125;else if(newInterval[0] &gt; interval[1])&#123; res.add(interval); &#125;else&#123; newInterval[0] = Math.min(interval[0],newInterval[0]); newInterval[1] = Math.max(interval[1],newInterval[1]); &#125; &#125; res.add(newInterval); return res.toArray(new int[0][]); &#125;&#125; å’Œ56ç›¸ä¼¼çš„æ€è·¯ã€‚ä¸‰ç§æƒ…å†µï¼š intervalå®Œå…¨ &lt; newInterval newIntervalå®Œå…¨&lt; interval æ­¤æ—¶intervalå˜ä¸ºnewintervalç»§ç»­å¾ªç¯ã€‚ äºŒè€…æœ‰overlapã€‚ 242. Valid Anagram Question Link &gt;&gt;&gt; class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] arr = new int[26]; for(int i=0 ; i&lt;t.length() ; i++)&#123; arr[t.charAt(i)-'a']++; &#125; for(int i=0 ;i&lt;s.length() ;i++)&#123; arr[s.charAt(i)-'a']--; &#125; for(int i=0 ;i&lt;arr.length;i++)&#123; if(arr[i]!=0)return false; &#125; return true; &#125;&#125; ä¸€ä¸ª26çš„arrï¼Œéå†s++ï¼Œéå†tâ€“ï¼Œå¦‚æœä¸¤ä¸ªç›¸åŒåˆ™æœ€åarré‡Œåº”è¯¥éƒ½æ˜¯0ï¼Œå¦åˆ™ä¸ºfalseã€‚ 75. Sort Colors Question Link &gt;&gt;&gt; class Solution &#123; public void sortColors(int[] nums) &#123; int[] bucket = new int[3]; for(int num : nums)&#123; bucket[num]++; &#125; int pos = 0; for(int i=0 ;i&lt;bucket.length;i++)&#123; for(int count = 0;count &lt; bucket[i] ; count++)&#123; nums[pos] = i; pos++; &#125; &#125; &#125;&#125; bucket sort + inplace change numsæ•°ç»„ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"WangHngLeee.github.io/tags/Sort/"},{"name":"Interval","slug":"Interval","permalink":"WangHngLeee.github.io/tags/Interval/"}]},{"title":"Leetcode EveryDay 67","slug":"chin-up-05","date":"2020-01-31T17:01:27.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2020/01/31/chin-up-05/","link":"","permalink":"WangHngLeee.github.io/2020/01/31/chin-up-05/","excerpt":"909. Snakes and Ladders ğŸ”—Question Link class Solution &#123; public int snakesAndLadders(int[][] board) &#123; if(board == null || board.length == 0)return 0; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] seen = new boolean[m*m+1]; queue.add(1); int steps = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int temp = queue.poll(); for(int j=1;j&lt;=6;j++)&#123; int next = temp + j; int[] pos = getpos(next,m); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == m*m)return steps; if(!seen[next])&#123; seen[next] = true; queue.add(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; public int[] getpos(int next, int m)&#123; int row = (next-1)/m; int col = (next-1)%m; int x = m-row-1; int y = row%2 == 0?col : m-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; queueå­˜numberï¼Œé€šè¿‡getposè·å¾—numå¯¹åº”åæ ‡ã€‚ç»å…¸bfsæ¨¡ç‰ˆã€‚","text":"909. Snakes and Ladders ğŸ”—Question Link class Solution &#123; public int snakesAndLadders(int[][] board) &#123; if(board == null || board.length == 0)return 0; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] seen = new boolean[m*m+1]; queue.add(1); int steps = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int temp = queue.poll(); for(int j=1;j&lt;=6;j++)&#123; int next = temp + j; int[] pos = getpos(next,m); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == m*m)return steps; if(!seen[next])&#123; seen[next] = true; queue.add(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; public int[] getpos(int next, int m)&#123; int row = (next-1)/m; int col = (next-1)%m; int x = m-row-1; int y = row%2 == 0?col : m-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; queueå­˜numberï¼Œé€šè¿‡getposè·å¾—numå¯¹åº”åæ ‡ã€‚ç»å…¸bfsæ¨¡ç‰ˆã€‚ 1091. Shortest Path in Binary Matrix ğŸ”—Question Link class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; if(grid[0][0] == 1 || grid[m-1][n-1] == 1)return -1; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;&#125;; boolean[][] seen = new boolean[m][n]; seen[0][0] = true; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0,0&#125;); int ans = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; int[] temp = queue.poll(); if(temp[0] == m-1 &amp;&amp; temp[1] == n-1)return ans+1; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp;y&lt;n &amp;&amp; grid[x][y] == 0 &amp;&amp; !seen[x][y])&#123; seen[x][y] = true; queue.add(new int[]&#123;x,y&#125;); &#125; &#125; &#125; ans++; &#125; return -1; &#125;&#125; ç»å…¸bfsæ¨¡ç‰ˆã€‚åˆ›å»ºmoveæ•°ç»„ã€‚é‡åˆ°1å°±åœæ­¢ã€‚é‡åˆ°0åˆ™åŠ å…¥queueç»§ç»­bfsã€‚ 130. Surrounded Region ğŸ”—Question Link class Solution &#123; public void solve(char[][] board) &#123; if (board.length == 0 || board[0].length == 0) return; if (board.length &lt; 3 || board[0].length &lt; 3) return; int m = board.length; int n = board[0].length; for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == 'O') helper(board, i, 0); if (board[i][n - 1] == 'O') helper(board, i, n - 1); &#125; for (int j = 1; j &lt; n - 1; j++) &#123; if (board[0][j] == 'O') helper(board, 0, j); if (board[m - 1][j] == 'O') helper(board, m - 1, j); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O') board[i][j] = 'X'; if (board[i][j] == '1') board[i][j] = 'O'; &#125; &#125; &#125; private void helper(char[][] board, int r, int c) &#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = '1'; helper(board, r + 1, c); helper(board, r - 1, c); helper(board, r, c + 1); helper(board, r, c - 1); &#125; &#125;&#125; åªæœ‰å’Œè¾¹ç•Œ0ç›¸è¿çš„0æ‰ä¸ä¼šå˜æˆxï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥å°±æ˜¯å°†å’Œè¾¹ç¼˜0ç›¸è¿çš„0å˜æˆ*ï¼Œç„¶åå†æ‰«ææ•´ä¸ªgraphï¼ŒæŠŠæ²¡æœ‰è¿ä¸Šçš„0å˜æˆxï¼Œ*å˜å›0ã€‚ 111. Minimum Depth of Binary Tree ğŸ”—Question Link class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)return 0; if(root.left == null &amp;&amp; root.right == null) return 1; int left = minDepth(root.left); int right = minDepth(root.right); if(root.left == null)return right+1; if(root.right==null)return left+1; return Math.min(left,right)+1; &#125;&#125; recursiveæ‰¾depthï¼Œç»´æŠ¤minå³å¯ã€‚ 559. Maximum Depth of N-ary Tree ğŸ”—Question Link class Solution &#123; public int maxDepth(Node root) &#123; if(root == null)return 0; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int depth = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; Node temp=queue.poll(); for(Node child : temp.children)&#123; queue.add(child); &#125; &#125; depth++; &#125; return depth; &#125;&#125; iterativeæ€è·¯ã€‚level order éå†treeã€‚ç»´æŠ¤depthï¼Œæœ€åè¿”å›depthå³ä¸ºmaxdepthã€‚ 1319. Number of Operations to Make Network Connected ğŸ”—Question Link class Solution &#123; public int find(int[] parents,int n)&#123; if(parents[n] == n)return n; return parents[n] = find(parents,parents[n]); &#125; public int makeConnected(int n, int[][] connections) &#123; int[] parents = new int[n]; for(int i=0 ;i&lt;n ;i++)&#123; parents[i] = i; &#125; int m = connections.length; int components = 0; int extra = 0; for(int i=0 ;i&lt;m ;i++)&#123; int root1 = find(parents,connections[i][0]); int root2 = find(parents,connections[i][1]); if(root1 == root2)extra++; else parents[root1] = root2; &#125; for(int i= 0;i&lt;n;i++)&#123; if(parents[i] == i) components++; &#125; return (extra &gt;= components -1) ? components - 1 : -1; &#125;&#125; ç®€åŒ–ç‰ˆunion findã€‚åŸºæœ¬çš„ufæ“ä½œï¼Œå°†unionçš„è¿‡ç¨‹æ”¾åœ¨äº†ä¸»å‡½æ•°ã€‚æœ€åæ‰¾componentçš„ä¸ªæ•°ï¼Œç‹¬ç«‹çš„éƒ¨åˆ†ä¸ªæ•°ï¼Œåˆ™éœ€è¦é“¾æ¥çš„linkä¸ªæ•°å°±æ˜¯component-1ä¸ªã€‚æ‰€ä»¥åªéœ€è¦åˆ¤æ–­å¤šä½™çš„extraæ˜¯å¦å¤§äºcomponent-1å³å¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"}]},{"title":"Leetcode EveryDay 66","slug":"chin-up-04","date":"2020-01-30T17:48:49.000Z","updated":"2020-02-03T14:37:08.709Z","comments":true,"path":"2020/01/30/chin-up-04/","link":"","permalink":"WangHngLeee.github.io/2020/01/30/chin-up-04/","excerpt":"987. Vertical Order Traversal of a Binary Tree ğŸ”—Question Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; å®šä¹‰pairç±»ï¼ŒåŒ…å«æ¨ªå‘ä½ç½®xã€‚mapå­˜xä½ç½®å¯¹åº”çš„nodeèŠ‚ç‚¹ï¼Œqueue + bfsï¼Œéå†æ‰€æœ‰nodeå¹¶ä¸”å­˜å…¥mapã€‚ åœ¨bfsä¸­æ›´æ–°minå’Œmaxå€¼ï¼Œæ‰¾åˆ°treeæœ€å·¦å’Œæœ€å³è¾¹ç•Œã€‚ é‡å†™sortï¼Œå°†åŒä¸€ä½ç½®çš„nodeæŒ‰å°-å¤§æ’åºã€‚ é’ˆå¯¹æ¯ä¸€ä¸ªä½ç½®xæ–°å»ºtemplistï¼Œæœ€åå°†templiståŠ å…¥resä¸­ã€‚","text":"987. Vertical Order Traversal of a Binary Tree ğŸ”—Question Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; å®šä¹‰pairç±»ï¼ŒåŒ…å«æ¨ªå‘ä½ç½®xã€‚mapå­˜xä½ç½®å¯¹åº”çš„nodeèŠ‚ç‚¹ï¼Œqueue + bfsï¼Œéå†æ‰€æœ‰nodeå¹¶ä¸”å­˜å…¥mapã€‚ åœ¨bfsä¸­æ›´æ–°minå’Œmaxå€¼ï¼Œæ‰¾åˆ°treeæœ€å·¦å’Œæœ€å³è¾¹ç•Œã€‚ é‡å†™sortï¼Œå°†åŒä¸€ä½ç½®çš„nodeæŒ‰å°-å¤§æ’åºã€‚ é’ˆå¯¹æ¯ä¸€ä¸ªä½ç½®xæ–°å»ºtemplistï¼Œæœ€åå°†templiståŠ å…¥resä¸­ã€‚ 863. All Nodes Distance K in Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,target); dfs(root,0,K,res); return res; &#125; public int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; public void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)res.add(root.val); dfs(root.left,dist+1,K,res); dfs(root.right,dist+1,K,res); &#125;&#125; å…ˆå®šä¹‰findå‡½æ•°ï¼Œç”¨mapå­˜targetä¸Šæ–¹èŠ‚ç‚¹è·ç¦»targetçš„è·ç¦»ï¼Œtargetä¸‹æ–¹ä¸å­˜ã€‚ å†dfséå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œå°†è·ç¦»ä¸ºkçš„å­˜å…¥resã€‚å¦‚æœmapä¸­æœ‰è¯¥ç‚¹ï¼Œåˆ™ä¸ºtargetä¸Šæ–¹çš„ç‚¹ã€‚ç›´æ¥å°†distæ›´æ–°ä¸ºmapå¯¹åº”çš„valueå³å¯ã€‚å¦‚æœæ²¡æœ‰åˆ™ä¸€æ­¥ä¸€æ­¥å‘ä¸‹æ·±å…¥ dist+1. 105. Construct Binary Tree from Preorder and Inorder Traversal Question Link &gt;&gt;&gt; class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder == null || preorder.length == 0 || inorder == null || inorder.length==0)&#123; return null; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); // store index of inorder for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; return build(inorder,0,inorder.length-1,preorder,0,preorder.length-1,map); &#125; public TreeNode build(int[]inorder,int istart, int iend, int[] preorder, int pstart, int pend, Map&lt;Integer,Integer&gt; map)&#123; if(istart &gt;iend || pstart &gt; pend)return null; TreeNode node = new TreeNode(preorder[pstart]); int inidx = map.get(preorder[pstart]); int remains = inidx - istart; node.left = build(inorder,istart,inidx-1,preorder,pstart+1,pstart + remains,map); node.right = build(inorder,inidx+1,iend,preorder,pstart + remains + 1,pend,map); return node; &#125;&#125; åˆ©ç”¨preorderæ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åå»inorderé‡Œæ‰¾åˆ°å·¦å³partçš„indexï¼Œåˆ©ç”¨ä¸åŒçš„indexå¯¹å·¦å³å­æ ‘è¿›è¡Œbuildã€‚ 449. Serialize and Deserialize BST Question Link &gt;&gt;&gt; è¿™é“é¢˜ä¸è®ºBSTæˆ–è€…BTéƒ½æ˜¯ä¸€æ ·çš„å†™æ³•ã€‚éƒ½æ˜¯preorderè½¬æˆstringï¼Œç„¶åsplitç©ºæ ¼ï¼Œå†ç”¨preorderæ–¹å¼è¿›è¡Œå»ºæ ‘ã€‚ è¿™é“é¢˜æ˜¯BSTï¼Œ å¦å¤–ä¸€é“BTçš„é¢˜ç›®é“¾æ¥åœ¨è¿™é‡Œâ¬‡ï¸ public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder st = new StringBuilder(); serialize(root, st); return st.toString(); &#125; public void serialize(TreeNode root, StringBuilder st) &#123; if (root == null) st.append(\"n\" + \" \"); else &#123; st.append(root.val + \" \"); serialize(root.left, st); serialize(root.right, st); &#125; &#125; public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.addAll(Arrays.asList(data.split(\" \"))); return deseralize(queue); &#125; public TreeNode deseralize(Queue&lt;String&gt; queue) &#123; String cur = queue.poll(); if (cur.equals(\"n\")) return null; TreeNode root = new TreeNode(Integer.parseInt(cur)); root.left = deseralize(queue); root.right = deseralize(queue); return root; &#125;&#125; æ€è·¯&amp;code å’Œ297ä¸€æ¨¡ä¸€æ ·ã€‚ 103. Binary Tree Zigzag Level Order Traversal Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); boolean zig = false; queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; templist.add(0,node.val); &#125;else&#123; templist.add(node.val); &#125; if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(templist); zig=!zig; &#125; return res; &#125;&#125; level traversalã€‚åŠ ä¸€ä¸ªzigåˆ¤æ–­æ·»åŠ é¡ºåºã€‚zigçš„é€†åºï¼Œä¸æ–­add(0,val)ã€‚ 102. Binary Tree Level Order Traversal Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; size;i++)&#123; TreeNode node = queue.poll(); templist.add(node.val); if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(templist); &#125; return res; &#125;&#125; ç»å…¸tree level traversalæ¨¡ç‰ˆã€‚å’Œ103ä¸€ä¸ªæ€è·¯ã€‚åªä¸è¿‡103éœ€è¦è€ƒè™‘zigï¼Œè¿™é“é¢˜å•çº¯çš„traversalå°±å¯ä»¥ã€‚ 96. Unique Binary Search Trees Question Link &gt;&gt;&gt; class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i &lt;=n;i++)&#123; for(int j = 1 ; j&lt;=i ; j ++)&#123; dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; dpæ€è·¯ã€‚æ•°å­¦æ€è·¯æ¯”è¾ƒè´¹æ—¶é—´ã€‚youtbeè§†é¢‘è®²è§£â¬‡ï¸ã€‚ 366. Find Leaves of Binary Tree Question Link &gt;&gt;&gt; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public int help(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return -1; int level = 1 + Math.max(help(root.left,res),help(root.right,res)); if(res.size() &lt; level + 1)res.add(new ArrayList&lt;&gt;()); res.get(level).add(root.val); return level; &#125;&#125; æ‰¾treeçš„æ·±åº¦levelï¼Œreså¤§å°å’Œlevelä¸€æ ·ã€‚ç„¶åé€šè¿‡getï¼ˆlevelï¼‰æ‰¾åˆ°å¯¹åº”çš„ä½ç½®ï¼Œæ·»åŠ root.valã€‚ 545. Boundary of Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null)return res; res.add(root.val); findleft(root.left,res); leaf(root.left,res); leaf(root.right,res); findright(root.right,res); return res; &#125; public void findleft(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null || root.left==null &amp;&amp; root.right == null)return; res.add(root.val); if(root.left == null)findleft(root.right,res); else findleft(root.left,res); &#125; public void leaf(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null)return; if(root.left==null &amp;&amp; root.right == null)res.add(root.val); leaf(root.left,res); leaf(root.right,res); &#125; public void findright(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null || root.left==null &amp;&amp; root.right == null)return; if(root.right == null)findright(root.left,res); else findright(root.right,res); res.add(root.val); &#125;&#125; å·¦-å¶å­-å³ çš„é¡ºåºã€‚å®šä¹‰ä¸‰ä¸ªå‡½æ•°å„è‡ªæ‰¾å·¦å¶å³ã€‚æ³¨æ„å·¦å³å‡½æ•°é‡Œï¼Œå½“rootå·¦å³éƒ½ä¸ºç©ºæ—¶è¦è¿”å›åœæ­¢ã€‚åªæœ‰æ‰¾å¶å­ç»“ç‚¹æ—¶æ‰res.addã€‚ æ³¨æ„æ‰¾å³æ—¶ï¼Œres.addé¡ºåºåœ¨é€’å½’ä¹‹åã€‚ 222. Count Complete Tree Nodes Question Link &gt;&gt;&gt; class Solution &#123; public int countNodes(TreeNode root) &#123; int left = countleft(root); int right = countright(root); if(left == right)&#123; return (1&lt;&lt;left) -1; &#125;else&#123; return 1 + countNodes(root.left) + countNodes(root.right); &#125; &#125; public int countleft(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; dep++; root = root.left; &#125; return dep; &#125; public int countright(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; dep++; root = root.right; &#125; return dep; &#125;&#125; Complete Tree Wiki å®šä¹‰ æ‰€ä»¥å¦‚æœæœ€å·¦æˆ–è€…æœ€å³æœ‰ä¸€ä¸ªç©ºç¼ºå°±ä¸æ˜¯complete treeã€‚æ‰€ä»¥æ‰¾æœ€å·¦æœ€å³çš„æ·±åº¦ã€‚ å¦‚æœç›¸åŒï¼Œåˆ™ç›´æ¥è¿”å›æ ‘ 1&lt;&lt;æ·±åº¦ -1å°±æ˜¯nodeçš„ä¸ªæ•°ã€‚&lt;&lt;ç›¸å½“äºå¯¹æ·±åº¦å–2çš„å¯¹æ•°ã€‚ å¦‚æœå·¦å³æ·±åº¦ä¸ç›¸åŒåˆ™é€’å½’ç»§ç»­æ‰¾å„è‡ªå·¦å³å­æ ‘å¹¶ä¸”åŠ 1ï¼ˆå½“å‰nodeï¼‰ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 65","slug":"chin-up-03","date":"2020-01-26T15:14:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/01/26/chin-up-03/","link":"","permalink":"WangHngLeee.github.io/2020/01/26/chin-up-03/","excerpt":"297. Serialize and Deserialize Binary Tree ğŸ”—Question Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(sb,root); return sb.toString(); &#125; public void serial(StringBuilder sb, TreeNode root)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(sb,root.left); serial(sb,root.right); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return buildTree(queue); &#125; public TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val.equals(\"n\"))return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left=buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; preorderéå†è½¬ä¸ºstringï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼Œå»ºæ ‘çš„æ—¶å€™splitç©ºæ ¼ï¼Œç„¶åpreorderå»ºæ ‘ã€‚ç”¨queueå­˜ä¸‹preorderçš„stringç»“æœã€‚","text":"297. Serialize and Deserialize Binary Tree ğŸ”—Question Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(sb,root); return sb.toString(); &#125; public void serial(StringBuilder sb, TreeNode root)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(sb,root.left); serial(sb,root.right); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return buildTree(queue); &#125; public TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val.equals(\"n\"))return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left=buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; preorderéå†è½¬ä¸ºstringï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼Œå»ºæ ‘çš„æ—¶å€™splitç©ºæ ¼ï¼Œç„¶åpreorderå»ºæ ‘ã€‚ç”¨queueå­˜ä¸‹preorderçš„stringç»“æœã€‚ 1130. Minimum Cost Tree From Leaf Values Question Link &gt;&gt;&gt; class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int num : arr)&#123; list.add(num); &#125; int res = 0; while(list.size() &gt; 1)&#123; int product = Integer.MAX_VALUE; int index = 0; for(int i=0 ;i&lt;list.size()-1;i++)&#123; if(product &gt; list.get(i) * list.get(i+1))&#123; product = list.get(i) * list.get(i+1); index = i; &#125; &#125; list.set(index,Math.max(list.get(index),list.get(index+1))); list.remove(index+1); res += product; &#125; return res; &#125;&#125; å®è´¨æ˜¯æ•°ç»„é¢˜ã€‚éå†æ‰¾productæœ€å°çš„ä¸¤æ•°ï¼Œå¹¶ä¸”è®°å½•ç¬¬ä¸€ä¸ªæ•°çš„åæ ‡ã€‚ç„¶åæ›´æ¢è¯¥ä½ç½®çš„æ•°ã€‚ 124. Binary Tree Maximum Path Sum Question Link &gt;&gt;&gt; class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right)+root.val; &#125;&#125; maxè®°å½•å½“å‰æœ€å¤§çš„sumã€‚ä½†æ˜¯recursiveè¿”å›çš„æ˜¯leftå’Œrightæœ€å¤§å€¼åŠ ä¸Šå½“å‰rootå€¼ã€‚ 199. Binary Tree Right Side View Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i&gt;= size-1)res.add(temp.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; ç»å…¸tree bfsã€‚å”¯ä¸€ä¸åŒæ˜¯åˆ¤æ–­å½“å‰æ˜¯å¦æ˜¯ç¬¬size-1ä¸ªï¼ŒåŠ å…¥resã€‚è¿™æ ·å°±ä¿è¯æ˜¯treeæœ€right side viewäº†ã€‚ 98. Validate Binary Search Tree Question Link &gt;&gt;&gt; class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return true; return check(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean check(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val&lt;= min || root.val &gt;=max)return false; return check(root.left,min,root.val) &amp;&amp; check(root.right,root.val,max); &#125;&#125; è®¾ä¸¤ä¸ªèŒƒå›´ï¼Œä¿è¯bstæ¯ä¸ªèŠ‚ç‚¹éƒ½åœ¨min å’Œmaxä¹‹é—´å°±å¯ä»¥ã€‚ 236. Lowest Common Ancestor of a Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; return root; &#125;&#125; lcaçš„é¢˜ã€‚é€’å½’å‰å…ˆåˆ¤æ–­è¯¥rootæ˜¯å¦å’Œp or qç›¸åŒã€‚å¦‚æœç›¸åŒåˆ™ç›´æ¥è¿”å›æ”¹å€¼ã€‚å¦‚æœæ²¡æœ‰åˆ™å·¦å³é€’å½’ã€‚è‹¥å·¦æ²¡æœ‰åˆ™ä»£è¡¨éƒ½åœ¨å³è¾¹ã€‚è‹¥å³æ²¡æœ‰åˆ™ä»£è¡¨åœ¨å·¦è¾¹ã€‚å¦‚æœä¸¤é¢éƒ½æœ‰åˆ™è¿”å›å½“å‰rootã€‚å› ä¸ºå·¦å³éƒ½æœ‰è‚¯å®šå½“å‰rootä¸ºlcaã€‚ 543. Diameter of Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; int ans = 0; public int diameterOfBinaryTree(TreeNode root) &#123; help(root); return ans; &#125; public int help(TreeNode root)&#123; if(root == null)return -1; int left = help(root.left)+1; int right = help(root.right)+1; ans = Math.max(ans,left+right); return Math.max(left,right); &#125;&#125; å·¦å³å„è‡ªæ‰¾æœ€é•¿depthï¼Œæ›´æ–°ansï¼Œæœ€åé€’å½’è¿”å›leftå’Œrightçš„æœ€å¤§å€¼ã€‚ 173. Binary Search Tree Iterator Question Link &gt;&gt;&gt; class BSTIterator &#123; public Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); public BSTIterator(TreeNode root) &#123; pushall(root); &#125; public int next() &#123; TreeNode temp = stack.pop(); if(temp.right!=null)&#123; pushall(temp.right); &#125; return temp.val; &#125; public boolean hasNext() &#123; return !stack.isEmpty(); &#125; public void pushall(TreeNode root)&#123; while(root!=null)&#123; stack.push(root); root = root.left; &#125; &#125;&#125; å®šä¹‰pushallå‡½æ•°ï¼Œå°†æ‰€æœ‰leftèŠ‚ç‚¹å­˜å…¥stackã€‚æœ€åæ ˆé¡¶åˆ™æ˜¯å½“å‰çš„minå€¼ã€‚nextæ—¶å€™å…ˆpopå‡ºpeekå…ƒç´ ï¼Œç„¶åå¯¹peekå…ƒç´ pushallï¼Œæ›´æ–°minå€¼ï¼Œç„¶åè¿”å›popå€¼ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 64","slug":"chin-up-02","date":"2020-01-22T18:20:42.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/01/22/chin-up-02/","link":"","permalink":"WangHngLeee.github.io/2020/01/22/chin-up-02/","excerpt":"5. Longest Palindromic Substring ğŸ”—Question Link class Solution &#123; int start, maxlen; public String longestPalindrome(String s) &#123; for(int i=0 ;i&lt;s.length(); i++)&#123; check(s,i,i); check(s,i,i+1); &#125; return s.substring(start,start + maxlen); &#125; public void check(String s, int left, int right)&#123; while(left &gt;= 0 &amp;&amp; right &lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; if(right - left &gt; maxlen)&#123; maxlen = right - left-1; start = left + 1; &#125; &#125;&#125; æ£€æŸ¥ä¸€ä½ or ä¸¤ä½çš„å›æ–‡æƒ…å†µã€‚checkè‡ªå·±æœ¬èº«ä»¥åŠè‡ªå·±å’Œåä¸€ä½ã€‚","text":"5. Longest Palindromic Substring ğŸ”—Question Link class Solution &#123; int start, maxlen; public String longestPalindrome(String s) &#123; for(int i=0 ;i&lt;s.length(); i++)&#123; check(s,i,i); check(s,i,i+1); &#125; return s.substring(start,start + maxlen); &#125; public void check(String s, int left, int right)&#123; while(left &gt;= 0 &amp;&amp; right &lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; if(right - left &gt; maxlen)&#123; maxlen = right - left-1; start = left + 1; &#125; &#125;&#125; æ£€æŸ¥ä¸€ä½ or ä¸¤ä½çš„å›æ–‡æƒ…å†µã€‚checkè‡ªå·±æœ¬èº«ä»¥åŠè‡ªå·±å’Œåä¸€ä½ã€‚ 20. Valid Parentheses ğŸ”—Question Link class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;();// to store the other part of parenthese for(int i= 0; i&lt;s.length();i++)&#123; if(s.charAt(i) ==' ')continue; if(s.charAt(i) == '&#123;')&#123; stack.push('&#125;'); &#125;else if(s.charAt(i) == '[')&#123; stack.push(']'); &#125;else if(s.charAt(i) == '(')&#123; stack.push(')'); &#125;else if(stack.isEmpty() || stack.pop() != s.charAt(i))return false; &#125; return stack.isEmpty(); &#125;&#125; ç”¨stackæ¥ä¿æŒä¸€å¯¹åˆæ ¼çš„æ‹¬å·ã€‚é‡åˆ°å¼€å£å°±å‘stackå­˜é—­å£ã€‚å¦‚æœä¸æ˜¯å¼€å£å°±åˆ¤æ–­popå‡ºæ¥çš„å’Œå½“å‰æ˜¯å¦ç›¸åŒã€‚ 3. Longest Substring Without Repeating Characters ğŸ”—Question Link class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int i = 0, j=0; int res = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j)); j++; res = Math.max(res,set.size()); &#125;else&#123; set.remove(s.charAt(i)); i++; &#125; &#125; return res; &#125;&#125; åŒæŒ‡é’ˆã€‚setå­˜å”¯ä¸€çš„å­—ç¬¦ã€‚å¦‚æœé‡åˆ°é‡å¤çš„ï¼Œåˆ™ä»å¤´å¼€å§‹ç§»å‡ºsetã€‚ä¿æŒresä¸ºsetçš„æœ€å¤§sizeã€‚ 22. Generate Parentheses ğŸ”—Question Link class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); help(\"\",res,0,0,n); return res; &#125; public void help(String cur, List&lt;String&gt; res, int open ,int close, int num)&#123; if(cur.length() == num *2)&#123; res.add(cur); return; &#125; if(open &lt; num)&#123; help(cur+\"(\",res,open+1,close,num); &#125; if(close &lt; open)&#123; help(cur + \")\",res,open,close+1,num); &#125; &#125;&#125; open å’Œ closeç”¨æ¥è®°å½•å·¦å³æ‹¬å·æ•°ï¼Œç„¶ååˆ†æƒ…å†µrecursiveè°ƒç”¨ã€‚æœ€åcuré•¿åº¦è¾¾åˆ°num*2å°±å¯ä»¥è¿”å›äº†ã€‚ 49. Group Anagrams ğŸ”—Question Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(strs == null || strs.length == 0)return res; for(String str : strs)&#123; int[] arr = new int[26]; for(int i=0 ;i&lt; str.length();i++)&#123; arr[str.charAt(i)-'a']++; &#125; String key = Arrays.toString(arr); if(!map.containsKey(key))&#123; map.put(key,new ArrayList&lt;&gt;()); &#125; map.get(key).add(str); &#125; for(String key : map.keySet())&#123; res.add(map.get(key)); &#125; return res; &#125;&#125; ç»å…¸çš„arr[26]æ–¹æ³•ã€‚å°†arr[]è½¬æˆkeyå­˜å…¥mapï¼Œç”¨å…¶æ¥å¯¹åº”ç»„æˆå­—æ¯ç›¸åŒçš„wordã€‚æœ€åè¿”å›ç›¸åŒå­—æ¯çš„wordé›†åˆã€‚ 91. Decode Ways ğŸ”—Question Link class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() == 0)return 0; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0) == '0' ? 0 : 1; for(int i=2 ;i&lt;=s.length();i++)&#123; int first = Integer.valueOf(s.substring(i-1,i)); int second = Integer.valueOf(s.substring(i-2,i)); if(first &gt;=1 &amp;&amp; first&lt;=9)&#123; dp[i]+=dp[i-1]; &#125; if(second&gt;=10 &amp;&amp; second &lt;=26)&#123; dp[i]+=dp[i-2]; &#125; &#125; return dp[n]; &#125;&#125; é‡åˆ°è¿”å›æ‰€æœ‰æƒ…å†µè€Œä¸”å­˜åœ¨ä¸è¿ç»­çš„æƒ…å†µï¼ŒåŸºæœ¬ç”¨dpè§£å†³ã€‚åˆ†1ä½æ•°å’Œ2ä½æ•°æ¥è§£å†³ã€‚å¦‚æœ1ä½æ•°åœ¨1-9ä¹‹é—´ï¼Œå¯ä»¥å¯¹åº”A-I,å¦‚æœ2ä½æ•°åœ¨10-26ä¹‹é—´ï¼Œå¯ä»¥å¯¹åº”J-Zã€‚dpä¸æ–­æ›´æ–°å¯æ„æˆçš„æœ€å¤šæƒ…å†µï¼Œæœ€åè¿”å›æœ€åä¸€ä½dpå€¼å³å¯ã€‚ 32. Longest Valid Parentheses ğŸ”—Question Link class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;len;i++)&#123; if(s.charAt(i) == '(')&#123; open++; &#125;else if(s.charAt(i) ==')' &amp;&amp; open &gt; 0)&#123; dp[i] = dp[i-1]+2; if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; dpæ€è·¯ã€‚openè®°å½•å¼€å£æ•°ï¼Œåªæœ‰å½“open&gt;0æ‰å¯¹closeå’Œdpæ“ä½œã€‚é¦–å…ˆæ›´æ–°dp=dp[i-1]+2ï¼ŒåŠ ä¸Šä¸€å¯¹åˆæ ¼å¯¹æ‹¬å·ã€‚ä¹‹åå¦‚æœi-dp[i]&gt;0è¯´æ˜iä¹‹å‰è¿˜æ˜¯æœ‰åˆæ ¼æ‹¬å·å¯¹å­˜åœ¨ï¼ŒæŠŠè¿™äº›ä¹ŸåŠ ä¸Šã€‚æœ€åç”¨maxè®°å½•æœ€å¤§ï¼Œè¿”å›maxã€‚ 125. Valid Palindrome ğŸ”—Question Link class Solution &#123; public boolean isPalindrome(String s) &#123; if(s == null || s.length()==0)return true; int left = 0; int right = s.length()-1; while(left&lt;=right)&#123; char l = s.charAt(left); char r = s.charAt(right); if(!Character.isLetterOrDigit(l))&#123; left++; &#125; else if(!Character.isLetterOrDigit(r))&#123; right--; &#125; else&#123; if(Character.toLowerCase(l) != Character.toLowerCase(r))return false; right--; left++; &#125; &#125; return true; &#125;&#125; two pointersã€‚å‰åå„è‡ªæ‰«æä¸ºå­—æ¯çš„ä½ç½®ã€‚å¦‚æœä¸¤ä¸ªä¸ç›¸åŒç›´æ¥falseï¼Œå¦‚æœç›¸åŒåˆ™ç»§ç»­å¾€é‡Œæ”¶ç¼©ã€‚ 819. Most Common Word ğŸ”—Question Link class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; banset = new HashSet&lt;&gt;(); String[] words = paragraph.toLowerCase().split(\"\\\\W++\"); for(String ban : banned)&#123; banset.add(ban); &#125; for(String word : words)&#123; if(!banset.contains(word))&#123; map.put(word,map.getOrDefault(word,0)+1); &#125; &#125; int max = 0; String res = \"\"; for(String key : map.keySet())&#123; if(map.get(key) &gt; max)&#123; max = map.get(key); res = key; &#125; &#125; return res; &#125;&#125; bannedå•è¯åŠ å…¥setï¼Œmapå­˜ä¸åœ¨bannedé‡Œçš„å•è¯çš„æ¬¡æ•°ï¼Œç„¶åæ‰¾åˆ°æœ€å¤šæ¬¡æ•°çš„å•è¯è¿”å›ã€‚ 227. Basic Calculator II ğŸ”—Question Link class Solution &#123; public int calculate(String s) &#123; int len = s.length(); if(s == null || len == 0)return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int num = 0; char sign = '+'; for(int i=0 ;i&lt;s.length();i++)&#123; if(Character.isDigit(s.charAt(i)))&#123; num = num*10 + s.charAt(i)-'0'; &#125; if( (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i)!=' ') || i == len-1)&#123; if(sign == '-')&#123; stack.push(-num); &#125; if(sign == '+')&#123; stack.push(num); &#125; if(sign == '*')&#123; stack.push(stack.pop() * num); &#125; if(sign == '/')&#123; stack.push(stack.pop() / num); &#125; sign = s.charAt(i); num=0; &#125; &#125; int res = 0; for(int nums : stack)&#123; res+=nums; &#125; return res; &#125;&#125; é€†æ³¢å…°å¼å­çš„åº”ç”¨ã€‚stackå­˜æ•°å­—ï¼Œç„¶ååˆå§‹åŒ–è¿ç®—ç¬¦ä¸º+å·ã€‚æ›´æ–°å®Œvalueåå†æŠŠç¬¦å·æ›´æ–°ä¸ºå½“å‰çš„ç¬¦å·ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Leetcode EveryDay 63","slug":"chin-up-01","date":"2020-01-20T17:13:54.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2020/01/20/chin-up-01/","link":"","permalink":"WangHngLeee.github.io/2020/01/20/chin-up-01/","excerpt":"å‰è¨€ï½œSay somethingâ€¦ Hiï¼Œå¾ˆä¹…æ²¡æœ‰æ›´æ–°blogäº†ï¼Œè¿™æœŸé—´ç»å†äº†è®¸å¤šï¼Œä¹Ÿå¯¹è‡ªå·±æœ‰äº†æ–°çš„è®¤è¯†ï¼Œåˆ·é¢˜ä¹Ÿæœ‰äº†æ–°çš„æ–¹æ³•ã€‚ è™½ç„¶å¾ˆä¹…æ²¡æœ‰æ›´æ–°blogäº†ï¼Œä½†æ˜¯æ¯å¤©éƒ½æœ‰åœ¨åšé¢˜ï¼Œå‰ä¸€æœˆåˆçš„æ—¶å€™è¾¾æˆäº†åˆ·é¢˜430é“ï¼Œç®—æ˜¯ä¸€ä¸ªå°æˆå°±å§ï¼Œæ¥ä¸‹æ¥ä¹Ÿä¸æ‰“ç®—åšæ–°é¢˜äº†ï¼Œä¸»è¦å¤ä¹ æ€»ç»“ä¹‹å‰åšè¿‡çš„é¢˜ç›®ã€‚ æœ€è¿‘ä¹Ÿé™†é™†ç»­ç»­æ”¶åˆ°åˆ«çš„å…¬å¸çš„oaå’Œé¢è¯•ï¼Œå¸Œæœ›è‡ªå·±å¥½å¥½å‡†å¤‡ã€‚ Keep head on and Chin up ! 199. Binary Tree Right Side View ğŸ”—Question Link class Solution&#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue= new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if(i&gt;=size-1)res.add(root.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; å…¸å‹tree+bfs+queueçš„level traversalï¼Œå”¯ä¸€differenceæ˜¯å½“sizeåˆ°è¾¾æ”¹å±‚æœ€åä¸€ä¸ªå…ƒç´ æ—¶æ‰åŠ å…¥resã€‚","text":"å‰è¨€ï½œSay somethingâ€¦ Hiï¼Œå¾ˆä¹…æ²¡æœ‰æ›´æ–°blogäº†ï¼Œè¿™æœŸé—´ç»å†äº†è®¸å¤šï¼Œä¹Ÿå¯¹è‡ªå·±æœ‰äº†æ–°çš„è®¤è¯†ï¼Œåˆ·é¢˜ä¹Ÿæœ‰äº†æ–°çš„æ–¹æ³•ã€‚ è™½ç„¶å¾ˆä¹…æ²¡æœ‰æ›´æ–°blogäº†ï¼Œä½†æ˜¯æ¯å¤©éƒ½æœ‰åœ¨åšé¢˜ï¼Œå‰ä¸€æœˆåˆçš„æ—¶å€™è¾¾æˆäº†åˆ·é¢˜430é“ï¼Œç®—æ˜¯ä¸€ä¸ªå°æˆå°±å§ï¼Œæ¥ä¸‹æ¥ä¹Ÿä¸æ‰“ç®—åšæ–°é¢˜äº†ï¼Œä¸»è¦å¤ä¹ æ€»ç»“ä¹‹å‰åšè¿‡çš„é¢˜ç›®ã€‚ æœ€è¿‘ä¹Ÿé™†é™†ç»­ç»­æ”¶åˆ°åˆ«çš„å…¬å¸çš„oaå’Œé¢è¯•ï¼Œå¸Œæœ›è‡ªå·±å¥½å¥½å‡†å¤‡ã€‚ Keep head on and Chin up ! 199. Binary Tree Right Side View ğŸ”—Question Link class Solution&#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue= new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if(i&gt;=size-1)res.add(root.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; å…¸å‹tree+bfs+queueçš„level traversalï¼Œå”¯ä¸€differenceæ˜¯å½“sizeåˆ°è¾¾æ”¹å±‚æœ€åä¸€ä¸ªå…ƒç´ æ—¶æ‰åŠ å…¥resã€‚ 863. All Nodes Distance K in Binary Tree ğŸ”—Question Link class Solution&#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root,TreeNode target, int K) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,target); dfs(root,0,K,res); return res; &#125; public int find(TreeNode root, int target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; public void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(key); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.right,dist+1,K,res)l &#125;&#125; findå‡½æ•°å°†taregtä¸Šæ–¹æ‰€æœ‰èŠ‚ç‚¹ ä¸targetçš„dist å­˜è¿›mapã€‚dfså‡½æ•°é‡Œé¦–å…ˆåˆ¤æ–­è¯¥èŠ‚ç‚¹æ˜¯å¦å­˜è¿›mapï¼Œå¦‚æœæœ‰åˆ™æŠŠdistæ›´æ–°ä¸ºmapé‡Œçš„å€¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä¸å˜ï¼Œdfsæ¯è¿›è¡Œä¸€æ¬¡dist+1ã€‚ 207. Course Schedule ğŸ”—Question Link class Solution&#123; public boolean canFinish(int numCourses, int[] prerequisites)&#123; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i=0 ;i&lt;indegree.length;i++)&#123; if(indegree[i] ==0)&#123; queue.add(i); &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); numCourse--; for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]]==0)&#123; queue.add(pair[0]); &#125; &#125; &#125; &#125; return numCourse == 0; &#125;&#125; å…¸å‹æ‹“æ‰‘æ’åºã€‚ç”¨indegreeå­˜æ¯ä¸ªè¯¾çš„å…¥åº¦ã€‚ç„¶åå°†å…¥åº¦ä¸º0ï¼Œå³å¯ä»¥ä¼˜å…ˆä¸Šçš„è¯¾åŠ å…¥queueã€‚bfsæ›´æ–°indegreeï¼Œå¦‚æœå†å‘ç°indegreeä¸ºé›¶ï¼Œåˆ™åœ¨åŠ å…¥queueã€‚æœ€ååˆ¤æ–­å‰©ä¸‹çš„è¯¾æ˜¯å¦ä¸º0ã€‚å¦‚æœå¯ä»¥ä¸Šåˆ™åº”è¯¥æ²¡æœ‰å‰©è¯¾ã€‚å¦åˆ™è¿”å›falseã€‚ 210. Course Schedule II ğŸ”—Question Link class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; int index = 0; for(int i=0 ;i&lt;indegree.length;i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); res[index] = i; index++; &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]]==0)&#123; queue.add(pair[0]); res[index]=pair[0]; index++; &#125; &#125; &#125; &#125; return index == numCourses ? res : new int[]&#123;&#125;; &#125;&#125; æ€è·¯å’Œä¸Šä¸€é¢˜ä¸€æ ·ï¼Œåªä¸è¿‡éœ€è¦ç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸ºè¯¾ç¨‹æ•°çš„æ•°ç»„ï¼ŒæŒ‰åºå­˜å…¥è¯¾ç¨‹å³å¯ã€‚ 529. Minesweeper ğŸ”—Question Link class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; int m = board.length; int n = board[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(click); while(!queue.isEmpty())&#123; int[] temp = queue.poll(); int row = temp[0]; int col = temp[1]; if(board[row][col] == 'M')&#123; board[row][col] = 'X'; &#125;else&#123; int count = 0; for(int i=-1 ;i&lt;2;i++)&#123; for(int j=-1;j&lt;2;j++)&#123; if(i == 0 &amp;&amp; j == 0)continue; int r = row + i; int c = col + j; if(r&gt;=0 &amp;&amp; r&lt;m &amp;&amp; c&gt;=0 &amp;&amp; c&lt;n &amp;&amp; (board[r][c] == 'M' || board[r][c] =='X') )&#123; count++; &#125; &#125; &#125; if(count &gt; 0)&#123; board[row][col] = (char)(count+'0'); &#125;else&#123; board[row][col] = 'B'; for(int i=-1 ;i&lt;2;i++)&#123; for(int j=-1 ;j&lt;2;j++)&#123; int r = row + i; int c = col + j; if(j == 0 &amp;&amp; i ==0)continue; if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &lt; 0 || c &gt;= n) continue; if(board[r][c] == 'E')&#123; queue.add(new int[]&#123;r,c&#125;); board[r][c] = 'B'; &#125; &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; ç»å…¸bfsã€‚é¦–å…ˆåˆ¤æ–­æ˜¯å¦æ˜¯é›·ï¼Œå¦‚æœæ˜¯åˆ™å˜ä¸ºxã€‚ç„¶åæ•°å‘¨å›´é›·æˆ–è€…xçš„ä¸ªæ•°ã€‚å¦‚æœä¸ªæ•°ä¸ä¸ºé›¶ï¼Œåˆ™è¯´æ˜è¯¥ä½ç½®å‘¨å›´æœ‰é›·ï¼Œå°†è¯¥ä½ç½®å˜ä¸ºé›·çš„ä¸ªæ•°ã€‚å¦‚æœä¸ªæ•°ä¸ºé›¶ï¼Œè¯´æ˜ä¸ºè¾¹ç•Œï¼Œåˆ™ç»§ç»­bfsæ‰©å¤§è¾¹ç•Œã€‚ 133. Clone Graph ğŸ”—Question Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt;queue=new LinkedList&lt;&gt;(); map.put(node,dummy); queue.add(node); while(!queue.isEmpty())&#123; Node cur = queue.poll(); for(Node nb:cur.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb,new Node(nb.val)); queue.add(nb); &#125; map.get(cur).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; ç”¨mapå­˜åŸnodeå’Œå…‹éš†çš„æ–°nodeï¼Œå¯¹åŸnodeçš„é‚»å±…è¿›è¡Œéå†ï¼Œå¦‚æœmapé‡Œæ²¡æœ‰åˆ™æŠŠè¯¥é‚»å±…èŠ‚ç‚¹å…‹éš†ï¼Œç„¶åputè¿›mapï¼ŒåŠ å…¥queueã€‚å¦‚æœå­˜åœ¨äº†å°±æŠŠå½“å‰nodeçš„é‚»å±…èŠ‚ç‚¹çš„å…‹éš†èŠ‚ç‚¹å­˜å…¥å½“å‰nodeçš„å…‹éš†èŠ‚ç‚¹çš„é‚»å±…èŠ‚ç‚¹é‡Œã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"}]},{"title":"Leetcode EveryDay 62 / LinkedList","slug":"leetcode62","date":"2019-11-18T20:13:54.000Z","updated":"2020-02-03T01:16:22.110Z","comments":true,"path":"2019/11/18/leetcode62/","link":"","permalink":"WangHngLeee.github.io/2019/11/18/leetcode62/","excerpt":"92. Reverse Linked List II class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i =0;i&lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; åŸºæœ¬çš„é“¾è¡¨æ“ä½œã€‚æ³¨æ„æ›´æ–°æ—¶ä»£ç çš„å†™æ³•ã€‚","text":"92. Reverse Linked List II class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i =0;i&lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; åŸºæœ¬çš„é“¾è¡¨æ“ä½œã€‚æ³¨æ„æ›´æ–°æ—¶ä»£ç çš„å†™æ³•ã€‚ 725. Split Linked List in Parts class solution&#123; public ListNode[] splitListToParts(ListNode root, int k) &#123; ListNode[] res = new ListNode[k]; int size = 0; for(ListNode node = root; node!=null ; node = node.next)&#123; size++; &#125; int n = size/k,r = size%k; ListNode prev = null, node = root; for(int i = 0 ; node!=null &amp;&amp; i&lt;k ; i++,r--)&#123; res[i] = node; for(int j = 0; j &lt; n + ( r &gt; 0 ? 1 : 0); j++)&#123; prev = node; node = node.next; &#125; prev.next = null; &#125; return res; &#125;&#125; å…ˆå°†rootå­˜å…¥res[0]ï¼Œç„¶åæ ¹æ®nå’Œrå¯¹æ•°ç»„å¤§å°è¿›è¡Œç¡®å®šï¼Œç„¶åéå†ï¼Œè®°ä½prevæ˜¯è¯¥æ•°ç»„çš„å°¾ï¼Œè€Œnodeåˆ™æ˜¯æ›´æ–°ä¸ºäº†ä¸‹ä¸€ä¸ªresçš„å¤´èŠ‚ç‚¹ã€‚ç›¸å½“äºç”¨prev.next==null æ¥æ–­é“¾è¡¨ã€‚ 148. Sort List class Solution &#123; public ListNode sortList(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int n = 0; while (head != null) &#123; head = head.next; n++; &#125; for (int step = 1; step &lt; n; step &lt;&lt;= 1) &#123; ListNode prev = dummy; ListNode cur = dummy.next; while (cur != null) &#123; ListNode left = cur; ListNode right = split(left, step); cur = split(right, step); prev = merge(left, right, prev); &#125; &#125; return dummy.next; &#125; private ListNode split(ListNode head, int step) &#123; if (head == null) return null; for (int i = 1; head.next != null &amp;&amp; i &lt; step; i++) &#123; head = head.next; &#125; ListNode right = head.next; head.next = null; return right; &#125; private ListNode merge(ListNode left, ListNode right, ListNode prev) &#123; ListNode cur = prev; while (left != null &amp;&amp; right != null) &#123; if (left.val &lt; right.val) &#123; cur.next = left; left = left.next; &#125; else &#123; cur.next = right; right = right.next; &#125; cur = cur.next; &#125; if (left != null) cur.next = left; else if (right != null) cur.next = right; while (cur.next != null) cur = cur.next; return cur; &#125;&#125; bottom-upã€‚ å°†nodeæŒ‰ä¸ªæ•°ä¸º1ï¼Œ2ï¼Œ4ï¼Œ8ï¼Œã€‚ã€‚ã€‚çš„é¡ºåºåˆ†åˆ«æ’åºï¼Œstep&lt;&lt;=1å°±æ˜¯å°†step*2.splitæ˜¯è¿”å›æ–­å¼€åå³è¾¹çš„listnodeï¼Œmergeå°±æ˜¯åˆå¹¶ï¼Œä½†è¦æ³¨æ„è¿”å›çš„æ˜¯åˆå¹¶åçš„å°¾éƒ¨çš„nodeï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡å¾ªç¯é“¾æ¥ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 61 / LinkedList","slug":"leetcode61","date":"2019-11-17T20:13:54.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/11/17/leetcode61/","link":"","permalink":"WangHngLeee.github.io/2019/11/17/leetcode61/","excerpt":"61. Rotate List class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(head == null)return null; int size = 1; ListNode fast = head,slow = head; while(fast.next!=null)&#123; size++; fast = fast.next; &#125; for(int i = size - k%size;i&gt;1;i--)&#123; slow = slow.next; &#125; fast.next = head; head= slow.next; slow.next = null; return head; &#125;&#125; ç¡®å®šlistnodeé•¿åº¦ï¼Œæ‰¾åˆ°ç¬¬k-k%sizeç¬¬å…ƒç´ ï¼Œç„¶åå°†å…¶åå…ƒç´ å…¨éƒ¨æå‰å³å¯ã€‚","text":"61. Rotate List class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(head == null)return null; int size = 1; ListNode fast = head,slow = head; while(fast.next!=null)&#123; size++; fast = fast.next; &#125; for(int i = size - k%size;i&gt;1;i--)&#123; slow = slow.next; &#125; fast.next = head; head= slow.next; slow.next = null; return head; &#125;&#125; ç¡®å®šlistnodeé•¿åº¦ï¼Œæ‰¾åˆ°ç¬¬k-k%sizeç¬¬å…ƒç´ ï¼Œç„¶åå°†å…¶åå…ƒç´ å…¨éƒ¨æå‰å³å¯ã€‚ 82. Remove Duplicates from Sorted List II class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null)return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = head; ListNode pre = dummy; while(cur!=null)&#123; while(cur.next!=null &amp;&amp; cur.val == cur.next.val)&#123; cur = cur.next; &#125; if(pre.next == cur)&#123; pre = pre.next; &#125;else&#123; pre.next = cur.next; &#125; cur = cur.next; &#125; return dummy.next; &#125;&#125; curå’ŒpreåŒæŒ‡é’ˆã€‚é¦–å…ˆåˆ¤æ–­curå’Œcur nextå€¼æ˜¯å¦ç›¸ç­‰ã€‚å¦‚æœç›¸ç­‰åˆ™è·³è¿‡ï¼Œpreé’ˆå¯¹curå¦‚æœæœ‰è·³è·ƒï¼Œåˆ™ç›´æ¥å°†pre next æ›´æ–°ä¸ºæ–°cur nextï¼Œ å¦‚æœæ²¡æœ‰è·³è·ƒåˆ™å°±ä¸ºpre nextã€‚ å› ä¸ºæ²¡æœ‰è·³è·ƒçš„è¯preå§‹ç»ˆåœ¨curçš„å‰é¢ã€‚ 141. Linked List Cycle class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast=head,slow=head; while(fast!=null)&#123; if(fast.next==null)return false; fast=fast.next.next; slow=slow.next; if(fast == slow)return true; &#125; return false; &#125;&#125; ç»å…¸å¿«æ…¢æŒ‡é’ˆã€‚fastèµ°ä¸¤ä¸ªï¼Œslowèµ°ä¸€ä¸ªï¼Œå¦‚æœä¸¤ä¸ªæŸä¸ªæ—¶åˆ»é‡åˆï¼Œè¯´æ˜æœ‰ç¯ã€‚å¦åˆ™æ²¡æœ‰ã€‚ 21. Merge Two Sorted Lists (1.iterative / 2. recursive) 1.Iterative æ–¹æ³• class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode res = dummy; while(l1 !=null &amp;&amp; l2 !=null)&#123; if(l1.val &lt; l2.val)&#123; res.next = l1; l1 = l1.next; &#125;else&#123; res.next = l2; l2=l2.next; &#125; res = res.next; &#125; if(l1 == null)res.next = l2; if(l2 == null)res.next = l1; return dummy.next; &#125;&#125; straightforwardæ–¹æ³•ã€‚æ–°å»ºä¸€ä¸ªå¤´èŠ‚ç‚¹dummyï¼Œåˆ†æƒ…å†µè®¨è®ºl1å’Œl2èŠ‚ç‚¹çš„å€¼å¤§å°ï¼Œåˆ†åˆ«åŠ å…¥dummy nextã€‚æœ€åè€ƒè™‘æŸä¸ªlistå·²ç»éå†å®Œçš„æƒ…å†µï¼Œåˆ™å°†å¦å¤–ä¸€ä¸ªlistç›´æ¥åŠ åˆ°dummy åé¢ã€‚ 2.Recursive æ–¹æ³• class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null || l2 == null)return l1 == null ? l2:l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next,l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; åŸºæœ¬çš„recursiveæ–¹æ³•ï¼Œåˆ†åˆ«å¯¹l1å’Œl2é€’å½’ã€‚ 23. Merge k Sorted Lists (priorityqueue / recursive ) priorityqueue class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode node1, ListNode node2)&#123; if(node1.val &lt; node2.val)return -1; else if(node1.val == node2.val)return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode last = dummy; for(ListNode node : lists)&#123; if(node != null)&#123; queue.add(node); &#125; &#125; while(!queue.isEmpty())&#123; last.next = queue.poll(); last = last.next; if(last.next!= null)&#123; queue.add(last.next); &#125; &#125; return dummy.next; &#125;&#125; è‡ªå®šä¹‰comparatorï¼Œå°†æ¯ä¸ªlistç¬¬ä¸€ä¸ªèŠ‚ç‚¹å­˜å…¥queueï¼Œç„¶ååˆ¤æ–­pollåçš„queueå¤´éƒ¨èŠ‚ç‚¹å’Œpollçš„èŠ‚ç‚¹nextçš„å€¼å¤§å°ã€‚ç„¶åä¾æ¬¡pollå‡ºå³å¯ã€‚ recursive ( based on mergeTwolists solutions) class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return mergeTwoList(lists,0,lists.length-1); &#125; public ListNode mergeTwoList(ListNode[] lists, int start, int end)&#123; if(start == end)return lists[start]; if(start &lt; end)&#123; int mid = (start + end)/2; ListNode l1 = mergeTwoList(lists,start,mid); ListNode l2 = mergeTwoList(lists,mid+1,end); return merge(l1,l2); &#125;else&#123; return null; &#125; &#125; public ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next=merge(l1.next,l2); return l1; &#125;else&#123; l2.next=merge(l1,l2.next); return l2; &#125; &#125;&#125; åŸºäºlc 21 mergetwolist çš„æ–¹æ³•ã€‚æœ¬é¢˜å˜ä¸ºkä¸ªlistï¼Œéœ€è¦å¤šä¸€å±‚å¯¹listè‡ªèº«å¯¹é€’å½’ã€‚äºŒåˆ†é€’å½’ã€‚ç„¶åå†æ¥ä¸Šmergetwolistçš„æ€è·¯ï¼Œå¯¹æŒ‡å®šå¯¹ä¸¤ä¸ªlistè¿›è¡Œmergeã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 60 / LinkedList","slug":"leetcode60","date":"2019-11-16T17:27:29.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/16/leetcode60/","link":"","permalink":"WangHngLeee.github.io/2019/11/16/leetcode60/","excerpt":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jå°±æ˜¯è®¡ç®—è¿›ä½ã€‚è€Œsum%10åˆ™æ˜¯è®¡ç®—åˆ¨é™¤è¿›ä½åéœ€è¦åŠ çš„æ•°ã€‚","text":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jå°±æ˜¯è®¡ç®—è¿›ä½ã€‚è€Œsum%10åˆ™æ˜¯è®¡ç®—åˆ¨é™¤è¿›ä½åéœ€è¦åŠ çš„æ•°ã€‚ 138. Copy List with Random Pointer class Solution &#123; public Node copyRandomList(Node head) &#123; if (head == null) return null; Node cur = head; while (cur != null) &#123; Node next = cur.next; cur.next = new Node(cur.val, next, null); cur = next; &#125; cur = head; while (cur != null) &#123; if (cur.random != null) cur.next.random = cur.random.next; cur = cur.next.next; &#125; cur = head; Node copyhead = head.next; while(cur!=null)&#123; Node curnext = cur.next.next;//curé“¾è¡¨ Node copy = cur.next;//copyé“¾è¡¨ cur.next = curnext; if(curnext!=null)&#123; copy.next = curnext.next; &#125; cur = curnext; &#125; return copyhead; &#125;&#125; ä¸‰æ¬¡éå†ã€‚ ç¬¬ä¸€æ¬¡åœ¨å¯¹åº”çš„nodeåé¢å¤åˆ¶è‡ªå·±æˆä¸ºnodeâ€™ ç¬¬äºŒæ¬¡å°†nodeâ€™çš„randomè¿çº¿ ç¬¬ä¸‰æ¬¡å„è‡ªæˆçº¿ã€‚ å¤§æ¦‚æ€è·¯å¦‚å›¾ï¼š 328. Odd Even Linked List class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head!=null)&#123; ListNode odd = head, even = head.next, evenhead = even; while(even !=null &amp;&amp; even.next !=null)&#123; odd.next = odd.next.next; even.next = even.next.next; odd = odd.next; even = even.next; &#125; odd.next = evenhead; &#125; return head; &#125;&#125; åŒºåˆ†oddå’Œevençš„headä¹‹åå„è‡ªnext.nextéå†å°±å¯ä»¥ã€‚æœ€åå°†evenheadåŠ åˆ°oddåé¢ã€‚ 1019. Next Greater Node In Linked List class Solution &#123; public int[] nextLargerNodes(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(ListNode node = head; node!=null;node = node.next)&#123; list.add(node.val); &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int size = list.size(); int[] res = new int[size]; for(int i = 0 ; i &lt; size;i++)&#123; while(!stack.isEmpty() &amp;&amp; list.get(stack.peek())&lt; list.get(i))&#123; res[stack.pop()] = list.get(i); &#125; stack.push(i); &#125; return res; &#125;&#125; listnodeå­˜ä¸ºarraylistã€‚ç”¨stackå­˜è´®indexï¼Œç„¶åå„è‡ªæ¯”è¾ƒã€‚ç±»ä¼¼next greator çš„é¢˜ï¼Œä¸€æ ·çš„æ€è·¯ã€‚ä¸‹ä¸€é¢˜å°±æ˜¯next greaterã€‚ 503. Next Greater Element II(circle) class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int size = nums.length; int res[] = new int[size]; Arrays.fill(res,-1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;size*2;i++)&#123; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%size])&#123; res[stack.pop()] = nums[i%size]; &#125; stack.push(i%size); &#125; return res; &#125;&#125; Loop once, we can get the Next Greater Number of a normal array. Loop twice, we can get the Next Greater Number of a circular array 496. Next Greater Element I class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num:nums2)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek() &lt; num)&#123; map.put(stack.pop(), num); &#125; stack.push(num); &#125; for(int i = 0;i&lt;nums1.length;i++)&#123; nums1[i]=map.getOrDefault(nums1[i],-1); &#125; return nums1; &#125;&#125; map + stackã€‚ 556. Next Greater Element III class Solution &#123; public int nextGreaterElement(int n) &#123; char[] number = (n+\"\").toCharArray(); int i,j; for (i = number.length-1; i &gt; 0; i--) if (number[i-1] &lt; number[i]) break;//ä»åå‘å‰éå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå·¦è¾¹å°äºå³è¾¹çš„indexã€‚ if (i == 0)//å¦‚æœæ²¡æœ‰ï¼Œä¹Ÿå°±æ˜¯æ•´ä¸ªåºåˆ—éƒ½æ˜¯é™åºï¼Œæœ¬èº«å°±æ˜¯æœ€å¤§å€¼äº†ã€‚ return -1; int x = number[i-1], smallest = i;// è®°ä½å°çš„æ•°å€¼ï¼Œè®°å½•å³è¾¹æ•°å€¼çš„indexã€‚ for (j = i+1; j &lt; number.length; j++)// åœ¨xåˆ°æœ€åä¸€ä½ä¹‹é—´ï¼Œå¯»æ‰¾å¤§äºxå€¼å¹¶ä¸”å°äºå³è¾¹å€¼çš„æœ€å°å€¼index if (number[j] &gt; x &amp;&amp; number[j] &lt;= number[smallest]) smallest = j; char temp = number[i-1];//å°†å·¦è¾¹çš„å°æ•°å€¼å’Œå³è¾¹éƒ¨åˆ†çš„æœ€å°å€¼äº’æ¢ã€‚ number[i-1] = number[smallest]; number[smallest] = temp; Arrays.sort(number, i, number.length);//å°†å‰©ä¸‹çš„å³è¾¹éƒ¨åˆ†sort long val = Long.parseLong(new String(number)); return (val &lt;= Integer.MAX_VALUE) ? (int) val : -1; &#125;&#125; æ€è·¯é™„åœ¨codeé‡Œã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 59 / Tree","slug":"leetcode59","date":"2019-11-14T19:14:36.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/14/leetcode59/","link":"","permalink":"WangHngLeee.github.io/2019/11/14/leetcode59/","excerpt":"Tree ç±»é¢˜æ¨¡ç‰ˆ å•tree ä¸¤ä¸ªtreeæ¯”è¾ƒ tree ä¸‰ç§ éå† 100. Same Tree class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null)return true; if(p == null || q == null)return false; boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right &amp;&amp; p.val == q.val; &#125;&#125; å•treeæ¨¡ç‰ˆã€‚","text":"Tree ç±»é¢˜æ¨¡ç‰ˆ å•tree ä¸¤ä¸ªtreeæ¯”è¾ƒ tree ä¸‰ç§ éå† 100. Same Tree class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null)return true; if(p == null || q == null)return false; boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right &amp;&amp; p.val == q.val; &#125;&#125; å•treeæ¨¡ç‰ˆã€‚ 101. Symmetric Tree class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return root == null || help(root.left,root.right); &#125; private boolean help(TreeNode node1, TreeNode node2)&#123; if(node1 == null &amp;&amp; node2 == null)return true; if(node1 == null || node2 == null)return false; boolean left = help(node1.left,node2.right); boolean right = help(node1.right,node2.left); return left&amp;&amp;right&amp;&amp;node1.val == node2.val; &#125;&#125; åŒtreeã€‚ç”±äºé¢˜ç›®ç»™å®šå•functioné‡Œåªæœ‰ä¸€ä¸ªtreeï¼Œè¦å•ç‹¬å†™ä¸€ä¸ªprivateã€‚ 951. Flip Equivalent Binary Trees class Solution &#123; public boolean flipEquiv(TreeNode root1, TreeNode root2) &#123; if(root1 == null &amp;&amp; root2 == null)return true; if(root1 == null || root2 == null)return false; boolean left1 = flipEquiv(root1.left,root2.left);//no change boolean left2 = flipEquiv(root1.left,root2.right); // flipped boolean right1 = flipEquiv(root1.right,root2.right); // no change boolean right2 = flipEquiv(root1.right,root2.left); // flipped return root1.val == root2.val &amp;&amp;( ( left1 &amp;&amp; right1) || (left2 &amp;&amp; right2) );// we have to make sure the correct left and right part is unchanged or flipped. &#125;&#125; åŒtreeã€‚è¦è€ƒè™‘å››ç§æƒ…å†µã€‚ left ï¼š change or flipped ã€‚rightä¸€æ ·ã€‚ 572. Subtree of Another Tree class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s==null)return false; return isSame(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t); &#125; private boolean isSame(TreeNode s, TreeNode t)&#123; if(s == null &amp;&amp; t == null)return true; if(s==null || t==null)return false; if(s.val!=t.val)return false; return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); &#125;&#125; å’Œ100 same tree ä¸€æ ·çš„æ€è·¯ã€‚åªä¸è¿‡subtreeä¸€æ ·ä¹Ÿå¯ä»¥ã€‚æ‰€ä»¥main é‡Œreturnä¸­æœ‰è€ƒè™‘left / right subtree ä¸€æ ·å•æƒ…å†µã€‚ 545. Boundary of Binary Tree class solutoin&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; if(root == null)return res; res.add(root.val); left(root.left); leaves(root.left); leaves(root.right); right(root.right); return res; &#125; public void left(TreeNode root)&#123; if(root == null || root.left == null &amp;&amp; root.right == null)return; res.add(root.val); if(root.left == null)left(root.right); else left(root.left); &#125; public void right(TreeNode root)&#123; if(root == null || root.left == null &amp;&amp; root.right == null)return; if(root.right == null)right(root.left); else right(root.right); res.add(root.val); &#125; public void leaves(TreeNode root)&#123; if(root == null)return; if(root.left == null &amp;&amp; root.right == null)res.add(root.val); leaves(root.left); leaves(root.right); &#125;&#125; å·¦è¾¹ç•Œ - å·¦å¶å­ - å³å¶å­ - å³è¾¹ç•Œã€‚ æ³¨æ„å·¦å³add rootçš„æ—¶æœºä¸åŒã€‚å·¦è¾¹å…ˆaddå†é€’å½’ã€‚å³è¾¹æ˜¯å…ˆé€’å½’å†addã€‚ æ³¨æ„ä¸‰ç§æƒ…å†µçš„å‡½æ•°å†™æ³•ã€‚left /leaves /right 103. Binary Tree Zigzag Level Order Traversal class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null)return res; queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int size = queue.size(); for(int i = 0;i&lt;size;i++)&#123; TreeNode cur = queue.poll(); if(zig)&#123; temp.add(0,cur.val); &#125; else&#123; temp.add(cur.val); &#125; if(cur.left!=null)queue.offer(cur.left); if(cur.right!=null)queue.offer(cur.right); &#125; res.add(temp); zig = !zig; &#125; return res; &#125;&#125; ç”¨zigæ¥æ ‡è®°è¯¥è¡Œæ˜¯å¦zigè¾“å‡ºã€‚å¦‚æœæ˜¯zigçš„ä¸€è¡Œï¼Œåˆ™å°†pollå‡ºæ¥çš„ add(0,temp)åˆ° tempçš„å¼€å¤´ã€‚å¦åˆ™çš„è¯å°±æŒ‰é¡ºåºaddåˆ°tempä¸­ã€‚æ¯ä¸ªteampå­˜çš„æ˜¯æ¯ä¸€è¡Œçš„å…ƒç´ ï¼Œæœ€åå°†tempåŠ å…¥resä¸­ã€‚ 124. Binary Tree Maximum Path Sum class Solution &#123; int max; public int maxPathSum(TreeNode root) &#123; max = Integer.MIN_VALUE; maxpath(root); return max; &#125; private int maxpath(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(maxpath(root.left),0); int right = Math.max(maxpath(root.right),0); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; trickyçš„åœ°æ–¹åœ¨äºï¼šmaxèµ‹å€¼é‚£é‡Œï¼Œmathé‡Œé¢çš„maxæ˜¯å·¦å³å­æ ‘éå†åçš„maxï¼Œè€Œå¤–é¢çš„maxè¿˜æ˜¯æœªæ›´æ–°çš„maxã€‚æ³¨æ„æœ€åreturnå·¦å³ä¸­æœ€å¤§çš„åŠ ä¸Šroot valï¼Œè¿”å›ç»™ä¸Šä¸€å±‚ç»§ç»­é€’å½’ã€‚ 653. Two Sum IV - Input is a BST class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); return dfs(root,set,k); &#125; private boolean dfs(TreeNode root, HashSet&lt;Integer&gt; set , int k)&#123; if(root == null)return false; if(set.contains(k-root.val))return true; set.add(root.val); return dfs(root.left,k) || dfs(root.right,k); &#125;&#125; two sum å˜ç§ã€‚ä¾æ—§ç”¨setå­˜ä¸‹å‡ºç°è¿‡çš„nodeå€¼ã€‚å¦‚æœsetä¸­æœ‰nodeæœ‰ç­‰äºk-root.valï¼Œåˆ™è¿”å›trueã€‚æ²¡æœ‰å°±ç»§ç»­å·¦å³é€’å½’ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"tree","slug":"tree","permalink":"WangHngLeee.github.io/tags/tree/"}]},{"title":"Leetcode EveryDay 58","slug":"leetcode58","date":"2019-11-13T20:45:36.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/13/leetcode58/","link":"","permalink":"WangHngLeee.github.io/2019/11/13/leetcode58/","excerpt":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jå°±æ˜¯è®¡ç®—è¿›ä½ã€‚è€Œsum%10åˆ™æ˜¯è®¡ç®—åˆ¨é™¤è¿›ä½åéœ€è¦åŠ çš„æ•°ã€‚","text":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jå°±æ˜¯è®¡ç®—è¿›ä½ã€‚è€Œsum%10åˆ™æ˜¯è®¡ç®—åˆ¨é™¤è¿›ä½åéœ€è¦åŠ çš„æ•°ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 57","slug":"leetcode57","date":"2019-11-11T19:35:36.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/11/leetcode57/","link":"","permalink":"WangHngLeee.github.io/2019/11/11/leetcode57/","excerpt":"863. All Nodes Distance K in Binary Tree class Solution &#123; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); dfs(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)return 0; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; private void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.left,dist+1,K,res); &#125;&#125; findå°†åœ¨targetä¹‹ä¸Šçš„nodeå­˜å…¥mapã€‚åœ¨target subtreeé‡Œçš„ä¸èµ‹å€¼ã€‚ dfsä¸­ï¼Œå¦‚æœæ˜¯targetä¹‹ä¸Šçš„èŠ‚ç‚¹ï¼Œå°†distæ›´æ–°ä¸ºmapä¸­å­˜çš„åˆ°targetçš„è·ç¦»ï¼Œå†è¿›è¡Œdfs dist+1ã€‚ å¦‚æœæ˜¯targetçš„subtreeï¼Œåˆ™å¾ªç¯åˆ°targetè‡ªèº«æ—¶ï¼Œdistä¼šå˜ä¸º0ï¼Œç„¶ådfsæ›´æ–°ï¼Œå½“dist==kæ—¶ï¼Œè¯¥èŠ‚ç‚¹ä¹Ÿå°±æ˜¯è¦å­˜å…¥resçš„èŠ‚ç‚¹ã€‚","text":"863. All Nodes Distance K in Binary Tree class Solution &#123; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); dfs(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)return 0; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; private void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.left,dist+1,K,res); &#125;&#125; findå°†åœ¨targetä¹‹ä¸Šçš„nodeå­˜å…¥mapã€‚åœ¨target subtreeé‡Œçš„ä¸èµ‹å€¼ã€‚ dfsä¸­ï¼Œå¦‚æœæ˜¯targetä¹‹ä¸Šçš„èŠ‚ç‚¹ï¼Œå°†distæ›´æ–°ä¸ºmapä¸­å­˜çš„åˆ°targetçš„è·ç¦»ï¼Œå†è¿›è¡Œdfs dist+1ã€‚ å¦‚æœæ˜¯targetçš„subtreeï¼Œåˆ™å¾ªç¯åˆ°targetè‡ªèº«æ—¶ï¼Œdistä¼šå˜ä¸º0ï¼Œç„¶ådfsæ›´æ–°ï¼Œå½“dist==kæ—¶ï¼Œè¯¥èŠ‚ç‚¹ä¹Ÿå°±æ˜¯è¦å­˜å…¥resçš„èŠ‚ç‚¹ã€‚ 987. Vertical Order Traversal of a Binary Tree class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; list.add(map.get(i).get(j).node.val); &#125; res.add(list); &#125; return res; &#125;&#125; æ–°å»ºpair ç±»ï¼Œç”¨queueå­˜æ”¾æ‰€æœ‰æ ‘èŠ‚ç‚¹ï¼Œè®°å½•æ‰€æœ‰æ ‘èŠ‚ç‚¹xçš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä¹‹åéå†è¦ç”¨åˆ°ã€‚ map å­˜æ”¾xåæ ‡éƒ½ç›¸åŒçš„paiã€‚ç„¶åç”¨compare ä»å°åˆ°å¤§sortã€‚ ç„¶åé€šè¿‡xé¡ºåºéå†mapï¼Œå°†ç›¸åŒxçš„å€¼å­˜è¿›åŒä¸€ä¸ªlistï¼Œå†åŠ å…¥resä¸­ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 56","slug":"leetcode56","date":"2019-11-09T18:35:36.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/11/09/leetcode56/","link":"","permalink":"WangHngLeee.github.io/2019/11/09/leetcode56/","excerpt":"1130. Minimum Cost Tree From Leaf Values class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(arr == null)return 0; int res = 0; stack.push(Integer.MAX_VALUE); for(int a: arr)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek()&lt;= a)&#123; int mid = stack.pop(); res+= mid * Math.min(stack.peek(),a); &#125; stack.push(a); &#125; while(stack.size()&gt;2)&#123; res+=stack.pop()*stack.peek(); &#125; return res; &#125;&#125; å¾ˆä¸é”™çš„ä¸€é“stacké¢˜ã€‚å¦‚æœå½“å‰å¾…å­˜çš„æ•°å¤§äºå½“å‰stackå †é¡¶çš„æ•°ï¼Œåˆ™å°†å †é¡¶æ•°popå‡ºï¼Œpopä¹‹åçš„å †é¡¶æ•°å’Œå½“å‰å¾…å­˜aä¸­æœ€å¤§çš„æ•°ä¹˜ä»¥popçš„æ•°ã€‚ä¸€ç›´å¾ªç¯ç›´åˆ°å †é¡¶çš„å…ƒç´ å¤§äºå½“å‰å¾…å­˜æ•°å€¼ã€‚ trickyçš„åœ°æ–¹åœ¨äºï¼Œå½“æ‰€æœ‰å…ƒç´ éå†ä¸€è¾¹åï¼Œä¼šæ£€æŸ¥å½“å‰stackçš„å¤§å°ï¼Œå¦‚æœå¤§äº2ï¼Œç»§ç»­popå¹¶ä¸”ä¹˜ä»¥å½“å‰peekï¼Œç›´åˆ°&lt;2ã€‚è¿”å›resï¼›å› ä¸ºå¦‚æœstack size&lt;2 è¯´æ˜ç¬¬ä¸€è½®whileå¾ªç¯æ—¶ï¼Œæœ€åä¸€ä¸ªæ•°å€¼ä¼šå¤§äºå‰é¢æ‰€æœ‰çš„æ•°ï¼Œæ‰€ä»¥ä¼šä¸€ç›´popå¹¶ä¸”æ›´æ–°resã€‚","text":"1130. Minimum Cost Tree From Leaf Values class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(arr == null)return 0; int res = 0; stack.push(Integer.MAX_VALUE); for(int a: arr)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek()&lt;= a)&#123; int mid = stack.pop(); res+= mid * Math.min(stack.peek(),a); &#125; stack.push(a); &#125; while(stack.size()&gt;2)&#123; res+=stack.pop()*stack.peek(); &#125; return res; &#125;&#125; å¾ˆä¸é”™çš„ä¸€é“stacké¢˜ã€‚å¦‚æœå½“å‰å¾…å­˜çš„æ•°å¤§äºå½“å‰stackå †é¡¶çš„æ•°ï¼Œåˆ™å°†å †é¡¶æ•°popå‡ºï¼Œpopä¹‹åçš„å †é¡¶æ•°å’Œå½“å‰å¾…å­˜aä¸­æœ€å¤§çš„æ•°ä¹˜ä»¥popçš„æ•°ã€‚ä¸€ç›´å¾ªç¯ç›´åˆ°å †é¡¶çš„å…ƒç´ å¤§äºå½“å‰å¾…å­˜æ•°å€¼ã€‚ trickyçš„åœ°æ–¹åœ¨äºï¼Œå½“æ‰€æœ‰å…ƒç´ éå†ä¸€è¾¹åï¼Œä¼šæ£€æŸ¥å½“å‰stackçš„å¤§å°ï¼Œå¦‚æœå¤§äº2ï¼Œç»§ç»­popå¹¶ä¸”ä¹˜ä»¥å½“å‰peekï¼Œç›´åˆ°&lt;2ã€‚è¿”å›resï¼›å› ä¸ºå¦‚æœstack size&lt;2 è¯´æ˜ç¬¬ä¸€è½®whileå¾ªç¯æ—¶ï¼Œæœ€åä¸€ä¸ªæ•°å€¼ä¼šå¤§äºå‰é¢æ‰€æœ‰çš„æ•°ï¼Œæ‰€ä»¥ä¼šä¸€ç›´popå¹¶ä¸”æ›´æ–°resã€‚ 449. Serialize and Deserialize BST public class Codec &#123; private static final String SEP = \",\"; private static final String NULL = \"null\"; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); if (root == null) return NULL; //traverse it recursively if you want to, I am doing it iteratively here Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); st.push(root); while (!st.empty()) &#123; root = st.pop(); sb.append(root.val).append(SEP); if (root.right != null) st.push(root.right); if (root.left != null) st.push(root.left); &#125; return sb.toString(); &#125; public TreeNode deserialize(String data) &#123; if (data.equals(NULL)) return null; String[] strs = data.split(SEP); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (String e : strs) &#123; q.offer(Integer.parseInt(e)); &#125; return getNode(q); &#125; private TreeNode getNode(Queue&lt;Integer&gt; q) &#123; //q: 5,3,2,6,7 if (q.isEmpty()) return null; TreeNode root = new TreeNode(q.poll());//root (5) Queue&lt;Integer&gt; samllerQueue = new LinkedList&lt;&gt;(); while (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123; samllerQueue.offer(q.poll()); &#125; //smallerQueue : 3,2 storing elements smaller than 5 (root) root.left = getNode(samllerQueue); //q: 6,7 storing elements bigger than 5 (root) root.right = getNode(q); return root; &#125;&#125; stackå­˜å‚¨é¡ºåºä¸º root left left left ã€‚ã€‚ã€‚ right right right right å»ºbstæ—¶è¦åˆ†å¤§å°queueã€‚ä¿è¯leftçš„å€¼å…¨åœ¨smallqueueä¸­å–ã€‚rightçš„åœ¨å‡ºé™¤å»leftå€¼çš„qä¸­å–ã€‚ 593. Valid Square class solution&#123; public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4)&#123; int[] len = new int[]&#123;dist(p1,p2),dist(p1,p3),dist(p1,p4),dist(p2,p3),dist(p2,p4),dist(p3,p4)&#125;; int max = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i : len)&#123; max = Math.max(max,i); map.put(i,map.getOrDefault(i,0)+1); &#125; return map.size()==2&amp;&amp;map.get(max)==1; &#125; public int dist(int[]point1,int[]point2)&#123; return ((point2[0]-point[0])*()point2[0]-point[0]) + (point2[1]-point1[1])*(point2[1]-point1[1])); &#125;&#125; åˆ¤æ–­å››ä¸ªç‚¹æ˜¯å¦ä¸ºä¸€ä¸ªsquareã€‚ç”¨mapå­˜å„ä¸ªç‚¹ä¹‹é—´è·ç¦»ã€‚æœ€ååªè¦ä¿è¯mapç‚¹å¤§å°ä¸º2(è¾¹é•¿å’Œå¯¹è§’çº¿ä¸¤ç§é•¿åº¦)ï¼Œä¸”æœ€é•¿çš„(å¯¹è§’çº¿)æœ‰ä¸”åªæœ‰ä¸¤ä¸ªã€‚ 759. Employee Free Time class solution&#123; public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) &#123; List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); PriorityQueue&lt;Interval&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt; a.start-b.start); schedule.forEach(e -&gt; queue.addAll(e)); while(!queue.isEmpty())&#123; temp = queue.poll(); if(temp.end &lt; queue.peek().start)&#123; res.add(new Interval(temp.end,queue.peek().start)); temp = queue.poll(); &#125;else&#123; temp = temp.end &lt; queue.peek().end ? queue.peek() : temp; queue.poll(); &#125; &#125; return res; &#125;&#125; priorityqueue å­˜intervalã€‚pollä¹‹ååˆ¤æ–­å½“å‰endå’Œpeekçš„startå¤§å°å…³ç³»å³å¯ã€‚æ³¨æ„ä¸ç¬¦åˆresæ¡ä»¶åå…ˆè·Ÿpeekæ¯”ç„¶ååœ¨pollã€‚ç›´æ¥pollä¼šTLEã€‚ 1091. Shortest Path in Binary Matrix class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] dir = new int[][]&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;,&#123;1,1&#125;&#125;; if(grid[0][0]==1 || grid[m-1][n-1]==1) &#123; return -1; &#125; boolean[][] visited = new boolean[m][n]; visited[0][0] = true; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0,0&#125;); int ans=0; while (!queue.isEmpty()) &#123; int size = queue.size(); for(int i=0;i&lt;size;i++) &#123; int[] pop = queue.poll(); if(pop[0]==m-1 &amp;&amp; pop[1]==n-1) &#123; return ans+1; &#125; for (int[] d:dir) &#123; int nextX = d[0]+pop[0]; int nextY = d[1]+pop[1]; if(nextX&gt;=0 &amp;&amp; nextX&lt;m &amp;&amp; nextY&gt;=0 &amp;&amp; nextY&lt;n &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY]==0) &#123; queue.add(new int[]&#123;nextX,nextY&#125;); visited[nextX][nextY]=true; &#125; &#125; &#125; ans++; &#125; return -1; &#125;&#125; queue + dir{}ã€‚ æ³¨æ„å½“éå†åˆ°æœ€åä¸€ä¸ªçš„æ—¶å€™è¦è¿”å›ans+1ï¼›å› ä¸ºanså­˜çš„ç±»ä¼¼äºæ­¥éª¤æ¬¡æ•°ï¼Œå’Œä¹‹å‰åšçš„é¢˜ç±»ä¼¼ï¼Œä½†æ˜¯è¿™é“é¢˜æ˜¯è¿”å›çš„è·ç¦»ï¼Œæ‰€ä»¥è¦ç”¨æ¬¡æ•°+1.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 55","slug":"leetcode55","date":"2019-11-08T03:54:49.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/07/leetcode55/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode55/","excerpt":"503. Next Greater Element II class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] next = new int[n] Arrays.fill(next,-1); for(int i=0;i&lt; n*2 ;i++)&#123; int num = nums[i%n]; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)&#123; next[stack.pop()] = num; &#125; if(i&lt;n)&#123; stack.push(i); &#125; &#125; return next; &#125;&#125; ç”¨stackå­˜åŸnumsé‡Œå…ƒç´ çš„indexã€‚æ–°å»ºä¸€ä¸ªç­‰å¤§çš„nextå­˜æ”¾ç»“æœã€‚ å…¨éƒ¨åˆå§‹ä¸º-1.è¿›è¡Œn*2æ¬¡éå†ï¼Œä¿è¯åŸnumsä¸­æœ€åçš„å…ƒç´ ä¹Ÿèƒ½æ‰¾åˆ°circleä¸­çš„maxã€‚ å¦‚æœstack peek()çš„indexå¯¹åº”çš„numsé‡Œçš„å…ƒç´ å°äºå½“å‰çš„numæ—¶ï¼Œè¡¨æ˜indexå¯¹åº”çš„å…ƒç´ ä¸‹ä¸€ä¸ªæœ€å¤§å€¼å°±æ˜¯å½“å‰çš„numã€‚å°†numèµ‹ç»™ next[stack.pop()]ã€‚å¦‚æœæ²¡æœ‰æœ€å¤§å€¼çš„ä½ç½®æ°¸è¿œæ˜¯-1ã€‚","text":"503. Next Greater Element II class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] next = new int[n] Arrays.fill(next,-1); for(int i=0;i&lt; n*2 ;i++)&#123; int num = nums[i%n]; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)&#123; next[stack.pop()] = num; &#125; if(i&lt;n)&#123; stack.push(i); &#125; &#125; return next; &#125;&#125; ç”¨stackå­˜åŸnumsé‡Œå…ƒç´ çš„indexã€‚æ–°å»ºä¸€ä¸ªç­‰å¤§çš„nextå­˜æ”¾ç»“æœã€‚ å…¨éƒ¨åˆå§‹ä¸º-1.è¿›è¡Œn*2æ¬¡éå†ï¼Œä¿è¯åŸnumsä¸­æœ€åçš„å…ƒç´ ä¹Ÿèƒ½æ‰¾åˆ°circleä¸­çš„maxã€‚ å¦‚æœstack peek()çš„indexå¯¹åº”çš„numsé‡Œçš„å…ƒç´ å°äºå½“å‰çš„numæ—¶ï¼Œè¡¨æ˜indexå¯¹åº”çš„å…ƒç´ ä¸‹ä¸€ä¸ªæœ€å¤§å€¼å°±æ˜¯å½“å‰çš„numã€‚å°†numèµ‹ç»™ next[stack.pop()]ã€‚å¦‚æœæ²¡æœ‰æœ€å¤§å€¼çš„ä½ç½®æ°¸è¿œæ˜¯-1ã€‚ ç±»ä¼¼çš„é¢˜ç›® 496. Next Greater Element I class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i = 0 ; i &lt; nums2.length;i++)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i])&#123; map.put(stack.pop(),nums2[i]); &#125; stack.push(nums2[i]); &#125; for(int i = 0 ; i &lt; nums1.length;i++)&#123; num1[i] = map.getOrDefault(nums1[i],-1); &#125; return nums1; &#125;&#125; ä¸€æ ·çš„æ€è·¯ï¼Œåªä¸è¿‡è¿™é“é¢˜ç›´æ¥å­˜çš„æ˜¯å…ƒç´ æœ¬èº«ï¼Œå› ä¸ºæ²¡æœ‰circleçš„è¦æ±‚ã€‚ç”¨mapå­˜ä½nums2é‡Œå…ƒç´ å’Œnext greaterçš„key-valueã€‚æœ€åå¯¹nums1è¿›è¡Œæ›´æ–°ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 54","slug":"leetcode54","date":"2019-11-07T19:54:49.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/11/07/leetcode54/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode54/","excerpt":"ç¬¬äºŒé 80. Remove Duplicates from Sorted Array II class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 2 || num &gt; nums[index-2])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; é€»è¾‘ä¸éš¾ã€‚ç•™å‡ºä¸¤ä¸ªä½ç½®ï¼Œå› ä¸ºé¢˜ç›®è¦æ±‚æœ€å¤šæœ‰ä¸¤ä¸ªé‡å¤å…ƒç´ ã€‚åªè¦å½“å‰numå’Œnums[index-2]å³å¯ã€‚å°†å½“å‰numå­˜å…¥indexçš„ä½ç½®ã€‚","text":"ç¬¬äºŒé 80. Remove Duplicates from Sorted Array II class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 2 || num &gt; nums[index-2])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; é€»è¾‘ä¸éš¾ã€‚ç•™å‡ºä¸¤ä¸ªä½ç½®ï¼Œå› ä¸ºé¢˜ç›®è¦æ±‚æœ€å¤šæœ‰ä¸¤ä¸ªé‡å¤å…ƒç´ ã€‚åªè¦å½“å‰numå’Œnums[index-2]å³å¯ã€‚å°†å½“å‰numå­˜å…¥indexçš„ä½ç½®ã€‚ ç›¸åŒçš„é€»è¾‘å¥—è·¯ã€‚ 26. Remove Duplicates from Sorted Array class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 1 || num &gt; nums[index-1])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; ä¸€æ ·çš„å¥—è·¯ã€‚è¿™é“é¢˜å…è®¸é‡å¤çš„ä¸ªæ•°åªæœ‰ä¸€ä¸ªã€‚ 442. Find All Duplicates in an Array class solution&#123; public List&lt;Integer&gt; findDuplicates(int[] nums)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++)&#123; int index = Math.abs(nums[i]) - 1; if(nums[index] &lt; 0)&#123; res.add(Math.abs(index + 1)); &#125; nums[index] = -nums[index]; &#125; return res; &#125;&#125; å°†numå¯¹åº”çš„indexå˜ä¸ºè´Ÿæ•°ï¼Œå¦‚æœéå†ä¸­é‡åˆ°äº†è‡ªå·±å¯¹åº”çš„indexå·²ç»ä¸ºè´Ÿï¼Œè¯´æ˜å·²ç»å‡ºç°è¿‡äº†ï¼Œå­˜å…¥resã€‚ 5. Longest Palindromic Substring class Solution &#123; private int start, dist; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)return s; for(int i = 0;i&lt;s.length();i++)&#123; valid(s,i,i); valid(s,i,i+1); &#125; return s.substring(start,start+dist); &#125; private void valid(String s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j))&#123; j++; i--; &#125; if(dist &lt; j-i-1)&#123; dist = j-i-1; start = i+1; &#125; &#125;&#125; ç¬¬ä¸‰éé‡åˆ°ã€‚è¿˜æ˜¯è¦æ³¨æ„ä¸¤ç§å¯¹ç§°æƒ…å†µã€‚121or1221ã€‚ 937. Reorder Data in Log Files Example 1: Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;] class Solution &#123; public String[] reorderLogFiles(String[] logs) &#123; Arrays.sort(logs,(s1,s2)-&gt;&#123; String[] split1 = s1.split(\" \",2); String[] split2 = s2.split(\" \",2); boolean isdigit1 = Character.isDigit(split1[1].charAt(0)); boolean isdigit2 = Character.isDigit(split2[1].charAt(0)); if(!isdigit1 &amp;&amp; !isdigit2)&#123; int compare_value = split1[1].compareTo(split2[1]); if(compare_value==0)&#123; return split1[0].compareTo(split2[0]); &#125; else return compare_value; &#125; else if(isdigit1 &amp;&amp; isdigit2)&#123; return 0; &#125; else if(isdigit1 &amp;&amp; !isdigit2)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;); return logs; &#125;&#125; çº¯ç²¹çš„stringæ“ä½œçŸ¥è¯†ç‚¹ã€‚ é¦–å…ˆåˆ¤æ–­ç¬¬äºŒä½æ˜¯æ•°å­—è¿˜æ˜¯å­—ç¬¦ï¼Œæ•°å­—é åæ”¾ï¼Œå­—ç¬¦å¾€å‰æã€‚è‡ªå®šä¹‰sorté¡ºåºï¼Œå½“isdigit1/2 å‡ä¸ºæ•°å­—æ—¶ï¼Œä¿æŒåŸé¡ºåºï¼Œä¼˜å…ˆåº¦ä¸º0ï¼›1ä¸ºdigit2ä¸æ˜¯ï¼Œä¼˜å…ˆåº¦æœ€ä½ï¼Œä¸º1ï¼Œ1ä¸æ˜¯digit 2æ˜¯digitï¼Œä¼˜å…ˆåº¦æœ€é«˜ï¼Œä¸º-1ï¼› å½“éƒ½ä¸æ˜¯digitæ—¶ï¼Œå¯¹ä¸¤è€…å¯¹å­—ç¬¦å¤§å°åˆ¤æ–­ï¼ŒcompareToå¦‚æœä¸º0ï¼Œè¯´æ˜ç¬¬äºŒä½å¼€å¤´å­—æ¯ä¹Ÿä¸€æ ·ã€‚é‚£å°±å¯¹ç¬¬ä¸€éƒ¨åˆ†å¯¹stringè¿›è¡Œå¤§å°æ’åºã€‚ 60. Permutation Sequence class solution&#123; public String getPermutation(int n, int k) &#123; StringBuilder sb = new StringBuilder&lt;&gt;(); List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; int sum = 1; for(int i = 1;i&lt;=n;i++)&#123; sum*=i; factorial[i] = sum; numbers.add(i); &#125; k=k-1; for(int i = 1; i &lt;= n;i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers[index])); numbers.remove(index); k = k-index*factorial[n-i]; &#125; return String.valueOf(sb); &#125;&#125; é¦–å…ˆå»ºç«‹factorialå’Œnumbersï¼Œå­˜ä½nçš„é˜¶ä¹˜å€¼å’Œæ‰€æœ‰çš„numberã€‚æ‰€æœ‰çš„ç»“æœåº”è¯¥æŒ‰å„è‡ªä¸ºå¼€å¤´æ’åˆ—ã€‚åªæœ‰1çš„å…¨éƒ¨éå†å®Œäº†æ‰ä¼šåˆ°2å¼€å¤´ã€‚ã€‚ã€‚ å½“å‰ç¬¬kä¸ªç»“æœçš„ç¬¬ä¸€ä¸ªæ•°å­—åœ¨numbersé‡Œçš„indexå¯ä»¥ç”¨index = k/factorial[n-i]æ¥è®¡ç®—ã€‚ n-iæ˜¯é™¤å»å¼€å¤´æ•°å­—å‰©ä¸‹æ‰€æœ‰æƒ…å†µï¼Œkåˆ™æ˜¯è¦æ±‚çš„ä½ç½®ã€‚k/factorial[n-i]åˆ™å¯ä»¥æ‰¾å‡ºå¼€å¤´æ•°å­—çš„ä½ç½®ã€‚ç„¶åå»numbersç”¨indexæ±‚å‡ºå¼€å¤´æ•°å­—ã€‚æœ€åè¦æ›´æ–°kï¼Œå› ä¸ºå¼€å¤´æ•°å­—æ‰¾åˆ°äº†ä»¥åï¼Œå†æ±‚ä¹‹åçš„æ•°å­—æ—¶ï¼Œè¦ç”¨kå‡å»ç¬¬ä¸€ä¸ªæ•°å­—æ‰€åœ¨çš„è½®æ¬¡ï¼Œç„¶åä»¥æ­¤ç±»æ¨å³å¯ã€‚ 71. Simplify Path class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); Set&lt;String&gt; banset = new HashSet&lt;&gt;(); for(String str : path.split(\"/\"))&#123; if(str.equals\"..\" &amp;&amp; !deque.isEmpty())deque.pop(); else if(!banset.contains(str))deque.push(str); &#125; String res = \"\"; while(!deque.isEmpty())&#123; res = \"/\" + deque.pop() + res; &#125; return res.isEmptuy() ? \"/\" : res; &#125;&#125; dequeLILOï¼Œé‡åˆ°â€¦ä¸”dequeä¸­æœ‰å…ƒç´ åˆ™popã€‚ 675. Cut Off Trees for Golf Event (hard) æ€è·¯ä¾æ—§Priority + bfs + æ“ä½œæ–¹å‘é›†{} class solution&#123; static int[] dir&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; PriorityQueue&lt;int[]&gt; pq = new LinkedList&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(), n=forest.get(0).size(); if(forest == null || forest.size() == 0)return 0; for(int i = 0;i&lt;m ;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;); &#125; &#125; &#125; int[] start = new int[2]; int sum = 0; while(!pq.isEmpty())&#123; int[] tree = pq.poll(); int step = getstep(forest,tree,start,m,n); if(step&lt;0)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; private int getstep(List&lt;List&lt;Integer&gt;&gt; forest, int[] tree, int[]start, int m, int n)&#123; int step = 0; boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i &lt; size;i++)&#123; int[] curr = queue.poll(); if(curr[0] == tree[0] &amp;&amp; curr[1] == tree[1])return step; for(int[] d : dir)&#123; int nr = curr[0] + d[0]; int nc = curr[1] + d[1]; if(nr &lt; 0 || nr &gt; m || nc &lt;0 || nc &gt;n || forest.get(nr).get(nc) == 0 || seen[nr][nc])continue; queue.add(new int[]&#123;nr,nc&#125;); seen[nr][nc] = true; &#125; &#125; step++; &#125; return -1; &#125;&#125; ç”¨priorityqueueæŒ‰å°åˆ°å¤§å°†treeå­˜ä¸‹ã€‚ç„¶åä»å°åˆ°å¤§pollå‡ºï¼Œè¿›è¡Œdfsã€‚åŸºæœ¬çš„priority + æ“ä½œ{} çš„dfsã€‚æ¡†æ¶è¦ç†Ÿè®°ã€‚ startç»™å®šä»0ï¼Œ0å¼€å§‹ï¼Œå½“dsfè¿‡åè®°å¾—å°†startæ›´æ–°ä¸ºç¬¬ä¸€ä¸ªtreeçš„åæ ‡:tree[0],tree[1].","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 53","slug":"leetcode53","date":"2019-11-07T05:34:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/07/leetcode53/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode53/","excerpt":"äºšéº» VO é¢ç» å‡†å¤‡ 560. Subarray Sum Equals K two pointer sliding window + æš´åŠ›è§£ class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; if(nums == null || nums.length == 0)return 0; for(int i=0;i&lt;nums.length ;i++)&#123; sum=nums[i]; if(sum == k)count++; for(int j = i+1;j&lt;nums.length ; j++)&#123; sum+=num[j]; if(sum == k)count++; &#125; &#125; return count; &#125;&#125; æš´åŠ›è§£ï¼Œä¸¤ä¸ªæŒ‡é’ˆï¼Œæ—¶é—´å¤æ‚åº¦o(næ–¹)ã€‚ç©ºé—´å¤æ‚åº¦o(1)","text":"äºšéº» VO é¢ç» å‡†å¤‡ 560. Subarray Sum Equals K two pointer sliding window + æš´åŠ›è§£ class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; if(nums == null || nums.length == 0)return 0; for(int i=0;i&lt;nums.length ;i++)&#123; sum=nums[i]; if(sum == k)count++; for(int j = i+1;j&lt;nums.length ; j++)&#123; sum+=num[j]; if(sum == k)count++; &#125; &#125; return count; &#125;&#125; æš´åŠ›è§£ï¼Œä¸¤ä¸ªæŒ‡é’ˆï¼Œæ—¶é—´å¤æ‚åº¦o(næ–¹)ã€‚ç©ºé—´å¤æ‚åº¦o(1) Presum + HashMap class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; Map&lt;Integer,Integer&gt; presum = new HashMap&lt;&gt;(); presum.put(0,1); for(num : nums)&#123; sum+=num; if(presum.containsKey(sum-k))&#123; count+= presum.get(sum-k); &#125; presum.put(sum,presum.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; æ€è·¯ä¸»è¦æ˜¯é€šè¿‡ SUM[i, j] = SUM[0, j]-SUM[0, i - 1] å¾—æ¥ã€‚ ç›¸å½“äºä»ç¬¬ä¸€ä½åˆ°æœ€åä¸€ä½æ‰€æœ‰çš„sumå­˜å…¥mapã€‚å¦‚æœmapå†å²ä¸­çš„æŸä¸ªsumæ­£å¥½ç­‰äºå½“å‰çš„sum - kï¼Œè¡¨æ˜ä¹‹å‰sumæˆªæ­¢çš„idxåˆ°å½“å‰åˆ°sumæˆªæ­¢idxä¸­é—´çš„å…ƒç´ å’Œæ­£å¥½ä¸ºkã€‚æ‰€ä»¥countåŠ ä¸€ã€‚ we know the key to solve this problem is SUM[i, j]. So if we know SUM[0, i - 1] and SUM[0, j], then we can easily get SUM[i, j]. To achieve this, we just need to go through the array, calculate the current sum and save number of all seen PreSum to a HashMap. Time complexity O(n), Space complexity O(n). sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmap-key --&gt; hashmap-key = sum - k","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 52","slug":"leetcode52","date":"2019-11-07T01:34:09.000Z","updated":"2020-02-03T01:16:22.110Z","comments":true,"path":"2019/11/06/leetcode52/","link":"","permalink":"WangHngLeee.github.io/2019/11/06/leetcode52/","excerpt":"ç¬¬äºŒé 98. Validate Binary Search Tree stack è§£æ³• class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return null Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); if(root !=null &amp;&amp; root.val &lt;= pre.val)return false; pre = root; root = root.right; &#125; return true; &#125;&#125;","text":"ç¬¬äºŒé 98. Validate Binary Search Tree stack è§£æ³• class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return null Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); if(root !=null &amp;&amp; root.val &lt;= pre.val)return false; pre = root; root = root.right; &#125; return true; &#125;&#125; åˆ¤æ–­BSTæ˜¯å¦åˆç†ï¼Œåˆ©ç”¨stackå®ç°in orderçš„æ“ä½œã€‚å·¦-æ ¹-å³çš„é¡ºåºå­˜å…¥stackï¼Œåˆ¤æ–­preå’Œrootçš„å€¼å¤§å°ã€‚å·¦æ”¯å°±æ˜¯ä¸‹-ä¸Šï¼Œpreåœ¨rootä¸‹é¢ï¼›å³æ”¯æ˜¯preåœ¨rootä¸Šé¢ã€‚ recursive è§£æ³• (in-order-traverslå®ç°ï¼Œå…ˆé€’å½’leftï¼Œå†è®¿é—®rootï¼Œå†é€’å½’right) class solution&#123; private boolean valid = true; private TreeNode pre = null; public boolean isValidBST(TReeNode root)&#123; test(root); return valid; &#125; private void test(TreeNode root)&#123; if(root == null)return; test(root.left); if(pre!=null &amp;&amp; root.val &lt;= pre.val)&#123; valid = false; return; &#125; pre = root; test(root.right); &#125;&#125; 101. Symmetric Tree iterativeè§£æ³• class solution&#123; public boolean symmetric(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null)return true; stack.push(root.left); stack.push(root.right); while(!stack.isEmpty())&#123; TreeNode tree1 = stack.pop(), tree2=stack.pop(); if(tree1 == null &amp;&amp; tree2 == null)continue; if(tree1 == null || tree2 == null || tree1.val !=tree2.val)return false; stack.push(tree1.left); stack.push(tree2.right); stack.push(tree1.right); stack.push(tree2.left); &#125; return true; &#125;&#125; iterativeã€‚è®°å¾—æŠŠtree node å¯¹ç§°åœ°pushè¿›stackã€‚ recursiveè§£æ³• class solution&#123; public boolean isSymmetric(TreeNode root) &#123; return root == null || test(root.left,root.right); &#125; private boolean test(TreeNode node1, TreeNode node2)&#123; if(node1 == null || node2 == null)return node1 == node2; if(node1.val != node2.val)return false; return test(node1.left,node2.right) %% test(node1.right,node2.left); &#125;&#125; æ³¨æ„æœ€ååŒæ—¶æ£€æŸ¥å¯¹ç§°ã€‚ node1æˆ–è€…node2æœ‰ä¸€ä¸ªä¸ºnullæ—¶ç›´æ¥è¿”å›node1==node2å³å¯ã€‚ç®€æ´ã€‚ 94. Binary Tree Inorder Traversal Iterative è§£æ³• class solution&#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); res.add(root); root=root.right; &#125; return res; &#125;&#125; in-order å°†èŠ‚ç‚¹åŠ å…¥resã€‚è®°ä½stackæ–¹æ³•çš„æ¡†æ¶ã€‚ 102. Binary Tree Level Order Traversal Iterative æ–¹æ³• class solution&#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist= new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; size; i ++)&#123; TreeNode cur = queue.poll(); if(cur.left!=null)queue.add(cur.left); if(cur.right!=null)queue.add(cur.right); templist.add(cur.val); &#125; res.add(templist); &#125; return res; &#125;&#125; Queueè‡ªä¸Šè€Œä¸‹å­˜èŠ‚ç‚¹ã€‚sizeä¸ºå½“å‰è¿™ä¸€è¡Œçš„å…ƒç´ ä¸ªæ•°ï¼Œéå†sizeéï¼Œå°†æ¯ä¸ªèŠ‚ç‚¹å·¦å³å­©å­åŠ å…¥queueåï¼Œå†å°†å…¶æœ¬èº«åŠ å…¥templistã€‚éå†ç»“æŸåŠ å…¥resã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 51","slug":"leetcode51","date":"2019-11-06T19:34:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/06/leetcode51/","link":"","permalink":"WangHngLeee.github.io/2019/11/06/leetcode51/","excerpt":"Tree Problems 1104. Path In Zigzag Labelled Binary Tree class Solution &#123; public List&lt;Integer&gt; pathInZigZagTree(int label) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;()l int parent = label; res.addFirst(parent); while(parent!=1)&#123; int depth = (int)Math.log(parent)/Math.log(2); int remains = (int)Math.pow(2,depth+!)-parent-1; partne = (int)(Math.pow(2,depth) + reamins)/2; res.addFirst(parent); &#125; return res; &#125;&#125; è‡ªä¸‹è€Œä¸Šã€‚åœ¨é¡ºåºé¢ å€’çš„ä¸€è¡Œæ—¶ï¼Œå…ˆè®¡ç®—å‡ºæ·±åº¦ï¼Œå†ç”±æ·±åº¦è®¡ç®—å‡ºå½“å‰labelè·ç¦»è¯¥è¡Œæœ€å¤§å€¼çš„è·ç¦»remainsï¼Œç„¶åé€šè¿‡æ­£å¸¸é¡ºåºè®¡ç®—å‡ºå¯¹åº”çš„parentã€‚å¹¶ä¸”addFirståˆ°resä¸­ã€‚","text":"Tree Problems 1104. Path In Zigzag Labelled Binary Tree class Solution &#123; public List&lt;Integer&gt; pathInZigZagTree(int label) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;()l int parent = label; res.addFirst(parent); while(parent!=1)&#123; int depth = (int)Math.log(parent)/Math.log(2); int remains = (int)Math.pow(2,depth+!)-parent-1; partne = (int)(Math.pow(2,depth) + reamins)/2; res.addFirst(parent); &#125; return res; &#125;&#125; è‡ªä¸‹è€Œä¸Šã€‚åœ¨é¡ºåºé¢ å€’çš„ä¸€è¡Œæ—¶ï¼Œå…ˆè®¡ç®—å‡ºæ·±åº¦ï¼Œå†ç”±æ·±åº¦è®¡ç®—å‡ºå½“å‰labelè·ç¦»è¯¥è¡Œæœ€å¤§å€¼çš„è·ç¦»remainsï¼Œç„¶åé€šè¿‡æ­£å¸¸é¡ºåºè®¡ç®—å‡ºå¯¹åº”çš„parentã€‚å¹¶ä¸”addFirståˆ°resä¸­ã€‚ 366. Find Leaves of Binary Tree class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); getheight(root,res); return res; &#125; private int getheight(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)&#123; jf(root == null) return -1; int level = 1 + Math.max(getheight(root.left,res), getheight(root.right,res)); if(res.size() &lt; level +1)res.add(new ArrayList&lt;&gt;()); res.get(level).add(root); return level; &#125;&#125; recursiveã€‚ å¾—åˆ°æ¯ä¸€å±‚è·ç¦»å¶èŠ‚ç‚¹çš„æœ€å¤§è·ç¦»levelï¼Œå¶èŠ‚ç‚¹levelä¸º0ï¼Œå­˜åœ¨res[0]ï¼Œè‡ªä¸‹è€Œä¸Šrecursiveã€‚å°†æ¯ä¸ªlevelçš„èŠ‚ç‚¹å­˜å…¥resã€‚ 897. Increasing Order Search Tree class Solution &#123; public TreeNode increasingBST(TreeNode root) &#123; return increase(root,null); &#125; public TreeNode increase(TreeNode root, TreeNode tail)&#123; if(root == null)return tail; TreeNode res = increase(root.left,root); root.left = null; root.right = increase(root.right,tail); return res; &#125;&#125; tailè®°å½•æœ€ç»ˆç»“æœé‡Œrootçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚leftåˆ†æ”¯ä¸­ï¼Œroot.leftçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯rootçˆ¶èŠ‚ç‚¹ã€‚å¹¶ä¸”å°†root.left è®¾ä¸ºnullã€‚å³åˆ†æ”¯åœ¨recursiveæ—¶ï¼Œåœ¨resèµ‹å€¼ä¸­ï¼Œå°†å½“å‰rootå½“ä½œä¸‹ä¸€èŠ‚ç‚¹å­˜å…¥resã€‚ 1123. Lowest Common Ancestor of Deepest Leaves class Solution &#123; TreeNode lca; int deepest = 0; public TreeNode lcaDeepestLeaves(TreeNode root) &#123; deep(root,0); return lca; &#125; private int deep(TreeNode root, int depth)&#123; deepest = Math.max(deepest,depth); if(root == null)return depth; int left = deep(root.left,depth+1); int right = deep(root.right,depth+1); if(left == deepest &amp;&amp; right == deepest)&#123; lcn = root; &#125; return Math.max(left,right); &#125;&#125; åªè¦å½“æŸä¸ªrootçš„left å’Œ right æ·±åº¦éƒ½ä¸ºdeepestæ—¶ ï¼Œè¯´æ˜è¯¥ä½ç½®çš„subtreeå¯¹ç§°æ·±åº¦ç›¸åŒã€‚é‚£ä¹ˆç›´æ¥è¿”å°†å½“å‰çš„rootèµ‹å€¼ç»™lcnã€‚ 1110. Delete Nodes And Return Forest class Solution &#123; public List&lt;TreeNode&gt; delNodes(TreeNode root, int[] to_delete) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); for(int i: to_delete)&#123; set.add(i); &#125; if(!set.contains(root))&#123; res.add(root); &#125; bfs(root,set,res); return res; &#125; private TreeNode dfs(TreeNode root, Set&lt;Integer&gt; set, List&lt;TreeNode&gt; res)&#123; if(root == null)return null; root.left = dfs(root.left,set,res); root.right = dfs(root.right,set, res); if(set.contains(root))&#123; if(root.left!-null)res.add(root.left); if(root.left!=null)res.add(root.right); return null; &#125; return root; &#125;&#125; dfs recursiveã€‚å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨deleteåå•é‡Œï¼Œçœ‹å®ƒå·¦å³èŠ‚ç‚¹æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœæœ‰ä¸ä¸ºnullçš„å°†å…¶å­èŠ‚ç‚¹å­˜å…¥resã€‚å¦‚æœéƒ½ä¸ºnullåˆ™å½»åº•åˆ é™¤è¯¥èŠ‚ç‚¹ï¼Œè¿”å›nullã€‚ å¦‚æœä¸å«è¯¥èŠ‚ç‚¹ï¼Œåˆ™è¿”å›è¯¥èŠ‚ç‚¹ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 50","slug":"leetcode50","date":"2019-11-06T00:34:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/05/leetcode50/","link":"","permalink":"WangHngLeee.github.io/2019/11/05/leetcode50/","excerpt":"866. Prime Palindrome class solution&#123; public int primePalindrome(int N) &#123; if( 8 &lt;= N &amp;&amp; N &lt;= 11)return 11; for(int x = 1; x &lt; 100000; x++)&#123; String s = Integer.toString(x); String news = new StringBuilder(s).reverse().toString(); int y = Integer.parseInt(s + news.substring(1)); if( y &gt;=N &amp;&amp; isPrime(y))return y; &#125; return -1; &#125; private boolean isPrime(int y)&#123; if(y &lt; 2 || y%2 == 0)return y==2; for(int i =3; i*i&lt;=y;i+=2)&#123; if(y%i == 0)return false; &#125; return true; &#125;&#125; æ€è·¯å¾ˆç®€å•ï¼Œåªéœ€è¦è€ƒè™‘å¥‡æ•°ä½çš„stringå°±å¯ä»¥äº†ã€‚æ³¨æ„æ„å»ºpalidromçš„æ–¹æ³•ã€‚reverseä¹‹åå–ç¬¬äºŒä¸ªä½ç½®åˆ°æœ€åï¼ŒåŠ åˆ°sä¸­ã€‚ è¿˜æœ‰è¦æ³¨æ„ç´ æ•°åˆ°åˆ¤æ–­ã€‚æœ€å¥½å…¨è®°ä½ã€‚","text":"866. Prime Palindrome class solution&#123; public int primePalindrome(int N) &#123; if( 8 &lt;= N &amp;&amp; N &lt;= 11)return 11; for(int x = 1; x &lt; 100000; x++)&#123; String s = Integer.toString(x); String news = new StringBuilder(s).reverse().toString(); int y = Integer.parseInt(s + news.substring(1)); if( y &gt;=N &amp;&amp; isPrime(y))return y; &#125; return -1; &#125; private boolean isPrime(int y)&#123; if(y &lt; 2 || y%2 == 0)return y==2; for(int i =3; i*i&lt;=y;i+=2)&#123; if(y%i == 0)return false; &#125; return true; &#125;&#125; æ€è·¯å¾ˆç®€å•ï¼Œåªéœ€è¦è€ƒè™‘å¥‡æ•°ä½çš„stringå°±å¯ä»¥äº†ã€‚æ³¨æ„æ„å»ºpalidromçš„æ–¹æ³•ã€‚reverseä¹‹åå–ç¬¬äºŒä¸ªä½ç½®åˆ°æœ€åï¼ŒåŠ åˆ°sä¸­ã€‚ è¿˜æœ‰è¦æ³¨æ„ç´ æ•°åˆ°åˆ¤æ–­ã€‚æœ€å¥½å…¨è®°ä½ã€‚ 456. 132 Pattern class solution &#123; public boolean find132pattern(int[] nums) &#123; int two = Integer.MIN_VALUE; int index = nums.length; for (int i=nums.length-1; i&gt;=0; i--) &#123; if (nums[i] &lt; two) return true; while (index &lt; nums.length &amp;&amp; nums[i] &gt; nums[index]) &#123; two = nums[index++]; &#125; index--; nums[index] = nums[i]; &#125; return false; &#125;&#125; ç”¨twoæ¥å­˜å¤§å°ä¸ºç¬¬äºŒå¤§çš„æ•°å­—ï¼Œä½†æ˜¯ä½ç½®åº”è¯¥æ˜¯åœ¨132ä¸­æœ€åçš„ä½ç½®ã€‚ 909. Snakes and Ladders é¢˜ç›® On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following: You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N. (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.) If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. solution class solution&#123; private int n; public snakesandladders(int[][]board)&#123; n = board.length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int steps = 0; boolean[] seen = new boolean[n*n+1]; queue.offer(1); seen[1] = true; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0; i &lt; n;i++)&#123; int cur = queue.poll(); for(int k = 0;k &lt;=6;k++)&#123; int next = cur + k; int [] pos = NumToPos(next); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == n*n)return steps; if(!seen[next])&#123; seen[next] = true; queue.offer(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; private int NumToPos(int target)&#123; int row = (target-1)/n, col = (target-1)%n; int x = n-row-1; int y = row%2 == 0? col:n-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; æ€è·¯ ä¸ç”¨å•ç‹¬å»ºä¸€ä¸ªä¸€ä½æ•°ç»„ï¼Œç›´æ¥ç§æœ‰ä¸€ä¸ªhelperå‡½æ•°å®ç°numå’Œpostionçš„è½¬æ¢ã€‚ è¿™ç§å›¾è·¯å¾„çš„é—®é¢˜åŸºæœ¬éƒ½æ˜¯queue+æ“ä½œæ–¹å‘/è·ç¦»é›†åˆï¼Œä¹‹å‰çš„é¢˜é‡Œæ–¹å‘é›†åˆæ³¨æ„new int[]{}çš„åˆå§‹åŒ–ï¼›è¿™é“é¢˜ç›´æ¥foréå†1-6æ­¥ã€‚ è¿™ç§é¢˜è¦åŠ ä¸Šseenåˆ¤æ–­æ˜¯å¦è®¿é—®è¿‡è¯¥ç‚¹ï¼Œæ ¹æ®å½“å‰ç‚¹æ˜¾ç¤ºæ•°å­—å¤§å°ï¼ˆæ­¤é¢˜åªæœ‰ç›®çš„ä½ç½®çš„æ•°å­—å’Œ-1ä¸¤ç§ï¼‰ï¼Œå°†ç¬¦åˆçš„å†å­˜å…¥queueã€‚æ›´æ–°seenä¸ºtrueã€‚ æ€è·¯å¤§ä½“ä¸ºnum -&gt; pos -&gt; num, é€šè¿‡NumToPoså‡½æ•°å®ç°numçš„è·³è½¬ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 49","slug":"leetcode49","date":"2019-11-05T02:34:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/11/04/leetcode49/","link":"","permalink":"WangHngLeee.github.io/2019/11/04/leetcode49/","excerpt":"994. Rotting Oranges é¢˜å¹² In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.","text":"994. Rotting Oranges é¢˜å¹² In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. æ€è·¯ è¿™é“é¢˜å’Œåšå®¢leetcode48ä¸­maxmium minum path scoreæœ‰ç›¸ä¼¼çš„æ€è·¯ã€‚ BFSæ‰«æï¼Œåªå¯¹gridä¸­ä¸º1çš„ç‚¹è¿›è¡Œæ“ä½œã€‚æ¯æ¬¡æ“ä½œå®Œä¸€ä¸ªç‚¹ä¹‹åå°†minute+1ã€‚ åˆ©ç”¨queueæ¥å­˜èŠ‚ç‚¹åæ ‡ã€‚ç”±äºæ²¡æœ‰min maxé™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥å­˜å…¥å°±å¯ä»¥ã€‚ å…ˆéå†ä¸€è¾¹gridï¼Œå­˜ä¸‹freshï¼ˆ1ï¼‰çš„ä¸ªæ•°ã€‚ç”±äºæ˜¯ä»åæ‰çš„å¼€å§‹æ‰©æ•£ï¼Œæ‰€ä»¥å†å°†åæ‰çš„æ©™å­åæ ‡å­˜å…¥queueã€‚ å¯¹queue pollå‡ºå¯¹ç‚¹è¿›è¡Œbfsï¼Œå³åæ‰ä½ç½® å»ºç«‹æ“ä½œæ–¹ä½çš„é›†åˆï¼Œæ“ä½œæ˜¯åªéœ€è¦éå†è¯¥é›†åˆå³å¯ã€‚ å¯¹æ›´æ–°ä½ç½®åå€¼ä¸º1çš„åæ ‡(newx,newy)è¿›è¡Œæ“ä½œï¼Œå°†å…¶æ”¹ä¸º2ï¼Œå­˜å…¥queueï¼Œfreshçš„æ•°é‡-1ã€‚ æœ€ååˆ¤æ–­freshçš„ä¸ªæ•°æ˜¯å¦ä¸ºé›¶ã€‚åº”è¯¥æ˜¯0ã€‚å¦‚æœæ˜¯0åˆ™è¿”å›minuteï¼›å¦‚æœä¸æ˜¯çš„è¯å°±è¿”å›-1. class Solution &#123; public int orangesRotting(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int rows = grid.length; int cols = grid[0].length; int freshnums = 0; for(int i = 0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(grid[i][j] == 1)freshnums++; else if(grid[i][j] == 2)&#123; queue.offer(new int[]&#123;i,j&#125;); &#125; &#125; &#125; if(freshnums == 0)return 0; int minutes = 0; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; while(!queue.isEmpty())&#123; if(freshnums == 0)return minutes; minutes++; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int[] point = queue.poll(); for(int[] move : moves)&#123; int newx = point[0] + move[0]; int newy = point[1] + move[1]; if(newx &lt; 0 || newy &lt; 0 || newx &gt;= rows || newy &gt;= cols || grid[newx][newy] == 0 || grid[newx][newy] == 2)continue; grid[newx][newy] = 2; queue.offer(new int[]&#123;newx,newy&#125;); freshnums--; &#125; &#125; &#125; return freshnums == 0 ? minutes: -1; &#125;&#125; 545. Boundary of Binary Tree class Solution &#123; List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;(1000); public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; if(root == null) return nodes; nodes.add(root.val); leftBoundary(root.left); leaves(root.left); leaves(root.right); rightBoundary(root.right); return nodes; &#125; public void leftBoundary(TreeNode root) &#123; if(root == null || (root.left == null &amp;&amp; root.right == null)) return; nodes.add(root.val); if(root.left == null) leftBoundary(root.right); else leftBoundary(root.left); &#125; public void rightBoundary(TreeNode root) &#123; if(root == null || (root.right == null &amp;&amp; root.left == null)) return; if(root.right == null)rightBoundary(root.left); else rightBoundary(root.right); nodes.add(root.val); // add after child visit(reverse) &#125; public void leaves(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) &#123; nodes.add(root.val); return; &#125; leaves(root.left); leaves(root.right); &#125;&#125; æŒ‰ç…§å·¦è¾¹ç•Œï¼Œå·¦å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹ï¼Œå³è¾¹ç•Œå¯¹é¡ºåºã€‚ leavesè¦ä¸€è‡´æ‰«æåˆ°æœ€åçš„èŠ‚ç‚¹å†è¿”å›ã€‚rightboundaryä¸­è®°å¾—è¦åœ¨è®¿é—®å­èŠ‚ç‚¹ä¹‹åå†å°†rootå€¼å­˜å…¥nodeã€‚ å› ä¸ºå·¦è¾¹ç•Œæ˜¯è‡ªä¸Šè€Œä¸‹ï¼Œè€Œå³è¾¹ç•Œæ˜¯è‡ªä¸‹è€Œä¸Šå­˜å…¥nodeã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 48","slug":"leetcode48","date":"2019-11-04T18:34:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/11/04/leetcode48/","link":"","permalink":"WangHngLeee.github.io/2019/11/04/leetcode48/","excerpt":"209. Minimum Size Subarray Sum class solution&#123; public minsizesub(int[]nums,int s)&#123; int start = 0,sum=0,min = Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-from+1); sum-=nums[start]; start++; &#125; &#125; return (min == Integer.MAX_VALUE) ? 0:min; &#125;&#125; two pointersæ–¹æ³•ã€‚æ­£åºæ‰«æç´¯åŠ ï¼Œå½“å¤§äºsçš„æ—¶å€™ï¼Œå‡å»nums[from],å­˜ä½å½“å‰minçš„å€¼ï¼Œç›´åˆ°å½“å‰fromåˆ°iå†…çš„å’Œå°äºsä¸ºæ­¢ï¼Œiç»§ç»­å‘åéå†ã€‚ orner case è¦åˆ¤æ–­minæ˜¯å¦å˜åŒ–ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›0ã€‚","text":"209. Minimum Size Subarray Sum class solution&#123; public minsizesub(int[]nums,int s)&#123; int start = 0,sum=0,min = Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-from+1); sum-=nums[start]; start++; &#125; &#125; return (min == Integer.MAX_VALUE) ? 0:min; &#125;&#125; two pointersæ–¹æ³•ã€‚æ­£åºæ‰«æç´¯åŠ ï¼Œå½“å¤§äºsçš„æ—¶å€™ï¼Œå‡å»nums[from],å­˜ä½å½“å‰minçš„å€¼ï¼Œç›´åˆ°å½“å‰fromåˆ°iå†…çš„å’Œå°äºsä¸ºæ­¢ï¼Œiç»§ç»­å‘åéå†ã€‚ orner case è¦åˆ¤æ–­minæ˜¯å¦å˜åŒ–ï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›0ã€‚ 1004. Max Consecutive Ones III class solution&#123; pubic maxconsecutive(int[] A,int K)&#123; int start=0,res=0,zeronums=0; for(int end =0;end&lt;A.length;end++)&#123; if(A[end] == 0)zeronums++; while(zeronums&gt;K)&#123; if(A[start] == 0)zeronums--; start++; &#125; res = Math.max(res,end-start+1); &#125; return res; &#125;&#125; sliding windowæ–¹æ³•ã€‚æ°¸è¿œä¿è¯windowé‡Œ0çš„ä¸ªæ•°ä¸ºKä¸ªï¼Œå¦‚æœè¶…è¿‡å°±è¦å†ç”¨startå¼€å§‹éå†ï¼Œä¿è¯0çš„ä¸ªæ•°å§‹ç»ˆä¸ºKï¼Œç„¶åå°†æœ€é•¿çš„substringå­˜ä¸ºresã€‚ åˆ‡è®°ä¸è¦è¢«endå’Œstartçš„å­—é¢æ„æ€è¿·æƒ‘ã€‚è¿™é“é¢˜çš„å…³é”®å°±æ˜¯ä¿æŒwindowé‡Œ0çš„ä¸ªæ•°ä¸ºKã€‚ 1099. Two Sum Less Than K class solution&#123; public twosumlessthanK(int[] A, int K)&#123; Arrays.sort(A); int i=0,j=0,max=-1; while(i&lt;j)&#123; int sum = A[i]+A[j]; if(sum &lt; K)&#123; max = Math.max(max,sum); i++; &#125;else&#123; j--; &#125; &#125; return max; &#125;&#125; two pointersã€‚ å…ˆsortï¼Œç„¶åä¸¤éå„è‡ªå‘ä¸­é—´æ‰«æï¼Œå¤§äºkå°±å³è¾¹ç¼©å°ä¸€ä½ï¼Œå°äºKå°±å·¦è¾¹æ‰©å¤§ä¸€ä½ï¼Œåªæœ‰å°äºKæ—¶æ›´æ–°maxï¼Œå¤§äºçš„æ—¶å€™ç›´æ¥jâ€“å°±å¯ä»¥ã€‚ 572. Subtree of Another Tree class solution&#123; public boolean isSubtree(TreeNode s, TreeNode t)&#123; if(s == null)return false; return isSame(s,t)|| isSubtree(s.left,t) || isSubtree(s.right,t); &#125; private boolean isSame(TreeNode s, TreeNode t)&#123; if(s == null &amp;&amp; t==null)return true; if(s == null || t == null) return false; if(s.val!= t.val)return false; return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); &#125;&#125; treeçš„pre-traversalã€‚å…ˆåˆ¤æ–­å½“å‰så’Œtæ˜¯å¦isSame,æˆ–è€…s.left/s.rightå’Œtæ˜¯å¦ä¸ºisSubTreeã€‚ isSameé‡Œä¸¤ç§æƒ…å†µä¸ºtrueï¼š valå‡ç›¸ç­‰ éƒ½ä¸ºnull å„è‡ªå·¦å³å­æ ‘ä¹Ÿä¸ºissameã€‚ 1102. Path With Maximum Minimum Value class Solution &#123; int M,N; public int maximumMinimumPath(int[][] A) &#123; M = A.length; N = A[0].length; int[] dx = new int[]&#123;1,-1,0,0&#125;; int[] dy = new int[]&#123;0,0,1,-1&#125;; boolean[][] seen = new boolean[M][N]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; b[0] - a[0]);//ä»¥å€¼ä¸ºå‚è€ƒè¿›è¡Œcomparre queue.offer(new int[]&#123;A[0][0],0,0&#125;); seen[0][0] = true; while(!queue.isEmpty())&#123; int[] cur = queue.poll(); if(cur[1] == M-1 &amp;&amp; cur[2] == N-1)&#123; return cur[0]; &#125; for(int i=0;i&lt;4;i++)&#123; int nx = cur[1] + dx[i]; int ny = cur[2] + dy[i]; if(nx &gt;= 0 &amp;&amp; nx &lt;M &amp;&amp; ny &gt;=0 &amp;&amp; ny &lt; N &amp;&amp; !seen[nx][ny])&#123; seen[nx][ny] = true; queue.offer(new int[]&#123;Math.min(cur[0],A[nx][ny]),nx,ny&#125;); &#125; &#125; &#125; return -1; &#125;&#125; PriorityQueueä»¥å¤§æ ¹å †çš„å½¢å¼å­˜ä½å„ä¸ªä½ç½®çš„å€¼ã€‚ å°†æ¯ä¸ªä½ç½®ä»¥ {å€¼ï¼Œxåæ ‡ï¼Œyåæ ‡} çš„å½¢å¼å­˜å…¥priorityã€‚ä»¥å€¼ä¸ºå‚è€ƒè¿›è¡Œè‡ªå®šä¹‰compareã€‚ åœ¨nx nyç§»åŠ¨çš„éƒ¨åˆ†ï¼Œå°†æ–°ä½ç½®çš„å€¼å’Œä¹‹å‰curçš„å€¼è¿›è¡Œæ¯”è¾ƒï¼Œä¾æ¬¡å­˜å…¥priorityqueueï¼Œæœ€æ ¹éƒ¨çš„åˆ™æ˜¯è¿™äº›æœ€å°å€¼ä¸­æœ€å¤§çš„å€¼ã€‚ ä»¥ä¾›ä¸‹æ¬¡å¾ªç¯æ—¶pollä½¿ç”¨ã€‚pollå‡ºæ¥çš„å‡ä¸ºä¸Šä¸€æ¬¡æ‰«æä¸­æœ€å°å€¼ä¸­çš„æœ€å¤§å€¼ã€‚åœ¨æ›´æ–°ä½ç½®å‰è¦åˆ¤æ–­æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœæ˜¯ç›´æ¥è¿”å›cur[0]ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 47","slug":"leetcode47","date":"2019-11-03T19:34:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/03/leetcode47/","link":"","permalink":"WangHngLeee.github.io/2019/11/03/leetcode47/","excerpt":"295. Find Median from Data Stream class MedianFinder &#123; PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()) max; PriorityQueue&lt;Integer&gt;() min; public MedianFinder()&#123; max = PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()); min = PriorityQueue&lt;Integer&gt;(); &#125; public void addnum(int num)&#123; min.offer(num); max.offer(min.poll()); if(min.size() &lt; max.size())&#123; min.offer(max.poll()); &#125; &#125; public double findmedian()&#123; if(min.size() == max.size())&#123; return ((min.peek() + max.peek()) / 2.0); &#125;else&#123; return min.peek(); &#125; &#125;&#125; ä¸¤ä¸ªheapï¼Œä¸€ä¸ªå­˜å°çš„ä¸€åŠï¼Œä¸€ä¸ªå­˜å¤§çš„ä¸€åŠã€‚findçš„æ—¶å€™åˆ¤æ–­ä¸¤éƒ¨åˆ†é•¿åº¦æ˜¯å¦ç›¸ç­‰ã€‚ maxä¸­è¾ƒå°çš„éƒ¨åˆ†é åï¼Œä¼˜å…ˆpeekï¼›minæ­£å¸¸å¤§pqï¼Œå¤§æ•°é åä¼˜å…ˆpeekã€‚","text":"295. Find Median from Data Stream class MedianFinder &#123; PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()) max; PriorityQueue&lt;Integer&gt;() min; public MedianFinder()&#123; max = PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()); min = PriorityQueue&lt;Integer&gt;(); &#125; public void addnum(int num)&#123; min.offer(num); max.offer(min.poll()); if(min.size() &lt; max.size())&#123; min.offer(max.poll()); &#125; &#125; public double findmedian()&#123; if(min.size() == max.size())&#123; return ((min.peek() + max.peek()) / 2.0); &#125;else&#123; return min.peek(); &#125; &#125;&#125; ä¸¤ä¸ªheapï¼Œä¸€ä¸ªå­˜å°çš„ä¸€åŠï¼Œä¸€ä¸ªå­˜å¤§çš„ä¸€åŠã€‚findçš„æ—¶å€™åˆ¤æ–­ä¸¤éƒ¨åˆ†é•¿åº¦æ˜¯å¦ç›¸ç­‰ã€‚ maxä¸­è¾ƒå°çš„éƒ¨åˆ†é åï¼Œä¼˜å…ˆpeekï¼›minæ­£å¸¸å¤§pqï¼Œå¤§æ•°é åä¼˜å…ˆpeekã€‚ 561. Array Partition I class solution&#123; public arraypart(int[] nums)&#123; int res = 0; Arrays.sort(nums); for(int i =0; i &lt; nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125; æ€è·¯å¾ˆç®€å•ï¼Œsortä¹‹åéš”2ä½ç›´æ¥ç›¸åŠ å°±æ˜¯æœ€ç»ˆç­”æ¡ˆã€‚å…·ä½“ç®—æ³•è§£æåœ¨è¿™é‡Œleetcode 561 167. Two Sum II - Input array is sorted class solution&#123; public twosumSorted(int[] numbers, int target)&#123; int[] idx = new int[2]; int left = 0, right = numbers.length-1; if(numbers == null || numbers.length &lt;2)return idx; while(left &lt; right)&#123; int temp = numbers[left] + numbers[right]; if(temp == target)&#123; idx[0] = left + 1; idx[1] = right + 1; break; &#125;else if(temp &gt; target)&#123; right--; &#125;else&#123; left++; &#125; &#125; return idx; &#125;&#125; å˜ç§two sumï¼Œ è¾“å…¥çš„numberså·²ç»sortedï¼Œåˆ©ç”¨åŒæŒ‡é’ˆå‰åæ‰«æï¼Œå¤§äºtargetå°±å³è¾¹æ”¶ç¼©ï¼Œå°äºtargetå°±å·¦è¾¹æ‰©å¤§ã€‚ 27. Remove Element class solution&#123; public remove(int[] nums, int target)&#123; int m = 0; for(int i = 0 ; i &lt; nums.length;i++)&#123; if(nums[i]!=target)&#123; nums[m] = nums[i]; m++; &#125; &#125; return m; &#125;&#125; ç›´æ¥å¾ªç¯æ‰«æï¼Œå¹¶ç”¨m-indexå°†æ–°çš„å€¼å­˜å¦‚æ•°ç»„ï¼Œæ¯æ¬¡å¾ªç¯æœ€åå°†m++.m++. 472. Concatenated Words dpè§£æ³• class solution&#123; public concatenatedword(String[] words)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); Set&lt;String&gt; prewords = new HashSet&lt;&gt;(); Arrays.sort(words, new Comparator&lt;String&gt;()&#123; @Override public int compare(String s1, String s2)&#123; return s1.length()-s2.length(); &#125; &#125;) for(int i = 0 ; i &lt; words.length;i++)&#123; if(form(words[i],prewords))&#123; res.add(words[i]); &#125; prewords.add(words[i]); &#125; return res; &#125; private static boolean form(String word, Set&lt;String&gt; dict)&#123; if(dict.isEmpty())return false; boolean[] dp = new boolean[word.length()+1]; dp[0] = true; for(int i = 1; i &lt; word.length();i++)&#123; for(int j = 0;j&lt;i;j++)&#123; if(!dp[j])continue; if(dict.contains(word.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[word.length()] &#125;&#125; å…ˆç”¨comparatorå°†word sortã€‚ dpå­˜ä½å½“å‰å­—æ¯ä¹‹å‰çš„wordæ˜¯å¦å·²ç»åœ¨distä¸­å­˜åœ¨ã€‚å¦‚æœæœ‰åˆ™è¯¥é•¿wordå¯ä»¥ç”¨ä¹‹å‰çš„çŸ­wordæ„æˆã€‚ dfs è§£æ³• class solution&#123; public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123; Arrays.sort(words,(a,b)-&gt; a.length()-b.length()); Set&lt;String&gt; set = new HashSet&lt;&gt;(); List&lt;String&gt; res = new ArraysList&lt;&gt;(); for(int i = 0 ; i &lt; words.length;i++)&#123; if(words[i].length != 0 &amp;&amp; valid(set,words[i]))&#123; res.add(words[i]); &#125; set.add(words[i]); &#125; return res; &#125; private boolean valid(Set&lt;String&gt; set, String word)&#123; if(word == null || word.length() == 0)return true; if(set.contains(word))return true; int len = word.length(); for(int i = 0; i &lt; len;i++)&#123; String temp = word.substring(0,i); if(set.contains(temp))&#123; if(valid(set,word.substring(i)))&#123; set.add(word); return true; &#125; &#125; &#125; return false; &#125;&#125; dfsæ€è·¯ã€‚part1å’Œdpæ€è·¯ä¸€è‡´ã€‚privateæ–¹æ³•é‡Œæ³¨æ„dfsä¹‹åè¦å°†ç›®å‰çš„wordå­˜å…¥setã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 46","slug":"leetcode46","date":"2019-10-27T22:49:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/27/leetcode46/","link":"","permalink":"WangHngLeee.github.io/2019/10/27/leetcode46/","excerpt":"123. Best Time to Buy and Sell Stock III class solution&#123; public int maxprofit(int[] prices)&#123; int onebuy = 0; int twobuy = 0; int onebuyonesell = Integer.MAX_VALUE; int twobuytwosell = Integer.MAX_VALUE; for(int i = 0; i &lt;prices.length;i++)&#123; int p = price[i]; onebuy = Math.min(p,onebuy); onebuyonesell = Math.max(p-onebuy,onebuyonesell); twobuy = Math.min(twobuy, p - onebuyonesell); twobuytwosell = Math.max(twobuytwosell, p - twobuy); &#125; return twobuytwusell; &#125;&#125; use onebuy and twobuy to store the min cost, and onebuyonesell &amp; twobuytwosell are used to store the max profit.","text":"123. Best Time to Buy and Sell Stock III class solution&#123; public int maxprofit(int[] prices)&#123; int onebuy = 0; int twobuy = 0; int onebuyonesell = Integer.MAX_VALUE; int twobuytwosell = Integer.MAX_VALUE; for(int i = 0; i &lt;prices.length;i++)&#123; int p = price[i]; onebuy = Math.min(p,onebuy); onebuyonesell = Math.max(p-onebuy,onebuyonesell); twobuy = Math.min(twobuy, p - onebuyonesell); twobuytwosell = Math.max(twobuytwosell, p - twobuy); &#125; return twobuytwusell; &#125;&#125; use onebuy and twobuy to store the min cost, and onebuyonesell &amp; twobuytwosell are used to store the max profit. 309. Best Time to Buy and Sell Stock with Cooldown class solitoin&#123; public int maxprofit(int[] prices)&#123; int sell = 0,presell = 0, buy = Integer.MIN_VALUE,prebuy; for(int price: prices)&#123; prebuy = buy; buy = Math.max(presell - price, prebuy); presell = sell; sell = Math.max(prebuy + price, presell); &#125; return sell; &#125;&#125; hard one. buy, sell are both used to store the max profit of the action queue which is ended with â€˜buyâ€™ or â€˜sellâ€™. When it is ended with buy, we compare the prebuy and presell - price(buying action cause profit to decrease, so minus the price) to choose the larger one. When it is ended with sell, we compare the presell and prebuy + price. Hint: we can not have two same actions like â€˜buyâ€™ â€˜buyâ€™ or â€˜sellâ€™â€˜sellâ€™. So in the comparision, we use different params instead of both sell or both buy.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 45","slug":"leetcode45","date":"2019-10-20T19:49:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/20/leetcode45/","link":"","permalink":"WangHngLeee.github.io/2019/10/20/leetcode45/","excerpt":"241. Different Ways to Add Parentheses class solution&#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length;i++)&#123; char c = input.charAt(i); if(c == '+' || c == '-' || c == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; p1 = map.getOrDefault(p1,diffWaysToCompute(part1)); List&lt;Integer&gt; p2 = map.getOrDefault(p2,diffWaysToCompute(part2)); for(Integer v1 : p1)&#123; for(Integer v2 : p2)&#123; int r = 0; switch (c) &#123; case('+'): r = p1+p2; break; case('-'): r = p1 - p2; break; case('*'): r = p1*p2; break; &#125; res.add(r); &#125; &#125; &#125; &#125; if(res.size() == 0)&#123; res.add(Integer.valueOf(input)); &#125; map.put(input,res); &#125;&#125; ç”¨mapå­˜ä½stringå¯¹åº”çš„æ‰€æœ‰ç»“æœå’Œï¼Œå‡å°‘æ—¶é—´ã€‚æ ¹æ®ç¬¦å·åˆ¤æ–­å½“å‰è¿ç®—æ–¹æ³•ï¼Œæœ€åè®°å¾—å°†reså’Œå½“å‰çš„inputå­˜å…¥mapã€‚","text":"241. Different Ways to Add Parentheses class solution&#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length;i++)&#123; char c = input.charAt(i); if(c == '+' || c == '-' || c == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; p1 = map.getOrDefault(p1,diffWaysToCompute(part1)); List&lt;Integer&gt; p2 = map.getOrDefault(p2,diffWaysToCompute(part2)); for(Integer v1 : p1)&#123; for(Integer v2 : p2)&#123; int r = 0; switch (c) &#123; case('+'): r = p1+p2; break; case('-'): r = p1 - p2; break; case('*'): r = p1*p2; break; &#125; res.add(r); &#125; &#125; &#125; &#125; if(res.size() == 0)&#123; res.add(Integer.valueOf(input)); &#125; map.put(input,res); &#125;&#125; ç”¨mapå­˜ä½stringå¯¹åº”çš„æ‰€æœ‰ç»“æœå’Œï¼Œå‡å°‘æ—¶é—´ã€‚æ ¹æ®ç¬¦å·åˆ¤æ–­å½“å‰è¿ç®—æ–¹æ³•ï¼Œæœ€åè®°å¾—å°†reså’Œå½“å‰çš„inputå­˜å…¥mapã€‚ 282. Expression Add Operators class solution&#123; public List&lt;String&gt; addOperators(String num, int target) &#123; StringBuilder sb = new StringBuilder(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); find(res,sb,num,0,target,0,0); return res; &#125; public void find(List&lt;Integer&gt; res , StringBuilder sb, String num, int pos, int target, int prev, int after)&#123; if(pos == num.length() )&#123; if(target == prev)&#123; res.add(sb.toString()); return; &#125; &#125; for(int i = 0; i &lt; num.length(); i++)&#123; if(num.charAt(pos) == '0' &amp;&amp; i!=pos)break; long cur = Long.parseLong(num.substring(pos,i+1)); int len = sb.length(); if(pos == 0)&#123; find(res,sb.append(curr),num,i+1,target,curr,curr); sb.setLength(length); &#125; else&#123; find(res,sb.append('+').append(curr),num,i+1,target,prev + curr, curr); sb.setLength(length); find(res,sb.append('-').append(curr),num,i+1,target,prev - curr, -curr); sb.setLength(length); find(res,sb.append('*').append(curr),num,i+1,target,prev - after + after*curr, after*curr); sb.setLength(length); &#125; &#125; &#125;&#125; hardã€‚ åˆ©ç”¨stringbuildeæ–¹æ³•æ¯”ç›´æ¥ç”¨stringæ›´å¿«ã€‚æ³¨æ„æ¯ä¸€æ¬¡findåè¦backtrackingï¼Œå°†sbçš„lengthè°ƒæ•´å›ä¸€å¼€å§‹çš„å€¼ï¼Œå°±æ˜¯æ¯æ¬¡findé‡Œå£°æ˜çš„sbçš„é•¿åº¦ã€‚ åˆ©ç”¨longå‹é¿å…å‡ºé”™ã€‚æ³¨æ„Long.parseLongçš„ç”¨æ³•ã€‚ç¬¬ä¸€æ­¥çš„æ—¶å€™å°†afterå’Œprevéƒ½è®¾ä¸ºcurrã€‚ä¹‹åæ‰ä¼šç»†åˆ†ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 44","slug":"leetcode44","date":"2019-10-18T19:49:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/10/18/leetcode44/","link":"","permalink":"WangHngLeee.github.io/2019/10/18/leetcode44/","excerpt":"","text":"23. Merge k Sorted Lists class solution&#123; public kmergelist(ListNode[] lists)&#123; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator &lt;ListNode&gt;()&#123; @override public int compare(ListNode node1, ListNode node2)&#123; if(node1.val &lt; node2.val)return -1; else if(node1.val == node2.val)return 0; else return 1; &#125; &#125;) ListNode dummy = new ListNode(0); ListNode last = dummy; for(ListNode node : lists)&#123; if(node!=null)queue.add(node); &#125; while(!queue.isEmpty)&#123; last.next = queue.poll(); last = last.next; if(last.next!=null)queue.add(last.next); &#125; return dummy.next; &#125;&#125; hardã€‚é¦–å…ˆè¦åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼Œç„¶åå®šä¹‰comparatorï¼Œå°†å°çš„å€¼æ”¾åœ¨æœ€é«˜ä¼˜å…ˆåº¦ã€‚queueç¬¬ä¸€æ¬¡åŠ çš„æ˜¯æ¯ä¸ªlinkedlistçš„å¤´èŠ‚ç‚¹ã€‚ç±»ä¼¼minheapã€‚ 973. K Closest Points to Origin class Solution &#123; public int[][] kClosest(int[][] points, int K) &#123; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] left, int[] right)&#123;// Just keep the highest priority to small dist. if( dist(left) &lt; dist(right) ) return -1; else if( dist(left) == dist(right) ) return 0; else return 1; &#125; &#125;); for(int[] point : points)&#123; queue.add(point); &#125; int[][] res = new int[K][2]; while(K&gt;0)&#123;// Keep in mind that Kth point is in int[K-1] position K--; res[K] = queue.poll(); &#125; return res; &#125; private int dist(int[] point)&#123; return point[0]*point[0] + point[1]*point[1]; &#125;&#125; Comparatoræ–¹æ³•ã€‚å°†distå°çš„pointèµ‹ç»™æœ€é«˜çš„ä¼˜å…ˆåº¦ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"IBM é«˜é¢‘ Online Assignments","slug":"ibmoa","date":"2019-10-17T02:31:09.000Z","updated":"2019-10-17T03:27:54.086Z","comments":true,"path":"2019/10/16/ibmoa/","link":"","permalink":"WangHngLeee.github.io/2019/10/16/ibmoa/","excerpt":"IBM | OA 2020 é«˜é¢‘ | Two Strings class solution&#123; public static void main(String[] args)&#123; String[] a = &#123;\"ab\", \"cd\", \"ef\"&#125;; String[] b = &#123;\"af\", \"ee\", \"ef\"&#125;; String[] res = commonSubstring(a,b); for(String ans : res)&#123; System.out.println(ans); &#125; &#125; private void commonSubstring(String[] a, String[] b)&#123; String res = new String[a.length]; for(i = 0;i&lt;a.length;i++)&#123; int twobitA = 0; int twobitB = 0; for(int j = 0;j&lt;a[i].length;j++)&#123; char a = a[i].charAt(j); char b = b[i].charAt(j); twobitA ï½œ= 1 &lt;&lt; (a-'a'); twobitB ï½œ= 1 &lt;&lt; (b-'a'); &#125; res[i] = (twobitA &amp;&amp; twobitB ) &gt; 0 ? \"Yes\" : \"No\"; &#125; return res; &#125;&#125; trickyï¼šåˆ©ç”¨äºŒè¿›åˆ¶ç›¸åŒè¿”å›å€¼å¤§äº0å¦åˆ™ä¸º00000â€¦çš„æ–¹æ³•ã€‚ï½œ= æ˜¯äºŒè¿›åˆ¶é‡Œçš„+=ï¼Œå³å°†è¯¥ä½ç½®çš„æ‰€æœ‰äºŒè¿›åˆ¶ç»“æœç›¸åŠ ï¼Œæœ€åå’Œbçš„ç›¸æ¯”è¾ƒï¼Œè‹¥æœ‰ç›¸åŒçš„ï¼Œåˆ™è¿”å›çš„äºŒè¿›åˆ¶è‚¯å®šä¸æ˜¯0ï¼Œè‹¥æ²¡æœ‰ï¼Œåˆ™è¿”å›çš„ä¸€å®šæ˜¯00000â€¦","text":"IBM | OA 2020 é«˜é¢‘ | Two Strings class solution&#123; public static void main(String[] args)&#123; String[] a = &#123;\"ab\", \"cd\", \"ef\"&#125;; String[] b = &#123;\"af\", \"ee\", \"ef\"&#125;; String[] res = commonSubstring(a,b); for(String ans : res)&#123; System.out.println(ans); &#125; &#125; private void commonSubstring(String[] a, String[] b)&#123; String res = new String[a.length]; for(i = 0;i&lt;a.length;i++)&#123; int twobitA = 0; int twobitB = 0; for(int j = 0;j&lt;a[i].length;j++)&#123; char a = a[i].charAt(j); char b = b[i].charAt(j); twobitA ï½œ= 1 &lt;&lt; (a-'a'); twobitB ï½œ= 1 &lt;&lt; (b-'a'); &#125; res[i] = (twobitA &amp;&amp; twobitB ) &gt; 0 ? \"Yes\" : \"No\"; &#125; return res; &#125;&#125; trickyï¼šåˆ©ç”¨äºŒè¿›åˆ¶ç›¸åŒè¿”å›å€¼å¤§äº0å¦åˆ™ä¸º00000â€¦çš„æ–¹æ³•ã€‚ï½œ= æ˜¯äºŒè¿›åˆ¶é‡Œçš„+=ï¼Œå³å°†è¯¥ä½ç½®çš„æ‰€æœ‰äºŒè¿›åˆ¶ç»“æœç›¸åŠ ï¼Œæœ€åå’Œbçš„ç›¸æ¯”è¾ƒï¼Œè‹¥æœ‰ç›¸åŒçš„ï¼Œåˆ™è¿”å›çš„äºŒè¿›åˆ¶è‚¯å®šä¸æ˜¯0ï¼Œè‹¥æ²¡æœ‰ï¼Œåˆ™è¿”å›çš„ä¸€å®šæ˜¯00000â€¦ IBM | OA 2020 é«˜é¢‘ | Aladdin and his Carpet class solution&#123; pubic static int optimalpoints(List&lt;Integer&gt; magic, List&lt;Integer&gt; dist)&#123; int pos = 0,cur=0,total=0; for(int i = 0; i &lt; magic.size();i++)&#123; int cost = magic.get(i) - dist.get(i); cur+=cost; total+=cost; if(cur&lt;0)&#123; pos = i; cur = 0; &#125; &#125; return total &gt; 0 ? pos+1 : -1; &#125;&#125; gas stationçš„ç±»å‹é¢˜ï¼Œåˆ¤æ–­é‚£ä¸ªä½ç½®å¯ä»¥å¼€å§‹è¿›è¡Œå¾ªç¯åæœ€ç»ˆå€¼ä¸å°äºé›¶ã€‚ç›¸åŒçš„é¢˜ç›®é“¾æ¥ leetcodeâ€“gasstation","categories":[{"name":"IBM-OA","slug":"IBM-OA","permalink":"WangHngLeee.github.io/categories/IBM-OA/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"},{"name":"OnlineAssignments","slug":"OnlineAssignments","permalink":"WangHngLeee.github.io/tags/OnlineAssignments/"}]},{"title":"Leetcode EveryDay 43","slug":"leetcode43","date":"2019-10-16T23:49:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/10/16/leetcode43/","link":"","permalink":"WangHngLeee.github.io/2019/10/16/leetcode43/","excerpt":"","text":"199. Binary Tree Right Side View class solution&#123; public List&lt;Integer&gt; rightsideview(TreeNode root)&#123; if(root == null) return new ArrayList(); Queue&lt;Integer&gt; queue = new LinkedList(); queue.offer(root); List&lt;Integer&gt; res = new ArrayList(); while(!queue.isEmpty())&#123; int size = queue.size(); while(size -- &gt;0)&#123; TreeNode cur = queue.poll(); if(size == 0)&#123; res.add(cur.val); &#125;if(cur.left!=null)&#123; queue.offer(cur.left); &#125;if(cur.right!=null)&#123; queue.offer(cur.right); &#125; &#125; &#125;return res; &#125;&#125; bfsæ–¹æ³•è¿”å›æœ€å³ä¾§çš„èŠ‚ç‚¹ã€‚åˆ©ç”¨sizeä½œä¸ºflagæ¥è®°å½•å½“å‰å±‚æ˜¯å¦éå†å®Œã€‚ â€“ &gt;æ˜¯æ¯”è¾ƒä¹‹åè‡ªèº«å‡ä¸€ã€‚queue.pollä»å‰ï¼Œstack.popä»åã€‚ 236. Lowest Common Ancestor of a Binary Tree class solution&#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123; if(root == q || root==p || root == null)return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; else&#123; return root; &#125; &#125;&#125; ç¬¬ä¸‰éã€‚è‡ªèº«è°ƒç”¨ï¼Œleftå°±æ˜¯å·¦å­æ ‘çš„æœ€å°çˆ¶èŠ‚ç‚¹ï¼Œrightå°±æ˜¯å³å­æ ‘çš„æœ€å°çˆ¶èŠ‚ç‚¹ã€‚ä¸ç”¨æƒ³å¤ªå¤šï¼Œè°ƒç”¨åç›´æ¥ç”¨è¿”å›å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¾ˆç®€å•ï¼Œleftä¸ºnullåˆ™è¡¨ç¤ºå·¦è¾¹æ²¡æœ‰æœ€å°çˆ¶èŠ‚ç‚¹ï¼Œè¿”å›å³å­æ ‘çš„æƒ…å†µã€‚åŒç†ï¼Œrightä¸ºnullæ—¶è¿”å›å·¦å­æ ‘çš„æƒ…å†µã€‚å¦‚æœä¸¤è¾¹éƒ½æ²¡æœ‰ï¼Œé‚£ä¹ˆå°±æ˜¯rootæœ¬èº«äº†ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 42","slug":"leetcode42","date":"2019-10-15T14:33:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/15/leetcode42/","link":"","permalink":"WangHngLeee.github.io/2019/10/15/leetcode42/","excerpt":"129. Sum Root to Leaf Numbers class solution&#123; public int sumnumbers(TreeNode root)&#123; return sum(root,0); &#125; public int sum(TreeNode n, int s)&#123; if(n == null)return 0; if(n.left == null &amp;&amp; n.right==null )&#123; return s*10 + n.val; &#125; return sum(n.left,s*10+n.val) + sum(n.right,s*10+n.val) &#125;&#125;","text":"129. Sum Root to Leaf Numbers class solution&#123; public int sumnumbers(TreeNode root)&#123; return sum(root,0); &#125; public int sum(TreeNode n, int s)&#123; if(n == null)return 0; if(n.left == null &amp;&amp; n.right==null )&#123; return s*10 + n.val; &#125; return sum(n.left,s*10+n.val) + sum(n.right,s*10+n.val) &#125;&#125; å°†æ¯ä¸€æ¡å­æ ‘é“¾ä¸Šæ•°å­—åŠ èµ·æ¥ç»„æˆå¤šä½æ•°ã€‚ç„¶åå°†æœ€åç»“æœç›¸åŠ ã€‚è‡ªèº«ä¸ºç©ºæ—¶è¿”å›0ã€‚leftæˆ–è€…rightä¸ºç©ºæ—¶åˆ™å°†ä¸Šä¸€ä½çš„çš„ç»“æœä¹˜10å†åŠ ä¸Šè‡ªèº«å€¼ã€‚ 222. Count Complete Tree Nodes class solution&#123; public int countnum(TreeNode root)&#123; int leftdepth = leftdepth(root); int rightdepth = rightdepth(root); if(leftdepth == rightdepth)&#123; return (1 &lt;&lt; leftdepth)-1; &#125;else&#123; return 1+countnum(root.left) + countnum(root.right); &#125; &#125; private int leftdepth(TreeNode root)&#123; int depth = 0; if(root!=null)&#123; depth++; root = root.left; &#125; return depth; &#125; private int rightdepth(TreeNode root)&#123; int depth = 0; if(root!=null)&#123; depth++; root = root.right; &#125; return depth; &#125;&#125; 1&lt;&lt; æ˜¯log2()çš„æ„æ€ï¼Œå› ä¸ºæ€»èŠ‚ç‚¹æ•°ç­‰äº2çš„å±‚æ•°ç«‹æ–¹-1ã€‚leftå’Œrightdepthéƒ½ç›¸ç­‰æ—¶ï¼Œå¯ä»¥ç›´æ¥è¿”å›leftçš„depthå…¬å¼ã€‚ å¦‚æœä¸ç›¸ç­‰ï¼Œåˆ™éœ€è¦recursiveè¿›è¡Œè®¡ç®—ã€‚è®°å¾—æœ€ååŠ 1ï¼Œç®—ä¸Šrootæ ¹ç»“ç‚¹","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 41","slug":"leetcode41","date":"2019-10-14T15:15:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/14/leetcode41/","link":"","permalink":"WangHngLeee.github.io/2019/10/14/leetcode41/","excerpt":"105. Construct Binary Tree from Preorder and Inorder Traversal class solution&#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0,0,inorder.length-1,preorder,inorder); &#125; public TreeNode helper(int prestart, int instart, int inend, int[] preorder, int[] inorder)&#123; if(prestart &gt; preorder.length-1 || instart &gt; inend)return null; TreeNode root = new TreeNode(preorder[prestart]); int idx=0; for(int i = 0;i&lt;=inorder.length;i++)&#123; if(inorder[i]==root.val)&#123; idx = i; &#125; &#125; root.left = helper(prestart+1,instart,idx-1,preorder,inorder); root.right = helper(prestart+idx-instart+1,idx+1,inend,preorder,inorder); return root; &#125;&#125; preorderç¬¬ä¸€ä¸ªæ°¸è¿œæ˜¯æ ¹ç»“ç‚¹ï¼Œæ ¹æ®preorderçš„æ ¹ç»“ç‚¹åœ¨inorderé‡Œæ‰¾åˆ°å°±å¯ä»¥åˆ’åˆ†å·¦å³å­æ ‘äº†ã€‚å·¦è¾¹æ˜¯ä»instartåˆ°idx-1ï¼Œå³è¾¹æ˜¯ä»idx+1åˆ°inendã€‚ è€Œä¸”preorderä¸­è¦è·³è¿‡å·¦å­æ ‘çš„éƒ¨åˆ†ï¼Œä¸ºidx-instart.","text":"105. Construct Binary Tree from Preorder and Inorder Traversal class solution&#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0,0,inorder.length-1,preorder,inorder); &#125; public TreeNode helper(int prestart, int instart, int inend, int[] preorder, int[] inorder)&#123; if(prestart &gt; preorder.length-1 || instart &gt; inend)return null; TreeNode root = new TreeNode(preorder[prestart]); int idx=0; for(int i = 0;i&lt;=inorder.length;i++)&#123; if(inorder[i]==root.val)&#123; idx = i; &#125; &#125; root.left = helper(prestart+1,instart,idx-1,preorder,inorder); root.right = helper(prestart+idx-instart+1,idx+1,inend,preorder,inorder); return root; &#125;&#125; preorderç¬¬ä¸€ä¸ªæ°¸è¿œæ˜¯æ ¹ç»“ç‚¹ï¼Œæ ¹æ®preorderçš„æ ¹ç»“ç‚¹åœ¨inorderé‡Œæ‰¾åˆ°å°±å¯ä»¥åˆ’åˆ†å·¦å³å­æ ‘äº†ã€‚å·¦è¾¹æ˜¯ä»instartåˆ°idx-1ï¼Œå³è¾¹æ˜¯ä»idx+1åˆ°inendã€‚ è€Œä¸”preorderä¸­è¦è·³è¿‡å·¦å­æ ‘çš„éƒ¨åˆ†ï¼Œä¸ºidx-instart. 106. Construct Binary Tree from Inorder and Postorder Traversal è§£æ³•1: 1ms class Solution &#123; int indexpost; int indexinorder; private TreeNode buildTree(int[] inorder, int[] postorder, TreeNode end) &#123; if(indexpost &lt; 0) return null; TreeNode n = new TreeNode(postorder[indexpost]); indexpost--; if(inorder[indexinorder] != n.val)&#123; n.right = buildTree(inorder,postorder,n); &#125; indexinorder--; if((end ==null) || (inorder[indexinorder]!=end.val))&#123; n.left = buildTree(inorder,postorder,end); &#125; return n; &#125; public TreeNode buildTree(int[] inorder, int[] postorder)&#123; indexpost = postorder.length -1; indexinorder = inorder.length-1; return buildTree(inorder,postorder,null); &#125;&#125; postorderçš„æœ€åä¸€ä¸ªå…ƒç´ æ°¸è¿œæ˜¯æ ¹èŠ‚ç‚¹ã€‚å½“inorderå…ƒç´ å’Œpostorderæœ€åä¸€ä¸ªå…ƒç´ ä¸ç›¸åŒï¼Œè¦ç»§ç»­å¾€ä¸‹å¾ªç¯ï¼Œæ„å»ºrightå­æ ‘ã€‚å½“å³å­æ ‘æ„å»ºå®Œæˆ/inorderé‡Œé‡åˆ°äº†postorderçš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯æ ¹ç»“ç‚¹ï¼Œå¼€å§‹è¿›è¡Œå·¦å­æ ‘çš„æ„å»ºå¾ªç¯ã€‚ è§£æ³•2: 3ms class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) return null; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;inorder.length;++i) hm.put(inorder[i], i); return buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1,hm); &#125; private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, HashMap&lt;Integer,Integer&gt; hm)&#123; if (ps&gt;pe || is&gt;ie) return null; TreeNode root = new TreeNode(postorder[pe]); int ri = hm.get(postorder[pe]); root.left = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm); root.right= buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm); return root; &#125;&#125; åˆ©ç”¨hashmapå­˜èŠ‚ç‚¹å’Œå¯¹åº”çš„ä½ç½®ã€‚ç„¶åæ ¹æ®postorderé‡Œæ ¹ç»“ç‚¹çš„ä½ç½®ï¼Œè¿›è¡Œå¯¹åº”çš„leftå’Œrightå­æ ‘æ„å»ºã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 39","slug":"leetcode39","date":"2019-10-12T15:15:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/12/leetcode39/","link":"","permalink":"WangHngLeee.github.io/2019/10/12/leetcode39/","excerpt":"144. Binary Tree Preorder Traversal class solution&#123; public List&lt;Integer&gt; preoeder(TreeNode root)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedLIst&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node != null)&#123; res.add(node.val); stack.push(node.right); stack.push(node.left); &#125; &#125; return res; &#125;&#125;","text":"144. Binary Tree Preorder Traversal class solution&#123; public List&lt;Integer&gt; preoeder(TreeNode root)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedLIst&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node != null)&#123; res.add(node.val); stack.push(node.right); stack.push(node.left); &#125; &#125; return res; &#125;&#125; preorder,æŒ‰ç…§å³å·¦é¡ºåºæ”¾å…¥dequeï¼Œå†æŒ‰å·¦å³é¡ºåºpopå‡ºã€‚ 145. Binary Tree Postorder Traversal class solution&#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); if(root == null) return res; while(!stack.isEmpty())&#123; root = stack.pop(); res.addFirst(root); if(root.left!=null)stack.push(root.left); if(root.right!=null)stack.push(root.right); &#125; return res; &#125;&#125; å’Œä¸Šä¸€é“é¢˜ç±»ä¼¼ï¼Œä¸è¿‡æ˜¯é€†åºè¾“å‡ºï¼Œåªéœ€è¦å°†addæ”¹ä¸ºaddFristå³å¯ã€‚Dequeçš„ç‰¹æ€§ã€‚ Amazon é«˜é¢‘é¢˜ Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 â†’ 4 â†’ 5 â†’ 9 is 4. You can only move either down or right at any point in time. Example 1:Input:[[5, 1], [4, 5]]Output: 4Explanation:Possible paths:5 â†’ 1 â†’ 5 =&gt; min value is 15 â†’ 4 â†’ 5 =&gt; min value is 4Return the max value among minimum values =&gt; max(4, 1) = 4. class solution&#123; public int mincvalue(int[][] mattix)&#123; int m = matrix.length; int n = matrix(0).length; int[] dp = new int[n]; dp[0]-matrix[0][0]; for(int i = 0;i&lt;m;i++)&#123; for(int j =0;j&lt;n;j++)&#123; if(i==0&amp;&amp;j==0)continue; if(j==0&amp;&amp;i!==)&#123; dp[j]=Math.min(matrix[i][j],dp[j]); &#125;else if(j!=0 &amp;&amp; i == 0)&#123; dp[j] = Math.min(matrix[i][j],dp[j-1]); &#125;else&#123; dp[j]= Math.min(Math.max(dp[j-1],dp[j]),matrix[i][j]); &#125; &#125; &#125; return dp[n-1]; &#125;&#125; ä¸€ç»´æ•°ç»„å¯¸ä½ç»“æœã€‚åªèƒ½å‘ä¸‹æˆ–è€…å‘å³æ‰«æã€‚ 5. Longest Palindromic Substring class solution&#123; private int lo, maxlength; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)return s; for(int i = 0 : i &lt; s.length()-1;i++)&#123; valid(s,i,i); valid(s,i,i+1); &#125; return s.substring(lo,lo+maxlength); &#125; private void valid(String s, int j, int k)&#123; while(j&gt;=0 &amp;&amp; k&lt;s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxlength &lt; k-j-1)&#123; lo = j+1; maxlength = k-j-1; &#125; &#125;&#125; è®°ä½ä¸¤ç§æƒ…å†µ ä¸€ä¸ªå­—æ¯é‡å¤ aba æˆ–è€…ä¸¤ä¸ªå­—æ¯é‡å¤ abba","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 40","slug":"leetcode40","date":"2019-10-12T15:15:09.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/10/12/leetcode40/","link":"","permalink":"WangHngLeee.github.io/2019/10/12/leetcode40/","excerpt":"103. Binary Tree Zigzag Level Order Traversal class solution&#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt;temp = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; queue.size();i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; temp.add(0,node.val); &#125;else&#123; temp.add(node.val); &#125;if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(temp); zig=!zig; &#125;return res; &#125;&#125; å¥‡æ•°å±‚zigä¸ºfalseï¼Œå¶æ•°å±‚zigä¸ºtrueã€‚trueåŠ åˆ°queueå‰é¢ï¼Œfalseåˆ™åœ¨åé¢æŒ‰é¡ºåºæ·»åŠ ã€‚","text":"103. Binary Tree Zigzag Level Order Traversal class solution&#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt;temp = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; queue.size();i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; temp.add(0,node.val); &#125;else&#123; temp.add(node.val); &#125;if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(temp); zig=!zig; &#125;return res; &#125;&#125; å¥‡æ•°å±‚zigä¸ºfalseï¼Œå¶æ•°å±‚zigä¸ºtrueã€‚trueåŠ åˆ°queueå‰é¢ï¼Œfalseåˆ™åœ¨åé¢æŒ‰é¡ºåºæ·»åŠ ã€‚ 297. Serialize and Deserialize Binary Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; return serial(new StringBuilder(),root).toString(); &#125; private StringBuilder serial(StringBuilder str, TreeNode root)&#123; if(root == null)return str.append(\"null\"); str.append(root.val).append(','); serial(str,root.left).append(\",\"); serial(str,root.right); return str; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; return deserial(new LinkedList&lt;&gt;(Arrays.asList(data.split(',')))); &#125; private TreeNode deserial(Queue&lt;String&gt;q)&#123; String val = q.poll(); if(\"null\"equals(val))return null; TreeNode root = new TreeNode(valueOf(val)); root.left = deserial(q); root.right = deserial(q); return root; &#125;&#125; ç¬¬ä¸‰æ¬¡åšã€‚æœ‰ç‚¹å¿˜ã€‚enocdeæ³¨æ„è¾¹ç•Œæ¡ä»¶ã€‚serialä¸­é—´åŠ é€—å·ã€‚è¿›è¡Œrightæ—¶ä¸ç”¨åŠ ï¼Œå› ä¸ºæ˜¯æœ€åä¸€ä¸ªä½ç½®ã€‚ decodeæ—¶æ³¨æ„deserialé‡Œé¢çš„å†™æ³•ï¼Œaslistå’Œsplitã€‚åŒæ ·æ³¨æ„è¾¹ç•Œæ¡ä»¶ã€‚å®ƒæ˜¯ä»æœ€åä¸€ä½å¾€å‰è¿­ä»£ã€‚ç›´åˆ°ç¬¬ä¸€ä½æ—¶ç­”æ¡ˆæ‰ä¼šæ˜¯æœ€å…¨çš„ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 38","slug":"leetcode38","date":"2019-10-11T02:15:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/10/leetcode38/","link":"","permalink":"WangHngLeee.github.io/2019/10/10/leetcode38/","excerpt":"113. Path Sum II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; pathsum(TreeNode root, int sum)&#123; re pathsum(root,sum); &#125; public void pathsum(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return; cur.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123; res.add(new ArrayList(cur)); &#125;else&#123; pathsum(root.left,sum-root.val,cur,res); pathsum(root.right,sum-root.val,cur,res); &#125; cur.remove(cur.size()-1); &#125;&#125; å¦‚æœå½“å‰rootä¸ºleafæ—¶ï¼Œroot val == sum ï¼Œé‚£ä¹ˆç›´æ¥å­˜å…¥curï¼›å¦‚æœä¸ç­‰äºsumï¼Œåˆ™ç»§ç»­iterateï¼Œå°†sum=sum-root.valã€‚ è®°å¾—æœ€åbacktrackingå°†curå¤§å°å‡ä¸€ï¼Œä¿è¯å…¶ä»–ç­”æ¡ˆä¸è¢«è¦†ç›–ã€‚","text":"113. Path Sum II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; pathsum(TreeNode root, int sum)&#123; re pathsum(root,sum); &#125; public void pathsum(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return; cur.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123; res.add(new ArrayList(cur)); &#125;else&#123; pathsum(root.left,sum-root.val,cur,res); pathsum(root.right,sum-root.val,cur,res); &#125; cur.remove(cur.size()-1); &#125;&#125; å¦‚æœå½“å‰rootä¸ºleafæ—¶ï¼Œroot val == sum ï¼Œé‚£ä¹ˆç›´æ¥å­˜å…¥curï¼›å¦‚æœä¸ç­‰äºsumï¼Œåˆ™ç»§ç»­iterateï¼Œå°†sum=sum-root.valã€‚ è®°å¾—æœ€åbacktrackingå°†curå¤§å°å‡ä¸€ï¼Œä¿è¯å…¶ä»–ç­”æ¡ˆä¸è¢«è¦†ç›–ã€‚ 114. Flatten Binary Tree to Linked List class solution&#123; public void flatten(TreeNode root) &#123; flatten(root,null); &#125; private TreeNode flatten(TreeNode root, TreeNode pre)&#123; if(root == null)return pre; pre=flatten(root.right,pre); pre=flatten(root.left,pre); root.right = pre; root.left = null; pre = root; return pre; &#125;&#125; dfsçš„æ€è·¯ï¼Œå…ˆä»rightåˆ†æ”¯æ‰¾åˆ°æœ€åä¸€ä¸ªrootï¼Œå°†å…¶è®¾ä¸ºpreï¼Œç„¶åé€æ¸é€’å½’ï¼Œä¾æ¬¡å°†rootå­˜å…¥preï¼Œå¹¶ä¸”å°†å½“å‰rootè®¾ä¸ºpreï¼Œå¹¶ä¸”å°†leftè®¾ä¸ºnullã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 37","slug":"leetcode37","date":"2019-10-08T03:15:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/07/leetcode37/","link":"","permalink":"WangHngLeee.github.io/2019/10/07/leetcode37/","excerpt":"","text":"Aamazon è¿‘æœŸé«˜é¢‘é¢˜ ï¼ 5. Longest Palindromic Substring class solution&#123; private lowpos,maxlength; public String longest(String s)&#123; if(s.length()&lt;2)return s; for(int i =0; i &lt; s.length()-1; i++)&#123; valid(s,i,i); //abaæƒ…å†µ valid(s,i,i+1); //baabæƒ…å†µ &#125; return s.substring(lowpos,lowpos+maxlength); &#125; private void valid(String s, int j, int k)&#123; while(j&gt;=0 &amp;&amp; k &lt; s.length() &amp;&amp; charAt(j) == charAt(k))&#123; j--; k++; &#125; if(maxlength&lt;k-j+1)&#123; lowpos = j+!; maxlength = k-j+1; &#125; &#125;&#125; åˆé‡åˆ°äº†ç¬¬äº”é¢˜ï¼ŒåŸºæœ¬æ€è·¯å°±æ˜¯åˆ†abaå’Œbaabçš„æƒ…å†µåˆ†åˆ«å¾ªç¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 36","slug":"leetcode36","date":"2019-10-04T04:15:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/10/04/leetcode36/","link":"","permalink":"WangHngLeee.github.io/2019/10/04/leetcode36/","excerpt":"","text":"Aamazon è¿‘æœŸé«˜é¢‘é¢˜ ï¼ Problem Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 â†’ 4 â†’ 5 â†’ 9 is 4. You can only move either down or right at any point in time. Example 1: Input:[[5, 1], [4, 5]]Output: 4Explanation:Possible paths:5 â†’ 1 â†’ 5 =&gt; min value is 15 â†’ 4 â†’ 5 =&gt; min value is 4Return the max value among minimum values =&gt; max(4, 1) = 4. æœ‰ç‚¹ç±»ä¼¼unique path problemIIï¼Œè¿™é“é¢˜è¦æ±‚è¿”å›æ¯ä¸ªè·¯å¾„ä¸Šæœ€å°å€¼ä¸­çš„æœ€å¤§å€¼ã€‚ class solution&#123; public int maxPath(int[][] grid)&#123; int m = grid.length(); int n = grid[0].length(); int[] dp = new int[n]; dp[0] = grid[0][0]; for(int i = 0 ; i &lt;m;i++)&#123; for(int j = 0 ; j &lt; n ; j ++)&#123; if(!i &amp;&amp; !j)continue; else if(j == 0)dp[j] = Math.min(grid[i][j],dp[j]); else if(i == 0)dp[j] = Math.min(grid[i][j],dp[j-1]); else&#123; dp[j] = Math.max(Math.min(grid[i][j],dp[j]),Math.min(grid[i][j],dp[j-1])); &#125; &#125; &#125; return dp[n-1]; &#125;&#125; å¦‚æœæ˜¯ç¬¬ä¸€è¡Œ åˆ™æ¨ªå‘æ¯”è¾ƒæ›´æ–°æœ€å°å€¼ï¼›è‹¥ç¬¬ä¸€åˆ—ï¼Œçºµå‘æ¯”è¾ƒï¼›å°†å€¼å­˜åœ¨dp[j]é‡Œã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 35","slug":"leetcode35","date":"2019-10-01T19:25:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/01/leetcode35/","link":"","permalink":"WangHngLeee.github.io/2019/10/01/leetcode35/","excerpt":"Aamazon è¿‘æœŸé«˜é¢‘é¢˜ ï¼ 1167. Minimum Cost to Connect Sticks class solution&#123; public int stickscost(int [] sticks)&#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(int s : sticks)&#123; queue.offer(s); &#125; int sum = 0; while(queue.size&gt;1)&#123; int temp = queue.poll() + queue.poll(); sum += temp; queue.offer(temp); &#125; return sum; &#125;&#125; åˆ©ç”¨priority queueçš„è‡ªåŠ¨ä»å°åˆ°å¤§pollçš„é¡ºåºä¼˜ç‚¹ï¼Œè‡ªåŠ¨å‡åºæ‰«æï¼Œæœ€ç»ˆè¿”å›æœ€å°çš„sumã€‚","text":"Aamazon è¿‘æœŸé«˜é¢‘é¢˜ ï¼ 1167. Minimum Cost to Connect Sticks class solution&#123; public int stickscost(int [] sticks)&#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(int s : sticks)&#123; queue.offer(s); &#125; int sum = 0; while(queue.size&gt;1)&#123; int temp = queue.poll() + queue.poll(); sum += temp; queue.offer(temp); &#125; return sum; &#125;&#125; åˆ©ç”¨priority queueçš„è‡ªåŠ¨ä»å°åˆ°å¤§pollçš„é¡ºåºä¼˜ç‚¹ï¼Œè‡ªåŠ¨å‡åºæ‰«æï¼Œæœ€ç»ˆè¿”å›æœ€å°çš„sumã€‚ Amazon | OA 2019 | Find Pair With Given Sum public static void main(String[] args) &#123; int[] nums1 = &#123;1, 10, 25, 35, 60&#125;; int target1 = 90; System.out.println(Arrays.toString(Find2Sum(nums1, target1-30))); int[] nums2 = &#123;20, 50, 40, 25, 30, 10&#125;; int target2 = 90; System.out.println(Arrays.toString(Find2Sum(nums2, target2-30))); int[] nums3 = &#123;50, 20, 10, 40, 25, 30&#125;; int target3 = 90; System.out.println(Arrays.toString(Find2Sum(nums3, target3-30)));&#125;private static int[] Find2Sum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int[] res = new int[2]; for(int i=0;i&lt;nums.length;i++) &#123; if(map.containsKey(nums[i])) &#123; if(nums[i] &gt; mac || nums[map.get(nums[i])] &gt; max)&#123; res[0] = map.get(nums[i]); res[1] = i; max = Math.max(nums[i],nums[map.get(nums[i])]); &#125; &#125; map.put(target - nums[i], i); &#125; return res;&#125; two sumçš„å˜ç§é¢˜ï¼Œæ— ç›¸ç­‰æ¡ä»¶ä¸‹è¦è¿”å›æœ€æ¥è¿‘targetçš„å€¼ã€‚æ‰€ä»¥å¤šä¸€æ­¥åˆ¤æ–­ã€‚å…¶ä½™çš„ä¸two sumä¸€æ ·çš„æ€è·¯ã€‚ 992. Subarrays with K Different Integers class solution&#123; public int substringarray(int[] A, int K)&#123; return atmostk(A,K) - atmost(A,K-1); &#125; int atmost(int[] A, int K)&#123; int i = 0; int ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int j = 0 ; j &lt; A.lengthj ; j++)&#123; if(map.getOrDefault(A[j],0) == 0 )K--; map.put(A[j],map.getOrDefault(A[j],0) + 1); while(K&lt;0)&#123; map.put(A[j],map.get(A[j])-1); if(map.get(A[j])==0)&#123; K++; &#125; i++; &#125; ans + = j - i + 1; &#125; return ans; &#125;&#125; è¦æ±‚æ‰¾å‡ºä¸åŒå…ƒç´ ä¸ªæ•°ä¸ºKçš„subarrayç§ç±»æ•°ï¼Œå…¶å®å¯ä»¥çœ‹ä½œæ˜¯F(K)-F(K-1)çš„ç»“æœï¼Œæœ€å¤šæœ‰Kä¸ªçš„ä¸ªæ•°å‡å»æœ€å¤šæœ‰K-1çš„ä¸ªæ•°å°±æ˜¯åªæœ‰Kä¸ªçš„ç§ç±»æ•°ã€‚ ä½†æ˜¯è¿™é‡Œç”¨sliding window ä¼šå¾ˆéº»çƒ¦ï¼Œæ‰€ä»¥å°±æ£€æŸ¥ä¸€å…±æœ‰å¤šå°‘ä¸ªä¸åŒçš„æ•°ã€‚å½“K&lt;0æ—¶ï¼Œè¯´æ˜å½“å‰windowé‡Œå·²ç»æœ‰ä¸¤ä¸ªä¸åŒçš„æ•°äº†ï¼Œç„¶åä»å·¦è¾¹æ”¶ç¼©windowçš„å¤§å° ansè®°å½•ä»å¼€å§‹åˆ°å½“å‰jä½ç½®ï¼Œç§ç±»æœ€å¤šæœ‰Kä¸ª(&lt;=K)çš„subarrayæ€»æ•°ã€‚ç„¶åå‡å»F(K-1)çš„å³å¯ã€‚ Youtubeè§†é¢‘è¯¦ç»†è®²è§£ï¼š","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 34","slug":"leetcode34","date":"2019-09-26T19:25:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/09/26/leetcode34/","link":"","permalink":"WangHngLeee.github.io/2019/09/26/leetcode34/","excerpt":"","text":"Aamazon è¿‘æœŸé«˜é¢‘é¢˜ ï¼ 937. Reorder Data in Log Files class solution&#123; public String[] reorderLogFiles(String[] logs) &#123; Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;()&#123; @override public int compare(String s1,String s2)&#123; int s1start=index(' '); int s2start=index(' '); char s1fc = s1.charAt(s1start+1); char s2fc = s2.charAt(s2start+1); if(s1fc &lt;= '9')&#123; if(s2fc &lt;= '9')&#123; return '0'; &#125; else return 1; &#125; if(s2fc&lt;='9')&#123; return -1; &#125; // åé¢æ˜¯é’ˆå¯¹ä¸¤ä¸ªä½ç½®éƒ½æ˜¯å­—æ¯çš„æƒ…å†µï¼Œå¦‚æœéƒ½ä¸ºé›¶ï¼Œè¯´æ˜è¯¥å­—æ¯åé¢å‡ä¸ºæ•°å­—æˆ–è€…å­—æ¯ï¼Œåˆ™éœ€è¦ä»0åˆ°å½“å‰åˆ°s1startå’Œs2startè¿›è¡Œé‡æ–°æ‰«æã€‚ // ç”¨s1startå’Œs2startè¿›è¡Œæ¯”è¾ƒ int precomp = s1.substring(s1start+1).compareTo(s1.substring(s2start+1)); if(precomp==0)&#123; return s1.substring(0,s1start).compareTo(s2.substring(0,s2start)); &#125; return precomp; &#125; &#125; //ç¬¬ä¸€ä½æ˜¯è¢«sortåˆ°å¯¹è±¡ï¼Œç¬¬äºŒä½æ˜¯å‚è€ƒé¡ºåºï¼Œcomparatorä¼šå°†å„ä¸ªå…ƒç´ è·Ÿæ¯”è¾ƒç»“æœè¿›è¡Œå…³è”ã€‚ Array.sort(logs,comp); return logs; &#125;&#125; @override çš„ç›®çš„æ˜¯ä¸ºäº†é˜²æ­¢åœ¨æ›´æ”¹çˆ¶ç±»æ—¶å‡ºé”™ï¼Œä¸åŠ ä¹Ÿå¯ä»¥ã€‚åˆ©ç”¨javaå†…ç½®comparatoræ¥å£ï¼Œå¯¹æ¯ä¸€ä¸ªlogè¿›è¡Œä¸»åŠ¨æ’åºï¼Œå°†æ’åºç»“æœå’Œlogå¯¹åº”èµ·æ¥ï¼Œå¯¹æ•°å­—å’Œå­—æ¯çš„æƒ…å†µè¿›è¡Œè®¾ç½®ã€‚ å­—æ¯å’Œå­—æ¯ä¹‹é—´comparatorä¼šè‡ªåŠ¨è¿›è¡Œæ’åºï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å¯¹æ•°å­—-æ•°å­— / æ•°å­—-å­—æ¯å¯¹æƒ…å†µè¿›è¡Œè®¨è®ºã€‚ comparatorç¬¬ä¸€ä½æ˜¯éœ€è¦è¿›è¡Œå…³è”èµ‹å€¼çš„å¯¹è±¡ï¼Œåä¸€ä½æ˜¯è¿›è¡Œæ¯”è¾ƒçš„å‚è€ƒä½ã€‚ è‹¥ä¸¤è€…éƒ½æ˜¯æ•°å­—ï¼Œåˆ™è¿”å›0ï¼Œä½ç½®ä¸åŠ¨ï¼ŒäºŒè€…priorityç›¸åŒï¼› è‹¥ç¬¬ä¸€ä¸ªæ˜¯æ•°å­—ï¼Œç¬¬äºŒä¸ªæ˜¯å­—æ¯ï¼Œè¿”å›1ï¼Œåè€…priorityé«˜äºå‰è€…ï¼ˆè¦æŠŠç¬¦åˆè¦æ±‚çš„æå‰ï¼Œåˆå› ä¸ºæ˜¯å‡åºæ’åºï¼Œæ‰€ä»¥è¦å°†priorityä½çš„å…³è”å€¼è®¾ç½®çš„å¤§ è‹¥ç¬¬ä¸€ä¸ªæ˜¯å­—æ¯ï¼Œç¬¬äºŒä¸ªæ˜¯æ•°å­—ï¼Œè¿”å›-1ï¼Œå‰è€…æ­¤æ—¶priorityæœ€é«˜ã€‚ è‹¥äºŒè€…éƒ½æ˜¯å­—æ¯ï¼Œåˆ™è¿›è¡Œprecompèµ‹å€¼ï¼Œå¦‚æœè¿˜æ˜¯æ’ç­‰äº0ï¼Œélogå•è¯åé¢å…¨æ˜¯æ•°å­—oréƒ½æ˜¯å•è¯ï¼Œæ‰€ä»¥è¦å¯¹0-s1start/s2startçš„substringå†æ‰«æï¼Œå¯¹s1startå’Œs2startä½ç½®è¿›è¡Œæœ€åæ¯”è¾ƒã€‚ æœ€åå¯¹logç”¨compçš„å‚è€ƒå€¼è¿›è¡Œæ’åºå³å¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 33","slug":"leetcode33","date":"2019-09-25T18:25:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/09/25/leetcode33/","link":"","permalink":"WangHngLeee.github.io/2019/09/25/leetcode33/","excerpt":"863. All Nodes Distance K in Binary Tree class solution&#123; Map&lt;Treenode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); search(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); &#125; return -1; &#125; private void search(TreeNode root, int distance, int K, List&lt;Integer&gt; res)&#123; if(root==null)return; if(map.containsKey(root))&#123; distance=map.get(root); &#125; if(dis==K)&#123; res.add(root.val); &#125; search(root.left,distance+1,K,res); search(root.right,distance+1,K,res); &#125;&#125; ç”¨HashMapå­˜ä½ä»æ ¹rootåˆ°target çš„pathä¸Šæ‰€æœ‰èŠ‚ç‚¹ç¦»targetçš„è·ç¦»ã€‚ æ¥ç€ç”¨dfsæ–¹æ³•å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œæ‰«æã€‚å¦‚æœmapæœ‰å½“å‰çš„èŠ‚ç‚¹ï¼Œè¯´æ˜åœ¨root-targetçš„pathä¸Šã€‚ç›´æ¥å°†distanceè®¾ç½®ä¸ºè¯¥èŠ‚ç‚¹åˆ°targetçš„è·ç¦»ã€‚ å¦‚æœå½“å‰èŠ‚ç‚¹ä¸åœ¨mapä¸­ä¸”è·ç¦»ä¸æ˜¯Kï¼ˆåœ¨targetçš„å­æ ‘é‡Œï¼‰,åˆ™ä¸‹ä¸€æ¬¡dfså°†distanceå€¼åŠ 1ã€‚","text":"863. All Nodes Distance K in Binary Tree class solution&#123; Map&lt;Treenode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); search(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); &#125; return -1; &#125; private void search(TreeNode root, int distance, int K, List&lt;Integer&gt; res)&#123; if(root==null)return; if(map.containsKey(root))&#123; distance=map.get(root); &#125; if(dis==K)&#123; res.add(root.val); &#125; search(root.left,distance+1,K,res); search(root.right,distance+1,K,res); &#125;&#125; ç”¨HashMapå­˜ä½ä»æ ¹rootåˆ°target çš„pathä¸Šæ‰€æœ‰èŠ‚ç‚¹ç¦»targetçš„è·ç¦»ã€‚ æ¥ç€ç”¨dfsæ–¹æ³•å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œæ‰«æã€‚å¦‚æœmapæœ‰å½“å‰çš„èŠ‚ç‚¹ï¼Œè¯´æ˜åœ¨root-targetçš„pathä¸Šã€‚ç›´æ¥å°†distanceè®¾ç½®ä¸ºè¯¥èŠ‚ç‚¹åˆ°targetçš„è·ç¦»ã€‚ å¦‚æœå½“å‰èŠ‚ç‚¹ä¸åœ¨mapä¸­ä¸”è·ç¦»ä¸æ˜¯Kï¼ˆåœ¨targetçš„å­æ ‘é‡Œï¼‰,åˆ™ä¸‹ä¸€æ¬¡dfså°†distanceå€¼åŠ 1ã€‚ 957. Prison Cells After N Days class solution&#123; public int[] prison(int[] cells, int N)&#123; for( N = (N-1)%14 + 1 ; N &gt; 0 ; N--)&#123; int[]cells2 = new int[8]; for(int i = 1; i&lt;7;i++)&#123; cell2[i] = cells[i1]==cells[i+1]? 1:0; &#125; cells = cell2; &#125; return cells; &#125;&#125; å…³é”®è¦æ‰¾åˆ°è¿™é“é¢˜çš„è§„å¾‹ï¼Œä¸ƒæ¬¡ä¸€å¾ªç¯ï¼Œcell loop7æ¬¡åä¼šå›åˆ°åŸå§‹çŠ¶æ€ï¼Œæ‰€ä»¥ç”¨(N-1)%14+1æ¥åˆ¤æ–­æ€»çš„å¾ªç¯æ¬¡æ•°ï¼Œåªéœ€è¦æ‰¾åˆ°å½“å‰Næ˜¯7æ¬¡é‡Œé¢çš„å“ªä¸€æ¬¡ã€‚ æ³¨æ„ä¸è®ºå¼€å¤´å’Œç»“å°¾æ˜¯ä»€ä¹ˆï¼Œç¬¬äºŒæ¬¡å¼€å§‹å…¨éƒ¨å˜ä¸º0ï¼Œå› ä¸ºæ²¡æœ‰adjenctï¼Œæ‰€ä»¥å°†cell2ç›´æ¥èµ‹å€¼ç»™cellsï¼Œå› ä¸ºcell2åˆå§‹æ—¶å¼€å¤´å’Œç»“å°¾å‡æ˜¯0ã€‚ Minimum Cost to Merge Stones class Solution &#123; public int mergeStones(int[] stones, int K) &#123; int n = stones.length; if ((n - 1) % (K - 1) &gt; 0) return -1; int[] prefix = new int[n+1]; for (int i = 0; i &lt; n; i++) prefix[i + 1] = prefix[i] + stones[i]; int[][] dp = new int[n][n]; for (int m = K; m &lt;= n; ++m) for (int i = 0; i + m &lt;= n; ++i) &#123; int j = i + m - 1; dp[i][j] = Integer.MAX_VALUE; for (int mid = i; mid &lt; j; mid += K - 1) dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + 1][j]); if ((j - i) % (K - 1) == 0) dp[i][j] += prefix[j + 1] - prefix[i]; &#125; return dp[0][n - 1]; &#125;&#125; é¦–å…ˆåˆ¤æ–­é•¿åº¦èƒ½ä¸èƒ½è¢«kæ•´é™¤ã€‚ ç”¨prefixå­˜ä½æŒ‰é¡ºåºç›¸åŠ çš„å’Œï¼Œå¤‡ç”¨ã€‚ ç”¨dpå­˜ä½å½“å‰ä¸¤ä¸ªä½ç½®ä¹‹é—´çš„min costã€‚æ³¨æ„ç”¨midå¯¹iï¼Œjä¹‹é—´çš„ä½ç½®è¿›è¡Œminæ‰«æï¼Œä¿è¯æ¯æ¬¡éƒ½å–åˆ°æœ€å°å€¼ã€‚ å¯¹mid loopå®Œåï¼Œå°†prefixé‡Œé¢iå’Œjçš„ç›¸å¯¹ä½ç½®çš„å€¼ç›¸å‡å¹¶ä¸”èµ‹ç»™dp[i][j]ã€‚ Combinations class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(ans,new ArrayList&lt;Integer&gt;(),1 ,n,k); return ans; &#125; public static void combine(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, int start, int n, int k)&#123; if(k == 0)ans.add(new ArrayList&lt;Integer&gt;(comb)); for(int i =start; i&lt;=n;i++)&#123; comb.add(i); combine(ans,comb,i+1,n,k-1); comb.remove(comb.size()-1); &#125; &#125;&#125; å›æº¯æ–¹æ³•ï¼Œè®°å¾—æœ€åå°†combé•¿åº¦-1ï¼› 22. Generate Parentheses class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res, new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res ,StringBuilder sb, int open, int close, int n)&#123; if(open == n &amp;&amp; close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+1,close,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125; å¤ä¹ ã€‚å›æº¯æ–¹æ³•ï¼Œé¦–å…ˆåˆ¤æ–­openå’Œcloseçš„å€¼ï¼Œè®°å¾—æ¯æ­¥æœ€åä¹Ÿè¦æŠŠlength-1.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 32","slug":"leetcode32","date":"2019-09-21T00:25:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/09/20/leetcode32/","link":"","permalink":"WangHngLeee.github.io/2019/09/20/leetcode32/","excerpt":"","text":"269. Alien Dictionary class solution&#123; public String alienOrder(String[] words) &#123; Map&lt;Character,Set&lt;Character&gt;&gt; map = new HashMap&lt;Character,Set&lt;Character&gt;&gt;(); Map&lt;Character,Integer&gt; degree = new HashMap&lt;Character,Integer&gt;(); String res = \"\"; if(words==null || words.length() == 0)return res; for(String s :words)&#123; for(char c: s.toCharArray())&#123; degree.get(C,0); &#125; &#125; for(int i = 0 ; i &lt; words.length ; i ++)&#123; String cur = words[i]; String next = words[i+1]; int length = Math.min(cur.length(),next.length()); for(int j = 0 ; j &lt;length;j++)&#123; char c1 = cur.charAt(j); char c2 = next.charAt(j); if(c1!=c2)&#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); if(map.containsKey(c1))set = map.get(c1); if(!set.contains(c2))&#123; set.add(c2); map.put(c1,set); degree.put(c2,degree.get(c2)+1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; q=new LinkedList&lt;Character&gt;(); for(char c : degree.keySet())&#123; if(degree.get(c) q.add(c); &#125; while(!q.isEmpty())&#123; char c = q.remove; res += c; if(map.contains(c))&#123; for(char c2 : map.get(C))&#123; degree.put(c2,degree.get(c2)-1); if(degree.get(c2)==0)&#123; q.add(c2); &#125; &#125; &#125; &#125; if(res.length != degree.size())return \"\"; return res; &#125;&#125; ç”¨mapæ„å»ºgraphï¼Œdegreeå­˜æ¯ä¸ªå­—æ¯çš„å…¥åº¦ï¼Œå°†æ¯ä¸ªå­—æ¯å…¥åº¦è®¾ç½®ä¸º0. ç›¸é‚»çš„å•è¯ï¼Œç¬¬ä¸€ä¸ªä¸åŒçš„å­—æ¯å‡ºç°æ—¶ï¼Œå‰ä¸€ä¸ªåœ¨åä¸€ä¸ªä¹‹å‰ï¼Œç„¶åå¯¹æ¯ä¸€ä¸ªå­—æ¯çš„mapè¿›è¡Œæ›´æ–°. æœ€åç”¨queueæ¥å¤„ç†ç»“æœï¼Œå°†degreeä¸º0çš„è¾“å…¥ï¼Œç„¶åä¸€ä¸ªä¸€ä¸ªremoveï¼Œå¹¶å¯¹è¯¥å­—æ¯è¿›è¡Œæ‰«æï¼Œå†å°†å…¥åº¦ä¸º0çš„å­˜å…¥queueã€‚ä»¥æ­¤ç±»æ¨ã€‚ 819. Most Common Word class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; String[] words = paragraph.toLowerCase().split(\"\\\\W++)\"); Set&lt;String&gt; set = new Hashset&lt;&gt;(); for(String word :banned)&#123; set.add(word); &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for(String word : words)&#123; if(!set.contains(word))&#123; map.put(word,map.getOrDefault(word,0)+1); &#125; &#125; int max = 0; String res = ''; for(String str : map.keySet())&#123; if(map.get(str) &gt; max)&#123; max = map.get(str); res = str; &#125; &#125; return res; æ­£åˆ™è¡¨è¾¾å¼ä¸­ï¼Œ\\wï¼ˆå°å†™wï¼‰ è¡¨ç¤ºå­—ç¬¦, \\Wï¼ˆå¤§å†™W)è¡¨ç¤ºéå­—ç¬¦. â€˜+â€™ æˆ‘ä»¬è¦æ»¡è¶³å¤šé¡¹ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 31","slug":"leetcode31","date":"2019-09-12T18:25:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/09/12/leetcode31/","link":"","permalink":"WangHngLeee.github.io/2019/09/12/leetcode31/","excerpt":"","text":"126. Word Ladder II class solution&#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (!wordList.contains(endWord)) &#123; return 0; &#125; Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Set&lt;String&gt; begin = new HashSet&lt;&gt;(); Set&lt;String&gt; end = new HashSet&lt;&gt;(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); begin.add(beginWord); end.add(endWrod); int step = 1; while(!begin.isEmpty() &amp;&amp; !end.isEmpty())&#123; if(begin.size() &lt; end.size())&#123; Set&lt;String&gt; set = beginSet; beginSet = endSet; endSet = set; &#125; Set&lt;String&gt; temp = new HashSet&lt;&gt;(); for(String word : begin)&#123; char[] chrs = word.charToArray(); for(int i = 0 ; i &lt; chrs.length ; i++)&#123; for(char c = 'a' ; c &lt;= 'z'; c++&gt;&#123; char old = chrs[i]; chrs[i] = c; String target = String.valueOf(chrs); if(end.contains(target))&#123; return step + 1; &#125; if(!visited.contains(target) &amp;&amp; dict.contains(target))&#123; visited.add(target); temp.add(target); &#125; chrs[i] = old; &#125; &#125; &#125; begin = temp; step++; &#125; return 0; &#125;&#125; ä½¿ç”¨åŒå‘æ‰«æï¼Œbeginå’Œendä¸€èµ·æ‰«æï¼Œç›´åˆ°æŸä¸€ä¸ªsetä¸­å‡ºç°äº†å¦å¤–ä¸€ä¸ªå•è¯ä¸ºæ­¢ï¼Œå…·ä½“è®²è§£å¦‚ä¸‹è§†é¢‘ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Ruby learning notes(1)","slug":"ruby","date":"2019-08-27T20:35:09.000Z","updated":"2019-08-27T21:17:52.000Z","comments":true,"path":"2019/08/27/ruby/","link":"","permalink":"WangHngLeee.github.io/2019/08/27/ruby/","excerpt":"å‰è¨€ ç”±äºé€‰äº†CSC517çš„oopéœ€è¦ç”¨rubyæ¥åšprojectï¼Œè™½ç„¶rubyè¾ƒä¸ºå†·é—¨ï¼Œä½†æ˜¯å¤šå­¦ä¸€é—¨è¯­è¨€æ€»æ˜¯å¥½çš„ã€‚ ç¯å¢ƒè®¾ç½®ä»¥åŠä¸€äº›åŸºæœ¬æ“ä½œå°±è·³è¿‡äº†ã€‚ Ruby è¯­æ³• rubyä¸­è¾“å‡ºç”¨puts puts \"Hello Ruby!\" Rubyä¸­çš„è¡Œå°¾ rubyä¸­ç”¨åˆ†å·ï¼›æˆ–è€…æ¢è¡Œç¬¦\\næ¥è¡¨ç¤ºè¡Œå°¾ã€‚ Rubyä¸­çš„Here Document Here Document&quot; æ˜¯æŒ‡å»ºç«‹å¤šè¡Œå­—ç¬¦ä¸²ã€‚ åœ¨ &lt;&lt; ä¹‹åï¼Œkå¯ä»¥æŒ‡å®šä¸€ä¸ªå­—ç¬¦ä¸²æˆ–æ ‡è¯†ç¬¦æ¥ç»ˆæ­¢å­—ç¬¦ä¸²ï¼Œä¸”å½“å‰è¡Œä¹‹åç›´åˆ°ç»ˆæ­¢ç¬¦ä¸ºæ­¢çš„æ‰€æœ‰è¡Œæ˜¯å­—ç¬¦ä¸²çš„å€¼ã€‚ å¦‚æœç»ˆæ­¢ç¬¦ç”¨å¼•å·æ‹¬èµ·ï¼Œå¼•å·çš„ç±»å‹å†³å®šäº†é¢å‘è¡Œçš„å­—ç¬¦ä¸²ç±»å‹ã€‚æ³¨æ„&lt;&lt; å’Œç»ˆæ­¢ç¬¦ä¹‹é—´å¿…é¡»æ²¡æœ‰ç©ºæ ¼. #!/usr/bin/ruby -w# -*- coding : utf-8 -*- print &lt;&lt;EOF è¿™æ˜¯ç¬¬ä¸€ç§æ–¹å¼åˆ›å»ºhere document ã€‚ å¤šè¡Œå­—ç¬¦ä¸²ã€‚EOF print &lt;&lt;\"EOF\"; # ä¸ä¸Šé¢ç›¸åŒ è¿™æ˜¯ç¬¬äºŒç§æ–¹å¼åˆ›å»ºhere document ã€‚ å¤šè¡Œå­—ç¬¦ä¸²ã€‚EOF print &lt;&lt;`EOC` # æ‰§è¡Œå‘½ä»¤ echo hi there echo lo thereEOC print &lt;&lt;\"foo\", &lt;&lt;\"bar\" # æ‚¨å¯ä»¥æŠŠå®ƒä»¬è¿›è¡Œå †å  I said foo.foo I said bar.bar","text":"å‰è¨€ ç”±äºé€‰äº†CSC517çš„oopéœ€è¦ç”¨rubyæ¥åšprojectï¼Œè™½ç„¶rubyè¾ƒä¸ºå†·é—¨ï¼Œä½†æ˜¯å¤šå­¦ä¸€é—¨è¯­è¨€æ€»æ˜¯å¥½çš„ã€‚ ç¯å¢ƒè®¾ç½®ä»¥åŠä¸€äº›åŸºæœ¬æ“ä½œå°±è·³è¿‡äº†ã€‚ Ruby è¯­æ³• rubyä¸­è¾“å‡ºç”¨puts puts \"Hello Ruby!\" Rubyä¸­çš„è¡Œå°¾ rubyä¸­ç”¨åˆ†å·ï¼›æˆ–è€…æ¢è¡Œç¬¦\\næ¥è¡¨ç¤ºè¡Œå°¾ã€‚ Rubyä¸­çš„Here Document Here Document&quot; æ˜¯æŒ‡å»ºç«‹å¤šè¡Œå­—ç¬¦ä¸²ã€‚ åœ¨ &lt;&lt; ä¹‹åï¼Œkå¯ä»¥æŒ‡å®šä¸€ä¸ªå­—ç¬¦ä¸²æˆ–æ ‡è¯†ç¬¦æ¥ç»ˆæ­¢å­—ç¬¦ä¸²ï¼Œä¸”å½“å‰è¡Œä¹‹åç›´åˆ°ç»ˆæ­¢ç¬¦ä¸ºæ­¢çš„æ‰€æœ‰è¡Œæ˜¯å­—ç¬¦ä¸²çš„å€¼ã€‚ å¦‚æœç»ˆæ­¢ç¬¦ç”¨å¼•å·æ‹¬èµ·ï¼Œå¼•å·çš„ç±»å‹å†³å®šäº†é¢å‘è¡Œçš„å­—ç¬¦ä¸²ç±»å‹ã€‚æ³¨æ„&lt;&lt; å’Œç»ˆæ­¢ç¬¦ä¹‹é—´å¿…é¡»æ²¡æœ‰ç©ºæ ¼. #!/usr/bin/ruby -w# -*- coding : utf-8 -*- print &lt;&lt;EOF è¿™æ˜¯ç¬¬ä¸€ç§æ–¹å¼åˆ›å»ºhere document ã€‚ å¤šè¡Œå­—ç¬¦ä¸²ã€‚EOF print &lt;&lt;\"EOF\"; # ä¸ä¸Šé¢ç›¸åŒ è¿™æ˜¯ç¬¬äºŒç§æ–¹å¼åˆ›å»ºhere document ã€‚ å¤šè¡Œå­—ç¬¦ä¸²ã€‚EOF print &lt;&lt;`EOC` # æ‰§è¡Œå‘½ä»¤ echo hi there echo lo thereEOC print &lt;&lt;\"foo\", &lt;&lt;\"bar\" # æ‚¨å¯ä»¥æŠŠå®ƒä»¬è¿›è¡Œå †å  I said foo.foo I said bar.bar Ruby ä¸­çš„BEGIN/END è¯­å¥ BEGIN&#123; cdoe&#125; è¡¨ç¤ºcodeä¼šåœ¨ç¨‹åºè¿è¡Œä¹‹å‰è°ƒç”¨ ä¾‹å­ï¼š puts \"this is main code\"BEGIN&#123; puts \"this is begin code\"&#125; ç»“æœï¼š this is begin codethis is main code END&#123; CODE&#125; è¡¨æ˜codeä¼šåœ¨ç¨‹åºè¿è¡Œä¹‹åè°ƒç”¨ ä¾‹å­ï¼š END&#123; puts \"this is END code\"&#125;puts \"this is main code\"BEGIN&#123; puts \"this is begin code\"&#125; ç»“æœï¼š this is begin codethis is main code this is end code Ruby ä¸­çš„æ•°ç»„ æ•°ç»„å­—é¢é‡é€šè¿‡[]ä¸­ä»¥é€—å·åˆ†éš”å®šä¹‰ï¼Œä¸”æ”¯æŒrangeå®šä¹‰ã€‚ ï¼ˆ1ï¼‰æ•°ç»„é€šè¿‡[]ç´¢å¼•è®¿é—® ï¼ˆ2ï¼‰é€šè¿‡èµ‹å€¼æ“ä½œæ’å…¥ã€åˆ é™¤ã€æ›¿æ¢å…ƒç´  ï¼ˆ3ï¼‰é€šè¿‡+ï¼Œï¼å·è¿›è¡Œåˆå¹¶å’Œåˆ é™¤å…ƒç´ ï¼Œä¸”é›†åˆåšä¸ºæ–°é›†åˆå‡ºç° ï¼ˆ4ï¼‰é€šè¿‡&lt;&lt;å·å‘åŸæ•°æ®è¿½åŠ å…ƒç´  ï¼ˆ5ï¼‰é€šè¿‡*å·é‡å¤æ•°ç»„å…ƒç´  ï¼ˆ6ï¼‰é€šè¿‡ï½œå’Œ&amp;ç¬¦å·åšå¹¶é›†å’Œäº¤é›†æ“ä½œï¼ˆæ³¨æ„é¡ºåºï¼‰ ä¸‹é¢ä¾‹å­å®Œæˆäº†æ•°ç»„çš„é¡ºåºè¾“å‡ºï¼š arr = [\"a\",\"bbb\",\"123\",\"null\",]arr.each do |i| puts iend Rubyçš„å“ˆå¸Œç±»å‹ Ruby å“ˆå¸Œæ˜¯åœ¨å¤§æ‹¬å·å†…æ”¾ç½®ä¸€ç³»åˆ—é”®/å€¼å¯¹ï¼Œé”®å’Œå€¼ä¹‹é—´ä½¿ç”¨é€—å·å’Œåºåˆ— =&gt; åˆ†éš”ã€‚å°¾éƒ¨çš„é€—å·ä¼šè¢«å¿½ç•¥ã€‚ hsh = colors = &#123;\"red\" =&gt; 0xf00, \"green\" =&gt; 0x0f0, \"blue\" =&gt; 0x00f&#125;hsh.each do |key,value| pring key,\"is\",value,\"\\n\"end Ruby èŒƒå›´ç±»å‹ ä¸€ä¸ªèŒƒå›´è¡¨ç¤ºä¸€ä¸ªåŒºé—´ã€‚ èŒƒå›´æ˜¯é€šè¿‡è®¾ç½®ä¸€ä¸ªå¼€å§‹å€¼å’Œä¸€ä¸ªç»“æŸå€¼æ¥è¡¨ç¤ºã€‚èŒƒå›´å¯ä½¿ç”¨ sâ€¦e å’Œ sâ€¦e æ¥æ„é€ ï¼Œæˆ–è€…é€šè¿‡ Range.new æ¥æ„é€ ã€‚ ä½¿ç”¨ â€¦ æ„é€ çš„èŒƒå›´ä»å¼€å§‹å€¼è¿è¡Œåˆ°ç»“æŸå€¼ï¼ˆåŒ…å«ç»“æŸå€¼ï¼‰ã€‚ä½¿ç”¨ â€¦ æ„é€ çš„èŒƒå›´ä»å¼€å§‹å€¼è¿è¡Œåˆ°ç»“æŸå€¼ï¼ˆä¸åŒ…å«ç»“æŸå€¼ï¼‰ã€‚å½“ä½œä¸ºä¸€ä¸ªè¿­ä»£å™¨ä½¿ç”¨æ—¶ï¼ŒèŒƒå›´ä¼šè¿”å›åºåˆ—ä¸­çš„æ¯ä¸ªå€¼ã€‚ èŒƒå›´ (1â€¦5) æ„å‘³ç€å®ƒåŒ…å«å€¼ 1, 2, 3, 4, 5 èŒƒå›´ (1â€¦5) æ„å‘³ç€å®ƒåŒ…å«å€¼ 1, 2, 3, 4 (10..15).each do|i| print i,' 'end è¾“å‡ºä¸º 10 11 12 13 14 15","categories":[{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/categories/ruby/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/tags/ruby/"},{"name":"OOP","slug":"OOP","permalink":"WangHngLeee.github.io/tags/OOP/"}]},{"title":"Leetcode EveryDay 30","slug":"leetcode30","date":"2019-08-22T13:25:09.000Z","updated":"2020-02-03T01:16:22.106Z","comments":true,"path":"2019/08/22/leetcode30/","link":"","permalink":"WangHngLeee.github.io/2019/08/22/leetcode30/","excerpt":"560. Subarray Sum Equals K class soluiton&#123; public int subarray(int[] nums, int k)&#123; if(nums.length == 0) return 0; int sum = 0, res = 0; map.put(0,1); for(int cur ; nums)&#123; sum+=cur; if(map.containsKey(sum-k))res+=map.get(sum-k); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return res; &#125;&#125; presum + hashmap çš„æ–¹æ³• sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmapçš„key --&gt; hashmapçš„key = sum - k hashmapä¸­å­˜çš„æ˜¯&lt;sum,sumå‡ºç°çš„æ¬¡æ•°&gt;ï¼›","text":"560. Subarray Sum Equals K class soluiton&#123; public int subarray(int[] nums, int k)&#123; if(nums.length == 0) return 0; int sum = 0, res = 0; map.put(0,1); for(int cur ; nums)&#123; sum+=cur; if(map.containsKey(sum-k))res+=map.get(sum-k); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return res; &#125;&#125; presum + hashmap çš„æ–¹æ³• sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmapçš„key --&gt; hashmapçš„key = sum - k hashmapä¸­å­˜çš„æ˜¯&lt;sum,sumå‡ºç°çš„æ¬¡æ•°&gt;ï¼› 547. Friend Circles class solution&#123; public int findfriend(int[][] M)&#123; boolean[] visited = new boolean[M.length]; int count = 0; for(int i = 0 ; i &lt; M.length; i++)&#123; if(!visited[i])&#123; dfs(M,visited,i); count++; &#125; &#125; return count; &#125; private void dfs(int[][] M,boolean[] visited, int person)&#123; for(int other = 0; other &lt; M.length; other++)&#123; if(M[person][other] == 1 &amp;&amp; !visited[other])&#123; visited[other] = true; dfs(M,visited,other); &#125; &#125; &#125;&#125; æƒ³è±¡æˆä¸€ä¸ªçŸ©é˜µï¼Œå·¦è¾¹æ˜¯personï¼Œä¸Šé¢æ˜¯otherï¼ˆç›¸å¯¹çš„ï¼‰ï¼Œç„¶åå…ˆä»personå¼€å§‹dfsï¼Œdfsä¸­åˆé€’å½’åœ°å¯¹personå¯¹åº”çš„otherè¿›è¡Œdfsï¼Œ å°†è¿™ä¸ªotherçœ‹æˆæ–°çš„personè¿›è¡Œdfsï¼Œæœ‰ç‚¹ç±»ä¼¼å›åˆåˆ¶ï¼Œperson - other - person - other éƒ½æ˜¯ç›¸å¯¹çš„ã€‚ 652. Find Duplicate Subtrees class solution&#123; public List&lt;TreeNode&gt; findduplicate(TreeNode root)&#123; List&lt;TreeNode&gt; res = new LinkedList&lt;&gt;(); fint(root,new HashMap&lt;&gt;(),res); return res; &#125; public String find(TreeNode cur, Map&lt;String&gt; map, List&lt;TreeNode&gt; res)&#123; if(cur == null)return \"#\"; String temp = cur.val + \",\" + find(cur.left,map,res) + \",\" + find(cur.right,map,res); if(map.getOrDefault(temp,0) == 1)res.add(cur); map.put(temp,map.getOrDefault(temp,0)+1); return temp; &#125;&#125; ä½¿ç”¨hashmapè®°å½•æ¯ä¸ªå­æ ‘ç»è¿‡å“ˆå¸Œåçš„æ•°é‡ï¼Œå“ˆå¸Œæ–¹æ³•å¯ä»¥ç”¨æœ€ç®€å•çš„å‰åºéå†ï¼Œå³ æ ¹,å·¦å­æ ‘,å³å­æ ‘ çš„æ–¹å¼é€’å½’æ„é€ ã€‚ è‹¥å‘ç°å½“å‰å­æ ‘åœ¨å“ˆå¸Œè¡¨ç¬¬äºŒæ¬¡å‡ºç°ï¼Œåˆ™å°†è¯¥ç»“ç‚¹è®°å…¥resåˆ—è¡¨ã€‚ 187. Repeated DNA Sequences class solution&#123; public List&lt;String&gt; find(String s)&#123; Set seen = new Hashset(); Set repeated = new Hashset(); for(int i = 0; i+9&lt;s.length();i++)&#123; String ten = s.substring(i,i+10); if(!seen.add(ten))&#123; repeated.add(ten); &#125; &#125; return new ArrayList(repeated); &#125;&#125; åˆ©ç”¨hashsetä¸èƒ½æ·»åŠ é‡å¤å…ƒç´ çš„ç‰¹å¾å’Œsliding windowç»“åˆçš„æ–¹æ³•ï¼Œä»iåˆ°i+10çš„èŒƒå›´å†…æ‰«æ å¦‚æœseené‡Œé¢ä¸èƒ½æ·»åŠ è¯¥10ä½stringï¼Œè¡¨æ˜å·²ç»æœ‰è¿‡ï¼Œæ‰€ä»¥æ·»åŠ åˆ°repeatedä¸­ã€‚ 1.Two Sum class solution&#123; public twosum(int[]nums,int target)&#123; int[]res = new int[2]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt;nums.length;i++)&#123; if(map.containsKey(target - nums[i]))&#123; res[1] = i; res[0] = map.get(target - nums[i]); return res; &#125; map.put(nums[i],i); &#125; &#125;&#125; ç»å…¸çš„two sumï¼Œjavaç‰ˆæœ¬æ³¨æ„å®šä¹‰hashmapçš„å†™æ³•ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 29","slug":"leetcode29","date":"2019-08-05T12:25:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/08/05/leetcode29/","link":"","permalink":"WangHngLeee.github.io/2019/08/05/leetcode29/","excerpt":"","text":"Permutations II (contains duplicates) class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, boolean[nums.length]); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist, int[] nums, boolean[] used)&#123; if(templist.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(templist)); &#125;else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1])continue; used[i] = true; templist.add(nums[i]); backtrack(list,templist,nums,used); used[i] = false; templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; è·Ÿ Permutationsçš„è§£æ³•ä¸€æ ·ï¼Œå°±æ˜¯è¦è€ƒè™‘â€œå»é‡â€ã€‚å…ˆå¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œè¿™æ ·åœ¨DFSçš„æ—¶å€™ï¼Œå¯ä»¥å…ˆåˆ¤æ–­å‰é¢çš„ä¸€ä¸ªæ•°æ˜¯å¦å’Œè‡ªå·±ç›¸ç­‰ï¼Œç›¸ç­‰çš„æ—¶å€™åˆ™å‰é¢çš„æ•°å¿…é¡»ä½¿ç”¨äº†ï¼Œè‡ªå·±æ‰èƒ½ä½¿ç”¨ï¼Œè¿™æ ·å°±ä¸ä¼šäº§ç”Ÿé‡å¤çš„æ’åˆ—äº†ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 28","slug":"leetcode28","date":"2019-08-05T00:35:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/08/04/leetcode28/","link":"","permalink":"WangHngLeee.github.io/2019/08/04/leetcode28/","excerpt":"38. Count and Say class solution&#123; public String countandsay(int n)&#123; if(n&lt;=0)return -1; String res = '1'; for(int i = 1; i&lt;n; i++)&#123; res = build(res); &#125; return res; &#125; private build(String res)&#123; StringBuiler sb = new StringBuilder(); int idx = 0; while(idx&lt;res.length)&#123; char val = res.charAt(idx); int count = 0; while(idx &lt; res.length &amp;&amp; res.charAt(p) == val )&#123; p++; count++; &#125; sb.append(String.valueOf(count); sb.append(val); &#125; return sb.toString(); &#125;&#125; åˆå§‹åªæœ‰ä¸€ä¸ª1ï¼Œç„¶åè®¡ç®—ç›¸åŒæ•°å­—çš„ä¸ªæ•°countï¼Œç„¶åå°†countå’Œå½“å‰valçš„å€¼åŠ å…¥resä¸­ï¼Œç»§ç»­å¾ªç¯è®¡ç®—ã€‚ 1 11 21 1211 111221 312211 â€¦ 1 ä¸€ä¸ª1(11) ä¸¤ä¸ª1(21) ä¸€ä¸ª2ä¸€ä¸ª1(1211) ä¸€ä¸ª1ä¸€ä¸ª2ä¸¤ä¸ª1(111221) ä¸‰ä¸ª1ä¸¤ä¸ª2ä¸€ä¸ª1(312211)â€¦","text":"38. Count and Say class solution&#123; public String countandsay(int n)&#123; if(n&lt;=0)return -1; String res = '1'; for(int i = 1; i&lt;n; i++)&#123; res = build(res); &#125; return res; &#125; private build(String res)&#123; StringBuiler sb = new StringBuilder(); int idx = 0; while(idx&lt;res.length)&#123; char val = res.charAt(idx); int count = 0; while(idx &lt; res.length &amp;&amp; res.charAt(p) == val )&#123; p++; count++; &#125; sb.append(String.valueOf(count); sb.append(val); &#125; return sb.toString(); &#125;&#125; åˆå§‹åªæœ‰ä¸€ä¸ª1ï¼Œç„¶åè®¡ç®—ç›¸åŒæ•°å­—çš„ä¸ªæ•°countï¼Œç„¶åå°†countå’Œå½“å‰valçš„å€¼åŠ å…¥resä¸­ï¼Œç»§ç»­å¾ªç¯è®¡ç®—ã€‚ 1 11 21 1211 111221 312211 â€¦ 1 ä¸€ä¸ª1(11) ä¸¤ä¸ª1(21) ä¸€ä¸ª2ä¸€ä¸ª1(1211) ä¸€ä¸ª1ä¸€ä¸ª2ä¸¤ä¸ª1(111221) ä¸‰ä¸ª1ä¸¤ä¸ª2ä¸€ä¸ª1(312211)â€¦ 49. Group Anagrams class solution&#123; public List&lt;List&lt;String&gt;&gt; groupanagrams(String[] strs)&#123; Map&lt;String,List&lt;String&gt;&gt; map = new HashMap(); for(String s : strs)&#123; int[] arr = new int[26]; for(int i = 0; i &lt; s.length();i++)&#123; arr[s.charAt(i)-'a']++; &#125; String key = Arrays.toString(arr); List&lt;String&gt; temp = map.getOrDefault(key, new LinkedList&lt;String&gt;()); temp.add(s); map.put(key,temp); &#125; return new LinkedList&lt;&gt;map.values(); &#125;&#125; ç”¨hashmapå­˜ä½26ä¸ªå­—æ¯çš„é¡ºåºä¸ªæ•°ï¼Œå½“åškeyï¼Œå†åé¢å¾ªç¯ä¸­åªéœ€è¦å¯¹æ¯”æ¯ä¸ªstringçš„å­—æ¯ä¸ªæ•°é¡ºåºå³å¯ã€‚ç›¸åŒçš„æ”¾åœ¨åŒä¸€ä¸ªtempä¸­ï¼Œå¹¶ä¸”æ›´æ–°è¯¥keyå¯¹åº”çš„tempç»„ã€‚ 151. Reverse Words in a String class solution&#123; public String reversewords(String s)&#123; StingBuilder sb = new StringBuilder(); int l = s.length(); int m = l-1; while(m&gt;=0)&#123; if(s.charAt(m) == ' ')&#123; m--; continue; &#125; int n = m-1; while(s.charAt(n) != ' ' )&#123; n--; &#125; sb.append(' '); sb.append(s.substring(n+1,m+1)); m=n-1; &#125; if(sb.length()&gt;0)sb.deleteCharAt(0); return sb.toString(); &#125;&#125; æ•´ä½“æ€è·¯ä»åå¾€å‰æ‰«æï¼Œiä¸ºç¬¬ä¸€ä¸ªä¸ä¸ºç©ºæ ¼çš„ä½ç½®ï¼Œjä¸ºç¬¬ä¸€ä¸ªç©ºæ ¼çš„ä½ç½®ï¼Œå°†substringï¼ˆj+1,i+1ï¼‰åŠ å…¥sbä¸­ï¼› æ³¨æ„åœ¨åŠ å…¥substringå‰å…ˆåŠ å…¥â€™ 'ï¼Œä¿è¯åç»­æ¯ä¸ªå­—æ®µå’Œä¹‹å‰éƒ½æœ‰ç©ºæ ¼ã€‚æœ€åå°†ç¬¬ä¸€ä¸ªä½ç½®çš„ç©ºæ ¼deleteå³å¯ã€‚ 165. Compare Version Numbers class solution&#123; public int compare(String version1, String version2)&#123; String[] v1 = version1.split('\\\\.'); String[] v2 = version2.split('\\\\.'); int n = Math.max(v1.length,v2.length); for(int i = 0; i&lt;n;i++)&#123; int num1 = i&lt;v1.length ? Integer.parseInt(v1[i]) : 0; int num2 = i&lt;v2.length ? Integer.parseInt(v2[i]) : 0; if(num1 &gt; num2)return '1'; else if(num1 &lt; num2) return'-1'; else continue; &#125; return 0; &#125;&#125; javaä¸­åˆ©ç”¨\\.æ¥åˆ†å‰². åˆ†å‰²åæ¯ä¸€é¡¹è¿›è¡Œå¯¹æ¯”ï¼Œæ³¨æ„parseIntç”¨æ³•ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 27","slug":"leetcode27","date":"2019-08-02T16:35:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/08/02/leetcode27/","link":"","permalink":"WangHngLeee.github.io/2019/08/02/leetcode27/","excerpt":"6. ZigZag Conversion class solution&#123; public String convert(String s, int numRows)&#123; int idx = 0; StringBuilder[] sb = new StringBuilder[numRows]; for(int i = 0 ; i &lt; numRows ; i++)sb[i] = new StringBuilder(); while(idx&lt;s.length())&#123; for(int i = 0; i&lt;numRows &amp;&amp; idx&lt; s.length(); i++)sb[i].append(s.charAt(idx++));// ç«–ç›´æ–¹å‘å¢åŠ  for(int i = numRows - 2 ; i&gt;0 &amp;&amp; idx&lt; s.length(); i-- ) sb[i].append(s.charAt(idx++));//æ–œå‘å¢åŠ  &#125; StringBuilder res = new StringBuilder(); for(int i = 0 ;i&lt;sb.length; i++)res.append(sb[i]); return res.toString(); &#125;&#125; zagzigæ–¹æ³•å®é™…ä¸Šå°±æ˜¯æŒ‰ç…§é¡ºåºåœ¨æ¯ä¸€è¡Œä¸Šå¢åŠ å…ƒç´ ã€‚ åˆ†æƒ…å†µï¼Œç«–ç›´æ–¹å‘å¢åŠ åå†æ–œå‘å¢åŠ ã€‚å¾ªç¯å³å¯ã€‚","text":"6. ZigZag Conversion class solution&#123; public String convert(String s, int numRows)&#123; int idx = 0; StringBuilder[] sb = new StringBuilder[numRows]; for(int i = 0 ; i &lt; numRows ; i++)sb[i] = new StringBuilder(); while(idx&lt;s.length())&#123; for(int i = 0; i&lt;numRows &amp;&amp; idx&lt; s.length(); i++)sb[i].append(s.charAt(idx++));// ç«–ç›´æ–¹å‘å¢åŠ  for(int i = numRows - 2 ; i&gt;0 &amp;&amp; idx&lt; s.length(); i-- ) sb[i].append(s.charAt(idx++));//æ–œå‘å¢åŠ  &#125; StringBuilder res = new StringBuilder(); for(int i = 0 ;i&lt;sb.length; i++)res.append(sb[i]); return res.toString(); &#125;&#125; zagzigæ–¹æ³•å®é™…ä¸Šå°±æ˜¯æŒ‰ç…§é¡ºåºåœ¨æ¯ä¸€è¡Œä¸Šå¢åŠ å…ƒç´ ã€‚ åˆ†æƒ…å†µï¼Œç«–ç›´æ–¹å‘å¢åŠ åå†æ–œå‘å¢åŠ ã€‚å¾ªç¯å³å¯ã€‚ 12345678996 1 5 9 159numRows=3 ==&gt; 2 4 6 8 9 ==&gt; 24689 3 7 6 376 3. Longest Substring Without Repeating Characters class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0)return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i = 0,j=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max; &#125;&#125; åŒæŒ‡é’ˆï¼Œiå…ˆå‘å‰æ‰«æï¼Œå¦‚æœhashmapå·²ç»å­˜åœ¨å½“å‰iå…ƒç´ ï¼Œjåˆ™è·³è¿‡å½“å‰å…ƒç´ åˆ°max(j,i+1)çš„ä½ç½®ã€‚ç„¶åå­˜ä½å½“å‰içš„å…ƒç´ ï¼Œæ›´æ–°maxã€‚ 273. Integer to English Words class Solution &#123; private final String[] belowTen = new String[] &#123; \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"&#125;; private final String[] belowTwenty = new String[] &#123;\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"&#125;; private final String[] belowHundred = new String[] &#123;\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"&#125;; public String numberToWords(int num) &#123; if (num == 0) return \"Zero\"; return helper(num); &#125; private String helper(int num) &#123; String result = new String(); if (num &lt; 10) result = belowTen[num]; else if (num &lt; 20) result = belowTwenty[num -10]; else if (num &lt; 100) result = belowHundred[num/10] + \" \" + helper(num % 10); else if (num &lt; 1000) result = helper(num/100) + \" Hundred \" + helper(num % 100); else if (num &lt; 1000000) result = helper(num/1000) + \" Thousand \" + helper(num % 1000); else if (num &lt; 1000000000) result = helper(num/1000000) + \" Million \" + helper(num % 1000000); else result = helper(num/1000000000) + \" Billion \" + helper(num % 1000000000); return result.trim(); &#125;&#125; é¦–å…ˆå»ºç«‹å­—ç¬¦è¡¨ï¼Œæ³¨æ„å‰é¢æœ‰&quot;&quot;ã€‚ç„¶åå„è‡ªé€’å½’è°ƒç”¨helperå‡½æ•°ï¼Œé€æ¸ç¼©å°æ•°å€¼å¹¶æ‰¾åˆ°å¯¹åº”çš„å•ä½ã€‚ class Trie &#123; TrieNode head; /** Initialize your data structure here. */ public Trie() &#123; head = new TrieNode(); &#125; public void insert(String word) &#123; if(word == null)return; TrieNode node = head; for(char ch: word.toCharArray())&#123; if(!node.charToNode.containsKey(ch))&#123; node.charToNode.put(ch,new TrieNode()); &#125; node = node.charToNode.get(ch); &#125; node.isend = true; &#125; public boolean search(String word) &#123; TrieNode node = head; for(char ch : word.toCharArray()) &#123; if(!node.charToNode.containsKey(ch))&#123; return false; &#125; node = node.charToNode.get(ch); &#125; return node.isend; &#125; public boolean startsWith(String prefix) &#123; if(prefix == null) return false; TrieNode node = head; for(char ch : prefix.toCharArray()) &#123; if(!node.charToNode.containsKey(ch))&#123; return false; &#125; node = node.charToNode.get(ch); &#125; return true; &#125; class TrieNode&#123; Map&lt;Character, TrieNode&gt; charToNode; boolean isend = false; public TrieNode()&#123; charToNode = new HashMap(); &#125; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ å®ç°Trieç»“æ„ï¼Œå®ç°å››ä¸ªåŠŸèƒ½ã€‚æ³¨æ„æœ€åçš„class TrieNodeé‡Œçš„å®šä¹‰ã€‚ 1.åªæœ‰åˆ°æœ€åä¸€ä¸ªå­—æ¯æ—¶æ‰å°†isendæ”¹ä¸ºtrueï¼Œå…¶ä½™éƒ½ä¸ºfalseã€‚ 2.ç”¨mapå­˜ä½æ¯ä¸ªå…ƒç´ ï¼Œå¹¶ä¸”åˆ©ç”¨getå’ŒcontainsKeyæ¥æ›´æ–°nodeå’ŒæŸ¥è¯¢æ˜¯å¦å­˜åœ¨å½“å‰å­—æ¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 26","slug":"leetcode26","date":"2019-06-25T12:35:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/06/25/leetcode26/","link":"","permalink":"WangHngLeee.github.io/2019/06/25/leetcode26/","excerpt":"100. Same Tree class solution&#123; public boolean issameTree(TreeNode p,TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val)&#123; return issameTree(q.left,p.left) &amp;&amp; issameTree(q.right,p.right); &#125; return false; &#125;&#125; é€’å½’åˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦éƒ½ç›¸åŒï¼Œæ¯”è¾ƒç®€å•ã€‚","text":"100. Same Tree class solution&#123; public boolean issameTree(TreeNode p,TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val)&#123; return issameTree(q.left,p.left) &amp;&amp; issameTree(q.right,p.right); &#125; return false; &#125;&#125; é€’å½’åˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦éƒ½ç›¸åŒï¼Œæ¯”è¾ƒç®€å•ã€‚ 106. Construct Binary Tree from Inorder and Postorder Traversal(Inorder/Postorder Tree Transform) /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; int indexp; int indexi; private TreeNode buildTree(int[] inorder,int[] postorder, TreeNode end)&#123; if(indexp&lt;0)return null; TreeNode n = new TreeNode(posrorder[indexp]); indexp--; if(inorder[indexi] != n.val)&#123; n.left=buildTree(inorder,posrorder,n); &#125; indexi--; if((end == null) || (inorder[indexi] != end.val))&#123; n.right = buildTree(inorder, posrorder, null); &#125; return n; &#125; public TreeNode buildTree(int[] inorder, int[]postorder)&#123; indexp = posrorder.length -1 ; indexi = inorder.length -1; return buildTree(inorder, postorder, null); &#125; &#125; ç»™å®špostorderå’Œinorderçš„æ ‘ç»“æ„ï¼Œè¾“å‡ºæ­£ç¡®çš„æ ‘ç»“æ„ã€‚postä¸­æœ€åä¸€ä½æ˜¯rootï¼Œè¿›è€Œåœ¨inorderä¸­æ‰¾rootçš„ä½ç½®ï¼Œåˆ¤æ–­æœ‰æ— å·¦å³å­æ ‘ã€‚ è‹¥æœ‰å·¦å­æ ‘ï¼Œåˆ™å°†å½“å‰çš„nä½œä¸ºendæ¥é€’å½’ï¼›è‹¥æœ‰å³å­æ ‘ï¼Œåˆ™å°†endé‡æ–°è®¾ä¸ºnullã€‚ æ€»ç»“ä¸€ä¸‹å¸¸è§çš„ä¸‰ç§order traversal 94. Binary Tree Inorder Traversal public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.empty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); res.add(root.val); root = root.right; &#125; return res;&#125; inorderè¦éå†å®Œæ‰€æœ‰çš„å·¦å­æ ‘å†éå†æ ¹èŠ‚ç‚¹ã€‚ 144. Binary Tree Preorder Traversal public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); res.add(root.val); if(root.right != null) stack.push(root.right); if(root.left != null) stack.push(root.left); &#125; return res;&#125; preorder æ ¹-å·¦-å³ï¼Œstackå…ˆå­˜rightå†å­˜leftï¼Œä¿è¯popæ—¶å…ˆå·¦åå³ 145. Binary Tree Postorder Traversal public class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; root = stack.pop(); res.addFirst(root.val); if (root.left != null) stack.push(root.left ); if (root.right != null) stack.push(root.right); &#125; return res; &#125;&#125; postå·¦-å³-æ ¹ï¼Œåˆ©ç”¨addfirstæ–¹æ³•ï¼Œä¸æ–­æ›´æ–°linkedlistã€‚è¿™æ—¶pushçš„é¡ºåºåº”è¯¥å…ˆå·¦åå³ã€‚å› ä¸ºpushåè¦è¿›è¡Œaddfirstï¼Œpopå‡ºå³ã€‚addfirstï¼›å†popleftï¼Œaddfirståæ­¤æ—¶leftå·²ç»åˆ°äº†rightå‰é¢ï¼Œç¬¦åˆpostè¦æ±‚ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 25","slug":"leetcode25","date":"2019-06-21T12:35:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/06/21/leetcode25/","link":"","permalink":"WangHngLeee.github.io/2019/06/21/leetcode25/","excerpt":"115. Distinct Subsequencesï¼ˆDP) class solution&#123; public distinctsu(String s, String t)&#123; int[][] mem = new int[t.length()+1][s.length()+1]; for(int i=0;i&lt;=s.length();i++)&#123; mem[0][i] = 1; &#125; for(int i=0;i&lt;t.length();t++)&#123; for(int j=;j&lt;s.length();j++)&#123; if(t.charAt(i)==s.charAt(j))&#123; mem[i+1][j+1]=mem[i][j]+mem[i+1][j]; &#125;else&#123; mem[i+1][j+1]=mem[i+1][j]; &#125; &#125; &#125; return mem[t.length()][s.length()]; &#125;&#125; dpæ€è·¯ã€‚å¤§ç¥çš„æ€è·¯æ°¸è¿œéƒ½æ˜¯ç®€å•è€Œåˆéœ‡æ’¼â†’leetcode 115. dpé¢˜åšå¤šäº†ä¼šå‘ç°å¤§ä½“ä¸Šçš„ç¨‹åºç»“æ„åŸºæœ¬æ˜¯ä¸€æ ·çš„ã€‚ 1.æ–°å»ºäºŒ/ä¸‰ç»´æ•°ç»„ï¼Œå¹¶åˆå§‹åŒ–è¾¹ç•Œã€‚ 2.å¾ªç¯æ‰«æï¼Œä¸€èˆ¬æ˜¯i+1\\j+1çš„ä½ç½®å’Œå·¦ä¸Šè§’/ä¸Šæ–¹/å·¦æ–¹çš„ä½ç½®è¿›è¡Œæ“ä½œã€‚ 3.è¿”å›æœ€åä½ç½®çš„çŠ¶æ€ã€‚","text":"115. Distinct Subsequencesï¼ˆDP) class solution&#123; public distinctsu(String s, String t)&#123; int[][] mem = new int[t.length()+1][s.length()+1]; for(int i=0;i&lt;=s.length();i++)&#123; mem[0][i] = 1; &#125; for(int i=0;i&lt;t.length();t++)&#123; for(int j=;j&lt;s.length();j++)&#123; if(t.charAt(i)==s.charAt(j))&#123; mem[i+1][j+1]=mem[i][j]+mem[i+1][j]; &#125;else&#123; mem[i+1][j+1]=mem[i+1][j]; &#125; &#125; &#125; return mem[t.length()][s.length()]; &#125;&#125; dpæ€è·¯ã€‚å¤§ç¥çš„æ€è·¯æ°¸è¿œéƒ½æ˜¯ç®€å•è€Œåˆéœ‡æ’¼â†’leetcode 115. dpé¢˜åšå¤šäº†ä¼šå‘ç°å¤§ä½“ä¸Šçš„ç¨‹åºç»“æ„åŸºæœ¬æ˜¯ä¸€æ ·çš„ã€‚ 1.æ–°å»ºäºŒ/ä¸‰ç»´æ•°ç»„ï¼Œå¹¶åˆå§‹åŒ–è¾¹ç•Œã€‚ 2.å¾ªç¯æ‰«æï¼Œä¸€èˆ¬æ˜¯i+1\\j+1çš„ä½ç½®å’Œå·¦ä¸Šè§’/ä¸Šæ–¹/å·¦æ–¹çš„ä½ç½®è¿›è¡Œæ“ä½œã€‚ 3.è¿”å›æœ€åä½ç½®çš„çŠ¶æ€ã€‚ 120. Triangleï¼ˆDP) class solution&#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle)&#123; if(triangle.size()==0) return 0; for(int i=triangle.size()-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;=i;j++)&#123; List&lt;Integer&gt; nextrow = triangle.get(i+1); int sum = Math.min(nextrow.get(j),nextrow.get(j+1))+triangle.get(i).get(j); triangle.get(i).set(j,sum); &#125; &#125; return triangle.get(0).get(0); &#125;&#125; dpæ€è·¯ã€‚è‡ªä¸‹è€Œä¸Šå¾ªç¯ã€‚äº®ç‚¹æ˜¯ä¸ç”¨å•ç‹¬å­˜å‚¨sumï¼Œç›´æ¥å°†é€‰å–çš„ä½ç½®å­˜ä¸Šå½“å‰çš„sumå€¼ï¼ŒèŠ‚çœç©ºé—´å¤æ‚åº¦ã€‚æœ€åè¿”å›æœ€ä¸Šé¢çš„ä½ç½®å³å¯ï¼Œå°±æ˜¯æœ€åçš„sumã€‚ 221. Maximal Squareï¼ˆDP) class solution&#123; public int maximalsquare(char[][] matrix)&#123; if(matrix.length == 0)return 0; int m = matrix.length,n=matrix[0].length,res = 0; int[][] ans = new int[m+1][n+1]; for(int i = 0; i&lt;=m;i++)&#123; for(int j = 0;j&lt;=n;j++)&#123; if(matrix[i-1][j-1]=='1')&#123; ans[i][j] = Math.min(Math.min(ans[i-1][j-1],ans[i-1][j]),ans[i][j-1])+1; res = Math.max(ans[i][j],res); &#125; &#125; &#125; return res*res; &#125;&#125; dpæ€è·¯ã€‚æ‰¾åˆ°æœ€å¤§çš„1å­—æ­£æ–¹å½¢ã€‚ç”¨dpå­˜ä½æ¯ä¸ªä½ç½®å½“å‰çš„æœ€å¤§æ­£æ–¹å½¢ã€‚åªæœ‰å½“å·¦/ä¸Š/å·¦æ–œä¸Šä½ç½®éƒ½ä¸ä¸º0æ—¶ï¼Œæ‰å¯èƒ½å­˜åœ¨æ­£æ–¹å½¢ã€‚ æœ€åæ›´æ–°resï¼Œå­˜ä½æœ€å¤§çš„æ­£æ–¹å½¢è¾¹é•¿ã€‚æœ€åè¿”å›é¢ç§¯ï¼Œè¾¹é•¿**2.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 24","slug":"leetcode 24","date":"2019-06-20T12:35:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/06/20/leetcode 24/","link":"","permalink":"WangHngLeee.github.io/2019/06/20/leetcode 24/","excerpt":"99. Recover Binary Search Tree(BST In-Order-traversal) class Solution &#123; private TreeNode first; private TreeNode second; private TreeNode pre; public void recoverTree(TreeNode root) &#123; if(root==null) return; first = null; second = null; pre = null; inorder(root); int temp = first.val; first.val = second.val; second.val = temp; &#125; private void inorder(TreeNode root)&#123; if(root==null) return; inorder(root.left); if(first==null &amp;&amp; (pre==null ||pre.val&gt;=root.val))&#123; first = pre; &#125; if(first!=null &amp;&amp; pre.val&gt;=root.val)&#123; second = root; &#125; pre = root; inorder(root.right); &#125;&#125; è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸­åºéå†ä¸­å‡ºç°å±€éƒ¨é™åºçš„èŠ‚ç‚¹ï¼Œè®¾ç½®preæŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåœ¨ä¸­åºéå†ä¸­æ¯”è¾ƒå‰ä¸€èŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹çš„æ•°å€¼ï¼Œä»è€Œåˆ¤æ–­æ˜¯å¦ä¸ºå±€éƒ¨é™åºï¼Œæœ€åï¼Œå°†ä¸¤ä¸ªå±€éƒ¨é™åºæŒ‡é’ˆæŒ‡(first\\second)å‘çš„èŠ‚ç‚¹çš„æ•°å€¼äº¤æ¢ï¼Œå³å¯å®Œæˆæœç´¢äºŒå‰æ ‘çš„æ¢å¤.","text":"99. Recover Binary Search Tree(BST In-Order-traversal) class Solution &#123; private TreeNode first; private TreeNode second; private TreeNode pre; public void recoverTree(TreeNode root) &#123; if(root==null) return; first = null; second = null; pre = null; inorder(root); int temp = first.val; first.val = second.val; second.val = temp; &#125; private void inorder(TreeNode root)&#123; if(root==null) return; inorder(root.left); if(first==null &amp;&amp; (pre==null ||pre.val&gt;=root.val))&#123; first = pre; &#125; if(first!=null &amp;&amp; pre.val&gt;=root.val)&#123; second = root; &#125; pre = root; inorder(root.right); &#125;&#125; è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸­åºéå†ä¸­å‡ºç°å±€éƒ¨é™åºçš„èŠ‚ç‚¹ï¼Œè®¾ç½®preæŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œåœ¨ä¸­åºéå†ä¸­æ¯”è¾ƒå‰ä¸€èŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹çš„æ•°å€¼ï¼Œä»è€Œåˆ¤æ–­æ˜¯å¦ä¸ºå±€éƒ¨é™åºï¼Œæœ€åï¼Œå°†ä¸¤ä¸ªå±€éƒ¨é™åºæŒ‡é’ˆæŒ‡(first\\second)å‘çš„èŠ‚ç‚¹çš„æ•°å€¼äº¤æ¢ï¼Œå³å¯å®Œæˆæœç´¢äºŒå‰æ ‘çš„æ¢å¤. 135. Candy(two scan ) class Solution &#123; public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1);// Give each child 1 candy for (int i = 1; i &lt; candies.length; i++)&#123;// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child if (ratings[i] &gt; ratings[i - 1]) candies[i] = (candies[i - 1] + 1); &#125; for (int i = candies.length - 2; i &gt;= 0; i--) &#123;// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child if (ratings[i] &gt; ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1)); &#125; int sum = 0; for (int candy : candies) sum += candy; return sum; &#125;&#125; æ¯”è¾ƒéš¾çš„ä¸€é“é¢˜ï¼Œå½“ç›¸é‚»çš„ä¸¤ä¸ªæ•°ï¼Œä¸‹ä¸€ä¸ªæ¯”å½“å‰å¤§æ—¶ï¼Œä¸‹ä¸€ä¸ªä½ç½®åˆ†é…çš„ç³–æœå¤šä¸€ä¸ªã€‚æ‰€ä»¥å·¦è‡³å³å’Œå³è‡³å·¦éƒ½æ‰«æä¸€æ¬¡ï¼Œè§£å†³äº†è¿ç»­é‡å¤æ•°å­—çš„é—®é¢˜ã€‚ Iâ€™ve come up with a simple proof of this algo. init with all 1 we only give one more when we see adjacent increase (both from left to right) I want to use some case to illustrate this ((notices we donâ€™t care the exact value of ratings, only their relation) the rating is similar to â€˜waveâ€™, increase of decrease letâ€™s look at this case: ratings: [1,3,6,9,4,2] candies: [1,2,3,4,2,1] the highest rating is 9, when scan from left to right, num of candies should be 4, scan right to left, it should be 3, then we choose the larger value. and letâ€™s look at some case containing adjacent-equal when there are adjacent-equal, lets look at some cases: ratings: [1,2,3,3,3,3,4,5] candies: [1,2,3,1,1,1,2,3] ratings: [1,2,8,8,8,8,8,2] candies: [1,2,3,1,1,1,2,1] with these cases it should be easier to understand.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 23","slug":"leetcode 23","date":"2019-06-17T12:35:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/06/17/leetcode 23/","link":"","permalink":"WangHngLeee.github.io/2019/06/17/leetcode 23/","excerpt":"109. Convert Sorted List to Binary Search Tree(linked list/recursion) /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode slow = head,fast=head,preslow=null; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; preslow = slow; slow = slow.next; fast = fast.next.next; &#125; if(preslow!=null)preslow.next=null; if(slow == null)return null; TreeNode n = new TreeNode(slow.val); if(head != slow)&#123; n.left = sortedListToBST(head) n.right = sortedListToBST(slow.next) &#125; return n; &#125;&#125;","text":"109. Convert Sorted List to Binary Search Tree(linked list/recursion) /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode slow = head,fast=head,preslow=null; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; preslow = slow; slow = slow.next; fast = fast.next.next; &#125; if(preslow!=null)preslow.next=null; if(slow == null)return null; TreeNode n = new TreeNode(slow.val); if(head != slow)&#123; n.left = sortedListToBST(head) n.right = sortedListToBST(slow.next) &#125; return n; &#125;&#125; BSTçš„é¢˜ï¼ŒåŸæ•°ç»„æ˜¯sortedçš„ï¼Œæ‰€ä»¥æ€è·¯æ¯”è¾ƒå¥½æƒ³ã€‚ç›´æ¥æ‰¾åˆ°ä¸­é—´æ•°ä½œä¸ºrootï¼Œå·¦å³åˆ†åˆ«æ‰¾ä¸­é—´æ•°ï¼Œrecursiveè°ƒç”¨ã€‚ æ¯”è¾ƒå¥½çš„ä¸¤ç‚¹ï¼š 1.å®šä¹‰preslowï¼Œç”¨æ¥ä½œä¸ºå·¦åŠéƒ¨åˆ†çš„tailï¼Œå¹¶ä¸”å°†tail.next=null,åˆ‡æ–­ 2.åˆ©ç”¨slow å’Œ fastä¸æ–­å¾ªç¯çš„æ€è·¯ï¼Œfasté¢†å…ˆslowä¸¤ä¸ªæ•°ï¼Œæ‰€ä»¥å½“fast next next = nullæ—¶ï¼Œslowæ­£å¥½åœ¨ä¸­é—´ä½ç½®ã€‚ 97. Interleaving Stringï¼ˆDP) class solution&#123; public boolean isintervleaing(String s1, String s2, String s3)&#123; if((s1.length()+s2.length())!=s3.length())return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1] for(int i=1;i&lt;matrix[0].length;i++)&#123; matrix[0][i] = matix[0][i-1]&amp;&amp;(s1.charAt(i-1)==s3.charAt(i-1)); &#125; for(int i=1;i&lt;matrix.length;i++)&#123; matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1)==s3.charAt(i-1)); &#125; for(int i = 1;i&lt;matrix.length;i++)&#123; for(int j = 1;j&lt;matrix[0].length;j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1) == s3.charAt(i+j-1))) &#125; &#125; return matrix[s2.length][s1.length]; &#125;&#125; hardçš„dpé¢˜ï¼Œåˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ä¸ºäº¤å‰çš„ã€‚ä¸è®ºå“ªä¸ªåœ¨å‰ï¼Œè‚¯å®šæœ‰ä¸€ä¸ªæ»¡è¶³åˆ†å­—ç¬¦ä¸²çš„ä½ç½®å’Œæ€»å­—ç¬¦ä¸²çš„ä½ç½®ç›¸åŒã€‚å…ˆå°†s1å’Œs2åˆ†åˆ«æ£€æµ‹ï¼Œå­˜åœ¨ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—é‡Œã€‚æœ€åè¿›è¡Œå…¨å±€æ‰«æï¼Œæ³¨æ„i+j-1çš„åº”ç”¨ã€‚ 77. Combinations (Backtracking) class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(ans,new ArrayList&lt;&gt;(),1,n,k); return ans; &#125; public static void combine(List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; comb,int start,int n, int k)&#123; if(k==0)&#123; ans.add(new ArrayList&lt;Integer&gt;(comb)); &#125; for(int i = start; i&lt;=n,i++)&#123; comb.add(i); combine(ans,comb,i+1,n,k-1); comb.remove(comb.size()-1); &#125; &#125;&#125; backtrackingæ€è·¯ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 22","slug":"leetcode22","date":"2019-06-13T12:35:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/06/13/leetcode22/","link":"","permalink":"WangHngLeee.github.io/2019/06/13/leetcode22/","excerpt":"241. Different Ways to Add Parentheses (recursive / HashMap) class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); if(map.containsKey(input))return map.get(input); List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for(int i =0;i&lt;input.length();i++)&#123; if(input.charAt(i) == '-' || input.charAt(i) == '+' || input.charAt(i) == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2ret = diffWaysToCompute(part2); for(Integer p1 : part1ret)&#123; for(Integer p2 : part2ret)&#123; int c = 0; switch(input.charAt(i))&#123; case '+': c=p1+p2; break; case '-': c=p1-p2; break; case '*': c=p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0)&#123; ret.add(Integer.valueOf(input)); &#125; return ret; &#125;&#125; recursiveçš„æ€æƒ³ï¼Œå¹¶ä¸”åˆ©ç”¨hashmapæ¥é¿å…é‡å¤è®¡ç®—çš„æƒ…å†µï¼Œé™ä½æ—¶é—´å¤æ‚åº¦ï¼Œæ³¨æ„switchçš„ç”¨æ³•ã€‚","text":"241. Different Ways to Add Parentheses (recursive / HashMap) class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); if(map.containsKey(input))return map.get(input); List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for(int i =0;i&lt;input.length();i++)&#123; if(input.charAt(i) == '-' || input.charAt(i) == '+' || input.charAt(i) == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2ret = diffWaysToCompute(part2); for(Integer p1 : part1ret)&#123; for(Integer p2 : part2ret)&#123; int c = 0; switch(input.charAt(i))&#123; case '+': c=p1+p2; break; case '-': c=p1-p2; break; case '*': c=p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0)&#123; ret.add(Integer.valueOf(input)); &#125; return ret; &#125;&#125; recursiveçš„æ€æƒ³ï¼Œå¹¶ä¸”åˆ©ç”¨hashmapæ¥é¿å…é‡å¤è®¡ç®—çš„æƒ…å†µï¼Œé™ä½æ—¶é—´å¤æ‚åº¦ï¼Œæ³¨æ„switchçš„ç”¨æ³•ã€‚ 96. Unique Binary Search Trees public int numtrees(int n)&#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i&lt;=n;i++)&#123; for(int j = 1; j&lt;=i;j++)&#123; dp[i] += dp[j-1] *dp[i-j]; &#125; &#125; return dp[n];&#125; ä¸»è¦æ˜¯æ•°å­¦æ€è·¯æ¯”è¾ƒéš¾ï¼Œéœ€è¦è®¡ç®—å‡ºä¸åŒå­æ ‘ç»“æ„çš„æ‰€æœ‰æ ‘çš„æ•°é‡ã€‚å…·ä½“æ€è·¯è§leetcode96.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Reactive Native (1)","slug":"rn1","date":"2019-06-10T17:23:41.000Z","updated":"2019-06-21T05:14:24.000Z","comments":true,"path":"2019/06/10/rn1/","link":"","permalink":"WangHngLeee.github.io/2019/06/10/rn1/","excerpt":"å¼€ä¸ªè´´è®°å½•ä¸€ä¸‹RNçš„å­¦ä¹ è®°å½•ï¼Œå¸Œæœ›æœ€åèƒ½å¤Ÿè‡ªå·±åšå‡ºæ¯”è¾ƒæ»¡æ„çš„appå§ã€‚ hello world import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';export default class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: \"center\", alignItems: \"center\" &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; React Native å†…ç½®äº†å¯¹ ES2015 æ ‡å‡†çš„æ”¯æŒ.ä¸‹é¢ä¸€è¡Œï¼š &lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt; å«åš JSX â€”â€” æ˜¯ä¸€ç§åœ¨ JavaScript ä¸­åµŒå…¥ XML ç»“æ„çš„è¯­æ³• ä»£ç ä¸­ï¼Œä½¿ç”¨çš„æ˜¯å†…ç½®çš„ç»„ä»¶ï¼Œå®ƒä¸“é—¨ç”¨æ¥æ˜¾ç¤ºæ–‡æœ¬ï¼Œè€Œå°±ç±»ä¼¼ html ä¸­çš„divæˆ–æ˜¯spanè¿™æ ·çš„å®¹å™¨ã€‚","text":"å¼€ä¸ªè´´è®°å½•ä¸€ä¸‹RNçš„å­¦ä¹ è®°å½•ï¼Œå¸Œæœ›æœ€åèƒ½å¤Ÿè‡ªå·±åšå‡ºæ¯”è¾ƒæ»¡æ„çš„appå§ã€‚ hello world import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';export default class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: \"center\", alignItems: \"center\" &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; React Native å†…ç½®äº†å¯¹ ES2015 æ ‡å‡†çš„æ”¯æŒ.ä¸‹é¢ä¸€è¡Œï¼š &lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt; å«åš JSX â€”â€” æ˜¯ä¸€ç§åœ¨ JavaScript ä¸­åµŒå…¥ XML ç»“æ„çš„è¯­æ³• ä»£ç ä¸­ï¼Œä½¿ç”¨çš„æ˜¯å†…ç½®çš„ç»„ä»¶ï¼Œå®ƒä¸“é—¨ç”¨æ¥æ˜¾ç¤ºæ–‡æœ¬ï¼Œè€Œå°±ç±»ä¼¼ html ä¸­çš„divæˆ–æ˜¯spanè¿™æ ·çš„å®¹å™¨ã€‚ Props(å±æ€§) react nativeä¸­å¤§å¤šç»„ä»¶å¯ä»¥ç”¨å‚æ•°æ¥ä¿®æ”¹ã€‚å¯ä»¥ä¿®æ”¹çš„è¿™äº›å‚æ•°å°±ç§°ä¸ºpropsã€‚ ä»¥æ’å…¥å›¾ç‰‡ä¸ºä¾‹ï¼š import React,&#123;Components&#125; from 'react';import &#123;Image&#125; from 'react-native';export default class Bananas extends Components&#123; render()&#123; let pic = &#123; url:'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'; &#125; return&#123; &lt;Image source=&#123;pic&#125; style=&#123;&#123;width:193,height:150&#125;&#125; /&gt; &#125;; &#125;&#125; åœ¨åˆ›å»ºä¸€ä¸ªå›¾ç‰‡æ—¶ï¼Œå¯ä»¥ä¼ å…¥ä¸€ä¸ªåä¸ºsourceçš„ prop æ¥æŒ‡å®šè¦æ˜¾ç¤ºçš„å›¾ç‰‡çš„åœ°å€ï¼Œä»¥åŠä½¿ç”¨åä¸ºstyleçš„ prop æ¥æ§åˆ¶å…¶å°ºå¯¸ã€‚ {pic}å¤–å›´æœ‰ä¸€å±‚æ‹¬å·ï¼Œéœ€è¦ç”¨æ‹¬å·æ¥æŠŠpicè¿™ä¸ªå˜é‡åµŒå…¥åˆ° JSX è¯­å¥ä¸­ã€‚æ‹¬å·çš„æ„æ€æ˜¯æ‹¬å·å†…éƒ¨ä¸ºä¸€ä¸ª js å˜é‡æˆ–è¡¨è¾¾å¼ï¼Œéœ€è¦æ‰§è¡Œåå–å€¼ã€‚å› æ­¤å¯ä»¥æŠŠä»»æ„åˆæ³•çš„ JavaScript è¡¨è¾¾å¼é€šè¿‡æ‹¬å·åµŒå…¥åˆ° JSX è¯­å¥ä¸­ã€‚ è‡ªå®šä¹‰çš„ç»„ä»¶ä¹Ÿå¯ä»¥ä½¿ç”¨propsã€‚é€šè¿‡åœ¨ä¸åŒçš„åœºæ™¯ä½¿ç”¨ä¸åŒçš„å±æ€§å®šåˆ¶ï¼Œå¯ä»¥å°½é‡æé«˜è‡ªå®šä¹‰ç»„ä»¶çš„å¤ç”¨èŒƒç•´ã€‚åªéœ€åœ¨renderå‡½æ•°ä¸­å¼•ç”¨this.propsï¼Œç„¶åæŒ‰éœ€å¤„ç†å³å¯ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼š import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', marginTop: 50&#125;&#125;&gt; &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125; åœ¨Greetingç»„ä»¶ä¸­å°†nameä½œä¸ºä¸€ä¸ªå±æ€§æ¥å®šåˆ¶ï¼Œè¿™æ ·å¯ä»¥å¤ç”¨è¿™ä¸€ç»„ä»¶æ¥åˆ¶ä½œå„ç§ä¸åŒçš„â€œé—®å€™è¯­. State æˆ‘ä»¬ä½¿ç”¨ä¸¤ç§æ•°æ®æ¥æ§åˆ¶ä¸€ä¸ªç»„ä»¶ï¼špropså’Œstateã€‚propsæ˜¯åœ¨çˆ¶ç»„ä»¶ä¸­æŒ‡å®šï¼Œè€Œä¸”ä¸€ç»æŒ‡å®šï¼Œåœ¨è¢«æŒ‡å®šçš„ç»„ä»¶çš„ç”Ÿå‘½å‘¨æœŸä¸­åˆ™ä¸å†æ”¹å˜ã€‚ å¯¹äºéœ€è¦æ”¹å˜çš„æ•°æ®ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨stateã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œä½ éœ€è¦åœ¨ constructor ä¸­åˆå§‹åŒ–stateï¼ˆè¯‘æ³¨ï¼šè¿™æ˜¯ ES6 çš„å†™æ³•ï¼Œæ—©æœŸçš„å¾ˆå¤š ES5 çš„ä¾‹å­ä½¿ç”¨çš„æ˜¯ getInitialState æ–¹æ³•æ¥åˆå§‹åŒ– stateï¼Œè¿™ä¸€åšæ³•ä¼šé€æ¸è¢«æ·˜æ±°ï¼‰ï¼Œç„¶ååœ¨éœ€è¦ä¿®æ”¹æ—¶è°ƒç”¨setStateæ–¹æ³•ã€‚ æ³¨æ„ç»©å‡ ç‚¹ï¼š 1.ä¸€åˆ‡ç•Œé¢å˜åŒ–éƒ½æ˜¯çŠ¶æ€stateå˜åŒ– 2.stateçš„ä¿®æ”¹å¿…é¡»é€šè¿‡setState()æ–¹æ³• 3.this.state.likes = 100ï¼Œ è¿™æ ·çš„ç›´æ¥èµ‹å€¼ä¿®æ”¹æ— æ•ˆï¼ 4.setState æ˜¯ä¸€ä¸ª merge åˆå¹¶æ“ä½œï¼Œåªä¿®æ”¹æŒ‡å®šå±æ€§ï¼Œä¸å½±å“å…¶ä»–å±æ€§ 5.setState æ˜¯å¼‚æ­¥æ“ä½œï¼Œä¿®æ”¹ä¸ä¼šé©¬ä¸Šç”Ÿæ•ˆ","categories":[{"name":"web/appå¼€å‘ï¼Œæ¡†æ¶","slug":"web-appå¼€å‘ï¼Œæ¡†æ¶","permalink":"WangHngLeee.github.io/categories/web-appå¼€å‘ï¼Œæ¡†æ¶/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"WangHngLeee.github.io/tags/React-Native/"},{"name":"app","slug":"app","permalink":"WangHngLeee.github.io/tags/app/"},{"name":"webapp","slug":"webapp","permalink":"WangHngLeee.github.io/tags/webapp/"}]},{"title":"Leetcode EveryDay 21","slug":"leetcode21","date":"2019-06-10T12:56:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/06/10/leetcode21/","link":"","permalink":"WangHngLeee.github.io/2019/06/10/leetcode21/","excerpt":"82. Remove Duplicates from Sorted List IIï¼ˆtwo pointer / linked list) class solution&#123; public ListNode deletedupliate(ListNode head)&#123; if(head == null)return null; ListNode dummy = head; dummy.next = head; ListNode pre = dummy; ListNode cur = head; ListNode fisrt = dummy;//æ–°å»ºä¸€ä¸ªfirsté“¾è¡¨æ¥å­˜å‚¨ä¸é‡å¤çš„èŠ‚ç‚¹ while(cur!=null &amp;&amp; cur.next!=null)&#123;//åˆ¤æ–­è¯¥èŠ‚ç‚¹å’ŒåèŠ‚ç‚¹ä¸ä¸ºç©º if(cur.val!=cur.next.val&amp;&amp;cur.val!=pre.val)&#123;//å‰åéƒ½æ— é‡å¤ first = cur; first.next = first; &#125; pre = cur; cur = cur.next; &#125; if(cur.val!=pre.val)&#123;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶åªè€ƒè™‘preå’Œcur first = cur; first.next = first; &#125; first.next = null;//æ³¨æ„ï¼Œè¿™æ˜¯ä¸ºäº†å¤„ç†å½“é“¾è¡¨éƒ½ä¸ºé‡å¤æ—¶ï¼Œå°†å…¨éƒ¨å‰”é™¤ã€‚ return dummy.next; &#125;&#125; linked list å’Œ two pointer çš„æ€è·¯ï¼Œæ–°å»ºfirsté“¾è¡¨å­˜ç­”æ¡ˆï¼Œåˆ¤æ–­å½“å‰åå‡ä¸ä¸ºé‡å¤æ—¶è¿›è¡Œæ“ä½œã€‚","text":"82. Remove Duplicates from Sorted List IIï¼ˆtwo pointer / linked list) class solution&#123; public ListNode deletedupliate(ListNode head)&#123; if(head == null)return null; ListNode dummy = head; dummy.next = head; ListNode pre = dummy; ListNode cur = head; ListNode fisrt = dummy;//æ–°å»ºä¸€ä¸ªfirsté“¾è¡¨æ¥å­˜å‚¨ä¸é‡å¤çš„èŠ‚ç‚¹ while(cur!=null &amp;&amp; cur.next!=null)&#123;//åˆ¤æ–­è¯¥èŠ‚ç‚¹å’ŒåèŠ‚ç‚¹ä¸ä¸ºç©º if(cur.val!=cur.next.val&amp;&amp;cur.val!=pre.val)&#123;//å‰åéƒ½æ— é‡å¤ first = cur; first.next = first; &#125; pre = cur; cur = cur.next; &#125; if(cur.val!=pre.val)&#123;//å¤„ç†æœ€åä¸€ä¸ªèŠ‚ç‚¹æ—¶åªè€ƒè™‘preå’Œcur first = cur; first.next = first; &#125; first.next = null;//æ³¨æ„ï¼Œè¿™æ˜¯ä¸ºäº†å¤„ç†å½“é“¾è¡¨éƒ½ä¸ºé‡å¤æ—¶ï¼Œå°†å…¨éƒ¨å‰”é™¤ã€‚ return dummy.next; &#125;&#125; linked list å’Œ two pointer çš„æ€è·¯ï¼Œæ–°å»ºfirsté“¾è¡¨å­˜ç­”æ¡ˆï¼Œåˆ¤æ–­å½“å‰åå‡ä¸ä¸ºé‡å¤æ—¶è¿›è¡Œæ“ä½œã€‚ 83. Remove Duplicates from Sorted Listï¼ˆlinked lilstï¼‰ class solutoin&#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list!=null)&#123; if(list.next == null)break; if(list.val == list.next.val)&#123; list.next = list.next.next; &#125;else&#123; list.next = list; &#125; &#125; return head; &#125;&#125; easyçš„82é¢˜ï¼Œè¦æ±‚å°†é‡å¤æ•°å­—çš„åªç•™ä¸‹ä¸€ä¸ªè¾“å‡ºï¼Œè€Œ82æ˜¯è¦æ±‚å°†é‡å¤çš„å…¨éƒ¨å‰”é™¤ï¼Œæ‰€ä»¥83ç›¸æ¯”82æ¯”è¾ƒç®€å• åªéœ€è¦å°†é‡å¤æƒ…å†µä¸‹list.next = list.next.next;å¾ªç¯ä¸‹å»ã€‚ 86. Partition List(listed node / two pointers) class solution&#123; public ListNode partation(ListNode head,int x)&#123; ListNode smallhead = new ListNode(0),bighead = new ListNode(0); ListNode smalltail = smallhead, bigtail = bighead; while(head!=null)&#123; if(head.val&lt;x)&#123; smalltail.next = head; smalltail = smalltail.next; &#125;else&#123; bigtail.next = head; bigtail = bigtail.next; &#125; head = head.next; &#125; bigtail.next = null; smalltail.next = bighead.next; return smallhead.next; &#125;&#125; æ–°å»ºsmallå’Œbigä¸¤ä¸ªé“¾è¡¨ï¼Œåˆ†åˆ«ç”¨æ¥å­˜å°äºxå’Œå¤§äºxçš„èŠ‚ç‚¹ï¼Œæœ€åå°†å¤§çš„èŠ‚ç‚¹åˆå¹¶åœ¨å°çš„èŠ‚ç‚¹åé¢å³å¯ã€‚æ³¨æ„bigtail.next=nullè¿™ä¸€æ­¥éå¸¸å…³é”®ï¼Œé¿å…äº†é“¾è¡¨çš„å¾ªç¯ï¼Œé˜²æ­¢TLEã€‚ 92. Reverse Linked List II(linked list / two pointers) class solution&#123; public ListNode reverselinkedlist(ListNode head, int m, int n)&#123; if(head == null)return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i = 0; i &lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; åŒæŒ‡é’ˆé—®é¢˜ã€‚preï¼Œstartï¼Œthenè¡¨ç¤ºå‰ä¸€èŠ‚ç‚¹ï¼Œå½“å‰ï¼ŒåèŠ‚ç‚¹ï¼Œå¾ªç¯m-1æ¬¡æ‰¾åˆ°preï¼Œå°†pre.nextå˜ä¸ºstartã€‚æ‰§è¡Œn-mæ¬¡æ¢ä½ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 20","slug":"leetcode 20","date":"2019-06-06T12:56:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/06/06/leetcode 20/","link":"","permalink":"WangHngLeee.github.io/2019/06/06/leetcode 20/","excerpt":"å†™åœ¨å‰é¢ æœ€è¿‘äº‹æƒ…æ¯”è¾ƒå¤šï¼ŒåŠç­¾è¯ï¼Œå†™è®ºæ–‡ï¼Œæ”¹æ ¼å¼ï¼Œæ²¡ä»€ä¹ˆæ—¶é—´åˆ·é¢˜å’Œçœ‹ç½‘è¯¾äº†ï¼Œç°åœ¨æ€»ç®—æ˜¯é—²ä¸‹æ¥äº†ï¼Œä¹‹åå¤§æ¦‚å°±æ˜¯ä¸€éå‡†å¤‡ç­”è¾©pptä¸€éåˆ·é¢˜å§ã€‚åŠ æ²¹åŠ æ²¹ã€‚ 209. Minimum Size Subarray Sum(two pointers) class solution&#123; public int minsub(int s, int[] nums)&#123; int sum = 0, int from = 0, mn = Integer.MAX_VALUE; for(int i = 0; i&lt; nums.length;i++)&#123; sum+=nums[i]; while(sum&gt;=s)&#123; mn = Math.min(mn,i-from+1); sum-=nums[from]; from++; &#125; &#125; return (mn == Integer.MAX_VALUE)? 0 : mn; &#125;&#125; åŒæŒ‡é’ˆé—®é¢˜ï¼Œfromä¸ºèµ·å§‹ä½ç½®ï¼Œsliding windowæ€æƒ³å¾ªç¯ä¸‹å»ï¼Œå½“sum&gt;sæ—¶ï¼Œå°†fromä»sumå‡å»ï¼ŒåŒæ—¶from++ï¼Œæ»‘åŠ¨æ£€ç´¢ã€‚","text":"å†™åœ¨å‰é¢ æœ€è¿‘äº‹æƒ…æ¯”è¾ƒå¤šï¼ŒåŠç­¾è¯ï¼Œå†™è®ºæ–‡ï¼Œæ”¹æ ¼å¼ï¼Œæ²¡ä»€ä¹ˆæ—¶é—´åˆ·é¢˜å’Œçœ‹ç½‘è¯¾äº†ï¼Œç°åœ¨æ€»ç®—æ˜¯é—²ä¸‹æ¥äº†ï¼Œä¹‹åå¤§æ¦‚å°±æ˜¯ä¸€éå‡†å¤‡ç­”è¾©pptä¸€éåˆ·é¢˜å§ã€‚åŠ æ²¹åŠ æ²¹ã€‚ 209. Minimum Size Subarray Sum(two pointers) class solution&#123; public int minsub(int s, int[] nums)&#123; int sum = 0, int from = 0, mn = Integer.MAX_VALUE; for(int i = 0; i&lt; nums.length;i++)&#123; sum+=nums[i]; while(sum&gt;=s)&#123; mn = Math.min(mn,i-from+1); sum-=nums[from]; from++; &#125; &#125; return (mn == Integer.MAX_VALUE)? 0 : mn; &#125;&#125; åŒæŒ‡é’ˆé—®é¢˜ï¼Œfromä¸ºèµ·å§‹ä½ç½®ï¼Œsliding windowæ€æƒ³å¾ªç¯ä¸‹å»ï¼Œå½“sum&gt;sæ—¶ï¼Œå°†fromä»sumå‡å»ï¼ŒåŒæ—¶from++ï¼Œæ»‘åŠ¨æ£€ç´¢ã€‚ 222. Count Complete Tree Nodes /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; int leftdepth = leftdepth(root); int rightdepth = rightdepth(root); if(leftdepth == rightdepth)&#123; return (1 &lt;&lt; leftdepth) -1; &#125; else&#123; return 1+countNodes(root.left) + countNodes(root.right); &#125; &#125; private int leftdepth(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; root = root.right; dep++; &#125; return dep; &#125; private int rightdepth(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; root = root.left; dep++; &#125; return dep; &#125;&#125; åˆ¤æ–­èŠ‚ç‚¹çš„ä¸ªæ•°ï¼ŒèŠ‚ç‚¹æ•°Nå’Œå±‚æ•°depthå¯¹å…³ç³»ï¼šN = 2^depth - 1ã€‚ç„¶ååˆ†å·¦å³ä¿©ä¸ªdepthå‡½æ•°æ¥è®¡ç®—æ·±åº¦ã€‚ 87. Scramble String class solution&#123; public boolean isScramble(String s1, String s2)&#123; if(s1 == null || s2 == null) return false; if(s1.equals(s2)) return true; if(s1.length() != s2.length()) return false; int[] letters = new int[26]; int len = s1.length(); for(int i = 0;i&lt;len;i++)&#123; letters[s1.charAt(i) - 'a']++; letters[s2.charAt(i) - 'a']--; &#125; for(int i = 0;i&lt;26;i++)&#123; if(letters[i] !=0)return false; &#125; for(int i = 1; i&lt;len;i++)&#123; if(isScramble(s1.substring(0,i), s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) return true; if(isScramble(s1.substring(0,i), s2.substring(len-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0,len-i))) return true; &#125; return false; &#125;&#125; ç±»ä¼¼trieçš„æ ‘å­—å…¸ï¼Œä½†æ˜¯åšæ³•æ¯”è¾ƒç®€å•ã€‚åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯åŒä¸€ä¸ªï¼Œå…ˆåˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼Œå…¶æ¬¡åˆ¤æ–­æ˜¯å¦ç›´æ¥ç›¸ç­‰ï¼Œåœ¨åˆ¤æ–­é•¿åº¦ï¼ˆè¿™é‡Œå¦‚æœé•¿åº¦ä¸åŒç›´æ¥falseï¼‰ ç”¨letter å­˜ä½æ¯ä¸ªå­—æ¯çš„å€¼ï¼Œs1çš„++ï¼Œs2çš„â€“ï¼Œå¦‚æœç›¸åŒåº”è¯¥ä»ä¸º0ã€‚æ³¨æ„substringçš„ç”¨æ³•ã€‚ï¼ˆèµ·å§‹ï¼Œç»“æŸï¼‰or(æŸä½ç½®ä»¥åçš„å…¨éƒ¨å…ƒç´ )ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"F-1 VISA Approvedï¼","slug":"Ç©Ö¤","date":"2019-06-05T02:29:43.000Z","updated":"2019-10-02T05:07:38.172Z","comments":true,"path":"2019/06/04/Ç©Ö¤/","link":"","permalink":"WangHngLeee.github.io/2019/06/04/Ç©Ö¤/","excerpt":"","text":"ä»Šå¤©å»åŒ—äº¬å®‰å®¶æ¥¼é¢ç­¾ï¼Œäººè¶…å¤šï¼Œæ²¡æƒ³åˆ°voåªè¦äº†æˆ‘çš„cvå’Œstudy plan å°±ç»™approvedäº†ï¼Œæ¯”è¾ƒå¹¸è¿ã€‚ æ¥ä¸‹æ¥ç»§ç»­åŠªåŠ›å§~ å¥½å‡ å¤©æ²¡åˆ·é¢˜äº†ï¼Œäº‹æƒ…æ¯”è¾ƒå¤šï¼ŒåŠ æ²¹åŠ æ²¹ã€‚","categories":[{"name":"Life","slug":"Life","permalink":"WangHngLeee.github.io/categories/Life/"}],"tags":[{"name":"F-1 VISA","slug":"F-1-VISA","permalink":"WangHngLeee.github.io/tags/F-1-VISA/"}]},{"title":"Leetcode EveryDay 19","slug":"leetcode 19","date":"2019-05-30T12:41:06.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/05/30/leetcode 19/","link":"","permalink":"WangHngLeee.github.io/2019/05/30/leetcode 19/","excerpt":"153. Find Minimum in Rotated Sorted Array (Binary search) class solution&#123; public int findmin(int[] nums)&#123; int left = 0; int right = nums.length-1; while(left&lt;right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else&#123; left = mid+1; &#125; &#125;return nums[left]; &#125;&#125;","text":"153. Find Minimum in Rotated Sorted Array (Binary search) class solution&#123; public int findmin(int[] nums)&#123; int left = 0; int right = nums.length-1; while(left&lt;right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else&#123; left = mid+1; &#125; &#125;return nums[left]; &#125;&#125; æ€è·¯ æ— é‡å¤æ•°å­—ã€‚äºŒåˆ†æŸ¥æ‰¾çš„åŸºæœ¬æ€æƒ³ã€‚ç¨å¾®éš¾åº¦å¢åŠ ï¼Œè¦æ±‚æ‰¾åˆ°æœ€å°å€¼ï¼Œå¹¶ä¸”æ•°ç»„sort rotatedã€‚åŸºæœ¬æ€è·¯å’ŒäºŒåˆ†å·®ä¸å¤šï¼Œè®¾ç½®midï¼Œåˆ¤æ–­midå’Œrightçš„å¤§å°ã€‚å¦‚æœmid&lt;rightï¼Œé‚£ä¹ˆè¯´æ˜midåœ¨é¡ºåºsortçš„æ•°ç»„é‡Œï¼Œæ­£å¸¸ç¼©å°rightèŒƒå›´å³å¯ã€‚å¦‚æœmid&gt;rightæ—¶ï¼Œè¯´æ˜rotateçš„æ•°ç»„éƒ¨åˆ†åœ¨midå³ä¾§ï¼Œæ‰€ä»¥æ›´æ–°leftä¸ºmid+1ã€‚æœ€åè¿”å›leftå€¼ã€‚ 154. Find Minimum in Rotated Sorted Array II (Binary search) class solution&#123; public int findmin2(int nums)&#123; int start = 0; int end = nums.length-1; while(start&lt;end)&#123; int mid = start + (end-start)/2; if(nums[mid] &gt; nums[end])&#123; start = mid+1; &#125; else if(nums[mid] &lt; nums[end])&#123; end = mid; &#125; else&#123; end--; &#125; &#125; return nums[start]; &#125;&#125; æ€è·¯ ä¸Šä¸€é¢˜çš„å‡çº§ç‰ˆï¼Œå­˜åœ¨é‡å¤çš„æ•°å­—ã€‚ æ¯”ç¬¬ä¸€é“é¢˜å¤šäº†ä¸€ä¸ªåˆ†ææƒ…å†µï¼Œå½“mid = endæ—¶ï¼Œendè¦â€“ï¼Œä¾æ—§æ˜¯å’Œendçš„æ•°å­—æ¯”è¾ƒï¼Œæ¯”ç›´æ¥å’Œstartæ•°å­—æ¯”è¾ƒæ–¹ä¾¿å¿«æ·ã€‚ 167. Two Sum II - Input array is sorted è‡ªå·±åšçš„binary search æ–¹æ³•ï¼Œ4msï¼Œè¶…è¿‡19%ï¼Œæœ‰ç‚¹æ…¢ class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; for(int i = 0; i &lt;numbers.length;i++)&#123; int left = i+1,right = numbers.length -1; int temp = target - numbers[i]; while(left &lt;= right)&#123; int mid = left + (right - left) /2; if(numbers[mid] == temp)&#123; return new int[]&#123;i+ 1, mid+ 1&#125;; &#125;else if(numbers[mid] &lt; temp)&#123; left = mid+1; &#125;else&#123; right = mid -1; &#125; &#125; &#125; return null; &#125;&#125; çœ‹äº†discussï¼Œæ¯”è¾ƒå¥½çš„æ˜¯two pointeræ–¹æ³•ã€‚ class souliton&#123; public int[] twoSum(int[] num, int target) &#123; int[] index = new int[2]; if(num == null || num.length&lt;2)return index; int left = 0, right = num.length -1; while(left&lt;right)&#123; long v = nums[left] + nums[right]; if(v == target)&#123; index[0] = left + 1; index[1] = right + 1; brerak; &#125; else if(v &gt;target)&#123; right --; &#125;else&#123; left ++; &#125; &#125; return index; &#125;&#125; æ¯”è¾ƒç›´è§‚ï¼Œå®¹æ˜“ç†è§£çš„æ€è·¯ï¼Œç”¨long v ä»£æ›¿ int væ˜¯ä¸ªå¾ˆå¥½çš„æ–¹æ³•ï¼Œä¸ºäº†é˜²æ­¢int overflowã€‚ 174. Dungeon Game (dp programming) class solution&#123; public int caculationminHP(int[][] dungeon)&#123; if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)return 0; int m = dungeon.length; int n = dungeon[0].length; int[][]hp = new int[m][n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; if(i == m-1 &amp;&amp; j == n-1)&#123; hp[i][j] = Math.max(1-dungeon[i][j], 1); &#125; else if( i == m-1)&#123; hp[i][j] = Math.max(hp[i][j+1] - dungeon[i][j], 1); &#125; else if( j == n-1)&#123; hp[i][j] = Math.max(hp[i+1][j] - dungeon[i][j], 1); &#125; else&#123; hp[i][j] = Math.min(Math.max(hp[i][j+1] - dungeon[i][j],1 ),Math.max(hp[i+1][j] - dungeon[i][j], 1)); &#125; &#125; &#125; return hp[0][0]; &#125;&#125; æ€è·¯ éå¸¸çƒ§è„‘çš„ä¸€é“é¢˜ã€‚è‡ªä¸‹è€Œä¸Šçš„dpæ€æƒ³ã€‚å½“å‰ä½ç½®çš„ç”Ÿå‘½å€¼æœ€å°‘ä¸º1ï¼Œæ‰€ä»¥è¦æ»¡è¶³å½“å‰hpå‡å»åœ°ç‰¢æŸè€—å€¼ &gt;=1ã€‚ å››ç§æƒ…å†µï¼š 1.æœ€å³ä¸‹è§’çš„ä½ç½®ï¼Œç»ˆç‚¹å¤„ç”Ÿå‘½å€¼åˆ¤æ–­ï¼› 2.æœ€åä¸€è¡Œï¼Œä»å³è‡³å·¦æ‰«æï¼Œä¸Šä¸€ä¸ªhpå‡å»å½“å‰çš„åœ°ç‰¢æŸè€—å€¼&gt;1å³å¯ 3.æœ€åä¸€åˆ—ï¼Œä»ä¸‹è‡³ä¸Šæ‰«æï¼Œä¸Šä¸€ä¸ªhpå‡å»å½“å‰çš„åœ°ç‰¢æŸè€—å€¼&gt;1å³å¯ 4.ä»»æ„ä½ç½®ï¼Œè¦æ±‚è¿™ä¸ªä½ç½®çš„å³æ–¹æˆ–è€…ä¸‹æ–¹çš„å€¼å‡å»ç›¸å¯¹åº”çš„æŸè€—å€¼åéƒ½è¦å¤§äº1ï¼Œå¹¶ä¸”åœ¨ç¬¦åˆè¦æ±‚çš„hpä¸­é€‰å–æœ€å°çš„æœ€ä¸ºæœ€ä¼˜é€‰ã€‚ æœ€åè¿”å›hp[0][0],ä¹Ÿå°±æ˜¯èµ·å§‹ä½ç½®çš„æœ€å°å€¼ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 18","slug":"leeetcode18","date":"2019-05-29T12:41:06.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/05/29/leeetcode18/","link":"","permalink":"WangHngLeee.github.io/2019/05/29/leeetcode18/","excerpt":"138. Copy List with Random Pointer (Hashmap &amp;&amp; linkedlist)","text":"138. Copy List with Random Pointer (Hashmap &amp;&amp; linkedlist) /*// Definition for a Node.class Node &#123; public int val; public Node next; public Node random; public Node() &#123;&#125; public Node(int _val,Node _next,Node _random) &#123; val = _val; next = _next; random = _random; &#125;&#125;;*/class Solution &#123; public RandomListNode copyRandomlist(RandomListNode head)&#123; if (head == null)return head; Node cur = head; while(curr!=null)&#123; Node next = cur.next; cur.next = new Node(cur.val, next, null); cur = next; &#125; cur = head; while(cur!=null)&#123; if(cur.random!=null)&#123; cur.next.random = c.random.next; &#125; cur = cur.next.next; &#125; cur = head; Node copyhead = head.next; while(cur!=null)&#123; Node curnext = cur.next.next;//curé“¾è¡¨ Node copy = cur.next;//copyé“¾è¡¨ cur.next = curnext; if(curnext!=null)&#123; copy.next = curnext.next; &#125; cur = curnext; &#125; return copyhead; &#125;&#125; æ€è·¯ åœ¨åŸnodeçš„åé¢å¤åˆ¶ä¸€ä¸ªnodeâ€™ï¼Œç„¶åå°†randomæŒ‡å‘å¯¹åº”çš„ä½ç½®ï¼Œæœ€åå„è‡ªè¿æ¥é“¾è¡¨ï¼Œå…±ä¸‰æ¬¡å¾ªç¯ï¼Œç¬¬ä¸€æ¬¡å¤åˆ¶ï¼Œç¬¬äºŒæ¬¡randomè¿çº¿ï¼Œç¬¬ä¸‰æ¬¡å„è‡ªæˆçº¿ã€‚ å¤§æ¦‚æ€è·¯å¦‚å›¾ï¼š 74. Search a 2D Matrix (Binary Search) class solution&#123; public boolean search(int[][] matrix, int target)&#123; int start = 0; int rows = matrix.length; int cols = matrix[0].length; int end = rows*cols-1; while(start&lt;=end)&#123; mid = (start+end)/2; if(matrix[mid/cols][mid%cols] == target)&#123; return true; &#125; else if(matrix[mid/cols][mid%cols] &lt; target)&#123; start = mid + 1; &#125; else&#123; end = mid -1; &#125; &#125; return false; &#125;&#125; æ€è·¯ äºŒåˆ†æŸ¥æ‰¾çš„é¢˜ï¼ŒåŸé¢˜æ˜¯2DçŸ©é˜µï¼Œä½†å…¶å®ä¸ç”¨é‚£ä¹ˆå¤æ‚ï¼Œè€ƒè™‘ä¸ºä¸€ä½æ•°ç»„å°±å¯ä»¥ï¼Œåˆ©ç”¨mid/colså¯ä»¥åˆ¤æ–­æ˜¯ç¬¬å‡ å°æ®µï¼Œç±»ä¼¼æ¨ªå‘æ’å¸ƒï¼Œæ‰€ä»¥matrix[mid/cols][mid%cols]æ–¹æ³•å°†äºŒç»´çŸ©é˜µè½¬æ¢æˆäº†ä¸€ç»´æ•°ç»„çš„é—®é¢˜ã€‚ä¸é”™çš„ideaã€‚ 81. Search in Rotated Sorted Array II(Binary Search) class solution&#123; public boolean search(int[] nums ,int target)&#123; int start = 0, end = nums.length - 1; //check each num so we will check start == end //We always get a sorted part and a half part //we can check sorted part to decide where to go next while(start&lt;=end)&#123; int mid = start + (end-start)/2; if(nums[mid] == target)return true; //if left part is sorted if(nums[mid] &gt; nums[start])&#123; if(target &gt; nums[mid] || target &lt; nums[start])&#123; //target is in rotated part start = mid +1; &#125;else&#123; end = mid -1; &#125; &#125;else if(nums[mid] &lt; nums[start])&#123; //right part is rotated //target is in rotated part if(target &lt; nums[mid] || target &gt; nums[end])&#123; end = mid -1; &#125;else&#123; start = mid + 1; &#125; &#125;else&#123; //duplicates, we know nums[mid] != target, so nums[start] != target //based on current information, we can only move left pointer to skip one cell //thus in the worest case, we would have target: 2, and array like 11111111, then //the running time would be O(n) start++;//è¿™é‡Œç”¨end--ä¹Ÿæ˜¯å¯ä»¥çš„ &#125; &#125;return false; &#125;&#125; æ€è·¯ ä¸€é“æ¯”è¾ƒå¤æ‚çš„äºŒåˆ†æŸ¥æ‰¾ï¼Œæ•°ç»„æ— è§„å¾‹sortï¼Œåˆ†ä¸ºé«˜ä½ä¸¤åŒºï¼Œéœ€è¦åˆ¤æ–­å“ªä¸ªåŒºç„¶åå†è¿›ä¸€æ­¥åšå†³å®šï¼Œå…·ä½“æ¯”è¾ƒç¹çã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 17","slug":"leetcode17","date":"2019-05-28T12:36:39.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/28/leetcode17/","link":"","permalink":"WangHngLeee.github.io/2019/05/28/leetcode17/","excerpt":"å†™åœ¨å¼€å¤´ åˆšæ‰åˆ·ä¸€äº©ä¸‰åˆ†åœ°ï¼Œçœ‹åˆ°æœ‰å¤§ä½¬åœ¨åˆ†äº«è‡ªå·±çš„ä¸Šå²¸å¿ƒå¾—ï¼Œæ„Ÿè§¦æŒºå¤šã€‚ä»–è¯´åˆ·é¢˜æ˜¯ä¸€é¡¹é•¿ä¹…çš„å·¥ä½œï¼Œåƒåƒé¥­ä¸€æ ·ï¼Œä¸èƒ½åœï¼Œè¦æ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿï¼Œå¤šå¤ä¹ å¤šæ€»ç»“ã€‚ è¿™ä¸€ç‚¹æˆ‘è™½ç„¶åšåˆ°äº†ä½†æ˜¯è¿˜è¦åšæŒä¸‹å»ã€‚åˆ·é¢˜çš„æ—¶å€™è¦æ€è€ƒï¼Œå¦‚æœé¢è¯•é—®åˆ°äº†è¿™é“é¢˜, äººå®¶ä¸ºä»€ä¹ˆè¦é—®ï¼Ÿå¸–å­çš„æ¥¼ä¸»è¯´å¾—æœ‰é“ç†ï¼Œå…¬å¸å®é™…é‡ä¸åˆ°çš„é—®é¢˜æ€ä¹ˆä¼šè€ƒä½ å‘¢ï¼Ÿ æ‰€ä»¥è¦æŠŠè¿™é“é¢˜å½“æˆç›®æ ‡å…¬å¸éœ€è¦è§£å†³çš„é—®é¢˜æ¥æ€è€ƒï¼Œå¤šè·Ÿhräº¤æµæ²Ÿé€šæ€è·¯ï¼Œä¸è¦é—·å¤´è§£é¢˜ã€‚ æ¯•ç«Ÿä¸€å…±ä¸€åƒå¤šé“é¢˜ï¼Œä¸€æ¬¡æŠ•å…¥æŒä¹…æ€§äº§å‡ºï¼ˆæ»‘ç¨½è„¸ï¼‰ã€‚ è¨€å½’æ­£ä¼ ï¼Œç»§ç»­åˆ·é¢˜å§ã€‚ä»Šåä¸»è¦æŒ‰tagæ¥åˆ·é¢˜ï¼Œæ›´æœ‰é’ˆå¯¹æ€§äº†ã€‚","text":"å†™åœ¨å¼€å¤´ åˆšæ‰åˆ·ä¸€äº©ä¸‰åˆ†åœ°ï¼Œçœ‹åˆ°æœ‰å¤§ä½¬åœ¨åˆ†äº«è‡ªå·±çš„ä¸Šå²¸å¿ƒå¾—ï¼Œæ„Ÿè§¦æŒºå¤šã€‚ä»–è¯´åˆ·é¢˜æ˜¯ä¸€é¡¹é•¿ä¹…çš„å·¥ä½œï¼Œåƒåƒé¥­ä¸€æ ·ï¼Œä¸èƒ½åœï¼Œè¦æ¯å¤©åˆ·é¢˜ï¼Œä¿æŒæ‰‹æ„Ÿï¼Œå¤šå¤ä¹ å¤šæ€»ç»“ã€‚ è¿™ä¸€ç‚¹æˆ‘è™½ç„¶åšåˆ°äº†ä½†æ˜¯è¿˜è¦åšæŒä¸‹å»ã€‚åˆ·é¢˜çš„æ—¶å€™è¦æ€è€ƒï¼Œå¦‚æœé¢è¯•é—®åˆ°äº†è¿™é“é¢˜, äººå®¶ä¸ºä»€ä¹ˆè¦é—®ï¼Ÿå¸–å­çš„æ¥¼ä¸»è¯´å¾—æœ‰é“ç†ï¼Œå…¬å¸å®é™…é‡ä¸åˆ°çš„é—®é¢˜æ€ä¹ˆä¼šè€ƒä½ å‘¢ï¼Ÿ æ‰€ä»¥è¦æŠŠè¿™é“é¢˜å½“æˆç›®æ ‡å…¬å¸éœ€è¦è§£å†³çš„é—®é¢˜æ¥æ€è€ƒï¼Œå¤šè·Ÿhräº¤æµæ²Ÿé€šæ€è·¯ï¼Œä¸è¦é—·å¤´è§£é¢˜ã€‚ æ¯•ç«Ÿä¸€å…±ä¸€åƒå¤šé“é¢˜ï¼Œä¸€æ¬¡æŠ•å…¥æŒä¹…æ€§äº§å‡ºï¼ˆæ»‘ç¨½è„¸ï¼‰ã€‚ è¨€å½’æ­£ä¼ ï¼Œç»§ç»­åˆ·é¢˜å§ã€‚ä»Šåä¸»è¦æŒ‰tagæ¥åˆ·é¢˜ï¼Œæ›´æœ‰é’ˆå¯¹æ€§äº†ã€‚ 64. Minimum Path Sum è‡ªå·±åšå‡ºæ¥çš„dpé¢˜ï¼Œæ€è·¯å¾ˆç®€å•ï¼Œä¹‹å‰åšè¿‡è®¸å¤šç±»ä¼¼çš„ï¼Œç›´æ¥ä¸Šä»£ç å§ã€‚ class solution&#123; public int minpath(int[][] grid)&#123; int m = grid.length; int n = grid[0].length; for(int i = 0 ; i&lt; m;i++)&#123; for(int j =0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j !=0)&#123;//ç¬¬ä¸€è¡Œ grid[i][j]+=grid[i][j-1]; &#125; else if (i!=0 &amp;&amp; j == 0)&#123;//ç¬¬ä¸€åˆ— grid[i][j] += grid[i-1][j]; &#125; else if(i==0&amp; j ==0)&#123;//å·¦ä¸Šè§’åŸç‚¹ grid[i][j]=grid[i][j]; &#125; else&#123;//æ­£å¸¸ç´¯åŠ ï¼Œå–æœ€å°å€¼ grid[i][j]+=Math.min(grid[i][j-1],grid[i-1][j]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; æ€è·¯ å’Œä¹‹å‰çš„unique path ä¸€ä¸ªæ€è·¯ï¼Œä¹‹åä¸è¿‡æ˜¯å°†æ¯ä¸ªç‚¹çš„è·¯å¾„æ•°é‡æ¢æˆäº†æƒå€¼ï¼Œéœ€è¦åœ¨æœ€åç´¯åŠ æ—¶ç”¨minæ¥å†³å®šæœ€å°å€¼çš„è·¯å¾„ã€‚ 67. Add Binary class solution&#123; public String addbinary(String a, String b)&#123; int i = a.length()-1;//ä»æœ«å°¾å¼€å§‹ç´¯åŠ  int j = b.length()-1; int carry = 0; StringBuilder sb = new StringBuilder(); while( i &gt;=0 || j&gt;= 0)&#123; int sum = carry; if( i &gt;=0)&#123; sum += a.charAt(i)-'0'; i--; &#125; if(j&gt;=0)&#123; sum += b.charAt(j)-'0'; j--; &#125; sb.append(sum%2);//sumå’Œ2çš„å…³ç³»ï¼Œé‡åˆ°sum=2 åŠ 0,1å’Œ0åˆ™ä¸ºæœ¬èº«ã€‚ carry = sum/2;// åˆ¤æ–­è¿›ä½ï¼Œåªæœ‰é‡åˆ°2æ—¶æ‰ä¸º1ï¼Œå…¶ä½™éƒ½ä¸º0. &#125; if(carry!=0) sb.append(carry);//åŠ å…¥æœ€åä¸€ä¸ªcarry return sb.reverse().toString();//é€†è½¬ä¸€ä¸‹ï¼Œå› ä¸ºä»æœ«å°¾å¼€å§‹æ˜¯é¡ºåºåŠ å…¥stringçš„ï¼Œæ‰€ä»¥è¦é€†åºè¾“å‡º &#125;&#125; æ€è·¯ äºŒè¿›åˆ¶åŠ æ³•é¢˜ï¼Œä»æœ«ä½ç›¸åŠ ï¼Œé‡è¦çš„æ˜¯sum%2 å’Œ sum/2çš„æ€æƒ³ã€‚æœ€åé€†åºè¾“å‡ºã€‚ å…¶å®ä¹Ÿå¯ä»¥ç”¨stackåšï¼Œæœ€åsb.add(stack.pop())å°±å¯ä»¥ï¼Œä½†æ˜¯æ¯”è¾ƒéº»çƒ¦ï¼Œè¿˜æ˜¯å–œæ¬¢StringBuilder çš„åšæ³•ã€‚ 85. Maximal Rectangle class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return 0; int m = matrix.length, n = matrix[0].length, maxArea = 0; int[] left = new int[n]; int[] right = new int[n]; int[] height = new int[n]; Arrays.fill(right, n - 1); for (int i = 0; i &lt; m; i++) &#123;//right ä»å³è‡³å·¦æ‰«æï¼Œæ‰¾min int rB = n - 1; for (int j = n - 1; j &gt;= 0; j--) &#123; if (matrix[i][j] == '1') &#123; right[j] = Math.min(right[j], rB); &#125; else &#123; right[j] = n - 1; rB = j - 1; &#125; &#125; int lB = 0; for (int j = 0; j &lt; n; j++) &#123;//left ä»å·¦è‡³å³æ‰«æï¼Œæ‰¾max if (matrix[i][j] == '1') &#123; left[j] = Math.max(left[j], lB); height[j]++; maxArea = Math.max(maxArea, height[j] * (right[j] - left[j] + 1)); &#125; else &#123; height[j] = 0; left[j] = 0; lB = j + 1; &#125; &#125; &#125; return maxArea; &#125;&#125; æ€è·¯ æŒºéš¾çš„ä¸€é“é¢˜ï¼Œæ‰¾å‡ºæœ€å¤§çš„çŸ©å½¢é¢ç§¯ã€‚ æ˜æ˜¾çš„DPæ–¹æ³•ï¼Œä½†æ˜¯å…·ä½“çš„æ€è·¯è¿˜æ˜¯å¬çƒ§è„‘çš„ã€‚ ç­–ç•¥: æŠŠmatrixçœ‹æˆå¤šä¸ªç›´æ–¹å›¾, æ¯ä¸€è¡ŒåŠå…¶ä¸Šæ–¹çš„æ•°æ®éƒ½æ„æˆä¸€ä¸ªç›´æ–¹å›¾, éœ€è¦è€ƒå¯Ÿmatrix.size()ä¸ªç›´æ–¹å›¾ å¯¹äºæ¯ä¸ªç‚¹(row, col), æˆ‘ä»¬æœ€åéƒ½è®¡ç®—ä»¥è¿™ä¸ªç‚¹ä¸Šæ–¹çš„è¿ç»­çš„â€™1â€™å¾€left, rightæ–¹å‘å»¶ç”³å¯ä»¥å¾—åˆ°çš„æœ€å¤§çš„çŸ©å½¢çš„é¢ç§¯ é€šè¿‡è¿™ç§æ–¹æ³•è·å–çš„çŸ©å½¢ä¸€å®šä¼šæŠŠæœ€å¤§çš„çŸ©å½¢åŒ…å«åœ¨å†… height[row][col]è®°å½•çš„æ˜¯(row, col)è¿™ä¸ªåæ ‡ä¸ºåº•åº§çš„ç›´æ–¹å›¾æŸ±å­çš„é«˜åº¦, å¦‚æœè¿™ä¸ªç‚¹æ˜¯â€™0â€™, é‚£ä¹ˆé«˜åº¦å½“ç„¶æ˜¯0äº† left[row][col]è®°å½•çš„æ˜¯(row, col)è¿™ä¸ªåæ ‡ç‚¹å¯¹åº”çš„heightå¯ä»¥å»¶ç”³åˆ°çš„æœ€å·¦è¾¹çš„ä½ç½® right[row][col]è®°å½•çš„æ˜¯(row, col)è¿™ä¸ªåæ ‡ç‚¹å¯¹åº”çš„heightå¯ä»¥å»¶ç”³åˆ°çš„æœ€å³è¾¹çš„ä½ç½®+1 ä»¥ä¸Šé¢çš„matrixä¸ºä¾‹, å¯¹äº(row=2, col=1)è¿™ä¸ªç‚¹, left=0, right=5, height=1 å¯¹äº(row=2, col=2)è¿™ä¸ªç‚¹, left=2, right=3, height=3 (2,2)è¿™ä¸ªç‚¹ä¸(2,1)ç´§æŒ¨ç€,leftå’Œrightå´å·²ç»å˜åŒ–å¦‚æ­¤ä¹‹å¤§äº†, è¿™æ˜¯å› ä¸ºleftå’Œrighté™¤äº†å—å·¦å³ä¸¤è¾¹çš„â€™1â€™å½±å“, è¿˜å—åˆ°äº†å…¶ä¸Šæ–¹è¿ç»­çš„â€™1â€™çš„åˆ¶çº¦ ç”±äºç‚¹(2,2)ä¸Šæœ‰height=3ä¸ªâ€™1â€™, è¿™å‡ ä¸ªâ€™1â€™çš„leftçš„æœ€å¤§å€¼ä½œä¸ºå½“å‰ç‚¹çš„left, è¿™å‡ ä¸ªâ€™1â€™çš„rightçš„æœ€å°å€¼ä½œä¸ºå½“å‰ç‚¹çš„right å› æ­¤, å®é™…ä¸Š, æˆ‘ä»¬æ˜¯è¦æ‰¾ä»¥hightå¯¹åº”çš„è¿™æ¡çº¿æ®µå¾€å·¦å³ä¸¤è¾¹ç§»åŠ¨(åªèƒ½å¾€å…¨æ˜¯â€™1â€™çš„åœ°æ–¹ç§»åŠ¨), å¯ä»¥æ‰«è¿‡çš„æœ€å¤§é¢ç§¯ å½“hightä¸ç›®æ ‡æœ€å¤§çŸ©å½¢åŒºåŸŸçš„æœ€çŸ­çš„heighté‡åˆæ—¶, æœ€å¤§çŸ©å½¢çš„é¢ç§¯å°±æ‰¾åˆ°äº†, å¦‚ä¸Šé¢çš„ä¾‹å­, å°±æ˜¯ç‚¹(2,3)æˆ–(2,4)å¯¹åº”çš„height 72. Edit Distance class solution&#123; public int mindistance(String word1,String word2)&#123; int m = word1.length(); int n = word2.length(); int[][] dp = new int[m+1][n+1]; for(int i = 0;i&lt;=m;i++)// æœ€å·¦åˆ—æƒ…å†µï¼Œword1å­˜åœ¨ï¼Œword2ä¸ºç©º cost[i][0] = i; for(int i = 1; i&lt;=n;i++)//æœ€ä¸Šè¡Œæƒ…å†µï¼Œword2å­˜åœ¨ï¼Œword1ä¸ºç©º cost[0][i]=i; for(int i = 0; i &lt;=m;i++)&#123; for(int j = 0; j &lt;=n;j++)&#123; if(word1.charAt(i) == word2.charAt(j))&#123;// i å’Œj å…ƒç´ ç›¸åŒ dp[i][j] = dp[i-1][j-1]; &#125; else&#123;//ä¸åŒçš„æƒ…å†µä¸‹ï¼Œä¸‰ç§æªæ–½ int replace = dp[i-1][j-1]; int delete = dp[i-1][j]; int insert = dp[i][j-1]; cost[i][j] = Math.min(replace,Math.min(delete,insert))+1; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; æ€è·¯ å…¸å‹çš„dpé¢˜ï¼Œå­—ç¬¦ä¸²çš„å¢åˆ æ›¿æ¢ï¼Œç”¨dpæ€æƒ³ï¼Œä¸€å…±æœ‰å››ç§æ“ä½œã€‚ 1.word1 çš„iå…ƒç´ å’Œword2çš„jå…ƒç´ ç›¸åŒï¼Œæ— æ“ä½œï¼Œå…¶æ“ä½œæ¬¡æ•°ä¸ºdp[i-1][j-1]å³ä¸Šä¸€ä¸ªå­—æ¯çš„æƒ…å†µã€‚2.è¿™ä¸¤ä¸ªå…ƒç´ ä¸ç›¸åŒï¼Œå¯ä»¥æœ‰ä¸‰ç§æ“ä½œï¼š (1) replace æ›¿æ¢ï¼Œdp[i-1][j-1]ï¼Œå°†ä¸Šä¸€ä¸ªå­—æ¯æ›¿æ¢ä¸ºå½“å‰å­—æ¯ï¼Œ (2) delete åˆ é™¤ï¼Œå°†word1é‡Œå½“å‰å…ƒç´ åˆ é™¤ï¼Œdp[i-1][j]ï¼Œå˜ä¸ºå…¶å‰ä¸€ä¸ªå­—æ¯ (3) insert æ’å…¥ï¼Œå‘word1é‡Œæ’å…¥word2çš„å‰ä¸€ä¸ªå…ƒç´ ï¼Œdp[i][j-1]ï¼Œ æ³¨æ„å–è¿™ä¸‰è€…çš„æœ€å°å€¼ï¼Œç„¶ååŠ 1ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 16","slug":"leetcode16","date":"2019-05-27T13:19:39.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/05/27/leetcode16/","link":"","permalink":"WangHngLeee.github.io/2019/05/27/leetcode16/","excerpt":"52. N-Queens II class solution&#123; int res = 0; public int nqueen2(int n)&#123; boolean[] col = new boolean[n]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; private void solve(int row, int n, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0;j&lt;nlj++)&#123; if(!col[j] &amp;&amp; !diag1[row+j] &amp;&amp; ! diag2[row-j+n-1])&#123; col[j]=true; diag1[row + j] = true; diag2[row-j+n-1]= true; solve(row+1,n,col,diag1,diag2); diag2[row-j+n-1]= false; diag1[row + j] = false; col[j]=false; &#125; &#125; &#125;&#125;","text":"52. N-Queens II class solution&#123; int res = 0; public int nqueen2(int n)&#123; boolean[] col = new boolean[n]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; private void solve(int row, int n, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0;j&lt;nlj++)&#123; if(!col[j] &amp;&amp; !diag1[row+j] &amp;&amp; ! diag2[row-j+n-1])&#123; col[j]=true; diag1[row + j] = true; diag2[row-j+n-1]= true; solve(row+1,n,col,diag1,diag2); diag2[row-j+n-1]= false; diag1[row + j] = false; col[j]=false; &#125; &#125; &#125;&#125; æ€è·¯ å’ŒNQueenæ€è·¯åŸºæœ¬ä¸€è‡´ï¼Œåªä¸è¿‡è¾“å‡ºçš„æ˜¯ç§ç±»æ•°é‡è€Œä¸æ˜¯Qçš„æ’åˆ—æ–¹å¼ã€‚æ‰€ä»¥ç›¸æ¯”äºQueen1æ¥è¯´æ¯”è¾ƒç®€å•ã€‚backtrackingçš„æ€æƒ³ã€‚ 57. Insert Interval class solution&#123; public int[][] insert(int[][] intervals, int[] newInterval)&#123; List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for(int [] interval : intervals)&#123; if(newInterval[1]&lt;interval[0])&#123; ans.add(newInterval); newInterval = interval; &#125; else if(newInterval[0] &gt; interval[1])&#123; ans.add(interval); &#125; else&#123; newInterval[0] = Math.max(newInterval[0],interval[0]); newInterval[1] = Math.min(newInterval[1],interval[1]); &#125; &#125; ans.add(newInterval); return ans.toArray( new int[][] &#123;&#125;); &#125;&#125; æ³¨æ„å–èˆçš„æƒ…å†µï¼Œintervalçš„å¼€å¤´ç»“å°¾å’Œnewintervalçš„å¼€å¤´ç»“å°¾è¿›è¡Œæ¯”è¾ƒã€‚ä¸‰ç§æƒ…å†µã€‚newå°ï¼Œå°†newåŠ å…¥ansï¼Œå¹¶æ›´æ–°newï¼›intervalå°ï¼Œå°†intervalåŠ å…¥ansã€‚ï¼›æœ‰é‡åˆéƒ¨åˆ†ï¼Œå¼€å¤´å–æœ€å°ï¼Œç»“å°¾å–æœ€å¤§ã€‚ 58. Length of Last Word class solution&#123; public int length(String s)&#123; if(s == null || s.length() == 0)&#123; return 0; &#125; int end = s.length() -1; while(end&gt;=0 &amp;&amp; s.charAt(end) == ' ')&#123; end--; &#125; if(end == -1)return 0; int start = end; while(start&gt;=0 &amp;&amp; s.charAt(start) != ' ')&#123; start--; &#125; return end - start; &#125;&#125; æŒ‰ç…§ç©ºæ ¼åˆ†éš”ï¼Œendé‡åˆ°ç©ºæ ¼å‡ä¸€ï¼Œè€Œstarté‡åˆ°éç©ºæ ¼å‡ä¸€ï¼Œä»åå‘å‰æ£€ç´¢ï¼Œæœ€åè¾“å‡ºend-startã€‚ 59. Spiral Matrix II class solution&#123; public int[][] generateMatrix(int n)&#123; int [][] res = new int[n][n]; int cur = 1; int rowbegin = 0; int rowend = n-1; int colbegin = 0; int colend = n-1; while( cur &lt; n*n)&#123; int i = rowbegin; int j = colbegin; for(j = colbegin; j &lt;= colend;j++)&#123; res[rowbegin][j] = cur; cur++; &#125; rowbegin++;// ç¬¬ä¸€æ­¥æ˜¯ä»ä¸Šè‡³ä¸‹ for(i = rowbegin ; i &lt;= rowend ; i++)&#123; res[i][colend] = cur; cur++; &#125; colend--;//ç¬¬äºŒæ­¥ä»å³è‡³å·¦ for(j = colend ; j &gt;= colbegin ; j++)&#123; res[rowend][j] = cur; cur++; &#125; rowend--;//ç¬¬ä¸‰æ­¥ä»ä¸‹è‡³ä¸Š for(i = rowend; i&gt;=rowbegin; i++)&#123; res[i][colbegin] = cur; cur++; &#125; colbegin ++;//æœ€åä¸€æ­¥ä»å·¦è‡³å³ &#125; &#125;&#125; æ€è·¯ èºæ—‹è¾“å‡ºçŸ©é˜µï¼Œåˆ†å››å¤§æ­¥ï¼Œä¸Šè‡³ä¸‹ï¼Œå³è‡³å·¦ï¼Œä¸‹è‡³ä¸Šï¼Œå·¦è‡³å³ã€‚ 61. Rotate List /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; public ListNode rotatelinkedlist(ListNode head, int k)&#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy, slow = dummy; int i; for (i = 0 ; fast.next!=null;i++)&#123; fast = fast.next; &#125; for(int j = i-k%n;j&gt;0;j--)&#123; slow = slow.next; &#125; fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next; &#125; &#125; æ€è·¯ åè½¬é“¾è¡¨ï¼Œå…³é”®çš„é—®é¢˜åœ¨äºæ–­ç‚¹slowçš„é€‰å–ï¼Œå…·ä½“è¯æ˜å‚è€ƒleetcode 61çš„discussï¼Œå¾ˆå·§å¦™ã€‚åœ¨å¾—å‡ºæ–­ç‚¹çš„ä½ç½®åï¼Œç›´æ¥è¿›è¡Œäº¤æ¢å³å¯ã€‚ 62. Unique Paths class solution&#123; public int uniquePath(int m, int n)&#123; Integer[][] map = new Integer[m][n]; for(int i =0 i&lt; m;i++)&#123; map[i][0] = 1; &#125; for(int j = 0; j &lt; n; j++)&#123; map[0][j] = 1; &#125; for(int i = 0; i&lt; m;i++)&#123; for(int j = 0; j &lt; n ; j ++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; &#125;return map[m-1][n-1]&#125; æ€è·¯ é‡æ–°å¤ä¹ ä¸€ä¸‹ï¼Œå…ˆå°†è¾¹ç¼˜è®¾ä¸º1ï¼Œç„¶åæ¯ä¸ªä½ç½®çš„ç§ç±»æ˜¯å®ƒtopå’Œleftç§ç±»å’Œã€‚ç„¶åå¾ªç¯ä¸‹å»ã€‚å¤æ‚åº¦æ˜¯O(m*n)ã€‚ 63. Unique Paths II class solution&#123; public int uniquepath(int [][] obstaclegrid)&#123; int width = obstaclegrid[0].length; int [] dp = new int[width]; dp[0] = 1; for(int [] row : obstaclegrid)&#123; for(int j = 0; j&lt; width;j++)&#123; if(row[j] == 1)&#123; dp[j] = 0; &#125; else if (j&gt;0)&#123; dp[j] += dp[j-1]; &#125; &#125; &#125; return dp[width-1]; &#125;&#125; æ€è·¯ æ–°å¥‡çš„åšæ³•ã€‚å¸¸è§„æ€è·¯ç”¨2Dçš„dpæ¥å­˜å‚¨ï¼Œè¿™é“é¢˜é‡‡ç”¨1Dçš„dpæ¥å­˜å‚¨ï¼Œåªè€ƒè™‘jï¼Œç”¨jæ¥æ›´æ–°dpå€¼ã€‚ dp [ j ] += dp [ j - 1 ] is dp [ j ] = dp [ j ] + dp [j - 1]; å³ new dp [ j ] = old dp [ j ] + dp [ j-1 ] å³ current cell = top cell + left cellã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 15","slug":"leetcode15","date":"2019-05-26T13:13:39.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/05/26/leetcode15/","link":"","permalink":"WangHngLeee.github.io/2019/05/26/leetcode15/","excerpt":"45. Jump Game II class solution&#123; public int jump(int[] nums)&#123; int jumps = 0, curend = 0, int curfast = 0; for(int i = 0; i&lt;nums.length-1;i++)&#123; curfast = Math.max(curfast, i+nums[i]); if(i == curend)&#123; jumps ++; curend = curfast; if(curend &gt;= nums.length)&#123; break; &#125; &#125; &#125; return jumps; &#125;&#125;","text":"45. Jump Game II class solution&#123; public int jump(int[] nums)&#123; int jumps = 0, curend = 0, int curfast = 0; for(int i = 0; i&lt;nums.length-1;i++)&#123; curfast = Math.max(curfast, i+nums[i]); if(i == curend)&#123; jumps ++; curend = curfast; if(curend &gt;= nums.length)&#123; break; &#125; &#125; &#125; return jumps; &#125;&#125; æ€è·¯ Greddy æ€æƒ³çš„ä¸€é“é¢˜ï¼Œç”¨curendå­˜ä½å½“å‰ä½ç½®èƒ½å¤Ÿè·³åˆ°çš„æœ€è¿œä½ç½®ï¼Œcurfastå­˜ä½ä»å½“å‰èŠ‚ç‚¹åˆ°curendä¹‹é—´ï¼Œå„ä¸ªèŠ‚ç‚¹èƒ½å¤Ÿèµ°åˆ°çš„æœ€è¿œä½ç½®ï¼Œæ‰€ä»¥å½“i=curendæ—¶ï¼Œä¹Ÿå°±æ˜¯èµ°åˆ°å½“å‰èŠ‚ç‚¹æ‰€èƒ½å¤Ÿè§¦åŠçš„æœ€åä¸€ä¸ªå…ƒç´ æ—¶ï¼Œjumpå¿…å®šåŠ ä¸€ï¼Œå¹¶ä¸”å°†curendæ›´æ–°ä¸ºcurfastã€‚å½“curendå¤§äºæ•´ä¸ªæ•°åˆ—é•¿åº¦æ—¶ï¼Œå³æ£€ç´¢å®Œæˆï¼Œåˆ™æå‰breaké€€å‡ºå¾ªç¯ã€‚ 55. Jump Game class solution&#123; public boolean jump(int [] nums)&#123; int dis = ; for(int i =0; i&lt;=dis;i++)&#123; dis = Math.max(dis,i+nums[i]); if(dis &gt; = nums.length -1)return true; &#125; return false; &#125;&#125; æ€è·¯ å’Œä¸Šä¸€é¢˜å·®ä¸å¤šçš„æ€è·¯ï¼Œåªä¸è¿‡æ˜¯æ¢æˆbooleanè¾“å‡ºï¼Œåªè¦åˆ¤æ–­å¾ªç¯ä¸­æœ‰æ— ä¸€ä¸ªæ—¶åˆ»ï¼Œdisè¶…å‡ºæˆ–è€…ç­‰äºnums.lengthï¼Œå¦‚æœæœ‰åˆ™è‚¯å®šä¸ºtrueï¼Œè‹¥æ²¡æœ‰åˆ™ä¸ºfalseã€‚ 47. Permutations II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; permutations(int [] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list,new ArrayList&lt;&gt;(),nums, new boolean[nums.length]); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist , int[]nums,boolean[] used)&#123; if(templist.size()==nums.length)&#123; list.add(new ArrayList&lt;&gt;(templist)); &#125; else&#123; for(int i = 0; i &lt;nums.length;i++)&#123; if(used[i] || i&gt;0 &amp;&amp;nums[i]==nums[i-1] &amp;&amp; !used[i-1]) continue; used[i] = true; templist.add(nums[i]); backtrack(list,templist,nums,used); used[i] = false; templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; æ€è·¯ backtrackçš„æ€æƒ³ï¼Œleetcode 13 é‡Œæœ‰è®²ï¼Œä»Šå¤©ç®—æ˜¯å¤ä¹ ä¸€éã€‚ æœ€åforé‡Œé¢çš„ifæ¡ä»¶ï¼š1.è¯¥å…ƒæœªä½¿ç”¨ 2. iã€‹0ï¼Œè¯¥å…ƒç´ åœ¨numsé‡Œå’Œå‰é¢é‡å¤ä¸”å‰é¢çš„å…ƒç´ æœªä½¿ç”¨è¿‡ï¼ˆå¦‚æœå‰ä¸€ä¸ªé‡å¤çš„å…ƒç´ ä½¿ç”¨è¿‡çš„è¯ï¼Œæ˜¯å¯ä»¥ç”¨å½“å‰å…ƒç´ çš„ï¼‰ã€‚ 51. N-Queens class solution&#123; public List&lt;List&lt;String&gt;&gt; solvequeens( int n)&#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] curr = new char[n][n]; for(int i = 0; i &lt;n;i++)&#123; for(int j = 0 ; j &lt; n ; j++)&#123; char[i][j] = '.'; &#125; &#125; boolean col = new boolean[n]; boolean diag1 = new boolean[n*2-1]; boolean diag2 = new boolean[n*2-1]; solve(curr,0,,n,res,col,diag1,diag2); return res; &#125; private void solve(char[][] curr, int row, int n, List&lt;List&lt;String&gt;&gt; ret, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; List&lt;String&gt; toadd = new ArrayList&lt;&gt;(); for(int i =0; i&lt;n;i++)&#123; toadd.add(String.valueOf(curr[i])); &#125; res.add(toadd); return; &#125; for(int j = 0; j &lt; n; j++)&#123; if(col[j] || diag1[row + n -j - 1] || diag2[row + j])continue; col[i]=true; diag1[row + n -j - 1]=true; diag2[row + j] = true; curr[row][j]='Q'; solve(curr,row+1,n,res,col,diag1,diag2); curr[row][j]='.'; diag2[row + j] = false; diag1[row + n -j - 1]=false; &#125; &#125;&#125; æ€è·¯ æ¯”è¾ƒéš¾çš„ä¸€é“é¢˜ï¼ŒåŸºæœ¬æ€æƒ³ä¹Ÿæ˜¯backtrackingï¼Œå…ƒç´ æ¯”è¾ƒå¤šã€‚ çš‡åæ£‹æ¯”è¾ƒæ¶å¿ƒçš„æ˜¯å¯¹è§’çº¿ä¹Ÿå¯ä»¥èµ°ï¼Œæ‰€ä»¥è¦è®¾ç½®ä¸¤ä¸ªdiag1 å’Œdiag2æ¥å­˜å‚¨æ­£åå¯¹è§’çº¿çš„å…ƒç´ ï¼Œæ³¨æ„[]å†…çš„è¡¨è¾¾å¼ã€‚ç”±äºæ¯ä¸€æ¬¡é€’å½’årowéƒ½+1ï¼Œæ‰€ä»¥ä¸éœ€è¦è€ƒè™‘æ¯ä¸€è¡Œçš„å†²çªï¼Œå› ä¸ºæ¯æ¬¡æ¯è¡Œåªä¼šå­˜ä¸€ä¸ªQã€‚ æ¯æ¬¡é€’å½’åè¦å…¨éƒ¨æ¢å¤åŸæ ·ï¼ï¼ï¼backtrackçš„åŸºæœ¬æ€æƒ³ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 14","slug":"leeticode14","date":"2019-05-25T20:13:39.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/05/25/leeticode14/","link":"","permalink":"WangHngLeee.github.io/2019/05/25/leeticode14/","excerpt":"","text":"44. Wildcard Matching class solutoin&#123; public boolean isMatch(String str, String pattern)&#123; int s =0,p=0,startidx=-1,match=0; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p) == '?' || str.charAt(s)==pattern.charAt(p))&#123; p++; s++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == '*')&#123; staridx = p; match = s; p++; &#125;else if(staridx !=-1)&#123; p = staridx + 1; match++; s=match; &#125; else return false; &#125; while (p&lt;pattern.length()&amp;&amp; pattern.charAt(p) =='*')&#123; p++; &#125; return p == pattern.length(); &#125;&#125; Hint ç®€å•çš„å‡ ä¸ªifåˆ¤æ–­ï¼ŒåŒæŒ‡é’ˆé—®é¢˜ã€‚ sæŒ‡å‘str-åŸstringï¼ŒpæŒ‡å‘pattern-å¾…æ£€æµ‹çš„stringã€‚ é‡è¦çš„æ˜¯ç¬¬ä¸‰ä¸ªifï¼Œå½“staridxä¸€ç›´ä¸ä¸º-1æ—¶ï¼Œpå§‹ç»ˆä¸ºstaridxçš„åä¸€ä½ï¼Œä¿è¯äº†å‰é¢çš„æ˜Ÿå·å¯ä»¥ä¸€ç›´é¡ºç€sæ£€æµ‹ä¸‹å»ä¸ä¸­æ–­ã€‚ 10. Regular Expression Matching class solution&#123; public boolean isMatch(String s, String p)&#123; if(s == null || p == null)return false; boolean[][] state = boolean[s.length()+1][p.length()+1]; state[0][0] = true; for(j = 1; j&lt;state[0].length();j++)&#123; if(p.charAt(j-1) == '*')&#123; if(state[0][j-1] || j&gt;1 &amp;&amp; state[0][j-2])&#123; state[0][j] = true; &#125; &#125; &#125; for(int i = 1; i&lt;state.legnth();i++)&#123; for(int j = 1 ; j &lt; state[0].legnth();j++)&#123; if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')&#123; state[i][j] =state[i-1][j-1]; &#125; if(p.charAt(j) == '*')&#123; if(s.charAt(i-1)!= p.charAt(j-2) &amp;&amp; p.charAt(j-2)!='.')&#123; state[i][j] = state[i][j-2]; &#125;else&#123; state[i][j] = state[i-1][j]||state[i][j-1]||state[i][j-2]; &#125; &#125; &#125; &#125; return state[s.length()][p.legnth()]; &#125;&#125; Hint hardçš„ä¸€é“é¢˜ï¼Œä¹Ÿæ˜¯åˆ¤æ–­.* çš„é¢˜ï¼Œ 1, å¦‚æœp.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]; 2, å¦‚æœp.charAt(j) == â€˜.â€™ : dp[i][j] = dp[i-1][j-1]; 3, å¦‚æœp.charAt(j) == 'â€™: (ç»†åˆ†ä¸‰ç§æƒ…å†µ) 1 å½“p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] // a è¡¨ç¤ºä¸ºç©º 2 å½“p.charAt(j-1) == s.charAt(i) or p.charAt(j-1) == â€˜.â€™:ï¼ˆç»†åˆ†ä¸‰ç§ï¼‰ dp[i][j] = dp[i-1][j] //a* è¡¨ç¤ºä¸¤ä¸ªa or dp[i][j] = dp[i][j-1] // a* è¡¨ç¤ºä¸€ä¸ªa or dp[i][j] = dp[i][j-2] // a* è¡¨ç¤ºä¸ºç©º","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 13","slug":"leetcode13","date":"2019-05-24T20:13:39.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/05/24/leetcode13/","link":"","permalink":"WangHngLeee.github.io/2019/05/24/leetcode13/","excerpt":"å‰å‡ å¤©åœ¨å¿™æ¯•è®¾å’Œç”»å›¾ï¼Œå¯¼è‡´åˆ·é¢˜è¿›åº¦ä¸€ç›´åœæ»ä¸å‰ã€‚ ä»Šå¤©åˆšåˆ°å…¬å¸å®ä¹ ï¼Œæ„Ÿè§‰å’Œå¤§ä½¬çš„å·®è·ä»ç„¶æ˜¯ä»¥å…‰å¹´ä¸ºå•ä½ã€‚ å—¯ï¼ŒåŠªåŠ›ä¸èƒ½åœå•Šã€‚ åºŸè¯ä¸å¤šè¯´ï¼Œç»§ç»­å¼€å§‹åˆ·é¢˜ã€‚ Backtracking ç±»å‹é¢˜ backtrackingæ€è·¯ï¼Œæ¯æ¬¡recursiveåå°†tamplistçš„æ•°ç»„å¤§å°å˜å›ä¹‹å‰ï¼Œä¸ºäº†æ–¹ä¾¿ä¸‹ä¸€è½®é€’å½’ã€‚å¹¶ä¸”å°†remainå˜ä¸ºremain-candidatesã€iã€‘ å¤§æ¦‚åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä¸ç”¨æ‹…å¿ƒæ•°å­—é‡å¤å‡ºç°çš„æƒ…å†µï¼›å¦ä¸€ç§æ˜¯ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œä¹Ÿä¸èƒ½å‡ºç°é‡å¤æ•°å­—ã€‚","text":"å‰å‡ å¤©åœ¨å¿™æ¯•è®¾å’Œç”»å›¾ï¼Œå¯¼è‡´åˆ·é¢˜è¿›åº¦ä¸€ç›´åœæ»ä¸å‰ã€‚ ä»Šå¤©åˆšåˆ°å…¬å¸å®ä¹ ï¼Œæ„Ÿè§‰å’Œå¤§ä½¬çš„å·®è·ä»ç„¶æ˜¯ä»¥å…‰å¹´ä¸ºå•ä½ã€‚ å—¯ï¼ŒåŠªåŠ›ä¸èƒ½åœå•Šã€‚ åºŸè¯ä¸å¤šè¯´ï¼Œç»§ç»­å¼€å§‹åˆ·é¢˜ã€‚ Backtracking ç±»å‹é¢˜ backtrackingæ€è·¯ï¼Œæ¯æ¬¡recursiveåå°†tamplistçš„æ•°ç»„å¤§å°å˜å›ä¹‹å‰ï¼Œä¸ºäº†æ–¹ä¾¿ä¸‹ä¸€è½®é€’å½’ã€‚å¹¶ä¸”å°†remainå˜ä¸ºremain-candidatesã€iã€‘ å¤§æ¦‚åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œä¸ç”¨æ‹…å¿ƒæ•°å­—é‡å¤å‡ºç°çš„æƒ…å†µï¼›å¦ä¸€ç§æ˜¯ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œä¹Ÿä¸èƒ½å‡ºç°é‡å¤æ•°å­—ã€‚ ç¬¬ä¸€ç±» Combination Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Permutations public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Subsets class solution&#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; ç¬¬äºŒç±» ç”±äºè¦æ±‚ä¸èƒ½å‡ºç°é‡å¤æ•°å­—ï¼Œè€Œä¸”ä¸èƒ½é‡å¤ä½¿ç”¨ï¼Œæ‰€ä»¥è¦åˆ¤æ–­nums[i]==nums[i+1]çš„æƒ…å†µä¸‹ç›´æ¥è·³è¿‡ï¼Œå¹¶ä¸”é€’å½’æ—¶i+1ã€‚ Combination Sum 2 (ä¸€ä¸ªæ•°åªç”¨ä¸€æ¬¡ä¸”ä¸èƒ½æœ‰é‡å¤çš„æ•°å­—) class solution&#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=start;i&lt;nums.length;i++)&#123; if(i&gt;start&amp;&amp;nums[i]==nums[i+1])continue; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i+1); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Permutations II (contains duplicates) public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; æ³¨æ„è¿™é“é¢˜å’Œå…¶ä»–æœ‰ç•¥å¾®ä¸åŒçš„åœ°æ–¹ï¼Œé¢å¤–ä½¿ç”¨booleanå€¼æ¥åˆ¤æ–­è¯¥ä½ç½®æ˜¯å¦ä½¿ç”¨è¿‡ï¼Œ Subsets II (contains duplicates) class solution&#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; if(i&gt;start&amp;&amp;nums[i]==nums[i+1])continue; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i+1); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; 43. Multiply Strings class solution&#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int [] pos = new int[m+n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; int mul = (num1charAt(i)-'0')*(num2charAt(j)-'0'); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p1]; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p); return sb.length() == 0 ? '0':sb.toString();&#125; æ€è·¯ å°†ä¹˜æ³•è¿‡ç¨‹å†™å‡ºæ¥ã€‚ å…·ä½“è§£é‡Šè§ leetcode 43 è¯¦è§£,å…¶å®åŸºæœ¬æ€æƒ³å°±æ˜¯å°†ç›¸ä¹˜è¿‡ç¨‹å†™å‡ºæ¥ï¼Œå‘ç°æ¯ä½ç›¸ä¹˜åå‘å‰ç§»åŠ¨ä¸€ä½ï¼Œæ‰€ä»¥å¯ä»¥é‡‡ç”¨i+jï¼Œi+j+1è¿›è¡Œposèµ‹å€¼ã€‚ å›¾è§£å¦‚ä¸‹ï¼š","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 12","slug":"leetcode12","date":"2019-05-17T13:33:07.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/05/17/leetcode12/","link":"","permalink":"WangHngLeee.github.io/2019/05/17/leetcode12/","excerpt":"22. Generate Parentheses class Solution&#123; public List&lt;String&gt; generate(int n)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res,new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res, StringBuilder sb, int open, int close, int n)&#123; if(open==n&amp;&amp;close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+,slose,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125;","text":"22. Generate Parentheses class Solution&#123; public List&lt;String&gt; generate(int n)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res,new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res, StringBuilder sb, int open, int close, int n)&#123; if(open==n&amp;&amp;close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+,slose,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125; Hint backtrack å’Œbuildstringç»“åˆã€‚é¦–å…ˆç¬¬ä¸€ä¸ªå¿…é¡»æ˜¯ï¼ˆï¼Œä¸‹ä¸€æ­¥ï¼ˆor)éƒ½å¯ä»¥ï¼Œä½†æ˜¯æ‰“å°ï¼‰çš„å‰ææ˜¯ï¼ˆçš„æ•°é‡è¦å¤§äºï¼‰çš„æ•°é‡ï¼Œè®°ä½æ¯ä¸€æ¬¡è¦å°†sbçš„length backtrack å‡1. 25. Reverse Nodes in k-Group class solution&#123; public ListNode reverseGroup(ListNode head,int k)&#123; ListNode curr = head; int count = 0; while(curr!=null&amp;&amp;count!=k)&#123; curr=curr.next; count++; &#125; if(count == k)&#123; curr = reverseGroup(curr,k); while(count--&gt;0)&#123; ListNode temp = head.next; head.next = curr; curr = head; head = temp; &#125; head = curr; &#125; return head; &#125;&#125; Hint æ¯é‡åˆ°kä¸ªå…ƒç´ å°±è¦ç¿»è½¬ä¸€æ¬¡ï¼Œæ¯ä¸ªå¾ªç¯çš„ç¿»è½¬æ¬¡æ•°ä¸€å…±æ˜¯countä¹Ÿå°±æ˜¯kæ¬¡ï¼Œæ³¨æ„ç¿»è½¬çš„codeè¡¨è¾¾ã€‚ 30. Substring with Concatenation of All Words class Solution &#123; public List&lt;Integer&gt; find(String s, String[] words)&#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int wordnum = words.length(); if (wordnum==0)&#123; return res; &#125; int wordlen = words[0].length(); HashMap&lt;String,Integer&gt; allwords = new HashMap&lt;String,Integer&gt;(); for(String w :words)&#123; int value = allwords.gerOrDefault(w,0); allwords.put(w,value+1); &#125; for(int i =0;i&lt;s.length()-wordnum*wordlen+1;i++)&#123; HashMap&lt;String,Integer&gt; haswords = new HashMap&lt;String,Integer&gt;(); int num = 0; while(num&lt;wordnum)&#123; String word = s.substring(i+num*wordlen,i+(num+1)*wordlen); if(allwords.containKey(word))&#123; int value = haswords.gerOrDefault(word,0); haswords.put(word,value+1); if(haswords.get(word)&gt;allwords.get(word))&#123; break; &#125; &#125;else&#123; break; &#125; num++; &#125; if(num==wordnum)&#123; res.add(i); &#125; &#125; return res; &#125;&#125; Hint Hardé¢˜ï¼Œäº®ç‚¹æ˜¯ç”¨åˆ°ä¸¤ä¸ªHashMapï¼Œç¬¬ä¸€ä¸ªæ˜¯å°†wordsé‡Œé¢å•è¯çš„ä¸ªæ•°å­˜å…¥ï¼Œhashmap2æ˜¯ç”¨æ¥éå†stringçš„æ—¶å€™ï¼Œå°†å½“å‰wordå­—æ®µçš„ä¸ªæ•°å­˜å…¥hashmap2ï¼Œåœ¨è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥map1é‡Œçš„ä¸ªæ•°å°äºmap2é‡Œçš„ä¸ªæ•°ï¼Œæˆ–è€…æœ‰æ–°çš„å­—æ®µï¼Œåˆ™breakï¼›å¦åˆ™è¿›è¡Œä¸‹ä¸€ä¸ªå­—æ®µï¼Œç›´åˆ°å½“å‰é•¿åº¦çš„wordså…¨éƒ¨æ£€æŸ¥åï¼Œæ²¡æœ‰å¼‚å¸¸åˆ™å°†iå­˜å…¥resã€‚ å…·ä½“æ€è·¯åœ¨ leetcode 30 31. Next Permutation class Solution &#123; public void next(int[] nums)&#123; int n = nums.length-1; p=-1; pv=0; for(int i = n;i&gt;=0;i--)&#123; if(nums[i]&lt;nums[i+1])&#123; p=i; pv = nums[i]; break; &#125; &#125; if(p==-1)&#123; reverse(nums,0,n); &#125; for(int i = n; i&gt;=0;i--)&#123; if(nums[i]&gt;pv)&#123; swap(nums,p,i); break; &#125; &#125; reverse(nums,p+1,n); &#125; void reverse(int[] nums, int s, int e)&#123; while(s&lt;e)&#123; swap(nums,s,e); s++; e--; &#125; &#125; void swap(int [] nums, int s, int e)&#123; int t = nums[s]; nums[s] = nums[e]; nums[e] = t; &#125;&#125; é¢å¤–å®šä¹‰reverseå’Œswapå‡½æ•°ï¼ŒåŸç†å¤§æ¦‚å°±æ˜¯ä»å³å‘å·¦æ‰«æï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯sorté¡ºåºçš„æ•°ï¼Œå­˜ä½ï¼Œç¬¬äºŒæ¬¡ä»å³æ‰«ææ‰¾æ¯”ä¹‹å‰é‚£ä¸ªå…ƒç´ å¤§çš„æ•°ï¼Œäº¤æ¢ä½ç½®ã€‚ç„¶åå†p+1,nä¹‹é—´ç»§ç»­swapã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 11","slug":"leetcode11","date":"2019-05-16T13:33:07.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/16/leetcode11/","link":"","permalink":"WangHngLeee.github.io/2019/05/16/leetcode11/","excerpt":"15. 3 Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int lo = i+1,hi=nums.length-1,sum=0-nums[i]; while(lo&lt;hi)&#123; if(nums[lo] + nums[hi] == sum)&#123; res.add(Array.asList(nums[i],nums[lo],nums[hi])); while(lo&lt;hi &amp;&amp; nums[lo] == nums[lo+1])lo++; while(lo&lt;hi &amp;&amp; nums[hi] == nums[hi-1])hi--; lo++; hi--; &#125;else if(nums[lo] + nums[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res; &#125;&#125;","text":"15. 3 Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int lo = i+1,hi=nums.length-1,sum=0-nums[i]; while(lo&lt;hi)&#123; if(nums[lo] + nums[hi] == sum)&#123; res.add(Array.asList(nums[i],nums[lo],nums[hi])); while(lo&lt;hi &amp;&amp; nums[lo] == nums[lo+1])lo++; while(lo&lt;hi &amp;&amp; nums[hi] == nums[hi-1])hi--; lo++; hi--; &#125;else if(nums[lo] + nums[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res; &#125;&#125; Hint å…ˆæ’åºï¼Œ3 pointeræ–¹æ³•ï¼Œiï¼Œloï¼Œhiï¼Œsum = ç›®æ ‡å€¼-nums[i],ç„¶åå¼€å§‹æ¯”è¾ƒloå’Œhiçš„å’Œä¸sumçš„å¤§å°å…³ç³»ã€‚ æ³¨æ„array.aslistçš„ç”¨æ³•ã€‚ 16. 3 sum closet class solution&#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int sum = nums[0] + nums[1] + nums[nums.length - 1]; int closetnums = sum; for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int left = i+1,right = nums.length - 1; while (left&lt;right)&#123; sum = nums[left] + nums[right] + nums[i]; if (sum&lt;target)&#123; while(left&lt;right&amp;&amp;nums[left] == nums[left+1])&#123; left++; &#125; left ++; &#125;else if(sum &gt; target)&#123; while(left&lt;right&amp;&amp; nums[right]==nums[right-1])&#123; right--; &#125; right--; &#125;else&#123; return sum; &#125; if (Math.abs(target-sum)&lt;Math.abs(target - closetnums))&#123; closetnums = sum; &#125; &#125; &#125; &#125; &#125; return closetnums;&#125; Hint å’Œ3sumä¸€æ ·çš„æ€è·¯ï¼Œ3 pointerï¼Œiï¼Œleftï¼Œrightï¼Œå°†æ’åºåçš„ç¬¬ä¸€ï¼Œç¬¬äºŒï¼Œæœ€åä¸‰ä¸ªæ•°çš„å’Œæš‚æ—¶å­˜ä¸ºclosetnums,å¾ªç¯é‡Œç”¨sumå­˜ä¸‹ä¸´æ—¶çš„å’Œï¼Œä¸targetæ¯”è¾ƒï¼Œåªæœ‰ç›¸ç­‰æ—¶è¿”å›sumï¼Œå¦åˆ™éƒ½è¦è¿›è¡Œæ¯”è¾ƒï¼Œå–å·®å€¼æœ€å°çš„ä½œä¸ºä¸‹ä¸€ä¸ªclosetnumsã€‚ 18. 4 Sum public class Solution { int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { len = nums.length; Arrays.sort(nums); return ksum(nums,target,4,0) private ArrayList&lt;List&lt;Integer&gt;&gt; ksum(int[] nums, int target, int k, int index){ ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (index &gt;= len){ return res; } if (k==2){ int i = index, j = len - 1; while(i&lt;j){ if(target-nums[i] == nums[j]){ List&lt;List&lt;Integer&gt;&gt; temp = new ArraysList&lt;&gt;(); temp.add(nums[i]); temp.add(target - nums[i]); res.add(temp); while(i&lt;j&amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j]==nums[j-1])j--; i++; j--; }else if(target - nums[i]&gt;nums[j]){ i++; }else{ j--; } } }else{ for(int i = index; i&lt; len - k + 1;i++){ ArrayList&lt;List&lt;Integer&gt;&gt; temp = ksum(nums,target - nums[i], k-1,i++); if(temp!=null){ for(List&lt;Integer&gt; t : temp){ t.add(0,nums[i]); } res.addAll(temp); } while(i&lt;len-1 &amp;&amp; nums[i] == nums[i+1]){ i++; } } } return res; } }","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Front-end Interview Questions 1 ğŸ’ª","slug":"Font-end Interview","date":"2019-05-12T18:28:27.000Z","updated":"2020-05-19T15:45:55.738Z","comments":true,"path":"2019/05/12/Font-end Interview/","link":"","permalink":"WangHngLeee.github.io/2019/05/12/Font-end Interview/","excerpt":"HTML ç¯‡ HTML5è¯­ä¹‰åŒ– å°±æ˜¯ç”¨åˆç†ã€æ­£ç¡®çš„æ ‡ç­¾æ¥å±•ç¤ºå†…å®¹ï¼Œå¦‚h1h2h3 p è¿™äº›ã€‚ prosï¼š1.æ˜“äºé˜…è¯»ï¼Œå½“æ ·å¼è¡¨ç°ä¸¢å¤±æ—¶ï¼Œç»“æ„æ–¹ä¾¿è¯»è€…é˜…è¯»ã€‚ 2.åˆ©äºå¼€å‘ç»´æŠ¤ï¼Œç±»åˆ«æ¸…æ™°ã€‚","text":"HTML ç¯‡ HTML5è¯­ä¹‰åŒ– å°±æ˜¯ç”¨åˆç†ã€æ­£ç¡®çš„æ ‡ç­¾æ¥å±•ç¤ºå†…å®¹ï¼Œå¦‚h1h2h3 p è¿™äº›ã€‚ prosï¼š1.æ˜“äºé˜…è¯»ï¼Œå½“æ ·å¼è¡¨ç°ä¸¢å¤±æ—¶ï¼Œç»“æ„æ–¹ä¾¿è¯»è€…é˜…è¯»ã€‚ 2.åˆ©äºå¼€å‘ç»´æŠ¤ï¼Œç±»åˆ«æ¸…æ™°ã€‚ ç»“æ„ 1.header å®šä¹‰æ–‡æ¡£æˆ–è€…æ–‡æ¡£çš„éƒ¨åˆ†åŒºåŸŸçš„é¡µçœ‰ï¼Œåº”ä½œä¸ºä»‹ç»å†…å®¹æˆ–è€…å¯¼èˆªé“¾æ¥æ çš„å®¹å™¨ã€‚ 2.nav åŒ…å«å¤šä¸ªè¶…é“¾æ¥çš„åŒºåŸŸï¼ŒåŒ…å«å¯ä»¥è·³è½¬åˆ°å…¶ä»–é¡µé¢æˆ–è€…è¯¥é¡µé¢å…¶ä»–éƒ¨åˆ†çš„é“¾æ¥åˆ—è¡¨ã€‚ 3.main å®šä¹‰æ–‡æ¡£çš„ä¸»è¦éƒ¨åˆ†ï¼Œåªèƒ½æœ‰ä¸€ä¸ªï¼Œ ä¸ºä»€ä¹ˆæœ€å¥½æŠŠ CSS çš„linkæ ‡ç­¾æ”¾åœ¨headä¹‹é—´ï¼Ÿä¸ºä»€ä¹ˆæœ€å¥½æŠŠJSçš„scriptæ ‡ç­¾æ°å¥½æ”¾åœ¨bodyä¹‹å‰ï¼Œæœ‰ä¾‹å¤–æƒ…å†µå—ï¼Ÿ 1.æŠŠlinkæ”¾åœ¨headä¸­ é¦–å…ˆï¼Œè¿™æ˜¯è§„èŒƒæ–‡æ¡£çš„è¦æ±‚ã€‚å…¶æ¬¡ï¼Œæ˜¯ä¸ºäº†è®©é¡µé¢é€æ­¥å‘ˆç°ï¼Œæé«˜ç”¨æˆ·ä½“éªŒã€‚è‹¥æ”¾åœ¨åº•éƒ¨ï¼Œéƒ¨åˆ†æµè§ˆå™¨ä¸èƒ½é€æ­¥å‘ˆç°ç”šè‡³åŠ è½½å¤±è´¥ã€‚ è¿™æ ·åšå¯ä»¥é˜²æ­¢å‘ˆç°ç©ºç™½é¡µæˆ–è€…æ— æ ·å¼é¡µé¢ã€‚ 2.æŠŠscriptæ”¾åœ¨/bodyä¹‹å‰ è„šæœ¬åœ¨ä¸‹è½½æ—¶å’Œæ‰§è¡ŒæœŸå‰ï¼Œä¼šé˜»æ­¢HTMLè§£æï¼Œæ”¾åœ¨åº•éƒ¨æ˜¯ä¸ºäº†ä¿è¯htmlèƒ½å¤Ÿé¡ºåˆ©åŠ è½½ï¼Œå°†é¡µé¢å°½å¿«å‘ˆç°ã€‚ ä¾‹å¤–çš„æƒ…å†µæ˜¯è„šæœ¬é‡ŒåŒ…å«document.write()æ—¶ã€‚æˆ–è€…æ˜¯scriptä½¿ç”¨deferå±æ€§ï¼Œæ”¾åœ¨headä¸­ã€‚ ä»€ä¹ˆæ˜¯æ¸è¿›å¼æ¸²æŸ“ï¼ˆprogressive renderingï¼‰ï¼Ÿ æ˜¯ç”¨äºæé«˜ç½‘é¡µæ€§èƒ½ï¼Œä»¥å°½å¿«å‘ˆç°ç½‘é¡µçš„æŠ€æœ¯ï¼Œç°å¤šç”¨äºç§»åŠ¨ç«¯(ç§»åŠ¨ç«¯ç½‘é€Ÿä¸ç¨³å®š) 1.å›¾ç‰‡æ‡’åŠ è½½â€”â€”é¡µé¢ä¸Šçš„å›¾ç‰‡ä¸ä¼šä¸€æ¬¡æ€§å…¨éƒ¨åŠ è½½ã€‚å½“ç”¨æˆ·æ»šåŠ¨é¡µé¢åˆ°å›¾ç‰‡éƒ¨åˆ†æ—¶ï¼ŒJavaScript å°†åŠ è½½å¹¶æ˜¾ç¤ºå›¾åƒã€‚ 2.åˆ†å±‚æ¬¡æ¸²æŸ“ã€‚é¡µé¢åªåŒ…å«åŸºæœ¬çš„æœ€å°‘é‡çš„ CSSã€è„šæœ¬å’Œå†…å®¹ï¼Œç„¶åå¯ä»¥ä½¿ç”¨å»¶è¿ŸåŠ è½½è„šæœ¬æˆ–ç›‘å¬DOMContentLoaded/loadäº‹ä»¶åŠ è½½å…¶ä»–èµ„æºå’Œå†…å®¹ã€‚ 3.å¼‚æ­¥åŠ è½½ HTML ç‰‡æ®µâ€”â€”å½“é¡µé¢é€šè¿‡åå°æ¸²æŸ“æ—¶ï¼ŒæŠŠHTMLæ‹†åˆ†ï¼Œé€šè¿‡å¼‚æ­¥è¯·æ±‚ï¼Œåˆ†å—å‘é€ç»™æµè§ˆå™¨ã€‚ viewport è§†å›¾çª—å£ï¼Œåœ¨ç§»åŠ¨webå¼€å‘ä¸­ä½¿ç”¨ã€‚è¡¨ç¤ºå°†è®¾å¤‡æµè§ˆå™¨å®½åº¦è™šæ‹Ÿæˆä¸€ä¸ªç‰¹å®šçš„å€¼ï¼ˆæˆ–è®¡ç®—å¾—å‡ºï¼‰ï¼Œè¿™æ ·åˆ©äºç§»åŠ¨webç«™ç‚¹è·¨è®¾å¤‡æ˜¾ç¤ºæ•ˆæœåŸºæœ¬ä¸€è‡´. Reflowå’ŒRepaint Reflow å½“æ¶‰åŠåˆ°DOMèŠ‚ç‚¹çš„å¸ƒå±€å±æ€§å‘ç”Ÿæ”¹å˜æ—¶ï¼Œä¼šé‡æ–°è®¡ç®—è¯¥å±æ€§ï¼Œå¹¶é‡æ–°æç»˜ç›¸åº”çš„å…ƒç´ ï¼Œç§°ä¸ºå›æµã€‚ Repaint å½“å½±å“DOMå…ƒç´ å¯è§æ€§çš„å±æ€§å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæµè§ˆå™¨ä¼šé‡æ–°æè¿°è¯¥å…ƒç´ ï¼Œç§°ä¸ºé‡ç»˜ã€‚ ä½†Repaintå’ŒReflowæ˜¯ä¸å¯é¿å…çš„ï¼Œåªèƒ½è¯´å¯¹æ€§èƒ½çš„å½±å“å‡åˆ°æœ€å°ã€‚ imgä¸­çš„altå’Œå…ƒç´ çš„titleå±æ€§ä½œç”¨ alt å¦‚æœæ— æ³•æ˜¾ç¤ºå›¾åƒï¼Œæµè§ˆå™¨ä¼šæ˜¾ç¤ºaltæŒ‡å®šçš„å…ƒç´ ã€‚ img é¼ æ ‡æ‚¬æµ®æ—¶æ˜¾ç¤ºtitleå†…å®¹ã€‚ hrefå’ŒsrcåŒºåˆ« hrefè¶…æ–‡æœ¬å¼•ç”¨ï¼Œç”¨äºaå’Œlinkå…ƒç´ ä¸Š srcæ˜¯å¼•ç”¨èµ„æºï¼Œæ›¿æ¢å½“å‰å…ƒç´ ã€‚æµè§ˆå™¨è§£æåˆ°srcæ—¶ä¼šæš‚åœå…¶ä»–ä»»åŠ¡ï¼Œä¹Ÿæ˜¯ä¸ºä»€ä¹ˆjsåº”è¯¥æ”¾åœ¨åº•éƒ¨çš„åŸå› ã€‚ æµè§ˆå™¨æ¸²æŸ“è¿‡ç¨‹ 1.è§£æhtmlç”ŸæˆDOMæ ‘ 2.è§£æcssç”Ÿæˆcssomæ ‘ 3.å°†domå’Œcssomåˆå¹¶æˆæ¸²æŸ“æ ‘ 4.éå†æ¸²æŸ“æ ‘å¼€å§‹å¸ƒå±€ï¼Œè®¡ç®—æ¯ä¸ªä½ç½®çš„å¤§å° 5.å°†æ¸²æŸ“æ ‘æ¯ä¸ªèŠ‚ç‚¹ç»˜åˆ¶åˆ°å±å¹•ä¸Š","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Leetcode EveryDay 10","slug":"leetcode10","date":"2019-05-12T13:33:07.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/05/12/leetcode10/","link":"","permalink":"WangHngLeee.github.io/2019/05/12/leetcode10/","excerpt":"557. Reverse Words in a String III class solution&#123; public reversewords(String s)&#123; char[] s1 = s.toCharArray; int i = 0; for(int j=0;j&lt;s1.length;j++)&#123; if (s1[j] == ' ')&#123; reverse(s1,i,j-1); i-j+1; &#125; &#125; reverse(s1,i,s.length-1); return new String(s1); &#125; public void reverse(s1,l,r)&#123; char[] temp=s[l]; s[l] = s[r]; s[r] = temp; l++;r--; &#125;&#125; æ€è·¯ ç”¨ç©ºæ ¼æ¥åˆ†å‰²å­—ç¬¦ä¸²ï¼Œé‡åˆ°spaceè¿è¡Œä¸€æ¬¡reverseï¼Œæ³¨æ„æœ€åç©ºæ ¼ä¹‹åè¿˜æœ‰æœ€åä¸€éƒ¨åˆ†å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥è¦é¢å¤–è¿è¡Œä¸€æ¬¡reverseã€‚ reverseåŸºæœ¬æ€æƒ³å°±æ˜¯swapã€‚","text":"557. Reverse Words in a String III class solution&#123; public reversewords(String s)&#123; char[] s1 = s.toCharArray; int i = 0; for(int j=0;j&lt;s1.length;j++)&#123; if (s1[j] == ' ')&#123; reverse(s1,i,j-1); i-j+1; &#125; &#125; reverse(s1,i,s.length-1); return new String(s1); &#125; public void reverse(s1,l,r)&#123; char[] temp=s[l]; s[l] = s[r]; s[r] = temp; l++;r--; &#125;&#125; æ€è·¯ ç”¨ç©ºæ ¼æ¥åˆ†å‰²å­—ç¬¦ä¸²ï¼Œé‡åˆ°spaceè¿è¡Œä¸€æ¬¡reverseï¼Œæ³¨æ„æœ€åç©ºæ ¼ä¹‹åè¿˜æœ‰æœ€åä¸€éƒ¨åˆ†å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥è¦é¢å¤–è¿è¡Œä¸€æ¬¡reverseã€‚ reverseåŸºæœ¬æ€æƒ³å°±æ˜¯swapã€‚ 344. Reverse String public class solution&#123; public reverstring(String s)&#123; char start; char end; for( int i =0;i&lt;(s.length)/2;i++)&#123; start = s[i]; end=s[(s.length-1)-i]; s[i] = end; s[(s.length-1)-i] = start; &#125; &#125; æ€è·¯ æ—¶é—´å¤æ‚åº¦O(n/2)ï¼Œç©ºé—´å¤æ‚åº¦O(1),right place æ”¹å˜é¡ºåºï¼Œä¸èƒ½ç”¨è¿”å›æ–°Stringçš„æ–¹æ³•äº†ã€‚äºŒåˆ†æ³•æ›¿æ¢ã€‚ 821. Shortest Distance to a Character class solutoin&#123; public int[] shortestToChar(String S. char C)&#123; int n = S.length(); int pos = -n; int[] res = new int[n]; for( int i =0;i&lt;n;i++)&#123; if(S.charAt(i) == C)&#123; pos = i; &#125; res[i] = i - pos; &#125; for( int i =n-1;i&gt;=0;i--)&#123; if(S.charAt(i) == C)&#123; pos = i; &#125; res[i] = Math.min(res[i], Math.abs(i-pos)); &#125; return res; &#125;&#125; æ€è·¯ two passï¼Œå·¦å³å„éå†ä¸€éï¼Œæ‰¾åˆ°minå€¼ã€‚ å°†pos=-nçº¯ç²¹æ˜¯ä¸ºäº†å°†å…¶è®¾çš„è¶³å¤Ÿå¤§ã€‚Brilliantã€‚ 867. Transpose Matrix class solution&#123; public int[][] transpose(int[][] A)&#123; int M = A.length; int N = A[0].length; int[][] B = new int[N][M]; for(int j =0;j&lt;N;j++)&#123; for(int i = 0; i&lt;M;i++)&#123; B[j][i] = A[i][j]; &#125; &#125; return B; &#125;&#125; æ€è·¯ çŸ©é˜µè½¬æ¢é¢˜ï¼Œæ³¨æ„æ–°å®šä¹‰çŸ©é˜µBçš„è¡Œåˆ—æ•°å’Œforçš„é¡ºåºï¼Œè½¬ç½®çŸ©é˜µåMxN å˜ä¸ºNxM, æ‰€ä»¥å…ˆj&lt;N å i&lt;M. 912. Sort an Array class solution: def sortinarray(self,nums:List[int] -&gt; List[int]): if len(nums)&lt;1: return nums pivot = random.choice(nums) l=[v for v in nums if v &lt; pivot] m=[v for v in nums if v == pivot] r=[v for v in nums if v &gt; pivot] return self.sortinarray(l) + m + self.sortinarray(r) æ€è·¯ æ¯”è¾ƒeasyçš„é¢˜ï¼Œä½†æ˜¯è¦è®°ä½quick sort çš„æ’åºæ–¹æ³•ï¼Œå…ˆrandomé€‰numsï¼Œåˆ†æˆ&lt;=&gt;ä¸‰éƒ¨åˆ†ï¼Œåœ¨å„è‡ªé€’å½’è°ƒç”¨ï¼Œè¿”å›æ—¶æ³¨æ„åŠ ä¸Šmï¼Œä¸­é—´å€¼ã€‚ 876. Middle of the Linked List class solution&#123; public ListNode middlelinked(ListNode head)&#123; ListNode slow = head; fast = head; while (fast!=null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125;&#125; æ€è·¯ éå¸¸é‡è¦çš„ä¸€ç§æ€è·¯ï¼Œfastå’ŒslowæŒ‡é’ˆåŒæ—¶æ‰«æï¼Œå½“faståˆ°è¾¾ç»“å°¾æ—¶ï¼Œslowä¸€å®šåœ¨middle(å¥‡å¶æ•°å®šç†å¯ä»¥è¯æ˜).è¿”å›slowæ­¤æ—¶ä½ç½®çš„åç»­æŒ‡é“¾ã€‚ 872. Leaf-Similar Trees /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class solution&#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); s1.push(root1); s2.push(root2); while(!s1.empty() &amp;&amp; !s2.empty())&#123; if(dfs(s1)!=dfs(s2))&#123; return false; &#125; return (s1.empty() &amp;&amp; s2.empty()); &#125; &#125; public int dfs(Stack&lt;TreeNode&gt; s)&#123; while(true)&#123; TreeNode node = s.pop(); if(node.left !=null) s.push(node.left); if(node.right !=null) s.push(node.right); if(node.left ==null &amp;&amp; node.right == null) return node.val; &#125; &#125;&#125; æ€è·¯ åˆ¤æ–­æ ‘æœ€åå„ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼Œé€šå¸¸æ€è·¯æ˜¯ç”¨DFSéå†treeæˆlist,ç„¶åæ¯”è¾ƒä¸¤ä¸ªlistã€‚ä½†æ˜¯æ¯”è¾ƒéº»çƒ¦ã€‚ è¿™é‡Œå°†é€ä¸ªå¶èŠ‚ç‚¹è¿›è¡Œæ¯”è¾ƒï¼Œé‡‡ç”¨stackå­˜å‚¨ï¼Œå…¶å®è¿™é‡Œéå†çš„æ–¹æ³•ç±»ä¼¼pre-orderï¼Œåªä¸è¿‡ä¸è¾“å‡ºã€‚ å®šä¹‰dfså‡½æ•°ï¼Œæ¯”è¾ƒæ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œè‹¥å·¦å³ä¸ç©ºï¼Œå°†å…¶å‹å…¥å †æ ˆï¼Œè‹¥ä¸ºç©ºï¼Œè¿”å›æœ€åèŠ‚ç‚¹çš„å€¼ï¼Œs1å’Œs2çš„å€¼è¿›è¡Œæ¯”è¾ƒã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 9","slug":"leetcode9","date":"2019-05-11T13:41:30.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/11/leetcode9/","link":"","permalink":"WangHngLeee.github.io/2019/05/11/leetcode9/","excerpt":"951. Flip Equivalent Binary Trees O(n)æ–¹æ¡ˆ class solution&#123; public boolean flipequv(TreeNode root1, TreeNode root2)&#123; if(root 1 == null &amp;&amp; root2 == null) return true; if(root1 == null || root2 == null || root1.val != root2.val) return false; if((root1.left != null ? root1.left.val : -1) != (root2.left != null ? root2.left.val : -1))&#123; TreeNode t = root1.left; root1.left = root1.right; root1.right = t; &#125; return flipequv(root1.left,root2.left) &amp;&amp; flipequv(root1.right,root2.right); &#125;&#125;","text":"951. Flip Equivalent Binary Trees O(n)æ–¹æ¡ˆ class solution&#123; public boolean flipequv(TreeNode root1, TreeNode root2)&#123; if(root 1 == null &amp;&amp; root2 == null) return true; if(root1 == null || root2 == null || root1.val != root2.val) return false; if((root1.left != null ? root1.left.val : -1) != (root2.left != null ? root2.left.val : -1))&#123; TreeNode t = root1.left; root1.left = root1.right; root1.right = t; &#125; return flipequv(root1.left,root2.left) &amp;&amp; flipequv(root1.right,root2.right); &#125;&#125; æ€è·¯ åˆ¤æ–­ä¸¤ä¸ªæ ‘ç»è¿‡flipåæ˜¯å¦æ˜¯åŒä¸€æ£µæ ‘ã€‚ é¦–å…ˆ1.è‹¥ä¸¤ä¸ªrootéƒ½ä¸ºnullï¼Œä¸ºtrue 2.è‹¥å…¶ä¸­ä¸€ä¸ªä¸ºnullè€Œå¦ä¸€ä¸ªä¸æ˜¯ï¼Œæˆ–è€…ä¸¤ä¸ªçš„valä¸åŒï¼Œfalse 3.é‡ç‚¹åœ¨ç¬¬ä¸‰ä¸ªifï¼Œåˆ†åˆ«åˆ¤æ–­å„è‡ªå·¦å­©å­æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœå·¦å³å­©å­éƒ½ç›¸åŒï¼Œåˆ™è·³è¿‡è¯¥ifï¼Œæ‰§è¡Œé€’å½’ï¼› è‹¥ï¼=ï¼Œåˆ†ä¸‰ä¸ªæƒ…å†µï¼š a. root1.left = null è€Œroot2.leftå­˜åœ¨ b. root1.left å­˜åœ¨ è€Œ root2.left = null c. root1.left.val != root2.left.val åœ¨ä»¥ä¸Šä¸‰ç§æƒ…å†µä¸‹ï¼Œè¯æ˜å’ŒåŸæ ‘ä¸ä¸€æ ·ï¼Œä¸ºäº†éªŒè¯æ˜¯å¦æ˜¯flipè¿‡ï¼Œç”¨swapæ€æƒ³ï¼Œå°†root1.left å’Œrightå€¼äº’æ¢ï¼Œå†è¿›è¡Œåˆ¤æ–­ã€‚ 338. Counting Bits class solution&#123; public int[] countbits(int num)&#123; int[] f = new int[num + 1]; for (int i=1; i&lt;=num; i++)&#123; f[i] = f[i &gt;&gt; 1] + (i &amp; 1); &#125; return f;&#125; æ€è·¯ å°†æ•´æ•°åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæœ€åä¸€ä½å’Œå‰é¢æ‰€æœ‰ã€‚ æœ€åä¸€ä½1 or 0ï¼Œç”¨ i&amp;1 (1%2)è¡¨ç¤ºï¼Œåˆ¤æ–­æœ€åä¸€ä½1çš„ä¸ªæ•°ï¼ˆä¹Ÿå°±æ˜¯çœ‹æ˜¯ä¸æ˜¯1ï¼‰ å…¶ä»–ä½æ•°ï¼Œç”¨f[i&gt;&gt;1]å³(i/2)è¡¨ç¤ºï¼Œåˆ¤æ–­å‰é¢çš„æ‰€æœ‰1çš„ä¸ªæ•° å…¶å®ç»†çœ‹ï¼Œå¶æ•°çš„f[i/2]å¯ä»¥è°ƒç”¨å‰é¢å·²æœ‰çš„æ•°å€¼ï¼Œæœ€åçš„ä¸ªä½è‚¯å®šä¸º0ï¼Œå¥‡æ•°æœ€åä¸ªä½è‚¯å®šä¸º1ï¼Œç±»ä¼¼dpï¼Ÿ 985. Sum of Even Numbers After Queries class Solution &#123; public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int sum = 0; int i = 0; for (int a : A)&#123; if(a%2 == 0)&#123; sum+=a; &#125; &#125; int [] ans = new int[queries.length]; for(int [] q:queries)&#123; if(A[q[1]] % 2 == 0)&#123; sum-=A[q[1]]; &#125; A[q[1]] += q[0]; if (A[q[1]] % 2 == 0)&#123; sum+=A[q[1]] &#125; ans[i] = sum; i++; &#125; return ans; &#125;&#125; æ€è·¯ ç°å°†å½“å‰æ•°ç»„çš„å¶æ•°åŠ èµ·æ¥ï¼Œå¼€å§‹å¾ªç¯ï¼Œå½“q[1]ä½ç½®ä¸ºå¶æ•°æ—¶ï¼Œä¿é™©èµ·è§ï¼Œå…ˆä»sumé‡Œå‡æ‰ï¼Œä¹‹åq[0]åŠ ä¸Šï¼Œå†æ¬¡åˆ¤æ–­æ˜¯å¦ä¸ºå¶æ•°ï¼Œå¦‚æœæ˜¯åˆ™åŠ è¿›sumï¼Œä¸æ˜¯çš„è¯ç›´æ¥æ”¾å¼ƒï¼Œå°†å½“å‰å¶æ•°æ”¾è¿›ans[i],i++ 885. Spiral Matrix III class solution&#123; public int[][] spiralMatrixIII(int R, int C, int r0, int c0) &#123; int[][] dirt = new int[][] &#123;&#123;0,1&#125;ï¼Œ&#123;1,0&#125;ï¼Œ&#123;0ï¼Œ-1&#125;ï¼Œ&#123;-1,0&#125;&#125;ï¼› List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int len = 0, d =0; res.add(new int[]&#123;r0,c0&#125;); while (res.size() &lt; R*C)&#123; if (d == 0 || d == 2)&#123; len++; &#125; for(int =0; i&lt; len;i++)&#123; r0+=dirt[d][0]; c0+=dirt[d][1]; if(r0 &gt;= 0 &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= 0 &amp;&amp; c0 &lt; C)&#123; res.add(new int[]&#123;r0,c0&#125;); &#125; &#125; d = (d+1)%4; &#125; return res.toArray(new int[R*C][2]);&#125; æ€è·¯ é¡ºæ—¶é’ˆå›å­—å½¢ä»èµ·ç‚¹å¼€å§‹æ‰«æï¼Œdirtè®¾ç½®æ¯æ¬¡ç§»åŠ¨åçš„åæ ‡ï¼Œdè®¾ç½®ç§»åŠ¨çš„æ­¥æ•°ï¼Œç”»å›¾åå‘ç°ï¼Œå³ä¸‹å„1æ­¥ï¼Œå·¦ä¸Šå„2æ­¥ï¼Œå³ä¸‹å„3æ­¥ï¼Œå·¦ä¸Šå„4æ­¥â€¦ï¼Œä»¥æ­¤ç±»æ¨ï¼Œdæ˜¯ç§»åŠ¨æ–¹å‘åœ¨dirté‡Œçš„ä½ç½®ï¼Œ0å³1ä¸‹2å·¦3ä¸Šï¼Œæ‰€ä»¥å½“d=0ï¼ˆèµ·ç‚¹æˆ–è€…ç»è¿‡ä¸€è½®åï¼‰ æˆ–è€… d=2ï¼Œæ¯æ¬¡çŠ¶æ€æ”¹å˜çš„æ—¶å€™ï¼Œç§»åŠ¨æ­¥é•¿lenè¦+1ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 8","slug":"Leetcode-8","date":"2019-05-10T15:11:27.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/10/Leetcode-8/","link":"","permalink":"WangHngLeee.github.io/2019/05/10/Leetcode-8/","excerpt":"979. Distribute Coins in Binary Tree class solution&#123; int res =0; public int distribute(TreeNode root)&#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 0; int left = dfs(root.left), right = dfs(root.right); res+=Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; æ€è·¯ æœ‰ç‚¹ç»•çš„ä¸€é“dfsé¢˜ã€‚è¦æ±‚å°†æ¯ä¸ªä½ç½®éƒ½å˜ä¸º1ï¼Œæ±‚å˜åŠ¨æ¬¡æ•°ï¼Œå…¶å®åè¿‡æ¥æƒ³ï¼Œå¦‚æœä¸€ä¸ªæœ€åèŠ‚ç‚¹åŸæ¥ä¸ºx,è¦å˜ä¸º1ï¼Œé‚£ä¹ˆå˜åŠ¨çš„æ•°å€¼å°±æ˜¯x-1çš„ç»å¯¹å€¼ï¼Œä¹Ÿå°±æ˜¯æƒ³çˆ¶èŠ‚ç‚¹ä¼ é€çš„å€¼æˆ–è€…å‘çˆ¶èŠ‚ç‚¹ç´¢è¦çš„å€¼ï¼Œå³å˜åŠ¨æ¬¡æ•°ï¼Œæ‰€ä»¥åªéœ€è¦é€’å½’çš„å°†æ¯ä¸ªèŠ‚ç‚¹çš„x-1ç´¯åŠ èµ·æ¥å³å¯ã€‚å¤šçœ‹ã€‚","text":"979. Distribute Coins in Binary Tree class solution&#123; int res =0; public int distribute(TreeNode root)&#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 0; int left = dfs(root.left), right = dfs(root.right); res+=Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; æ€è·¯ æœ‰ç‚¹ç»•çš„ä¸€é“dfsé¢˜ã€‚è¦æ±‚å°†æ¯ä¸ªä½ç½®éƒ½å˜ä¸º1ï¼Œæ±‚å˜åŠ¨æ¬¡æ•°ï¼Œå…¶å®åè¿‡æ¥æƒ³ï¼Œå¦‚æœä¸€ä¸ªæœ€åèŠ‚ç‚¹åŸæ¥ä¸ºx,è¦å˜ä¸º1ï¼Œé‚£ä¹ˆå˜åŠ¨çš„æ•°å€¼å°±æ˜¯x-1çš„ç»å¯¹å€¼ï¼Œä¹Ÿå°±æ˜¯æƒ³çˆ¶èŠ‚ç‚¹ä¼ é€çš„å€¼æˆ–è€…å‘çˆ¶èŠ‚ç‚¹ç´¢è¦çš„å€¼ï¼Œå³å˜åŠ¨æ¬¡æ•°ï¼Œæ‰€ä»¥åªéœ€è¦é€’å½’çš„å°†æ¯ä¸ªèŠ‚ç‚¹çš„x-1ç´¯åŠ èµ·æ¥å³å¯ã€‚å¤šçœ‹ã€‚ ##968. Binary Tree Cameras class solution&#123; int res = 0; public int camera(TreeNode root)&#123; int state = dfs(root); return (dfs(root) &lt; 1? 1:0) + res; &#125; public int dfs(TreeNode root)&#123; int needcamera = 0; int covered = 0; if (root.left == null &amp;&amp; root.right == null) return 0;// çŠ¶æ€ä¸º0çš„å¶èŠ‚ç‚¹ if (root.left!=null)&#123; int state = dfs(root.left); if (state==0)&#123;//å­©å­ä¸ºå¶èŠ‚ç‚¹ï¼Œåˆ™è¯¥ä½ç½®è®¾ä¸ºcameraï¼Œå¹¶è¢«cover needcamera = 1; covered = 1; &#125; else if(state ==1)&#123;//å­©å­ä¸ºcameraï¼Œè¢«cover covered =1; &#125; &#125; if (root.right!=null)&#123;//ä¸å·¦å­æ ‘ç›¸åŒ int state = dfs(root.right); if (state==0)&#123; needcamera = 1; covered = 1; &#125; else if(state ==1)&#123; covered =1; &#125; &#125; if (needcamera&gt;0)&#123;//è¿™é‡Œå¾€ä¸‹å¼€å§‹è¿”å›stateçš„å€¼ï¼Œè®¾ä¸ºcameraçš„ç‚¹ res++; return 1; &#125; if(covered&gt;0)&#123;//ä¸æ˜¯cameraç‚¹å¹¶ä¸”è¢«coverè¿‡ï¼Œåˆ™æ˜¯cameraçš„çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¿”å›çŠ¶æ€2 return 2; &#125; return 0;//åˆ™å˜ä¸º0çŠ¶æ€ï¼Œç­›æ‰è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹åçš„èµ·å§‹èŠ‚ç‚¹ï¼Œå¯ä»¥çœ‹æˆæ–°çš„å¶èŠ‚ç‚¹ã€‚ &#125;&#125; æ€è·¯ ç¬¬ä¸€æ¬¡è‡ªå·±åšå‡ºæ¥çš„hardé¢˜ï¼Œä¸å¤ªå¥½åšã€‚ ä»ä¸Šè‡³ä¸‹æ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥å¹²è„†ä»ä¸‹è‡³ä¸Šé€’å½’ã€‚é¦–å…ˆåˆ†ä¸‰ç§çŠ¶æ€ï¼š æ²¡æœ‰å·¦å³å­©å­çš„å¶èŠ‚ç‚¹ï¼ŒçŠ¶æ€ä¸º0ï¼› å·¦å³å­©å­ä¸ºå¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¦è®¾ä¸ºcameraçš„èŠ‚ç‚¹ï¼ŒçŠ¶æ€ä¸º1ï¼› è®¾ä¸ºcameraèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå³è¢«coveredçš„écameraèŠ‚ç‚¹ï¼› æ³¨æ„stateæ˜¯è¯¥èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹ï¼Œå¹¶éæœ¬èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ‰€ä»¥å½“stateä¸º0ï¼Œå³å­©å­èŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹æ˜¯ï¼Œæœ¬èŠ‚ç‚¹å°±åº”ä¸º1ï¼Œè®¾ä¸ºcameraï¼›å½“state=1æ—¶ï¼Œè¡¨æ˜å…¶å­©å­èŠ‚ç‚¹ä¸ºcameraï¼Œåˆ™è¯¥èŠ‚ç‚¹çŠ¶æ€ä¸º2ï¼Œcameraçš„çˆ¶èŠ‚ç‚¹ã€‚ æœ€åå‰©ä¸‹çš„åˆ™æ˜¯æœªè¢«coverçš„èŠ‚ç‚¹ï¼Œå¯ä»¥é‡æ–°å¯»æ‰¾é€‚åˆçš„cameraèŠ‚ç‚¹ã€‚ é€’å½’çš„æ—¶å€™å…ˆåˆ¤æ–­rootå­©å­èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œç„¶åæ”¹å˜å½“å‰rootçš„cameraå’Œcoverï¼Œæœ€åè¿”å›è¯¥rootçš„çŠ¶æ€å€¼ï¼ˆ0,1,2ï¼‰ï¼Œä»¥ä¾›ä¸‹æ¬¡é€’å½’ä½¿ç”¨ã€‚ é€’å½’ä¸€èˆ¬æ ¹æ®å­©å­èŠ‚ç‚¹çŠ¶æ€åˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„é—®é¢˜å€¼ï¼Œæœ€åå†è¿”å›å½“å‰èŠ‚ç‚¹çš„çŠ¶æ€ã€‚ å¤šç»ƒç±»ä¼¼çš„é¢˜ã€‚ 419. Battleships in a Board class solution&#123; public int countbattleship(char[][] board)&#123; int m = board.length; int n = board[0].length; int count = 0; if(m==0)&#123; return 0; &#125; for (int i = 0 ; i&lt;m;i++)&#123; for(int j =0; j&lt;n;j++)&#123; if (board[i][j] == '.') continue; if(j&gt;0 &amp;&amp; board[i][j-1] == 'x') continue;//çºµåˆ—é—´æœ‰æ²¡æœ‰adjacent if (i&gt;0 &amp;&amp; board[i-1][j] == 'X') continue;//è¡Œé—´æœ‰æ²¡æœ‰adjacent count++; &#125; &#125; return count; &#125;&#125; æ€è·¯ æ³¨æ„åˆ—.è¡Œçš„åˆ¤æ–­æ–¹æ³•ã€‚ 559. Maximum Depth of N-ary Tree class solution&#123; public maxDepth(Node root)&#123; if(root == null) return 0; int maxDepth=0; for(Node child:root.children)&#123; maxDepth = Math.max(maxDepth,maxDepth(child)) &#125; return maxDepth+1 &#125;&#125; æ€è·¯ æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç®€å•çš„é€’å½’ï¼Œä¸Šé¢æ˜¯ç”¨çš„nodeé“¾è¡¨ï¼Œqueueé˜Ÿåˆ—ä¹Ÿå¯ä»¥è§£å†³ï¼Œä»£ç å¦‚ä¸‹ã€‚ class solution&#123; public int maxDepth(Node root)&#123; if(root == null) return 0; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty())&#123; int size = queue.size(); for(int i =0; i&lt;size;i++)&#123; Node curr = queue.poll(); for(Node child:root.children)&#123; queue.offer(child); &#125; &#125; depth++; &#125; return depth; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Lazy Day 1","slug":"Lazy-Day-1","date":"2019-05-10T02:35:21.000Z","updated":"2019-06-21T05:14:14.000Z","comments":true,"path":"2019/05/09/Lazy-Day-1/","link":"","permalink":"WangHngLeee.github.io/2019/05/09/Lazy-Day-1/","excerpt":"","text":"lazy day 1 æ©ï¼Œå¼€ä¸ªè´´è®°å½•ä¸€ä¸‹é¸½çš„æ¯ä¸€å¤©ï¼Œè­¦é†’ä¸€ä¸‹ã€‚ ä¸è¿‡ä»Šå¤©ä¹Ÿç®—ä¾‹å¤–ï¼Œä¸€ç›´åœ¨å¿™æ‰¾å®ä¹ çš„äº‹æƒ…ï¼Œè€½è¯¯äº†ä¸€å¤©ï¼Œå¸Œæœ›æœ€åèƒ½æœ‰é€‚åˆçš„å®ä¹ å§ã€‚ å°±è¿™æ ·ã€‚ Ps: å†åƒä¸­å¿ƒé£Ÿå ‚çš„å†·é¢æˆ‘å°±æ˜¯å¼Ÿå¼Ÿï¼Œå¼Ÿä¸­å¼Ÿé‚£ç§ã€‚","categories":[{"name":"lazyday","slug":"lazyday","permalink":"WangHngLeee.github.io/categories/lazyday/"}],"tags":[{"name":"é¸½","slug":"é¸½","permalink":"WangHngLeee.github.io/tags/é¸½/"}]},{"title":"Leetcode EveryDay 7","slug":"Leetcocde-7","date":"2019-05-08T13:28:27.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/05/08/Leetcocde-7/","link":"","permalink":"WangHngLeee.github.io/2019/05/08/Leetcocde-7/","excerpt":"æ˜¨å¤©åˆšå¼€å§‹ä¸ŠUdemyçš„The Web Developer Bootcampï¼Œå…¨æ ˆå¼€å‘æŒºæœ‰æŒ‘æˆ˜æ€§ã€‚ åšè¿™ä¸ªåšå®¢çš„æ—¶å€™æ²¡å­¦é‚£ä¹ˆæ·±ï¼Œå¸Œæœ›è¿™é—¨è¯¾ç»“æŸåèƒ½å®Œæˆä¸€ä¸ªæ‹¿å¾—å‡ºæ‰‹çš„å®é™…åº”ç”¨ç½‘ç«™ã€‚å¥½äº†ï¼Œç»§ç»­åˆ·é¢˜æ‰“å¡ï¼ 561. Array Partition I public class solution&#123; public arraypart(int[] nums)&#123; int res=0; Arrays.sort(nums); for(int i =0; i&lt;nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125;","text":"æ˜¨å¤©åˆšå¼€å§‹ä¸ŠUdemyçš„The Web Developer Bootcampï¼Œå…¨æ ˆå¼€å‘æŒºæœ‰æŒ‘æˆ˜æ€§ã€‚ åšè¿™ä¸ªåšå®¢çš„æ—¶å€™æ²¡å­¦é‚£ä¹ˆæ·±ï¼Œå¸Œæœ›è¿™é—¨è¯¾ç»“æŸåèƒ½å®Œæˆä¸€ä¸ªæ‹¿å¾—å‡ºæ‰‹çš„å®é™…åº”ç”¨ç½‘ç«™ã€‚å¥½äº†ï¼Œç»§ç»­åˆ·é¢˜æ‰“å¡ï¼ 561. Array Partition I public class solution&#123; public arraypart(int[] nums)&#123; int res=0; Arrays.sort(nums); for(int i =0; i&lt;nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125; æ€è·¯ çº¯æ•°å­¦é¢˜ï¼Œå°†2næ•°ç»„åˆ†æˆnå¯¹ï¼Œåˆ†åˆ«æ±‚nå¯¹é‡Œæœ€å°å€¼çš„å’Œã€‚å¾ˆç®€å•ï¼Œå…ˆsortæ’åºï¼Œç„¶åç´¯åŠ å¥‡æ•°ä½ç½®çš„æ•°å°±å¯ä»¥ã€‚ 700. Search in a Binary Search Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode searchBST(TreeNode root,int val)&#123; if(root == null) return root; if(root.val == val) return root; else&#123; if(root.val&gt;val)&#123; return searchBST(root.left,val); &#125; return searchBST(root.right,val); &#125; &#125;&#125; æ€è·¯ ç®€å•çš„BSTï¼Œæ³¨æ„nullæ—¶çš„è¿”å›å€¼ä¹Ÿæ˜¯rootã€‚ 590. N-ary Tree Postorder Traversal // Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;class solution&#123; public List&lt;Integer&gt; postorder(Node root)&#123; LinkedList&lt;Integer&gt; list = newe LinkedList(); if (root==null) return list;//åˆ›å»ºå †æ ˆæ¥å­˜è´®å½“å‰èŠ‚ç‚¹ Stack(Node) s = new Stack() s.push(root); while(!isEmpty(s))&#123; Node temp = s.pop(); //ä½¿ç”¨AddFirstå°†èŠ‚ç‚¹åŠ åˆ°listå‰é¢ï¼Œé¿å…ä½¿ç”¨reverse list.AddFirst(temp.val); for(Node n :temp.children)&#123; s.push(n); &#125; &#125; return list; &#125;&#125; æ€è·¯ ç±»ä¼¼å€’åºè¾“å‡ºèŠ‚ç‚¹ï¼Œä¸å±‚æ¬¡éå†é¡ºåºä¸åŒã€‚ å±‚æ¬¡éå†æ˜¯å°†èŠ‚ç‚¹popå‡ºæ¥å³å¯ï¼Œæ­¤é¢˜éœ€è¦é€†åºè¾“å‡ºï¼Œæ‰€ä»¥å¾ˆå¥½çš„ä¸€ä¸ªç‚¹å°±æ˜¯å°†listè®¾ç½®ä¸ºé“¾è¡¨ï¼Œç„¶åå°†æ–°å…ƒç´ ä¸€ç›´åŠ åˆ°å¤´éƒ¨å°±å¯ä»¥ï¼Œæœ€åè¾“å‡ºlistã€‚ 589. N-ary Tree Preorder Traversal // Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;class solution&#123; public List&lt;Integer&gt; postorder(Node root)&#123; LinkedList&lt;Integer&gt; list = newe LinkedList(); if (root==null) return list; Stck&lt;Node&gt; stack = new Stack(); stack.add(root); while (!isEmpty)&#123; root=stack.pop(); list.add(root.val); for(int i =root.children.size()-;i&gt;=0;i++)&#123; stack.add(root.childre.get(i)); &#125; &#125; return list; &#125;&#125; æ€è·¯ æ˜¯ä¸Šä¸€é¢˜çš„ç®€åŒ–ç‰ˆï¼Œéå†å®Œè¯¥æ”¯å…¨éƒ¨èŠ‚ç‚¹åæ‰è½¬åˆ°ä¸‹ä¸€æ”¯ï¼Œä¸éœ€è¦é€†è½¬listï¼Œæ³¨æ„root.children.getçš„æ–¹æ³•ã€‚ 965. Univalued Binary Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class solution&#123; public boolean UnivalTree(Treenode root)&#123; if(root.left!=null)&#123; if(!isUnivalTree(root.left)) return false; if(root.left.val!=root.val) return false; &#125; if(!isUnivalTree(root.right)) return false; if(root.right.val!=root.val) return false; &#125; return true; &#125; æ€è·¯ è‡ªèº«é€’å½’çš„BST,æ³¨æ„é€’å½’å’Œåˆ¤æ–­valçš„å‰åé¡ºåºã€‚å’Œleetcode 5 é‡Œé¢ä¸€é“é¢˜å¾ˆç›¸ä¼¼ï¼Œéœ€è¦è‡ªå·±åŠ ä¸€ä¸ªprivateå‡½æ•° 1030. Matrix Cells in Distance Order class solution&#123; public int[][] allcellsindis(int R, int C, int r0, int c0)&#123; boolean[][] visited = new boolean[R][C]; int[][] res = new int[R*C][2]; int i =0; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); queue.offer(new int[]&#123;r0,c0&#125;); while(!queue.isEmpty())&#123; int[] cell = queue.poll(); int r = cell[0]; int c = cell[1]; if( r &lt; 0 || r &gt;= R || c &lt; 0 ||c &gt;= C)&#123; continue; &#125; if(visited[r][c])&#123; continue; &#125; res[i] = cell; i++; visited[r][c] = true; queue.offer(new int[]&#123;r, c - 1&#125;); queue.offer(new int[]&#123;r, c + 1&#125;); queue.offer(new int[]&#123;r - 1, c&#125;); queue.offer(new int[]&#123;r + 1, c&#125;); &#125; return res; &#125;&#125; æ€è·¯ æŸä¸ªçŸ©é˜µï¼Œç»™å®šä¸€ä¸ªåæ ‡ï¼Œè®©è¾“å‡ºå…¶ä»–ä½ç½®å’Œè¿™ä¸ªä½ç½®çš„è·ç¦»å·®ï¼Œç»™å®šr0c0ï¼Œxä½ç½®ä¸è¯¥ä½ç½®çš„è·ç¦»å·®å°±æ˜¯nx-n0ï¼Œcx-c0 å½“éšä¾¿ç”»å‡ ä¸ªçŸ©é˜µå‡ºæ¥ä¹‹åå‘ç°ï¼Œè¾“å‡ºçš„ç»“æœå…¶å®å°±æ˜¯ä»è¯¥æŒ‡å®šä½ç½®bfsæœç´¢çš„ç»“æœï¼ˆæ©ï¼Œå°±æ˜¯è¿™ä¹ˆå·§è¿™ä¹ˆç¥å¥‡ï¼‰ æ‰€ä»¥å°±å¯ä»¥æŒ‰ç…§bfsçš„æ€è·¯æ¥è®¾è®¡codeï¼Œç”¨queueæ¥å®ç°ï¼Œè®¾ç½®visitedå˜é‡æ¥è®°å½•æ˜¯å¦è®¿é—®è¿‡è¯¥èŠ‚ç‚¹ã€‚ æ³¨æ„poll() å’Œ offer() ï¼Œä¸pop() å’Œpush()ç±»ä¼¼ï¼Œä½†æ˜¯æ•ˆæœæ›´å¥½ï¼Œå‡ºé”™æ—¶è‡ªåŠ¨åœæ­¢ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 6","slug":"Leetcode-6","date":"2019-05-07T14:01:06.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/05/07/Leetcode-6/","link":"","permalink":"WangHngLeee.github.io/2019/05/07/Leetcode-6/","excerpt":"å†™åœ¨å¼€å¤´ ä»¥åå°½é‡å¤šç”¨javaåšcodingå§ï¼Œæ˜¨æ™šæ‰çŸ¥é“Amazonçš„onsiteæ²¡æœ‰pythonè¿™ä¸ªé€‰é¡¹â€¦orzï¼Œæ‰€ä»¥å¼€å§‹å•ƒjavaå§~ 797. All Paths From Source to Target class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; allPassSourceTarget(int[][] graph)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); path.add(0); dfsSearch(graph,0,res,path); return res; &#125; private void dfsSearch(int [][] graph, int node,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path )&#123; if ( node == graph.length -1)&#123; res.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; for ( int nextNode:graph[node])&#123; path.add(nextNode); dfsSearch(graph,nextNode,res,path); path.remove(path.size()-1);// å¾ˆé‡è¦çš„ä¸€æ­¥ï¼Œbackstrackå›å» &#125; &#125;&#125;","text":"å†™åœ¨å¼€å¤´ ä»¥åå°½é‡å¤šç”¨javaåšcodingå§ï¼Œæ˜¨æ™šæ‰çŸ¥é“Amazonçš„onsiteæ²¡æœ‰pythonè¿™ä¸ªé€‰é¡¹â€¦orzï¼Œæ‰€ä»¥å¼€å§‹å•ƒjavaå§~ 797. All Paths From Source to Target class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; allPassSourceTarget(int[][] graph)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); path.add(0); dfsSearch(graph,0,res,path); return res; &#125; private void dfsSearch(int [][] graph, int node,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path )&#123; if ( node == graph.length -1)&#123; res.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; for ( int nextNode:graph[node])&#123; path.add(nextNode); dfsSearch(graph,nextNode,res,path); path.remove(path.size()-1);// å¾ˆé‡è¦çš„ä¸€æ­¥ï¼Œbackstrackå›å» &#125; &#125;&#125; æ€è·¯ ä¸€é“dfsæ€è·¯çš„è·¯å¾„é¢˜ï¼Œè¾“å…¥ç»“æ„å¦‚ä¸‹ï¼šgraph [[1,2],[3],[3],[]] graph[i]ä¸­å­˜æ”¾çš„æ˜¯èŠ‚ç‚¹ièƒ½å¤Ÿåˆ°è¾¾çš„èŠ‚ç‚¹é›†åˆï¼Œæ¯”å¦‚graph[0]ä¸­å­˜æ”¾çš„æ˜¯1å’Œ2ï¼Œæ„æ€å°±æ˜¯0èƒ½å¤Ÿåˆ°è¾¾1å’Œ2ï¼Œä»¥æ­¤ç±»æ¨ï¼Œ1 å’Œ 2 å‡å„è‡ªèƒ½åˆ°è¾¾3 ã€‚ æ‰€ä»¥åˆ›å»ºä¸€ä¸ªprivateå‡½æ•°ï¼Œç”¨æ¥é€’å½’dfsã€‚æ³¨æ„çš„æ˜¯åœ¨nextnodeè°ƒç”¨dfsä¹‹åï¼Œè¦backstrackå›å»ï¼Œå°†pathçš„size()-1,ä»¥ä¿è¯å…¶ä»–è·¯å¾„dfsæ—¶ä¸ä¼šå—å½±å“ã€‚ 942. DI String Match class solution&#123; public int[] distringmatch(String S)&#123; int n = S.length(),left=0,right = n; int [] res = new int[n+1] for ( int i=0; i&lt;n;i++)&#123; res[i] = S.charAt(i) == 'I' ? left++:right--; &#125; res[n] = left; return res &#125;&#125; æ€è·¯ ä¸€é“easyé¢˜ï¼Œoutside-inçš„æ–¹æ³•ï¼Œåˆ¤æ–­å¦‚æœä¸ºIï¼Œå°†leftèµ‹å€¼ç»™res[i]ï¼Œ å¦åˆ™èµ‹å€¼rightï¼Œä¹‹åå°†leftæˆ–è€…rightè¿›è¡Œ++ æˆ–â€“ï¼Œæœ€åé€€å‡ºå¾ªç¯çš„æ—¶å€™ï¼Œæœ€åä¸€ä½è‚¯å®šæ˜¯å½“å‰çš„leftçš„å€¼ã€‚ 763. Partition Labels class solution&#123; public List&lt;Integer&gt; partitionlabels(String S)&#123; if (S is null||S.length() == 0)&#123; return null; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int[] map = new int[26]; for (int i =0;i&lt;S.length();i++)&#123; map[S.charAt(I)-'a'] = i; &#125; int last = 0; int start = 0; for (int i=0;i&lt;S.length;i++)&#123; last = Math.max(last,map[S.charAt(i) - 'a']); if (last == i):&#123; list.add(last-start+1); start = last + 1; &#125; &#125; return list; &#125;&#125; æ€è·¯ ç”¨mapå­˜ä½æ¯ä¸€ä¸ªå­—æ¯å‡ºç°çš„æœ€åä¸€ä¸ªä½ç½®ï¼Œä¸é”™çš„å°æŠ€å·§map[S.charAt(i)-â€˜aâ€™] = iï¼Œå¯ä»¥ä¸æ–­æ›´æ–°æŸå­—æ¯æœ€åå‡ºç°çš„ä½ç½®ã€‚ é‡æ–°éå†ä¸€éSï¼Œæ¯”è¾ƒå½“å‰å­—æ¯çš„æœ€åä½ç½®ï¼Œå°†æœ€å¤§å­˜ä¸ºlastï¼Œå½“last== i å³è¯¥å­—æ¯é‡åˆæ—¶ï¼Œå°†è¯¥å­—æ®µé•¿åº¦å­˜å…¥listï¼Œæ›´æ–°startã€‚ 617. Merge Two Binary Trees /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; public TreeNode mergetree(TreeNode t1, TreeNode t2)&#123; if (t1 == null &amp;&amp; t2 == null)&#123; return null; &#125; elif (t1 == null)&#123; return t2; &#125; elif (t2 == null)&#123; return t1; &#125; TreeNode n = new TreeNode(t1.val + t2.val); n.left = mergetree(t1.left,t2.left); n.right = mergetree(t1.right, t2.right); return n; &#125; &#125; æ€è·¯ ç®€å•çš„èåˆä¸¤ä¸ªäºŒå‰æ ‘çš„é¢˜ï¼Œåˆ¤æ–­å„è‡ªæ˜¯å¦ä¸ºç©ºåï¼Œè‡ªèº«ç®€å•é€’å½’å³å¯ï¼Œæ³¨æ„å®šä¹‰næ—¶è¦å…ˆè¯´æ˜ç±»åˆ«ï¼Œä¸pythonä¸åŒï¼Œè¿˜éœ€è¦å¤šå¤šç»ƒä¹ ~ 861. Score After Flipping Matrix class solution&#123; public int matrixScore(int[][] A) &#123; int M = A.length, N = A[0].length, res = (1&lt;&lt;(N-1))*M; for(int j = 1;j&lt;N;j++)&#123; int cur = 0; for(int i = 0; i&lt; M;i++)&#123; cur + = A[i][0]==A[i][j] ? 1 :0; res + = Math.max(cur,M-cur) * (1&lt;&lt;(N-1-j)); &#125; &#125; return res; &#125;&#125; æ€è·¯ è™½ç„¶è¡Œæ•°ä¸å¤šï¼Œä½†æ˜¯æ˜¯æ¯”è¾ƒçƒ§è„‘çš„ä¸€é“é¢˜ã€‚ä¸ºäº†äºŒè¿›åˆ¶è¾¾åˆ°æœ€å¤§å€¼ï¼Œè‚¯å®šè¦æŠŠç¬¬ä¸€åˆ—çš„æ‰€æœ‰æ•°å…¨éƒ¨è®¾ä¸º1 1&lt;&lt;(N-1) å°†1çš„äºŒè¿›åˆ¶å·¦ç§»N-1ä½ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º10000ï¼ˆn-1ä¸ª0ï¼‰ï¼Œç¬¦åˆæœ¬é¢˜çš„è¾“å…¥ç»“æ„æ•°ç»„ã€‚ è®¾ç½®å®Œçš„ç¬¬ä¸€åˆ—ä½œä¸ºå¯¹æ¯”åˆ—ï¼Œæ‰€ä»¥jä»1å¼€å§‹ã€‚ç„¶åå°†æ¯ä¸€åˆ—çš„æ¯è¡Œå…ƒç´ å’Œæ¯è¡Œç¬¬ä¸€ä¸ªå…ƒç´ æ¯”è¾ƒï¼Œå¦‚æœç›¸åŒï¼Œcur+1ï¼Œæ¯”è¾ƒcurå’ŒM-curï¼Œåˆ¤æ–­æ¯åˆ—æœ€å¤šå¯ä»¥å¾—åˆ°1çš„ä¸ªæ•°ï¼Œè¿›è€Œè®¾ç½®1&lt;&lt;(N-1-j)çš„å·¦ç§»äºŒè¿›åˆ¶ï¼Œè·Ÿåœ¨ç¬¬ä¸€åˆ—çš„åé¢ã€‚ cur è®°å½•å’ŒA[i][0]ç›¸åŒçš„å…ƒç´ ä¸ªæ•°ï¼Œå› ä¸ºä¸€å¼€å§‹å°†ç­”æ¡ˆç¬¬ä¸€åˆ—è®¾ä¸º1ï¼Œæ‰€ä»¥ä¸ç®¡åŸå§‹ç¬¬ä¸€åˆ—æ˜¯1è¿˜æ˜¯0ï¼ŒA[i][j]å¦‚æœç›¸åŒï¼Œç”±äºé0å³1ï¼Œåˆ™ä»£è¡¨è¯¥ä½ç½®å¯ä»¥æ˜¯1.ä¸ç®¡åŸæ¥å°±æ˜¯è¿˜æ˜¯æ›´æ”¹ä¸º1ï¼Œæ‰€ä»¥curå¯ä»¥è®°å½•è¯¥åˆ—èƒ½å¤Ÿå­˜æ”¾1çš„æœ€å¤§ä¸ªæ•° å…¶å®æ¯ä¸€åˆ—1çš„ä½ç½®å¹¶ä¸é‡è¦ï¼Œå› ä¸ºå¼€å¤´éƒ½æ˜¯1ï¼Œæ‰€ä»¥åªæœ‰ä¸ªæ•°æ‰èƒ½å†³å®šæœ€ç»ˆå’Œçš„å¤§å°ï¼Œæ­¤é¢˜è¦åå¤ç¢ç£¨ï¼Œemmmï¼ŒæŒºç»•çš„ã€‚ 921. Minimum Add to Make Parentheses Valid class solution&#123; public int minaddtomamkeparentheses(String S)&#123; int left = 0,int right = 0; for (char i : S.toCharArray())&#123; if (right == 0 &amp;&amp; i ==')')&#123; left++ &#125; else right += i =='(' ? 1: -1; &#125; return left + right &#125;&#125; æ€è·¯ åˆ¤æ–­éœ€è¦åŠ å¤šå°‘ä¸ªæ‹¬å·æ‰èƒ½ä½¿stringå˜æˆå®Œæ•´çš„æ‹¬å·ç¾¤ï¼Œ())))å°±éœ€è¦ä¸‰ä¸ªå·¦æ‹¬å·æ‰èƒ½å˜å®Œæ•´ã€‚ 728. Self Dividing Numbers class solution&#123; public List&lt;Integer&gt; selfdividingnum(int left, int right)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;() for( int i = left; i&lt;=right;i++)&#123; if(valid(i))&#123; res.add(i) &#125; &#125; return res &#125; public void valid(int num)&#123; int cur = num; while( cur!=0)&#123; digit = cur%10; if (digit == 0 || num % digit != 0)&#123; return false; &#125; cur/=10; &#125; return true; &#125;&#125; æ€è·¯ ä¸€é“æ•°å­¦é¢˜ï¼Œè¾“å‡ºä»leftåˆ°righté‡Œï¼Œèƒ½å¤Ÿæ•´é™¤å…¶æ‰€æœ‰digitçš„æ•°ï¼Œä¾‹å¦‚ 128 èƒ½å¤Ÿæ•´é™¤1 2 8ã€‚ åœ¨validå‡½æ•°ä¸­ï¼Œå…ˆ%10 å–ä¸ªä½æ•°ï¼Œåˆ¤æ–­èƒ½å¦æ•´é™¤ï¼Œè‹¥å¯ä»¥ï¼Œå†æ¥ç€å°†cur/10æŠ›å»ä¸ªä½æ•°ï¼Œå†é‡å¤ä¹‹å‰çš„æ­¥éª¤å³å¯ ä¸¾ä¾‹128ï¼š é¦–å…ˆ128%10=8ï¼Œèƒ½å¤Ÿæ•´é™¤ï¼Œåˆ™128/10=12ï¼Œ 12%10 = 2ï¼Œå¯ä»¥æ•´é™¤ï¼Œå†çœ‹12/10=1,1%10=1ï¼Œå¯æ•´é™¤ï¼Œå†è¿›è¡Œ1/10=0ï¼Œé€€å‡ºå¾ªç¯ï¼Œè¾“å‡ºtrue","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 5","slug":"Leetcode-5","date":"2019-05-06T12:56:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/06/Leetcode-5/","link":"","permalink":"WangHngLeee.github.io/2019/05/06/Leetcode-5/","excerpt":"1038. Binary Search Tree to Greater Sum Tree # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: val = 0 def bstToGst(self, root: TreeNode) -&gt; TreeNode: if root.right: self.bstToGst(root.right) root.val = self.val = root.val + self.val if root.left: self.bstToGst(root.left) return root æ€è·¯ ä¸€é“ä¸­ç­‰çš„å€’åºéå†sumçš„é¢˜ï¼Œä¹‹åé¡ºåºè¾“å‡ºå³å¯ã€‚ ç”±äºtreeçš„å³å­©å­æ°¸è¿œå¤§äºå·¦å­©å­ï¼Œæ‰€ä»¥å¯ä»¥è®¾ç½®ä¸€ä¸ªä¸´æ—¶å˜é‡valæ¥è®°å½•å½“å‰çš„å’Œï¼Œä»æœ€å³ç«¯çš„æ ¹èŠ‚ç‚¹å¼€å§‹å‘ä¸Šå¾ªç¯ï¼Œå¹¶æ›´æ–°root.val","text":"1038. Binary Search Tree to Greater Sum Tree # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: val = 0 def bstToGst(self, root: TreeNode) -&gt; TreeNode: if root.right: self.bstToGst(root.right) root.val = self.val = root.val + self.val if root.left: self.bstToGst(root.left) return root æ€è·¯ ä¸€é“ä¸­ç­‰çš„å€’åºéå†sumçš„é¢˜ï¼Œä¹‹åé¡ºåºè¾“å‡ºå³å¯ã€‚ ç”±äºtreeçš„å³å­©å­æ°¸è¿œå¤§äºå·¦å­©å­ï¼Œæ‰€ä»¥å¯ä»¥è®¾ç½®ä¸€ä¸ªä¸´æ—¶å˜é‡valæ¥è®°å½•å½“å‰çš„å’Œï¼Œä»æœ€å³ç«¯çš„æ ¹èŠ‚ç‚¹å¼€å§‹å‘ä¸Šå¾ªç¯ï¼Œå¹¶æ›´æ–°root.val 980. Unique Paths III class Solution: def uniquePathsIII(self, A: List[List[int]]) -&gt; int: self.res = 0 m,n,empty = len(A),len(A[0]),1 for i in range(m): for j in range(n): if A[i][j] == 1: x,y = (i,j) elif A[i][j] == 2: end =(i,j) elif A[i][j] == 0: empty +=1 def dfs(x,y,empty): if not ( 0&lt;=x&lt;=m and 0&lt;=y&lt;=n and A[x][y] &gt;=0 ):return if (x,y) == end: self.res += empty == 0 return A[i][j] = -2 dfs(x+1,y,empty-1) dfs(x-1,y,empty-1) dfs(x,y+1,empty-1) dfs(x,y-1,empty-1) A[i][j] = 0 dfs(x,y,empty) return res æ€è·¯ ä¸€é“ç±»ä¼¼bfså’Œdpçš„é¢˜ï¼Œé‡‡ç”¨Brute Force Backstracking æ–¹æ³•ã€‚ é¦–å…ˆæ‰¾åˆ°startå’Œendçš„åæ ‡ï¼Œè®¡ç®—å‡ºemptyçš„æ•°é‡ï¼Œç„¶åå‘å››å‘¨æ‰©æ•£ï¼Œ åœ¨æ¯ä¸€æ¬¡bfsè¿‡ç¨‹å¼€å§‹ï¼Œå…ˆå°†è¯¥ä½ç½®è®¾ç½®ä¸º-2ï¼Œé¿å…å†æ¬¡è®¿é—®ï¼›å½“è¯¥æ¬¡bfsç»“æŸåï¼Œä¸€å®šè¦è®°å¾—backstrackingå›å»ï¼Œå°†è¯¥ä½ç½®é‡æ–°è®¾ç½®ä¸º0ï¼Œé¿å…å…¶ä»–bfsé‡åˆ°è¯¥ç‚¹å‡ºé”™ã€‚æ—¶é—´å¤æ‚åº¦å’Œdpä¸€æ ·ï¼Œä½†æ˜¯ç©ºé—´å¤æ‚åº¦è¦å°‘è®¸å¤šã€‚ 1028. Recover a Tree From Preorder Traversal # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def recoverFromPreorder(self, S: str) -&gt; TreeNode: stack,i = [],0 while i &lt; len(S): level, val = 0,'' while i &lt; len(S) and S[i] =='-': level,i = level + 1,i+1 while i &lt; len(S) and S[i] !='-': val,i = val + S[i], i+1 while len(stack) &gt; len(level): stack.pop() node = TreeNode(val) if stack and stack[-1].left is None: stack[-1].left = node elif stack: stack[-1].right = node stack.append(node) return stack[0] æ€è·¯ ç”±äºé¢˜å¹²è¾“å…¥æ˜¯å…ˆåºç»“æ„ï¼Œç”¨stackå‰åºå­˜å‚¨å½“å‰çš„æ ¹èŠ‚ç‚¹ï¼Œä¹‹åå±‚æ¬¡è¾“å‡ºï¼Œç”¨levelè®°å½•å½“å‰èŠ‚ç‚¹æ·±åº¦ï¼Œstackå…ƒç´ ä¸ªæ•°è¶…å‡ºlevelæ—¶ï¼Œpopç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œæ¯æ¬¡å¾ªç¯å¼€å§‹å°†levelåˆå§‹ä¸º0ï¼Œå½“i&gt;è¾“å…¥æ•°å­—çš„é•¿åº¦æ—¶ï¼Œé€€å‡ºç¬¬ä¸€ä¸ªwhileå¾ªç¯ï¼Œç”±äºæ­¤æ—¶stackåªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œæœ€åå†è¿”å›stack[0]å³å¯ã€‚ 961. N-Repeated Element in Size 2N Array class Solution &#123; public int repeatedNTimes(int[] A) &#123; for (i = 2 ;i &lt; A.length;i++) if (A[i] == A [i-1] || A[i] == A[i-2]) return A[i]; return A[0]; &#125;&#125; æ€è·¯ æ©ï¼Œæœ€è¿‘ä¹Ÿåœ¨å­¦javaï¼Œäºæ˜¯å¹²è„†å°±ç”¨javaå†™ä¸€é“é¢˜å§ã€‚ ç®—æ˜¯ä¸€é“æ•°å­¦é¢˜å§ï¼Œç»™å®š2Nå¤§å°çš„æ•°ç»„ï¼Œæ‰¾å‡ºé‡å¤Næ¬¡çš„æ•°å­—ï¼Œæœ€åˆ†æ•£çš„æƒ…å†µæ— éå°±æ˜¯abacadaeafï¼Œaé‡å¤äº†5æ¬¡ï¼Œæ‰€ä»¥åªéœ€è¦åˆ¤æ–­è¯¥å…ƒç´ å’Œä»–å‰é¢ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç›¸ç­‰å³å¯ï¼Œå¦‚æ»¡è¶³ä»»æ„ä¸€ä¸ªæ¡ä»¶ï¼Œåˆ™è¯¥æ•°å°±æ˜¯æ‰€æ±‚æ•°ã€‚ 1008. Construct Binary Search Tree from Preorder Traversal # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: i=0 def bstFromPreorder(self, A: List[int],bound = float('inf')) -&gt; TreeNode: if self.i == 0 or A[self.i]&gt; bound: return None root = TreeNode(A[self.i]) self.i + =1 root.left = self.bstFromPreorder(A,root.val) root.right = self.bstFromPreorder(A,bound) return root æ€è·¯ åˆæ˜¯ä¸€é“éå†æ ‘çš„é—®é¢˜ï¼Œè®¾ç½®ä¸€ä¸ªboundæ— é™å¤§è¾¹ç•Œï¼Œé€’å½’å³å­æ ‘æ—¶æ–¹ä¾¿ç”¨ï¼Œé€’å½’å‰å°†self.i åŠ ä¸€å³å¯ã€‚ Sort Array By Parity class Solution &#123; public int[] sortArrayByParity(int[] A) &#123; int i = 0; int j = A.length - 1; while (i &lt; j) &#123; if(A[i] % 2 == 0) &#123; // Even first i++; &#125; else &#123; if(A[j] % 2 != 0) &#123; // Both odd j--; &#125; if (A[j] % 2 == 0) &#123; // Odd, Even swap(A, i, j); i++; j--; &#125; &#125; &#125; return A; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; æ€è·¯ ä¸€é“ç®€å•çš„å¥‡å¶æ’åºé—®é¢˜ï¼Œå°†å¶æ•°å…¨éƒ¨æè‡³å‰é¢è¾“å‡ºï¼Œå•ç‹¬å®šä¹‰äº†swapå‡½æ•°ï¼Œæ¯”è¾ƒåŸºæœ¬ï¼Œjavaç‰ˆæœ¬ 814. Binary Tree Pruning # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pruneTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if not root.left and not root.right and not root.val: return None return root æ€è·¯ ç®€å•çš„ä¸€é“äºŒå‰æ ‘çš„é¢˜ï¼Œä¼‘æ¯ä¼‘æ¯è„‘å­233333ã€‚èŠ‚ç‚¹åªæœ‰0å’Œ1ï¼Œå°†èŠ‚ç‚¹ä¸º0çš„è€Œä¸”æ²¡æœ‰å·¦å³å­æ ‘çš„èŠ‚ç‚¹å˜ä¸ºnullï¼Œä¾æ¬¡é€’å½’è°ƒç”¨ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 4","slug":"Leetcode4","date":"2019-05-06T03:03:39.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/05/Leetcode4/","link":"","permalink":"WangHngLeee.github.io/2019/05/05/Leetcode4/","excerpt":"å¾ˆä¹…æ²¡æœ‰æ›´æ–°leetcodeç¬”è®°äº†ï¼Œä¹‹å‰åªåˆ·é¢˜æ²¡æœ‰å†™Blogè®°å½•å¿ƒå¾—ã€‚ä¸è¿‡ä¹Ÿå¥½ï¼Œæœ€è¿‘åˆšåˆ·å®Œtop interview 100 é¢˜ï¼Œå€Ÿæ­¤æœºä¼šå¤ä¹ å·©å›º+å†™bolg~ ä»Šåæ¯æ—¥ä¸€ç¯‡å§ï¼Œæ¯ç¯‡4-6é¢˜ï¼Œä¸Šä¸å°é¡¶ã€‚ Max Increase to Keep City Skyline class Solution: def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int: row, col = list(map(max,grid)), list(map(max,zip(*grid))) return sum(min(i,j) for i in row for j in col ) - sum(map(max,grid)) rowé‡Œå­˜æ”¾æ¯è¡Œæœ€å¤§å€¼ï¼Œcolå­˜æ”¾æ¯åˆ—æœ€å¤§å€¼ï¼Œå¢åŠ åçš„æ¯ä¸ªä½ç½®çš„å…ƒç´ éƒ½ä¸èƒ½è¶…è¿‡è¯¥è¡Œorè¯¥åˆ—çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥è¦å–min(row,col),å¾ªç¯éå†åå–sum,å†å‡å»åŸå§‹çŸ©é˜µçš„å…ƒç´ å’Œå°±æ˜¯æ‰€æ±‚çš„Max increaseã€‚","text":"å¾ˆä¹…æ²¡æœ‰æ›´æ–°leetcodeç¬”è®°äº†ï¼Œä¹‹å‰åªåˆ·é¢˜æ²¡æœ‰å†™Blogè®°å½•å¿ƒå¾—ã€‚ä¸è¿‡ä¹Ÿå¥½ï¼Œæœ€è¿‘åˆšåˆ·å®Œtop interview 100 é¢˜ï¼Œå€Ÿæ­¤æœºä¼šå¤ä¹ å·©å›º+å†™bolg~ ä»Šåæ¯æ—¥ä¸€ç¯‡å§ï¼Œæ¯ç¯‡4-6é¢˜ï¼Œä¸Šä¸å°é¡¶ã€‚ Max Increase to Keep City Skyline class Solution: def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int: row, col = list(map(max,grid)), list(map(max,zip(*grid))) return sum(min(i,j) for i in row for j in col ) - sum(map(max,grid)) rowé‡Œå­˜æ”¾æ¯è¡Œæœ€å¤§å€¼ï¼Œcolå­˜æ”¾æ¯åˆ—æœ€å¤§å€¼ï¼Œå¢åŠ åçš„æ¯ä¸ªä½ç½®çš„å…ƒç´ éƒ½ä¸èƒ½è¶…è¿‡è¯¥è¡Œorè¯¥åˆ—çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥è¦å–min(row,col),å¾ªç¯éå†åå–sum,å†å‡å»åŸå§‹çŸ©é˜µçš„å…ƒç´ å’Œå°±æ˜¯æ‰€æ±‚çš„Max increaseã€‚ Range Sum of BST # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rangeSumBST(self, root: TreeNode, L: int, R: int) -&gt; int: if not root: return None l = self.rangeSumBST(root.left,L,R) r = self.rangeSumBST(root.right, L,R) temp = 0 if L &lt;= temp &lt;= R: temp+= root.val return l + r + temp å—¯ï¼Œåˆé‡åˆ°ä¸€é“BSTï¼Œè¯ä¸å¤šè¯´ï¼Œä¸Šæ¥ç›´æ¥è‡ªèº«é€’å½’è°ƒç”¨å‡½æ•°ï¼Œåˆ¤æ–­æ ¹èŠ‚ç‚¹å€¼æ˜¯å¦åœ¨L,RåŒºé—´å†…ï¼Œä»æœ€åº•ä¸‹çš„èŠ‚ç‚¹å¼€å§‹å‘ä¸Šå¾ªç¯è¿”å›å€¼ï¼Œæœ€åè¾“å‡ºç»“æœã€‚ Encode and Decode TinyURL class Codec: sample = string.acsii_letters + '1234567890' def __init__(self): self.url2code = &#123;&#125; self.code2url = &#123;&#125; def encode(self,longUrl): while longUrl not in self.url2code: code = ''.join(random.choice(Codec.sample) for _ in range(6)) if code not in self.code2url: self.code2url[longUrl] = code self.url2code[code] - longUrl return 'http://tinyurl.com/' + self.url2code[longUrl] def decode(self,shortUrl): return self.code2url[shortUrl[-6:]] ç½•è§çš„ä¸€é“designé¢˜ï¼Œè®¾è®¡encodeå’Œdecodeä¸¤ä¸ªåŠŸèƒ½æ¨¡å—ï¼Œå°†urlåŠ å¯†å’Œè§£ç ï¼Œæ ¸å¿ƒéƒ¨åˆ†æ˜¯sampleçš„è®¾ç½®ï¼Œå°†sampleåº“è®¾ç½®ä¸ºasciiç å’Œæ•°å­—çš„ç»„åˆï¼Œç„¶åencodeæ—¶randomæŠ½å–å…­ä½åŠ åœ¨åŸé“¾æ¥çš„åé¢ï¼Œé¡ºä¾¿å°†åŒæ–¹å„è‡ªä½œä¸ºkeyåŠ å…¥å­—å…¸ä¸­ï¼Œåœ¨decodeä¸­æ–¹ä¾¿ç›´æ¥è°ƒç”¨encodeåå…­ä½æ‰€å¯¹åº”çš„çš„åŸé“¾æ¥å³å¯ã€‚ Maximum Binary Tree # Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def constructMaximumBinaryTree(self, nums): if not nums: return None i = nums.index(max(nums)) node = TreeNode(nums[i]) node.left = constructMaximumBinaryTree(nums[:i]) node.right = constructMaximumBinaryTree(nums[i+1:]) return node ä¸€é“åŸºæœ¬çš„éå†æ ‘é—®é¢˜ï¼Œè¾“å…¥æ ·æœ¬æ˜¯ä¸­åºéå†çš„é¡ºåºï¼Œæ‰€ä»¥ç›´æ¥é€‰å–å½“å‰numsä¸­æœ€å¤§çš„æ•°ä½œä¸ºnodeå°±å¯ä»¥äº†ï¼Œç„¶åè€æ ·å­ï¼Œé€’å½’èµ‹å€¼node.leftå’Œnode.rightï¼Œæœ€åè¿”å›nodeå³å¯ã€‚ Divide Two Integers class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: pos = (divisor &lt; 0) is (dividend &lt; 0) dividend = abs(dividend) divisor = abs(divisor) res = 0 while divisor &lt;= dividend: temp,i = divisor,1 while dividend&gt;= temp: temp&lt;&lt;=1 i&lt;&lt;=1 res+=i if not pos: res = -res return min(max(-2147483648,res),2147483647) emmmçº¯æ•°å­¦é¢˜â€¦é™¤æ•°å’Œè¢«é™¤æ•°çš„å…³ç³»ï¼Œå…¶ä¸­æœ‰å‡ ä¸ªæˆ‘ä¸ªäººæ¯”è¾ƒå–œæ¬¢çš„å°cheatæ–¹æ³•ã€‚ 1.(a &lt;0) is (b&lt;0) å¯ä»¥åŒæ—¶åˆ¤æ–­aå’Œbçš„æŸç§å…±åŒç‰¹æ€§å…³ç³»ï¼Œå°¤å…¶æ˜¯æ­£è´Ÿ 2.a&lt;&lt;=1 è¶…çº§preferçš„cheatï¼Œå¦å¤–ä¸€ç§è¡¨ç¤ºä¹˜ä»¥äºŒçš„æ–¹å¼ï¼ŒåŸç†æ˜¯é‡‡ç”¨äºŒè¿›åˆ¶å·¦ç§»1çš„æ–¹æ³•ï¼Œé€Ÿåº¦å¾ˆå¿« 3.å¦‚æœé¢˜ç›®å­˜åœ¨è¾“å‡ºå€¼èŒƒå›´çš„é—®é¢˜ï¼Œå¯ä»¥é‡‡ç”¨æœ€åä¸€è¡Œçš„min(max(a,answer),b)çš„æ–¹æ³•ï¼Œå…¶ä¸­aæ˜¯æœ€å°å€¼ï¼Œbæ˜¯æœ€å¤§å€¼ï¼Œansweræ˜¯æ‰€æ±‚å€¼ã€‚","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 3","slug":"Leetcode3","date":"2019-03-31T02:59:41.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/03/30/Leetcode3/","link":"","permalink":"WangHngLeee.github.io/2019/03/30/Leetcode3/","excerpt":"Problem 1 Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5","text":"Problem 1 Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Hint: Due to the topic of time complexity and space complexity is higher, so looked at various solutions, the best solution is to merge sort, because the list in the merge operation does not need to be like an array of merge operation assigned a temporary array space, space complexity, so it is constant, of course, there is no consideration of recursive system call stack. This involves a linked list commonly used operation, that is, fast and slow pointer skills.Set slow and fast Pointers, both of which start at the top of the table, fast takes two steps at a time, slow takes one step at a time, fast goes to the end of the list, slow goes right to the middle, and that cuts the list in two. class Solution: def sortlist(self,head:ListNode) -&gt; ListNode: if not head or not head.next: return head pre,slow,fast = None,head,head while fast and fast.next: pre,slow,fast = slow,slow.next,fast.next.next pre.next = None return self.merge(self.sortlist(head),self.sortlist(slow))# def merge(self,h1,h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next,h1 = h1,h1.next else: tail.next,h2 = h2,h2.next tail = tail.next tail.next = h1 or h2 return dummy.next Problem 2 Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] Hint: Topological sorting application.The topological order is like the backward order of every small project completed in a project, and our task is to find out the sequence of successful completion. The method is to delete a node whose entry degree is 0 at a time, and subtract the entry degree of the node it points to by one.And each time the degree of entry is 0 node saved, and finally return it.Thatâ€™s pretty much the same thing. class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: dic = [0 for i in range(numCourses)] neigh = collections.defaultdict(set) for i,j in prerequisites: dic[i]+=1 neigh[j].add(i) stack = [i for i in range(numCourses) if dic[i]==0] res = [] while stack: node = stack.pop() res.append(node) for i in neigh[node]: dic[i]-=1 if dic[i] == 1: stack.append(i) for i in range(numCourses): if dic[i] &gt; 0: return [] return res","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 2","slug":"Leetcode2","date":"2019-03-15T02:28:58.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/03/14/Leetcode2/","link":"","permalink":"WangHngLeee.github.io/2019/03/14/Leetcode2/","excerpt":"Problem1: Group Anagrams Given an array of strings, group anagrams together. Example: Input: [â€œeatâ€, â€œteaâ€, â€œtanâ€, â€œateâ€, â€œnatâ€, â€œbatâ€], Output: [ [â€œateâ€,â€œeatâ€,â€œteaâ€], [â€œnatâ€,â€œtanâ€], [â€œbatâ€] ] ä»£ç å¦‚ä¸‹","text":"Problem1: Group Anagrams Given an array of strings, group anagrams together. Example: Input: [â€œeatâ€, â€œteaâ€, â€œtanâ€, â€œateâ€, â€œnatâ€, â€œbatâ€], Output: [ [â€œateâ€,â€œeatâ€,â€œteaâ€], [â€œnatâ€,â€œtanâ€], [â€œbatâ€] ] ä»£ç å¦‚ä¸‹ class Solution(object): def groupAnagrams(self, strs): d = &#123;&#125; #å»ºç«‹ç©ºçš„å­—å…¸ for w in strs: #éå†strä¸­æ‰€æœ‰çš„å­—ç¬¦ä¸² key = tuple(sorted(w)) #å°†å­—ç¬¦ä¸²å»é‡ï¼Œåˆ©ç”¨sort()å‡½æ•° d[key] = d.get(key,[]) + [str(w)] # å°†dä¸­çš„keyæŒ‡å‘åŒ…å«è¯¥keyçš„å€¼ å¹¶ä¸”åœ¨forä¸­å¾ªç¯ç›´è‡³å…¨éƒ¨éå†å®Œæˆ return list(d.values()) #å°†å­—å…¸dä¸­çš„valuesä»¥listçš„å½¢å¼è¿”å› Problem2 :Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps ä»£ç å¦‚ä¸‹ï¼š def climbStairs1(self, n): if n == 1: #è®¾ç½®èµ°ä¸€æ­¥çš„æƒ…å†µ return 1 if n == 2: # è®¾ç½®èµ°ä¸¤æ­¥çš„æƒ…å†µ return 2 return self.climbStairs(n-1)+self.climbStairs(n-2) # å‡½æ•°å†…å¼•ç”¨è‡ªèº«å‡½æ•°ï¼Œè¿›è¡Œè¿­ä»£ï¼Œå®Œæ•´éå†ä¸€é åœ¨leetcodeäº‘æœåŠ¡å™¨ä¸Šè¿è¡Œåï¼Œå‡ºç°äº†TLEé”™è¯¯ï¼ŒåŸå› æ˜¯æ—¶é—´å¤æ‚åº¦ä¸º O(2^n)ï¼Œä¸åˆé¢˜æ„ åæ¥åœ¨ leetå¤§ç¥ @sfdye å¸®åŠ©ä¸‹ï¼Œå­¦åˆ°äº†ä¸€ä¸ªæ–°trickï¼Œåˆ©ç”¨è£…é¥°å™¨@lru_cache()è¿›è¡Œè¡¥æ•‘ è£…é¥°å™¨å°†ä½¿ç”¨ç›¸åŒçš„æ–¹æ³•è°ƒç”¨å‚æ•°è‡ªåŠ¨ç¼“å­˜ç»“æœ å…¶ä¸­ï¼Œ()å†…å¡«å†™ä½ æƒ³è®¾ç½®çš„èŒƒå›´ï¼ŒNoneè¡¨ç¤ºæ— é™åˆ¶ï¼Œæ‰€ä»¥æ—¶é—´TLEé—®é¢˜å°±å¾—åˆ°äº†è§£å†³ï¼ æ–°ä»£ç å¦‚ä¸‹ from functools import lru_cacheclass Solution: @lru_cache(None) #æ’å…¥è£…é¥°å™¨ru_cache.() def climbStairs(self, n): if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1) + self.climbStairs(n-2) Problems3:Unique Paths(DPåŠ¨æ€è§„åˆ’é—®é¢˜) A robot is located at the top-left corner of a m x n grid (marked â€˜Startâ€™ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked â€˜Finishâ€™ in the diagram below). How many possible unique paths are there? Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: Right -&gt; Right -&gt; Down Right -&gt; Down -&gt; Right Down -&gt; Right -&gt; Right å…¶å®ç”»å›¾åå‘ç°ï¼Œåœ¨ç¬¬ä¸€è¡Œæˆ–è€…æœ€å·¦åˆ—ï¼Œç”±äºæ˜¯åªèƒ½å‘ä¸Šæˆ–è€…å‘ä¸‹ç§»åŠ¨ï¼Œæ‰€ä»¥æ— è®ºå“ªä¸ªä½ç½®ä¸Šéƒ½åªèƒ½æœ‰ä¸€ç§è·¯å¾„ï¼Œå› æ­¤å¯ä»¥å…ˆå°†å…¨éƒ¨çš„æ ¼å­å†…çš„æ­¥æ•°è®¾ä¸º1ï¼Œç„¶åä»ç¬¬äºŒè¡Œç¬¬äºŒåˆ—å¼€å§‹è¿­ä»£(ç”±äºç¨‹åºä¸­é»˜è®¤ä»0å¼€å§‹ï¼Œæ‰€ä»¥ä»£ç ä¸­ç”¨1æ¥è¡¨ç¤ºç¬¬äºŒè¡Œç¬¬äºŒåˆ—) æ ¹æ®åŠ¨æ€è§„åˆ’æ¥æ€è€ƒï¼Œåªè¦æˆ‘ä»¬æ±‚å‡ºäº†åˆ°è¾¾æ¯ä¸€ä¸ªç‚¹çš„æœ€å¤§è·¯å¾„æ•°ï¼Œç”±äºåªèƒ½å‘ä¸‹å‘å³èµ°ï¼Œåˆ™æœ€åä¸€ä¸ªç‚¹çš„æœ€å¤§è·¯å¾„æ•°ä¸å°±æ˜¯å‰ä¸¤ä¸ªçš„æœ€å¤§è·¯å¾„ä¹‹å’Œæƒ³åŠ ä¹ˆ,å³å¾—å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹ p[i][j] = p[i][j-1]+p[i-1][j] ä»£ç å¦‚ä¸‹ï¼š class Solution(object): def uniquePaths(self, m, n): # é¦–å…ˆæ’é™¤åªæœ‰ä¸€è¡Œä¸€åˆ—çš„æƒ…å†µï¼Œæ­¤æ—¶åªæœ‰ä¸€ç§è·¯å¾„ if n == 1 or m == 1: return 1 # å°†æ•´ä¸ªæ•°ç»„å‡è®¾ç½®ä¸º1ï¼Œåˆå§‹åŒ– dp = [[1 for _ in range(n) for _ in range(m)]] for i in (1,m): for j in (1,n): # é’ˆå¯¹æ¯ä¸€ä¸ªåæ ‡(i,j)ä¸‹çš„ä½ç½®è¿›è¡ŒçŠ¶æ€è½¬ç§»ï¼Œ #å…¶å€¼ä¸ºè¯¥ä½ç½®ä¸Šæ–¹å’Œå·¦æ–¹çš„è·¯å¾„æ•°ä¹‹å’Œ dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]# è¿”å›dpä¸­çš„æœ€åä¸€ä¸ªå…ƒç´  Problems 4 : Pascalâ€™s Triangle(DPåŠ¨æ€è§„åˆ’é—®é¢˜) Given a non-negative integer numRows, generate the first numRows of Pascalâ€™s triangle. ç»™å‡ºä¸€å®šçš„è¡Œæ•°ï¼Œè¾“å‡ºæ¥ä¸‹æ¥çš„æ¯ä¸€è¡Œå…ƒç´ ä¸ªæ•° Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] ä»”ç»†å¯»æ‰¾è§„å¾‹åï¼Œå‘ç°æ¯ä¸€è¡Œé™¤äº†1ä»¥å¤–ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æ˜¯å…¶ä¸Šä¸€è¡Œå¯¹åº”ä½ç½®å’Œå‰ä¸€ä¸ªä½ç½®çš„å’Œ ä»£ç å¦‚ä¸‹ï¼š class Solution(object): def generate(self, numRows): # åˆå§‹åŒ–ä¸€ä¸ªå…¨ä¸º1çš„ä¸‰è§’å½¢ï¼Œæ¯ä¸€è¡Œå…ƒç´ ä¸ªæ•°æ˜¯è¡Œæ•°åŠ ä¸€(ä»£ç ä¸­0ä¸ºç¬¬ä¸€è¡Œ) tree = [[1]* (i+1) for i in range(numRows)] for i in range(numRows): for j in range(1,i): # è¿›è¡ŒçŠ¶æ€è½¬ç§» tree[i][j]=tree[i-1][j-1] + tree[i-1][j] return tree","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 1","slug":"Leetcode1","date":"2019-03-07T02:33:07.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/03/06/Leetcode1/","link":"","permalink":"WangHngLeee.github.io/2019/03/06/Leetcode1/","excerpt":"Problem 1 : Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","text":"Problem 1 : Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. class solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: r = &#123;&#125; #create dict for x in range(0,len(nums)): n = target - nums(x) #find the other number if n in r: # return [r[n],x] #return the addresses of matched numbers r[nums[x]] = x #input the address of number to r&#123;&#125; Problem 2 : Add two numbers Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry,10) n.next = ListNode(val) n = n.next return root.next Problems 3 : Longest Substring Without Repeating Characters Description Given a string, find the length of the longest substring without repeating characters. Example 1: Input: â€œabcabcbbâ€ Output: 3 Explanation: The answer is â€œabcâ€, with the length of 3. class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: usedchar = &#123;&#125; for i in range(len(s)): if s[i] in usedchar and start&lt;= usedchar(s[i]): start = usedchar(s[i])+1 else: maxlength = max(maxlength, i-start+1) return maxlength Problems 4 : Longest Palindromic Substring Description Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: â€œbabadâ€ Output: â€œbabâ€ Note: â€œabaâ€ is also a valid answer. class Solution(object): def self.helper(object): while i &gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1;r+=1 return s[l+1:r] def longestPalindrome(self, s): res = \"\" tem = self.helper(s,i,i) if len(tem)&gt;len(res): res = tem tem = self.helper(s,i,i+1) if len(tem) &gt; len(res): res = tem return res","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"OpenCv Learning Notes (1)","slug":"OpenCv","date":"2019-03-06T14:23:41.000Z","updated":"2019-11-03T21:42:16.034Z","comments":true,"path":"2019/03/06/OpenCv/","link":"","permalink":"WangHngLeee.github.io/2019/03/06/OpenCv/","excerpt":"Representation of image As a computer, an image is just a bunch of dots of varying brightness. An M by N image can be represented by an M by N matrix. The value of the matrix element indicates the brightness of the pixel at this position. Generally, the larger the pixel value is, the brighter the point will be. In general, grayscale images are represented by a 2-dimensional matrix, and color (multi-channel) images are represented by a 3-dimensional matrix (M by N by 3).For image display, most devices currently use unsigned 8-bit integer The number (of type CV_8U) represents the pixel brightness.The order in which image data is stored in the computer memory starts at the top left (or possibly bottom left) of the image, as shown in the figure","text":"Representation of image As a computer, an image is just a bunch of dots of varying brightness. An M by N image can be represented by an M by N matrix. The value of the matrix element indicates the brightness of the pixel at this position. Generally, the larger the pixel value is, the brighter the point will be. In general, grayscale images are represented by a 2-dimensional matrix, and color (multi-channel) images are represented by a 3-dimensional matrix (M by N by 3).For image display, most devices currently use unsigned 8-bit integer The number (of type CV_8U) represents the pixel brightness.The order in which image data is stored in the computer memory starts at the top left (or possibly bottom left) of the image, as shown in the figure Iij represents the pixel value of row I, column j.If it is a multi-channel image, such as an RGB image, each pixel is represented by three bytes.In OpenCV, the channel order of RGB image is BGR, as stored As shown in figure. Mat In the early OpenCV, IplImage and CvMat data structures were used to represent images. In the new version of OpenCV, Mat class is introduced, which can manage memory automatically. With Mat, you no longer have to spend a lot of effort on memory management, and your code becomes cleaner and fewer lines of code. IplImage and CvMat are still available in the new version of OpenCV, but some of the new functions only provide Mat interfaces. The Mat class is defined as follows, and the key properties are as follows: class CV_EXPORTS Mat&#123;public: // A series of functions ... /* The flag parameter contains a lot of information about matrices, such as:- logo Mat- whether the data is continuous- depth - number of channels */ int flags; // The dimension of the matrix should be greater than or equal to 2 int dims; // The number of rows and columns in the matrix, if the matrix exceeds 2 dimensions, both of these variables have a value of 1 int rows, cols; // A pointer to data uchar* data; // A pointer to a reference count // NULL if the data is assigned by the user int* refcount;24 // Other member variables and member functions ...&#125;; Create Mat object Constructor method The Mat class provides a series of constructors that make it easy to create Mat objects as needed. Mat M(3,2, CV_8UC3, Scalar(0,0,255)); cout &lt;&lt; \"M = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; M &lt;&lt; endl; The first line of code creates an image with 3 rows (height) and 2 columns (width), and the image element is an 8-bit unsigned integer type with three channels.All pixel values of the image are initialized to (0, 0, 255).Since the default color order in OpenCV is BGR, this is an all-red image.The second line outputs all the pixel values of an instance M of the Mat class.Mat redefines the &lt;&lt; operator, With this operator, you can easily output all pixel values without having to use a for loop to output each pixel individually. The output of the code is shown in the figure Common constructors are: Mat::Mat () Parameterless construction method; Mat::Mat(int rows, int cols, int type) Create an image with rows, col and type rows. Mat::Mat (Size Size, int type) Create an image of size and type. Mat::Mat(int rows, int cols, int type, const Scalar&amp; s) Create an image with rows, col and type, and initialize all elements with the value s â€¦ If more channels are needed, use the macro CV_8UC(n), for example: Mat M(3,2, CV_8UC(5));// Create images with rows 3, columns 2, and channels 5 Create the object with the create() function In addition to creating images in the constructor, you can also create images using the create() function of the Mat class. If the create() function specifies the same parameters as before the image, no real memory is used.Application for operation; If the parameters are different, the index of the original data memory is reduced and the memory is reapplied.The use method is as follows: Mat M(2,2, CV_8UC3);// The constructor creates the imageM.create(3,2, CV_8UC2);// Free up memory to recreate the image Note that the initial value of the image pixel cannot be set using the create() function. Create objects using Matlab Matlab style functions such as zeros(), ones() and eyes() are provided in OpenCV 2.It makes the code very simple and easy to use.Using these functions requires specifying the size and type of the image. Mat Z = Mat::zeros(2,3, CV_8UC1);cout &lt;&lt; \"Z = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; Z &lt;&lt; endl;Mat O = Mat::ones(2, 3, CV_32F); cout &lt;&lt; \"O = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; O &lt;&lt; endl;Mat E = Mat::eye(2, 3, CV_64F); cout &lt;&lt; \"E = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; E &lt;&lt; endl; In this code, some type parameters do not indicate the number of channels, in which case it represents a single channel.The output of the above code is shown in the figure","categories":[{"name":"Image Recognition","slug":"Image-Recognition","permalink":"WangHngLeee.github.io/categories/Image-Recognition/"}],"tags":[{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"OpenCv","slug":"OpenCv","permalink":"WangHngLeee.github.io/tags/OpenCv/"}]},{"title":"TensorFlow Learning Notes (1)","slug":"Tensorflow","date":"2019-03-02T04:29:43.000Z","updated":"2019-06-21T05:14:28.000Z","comments":true,"path":"2019/03/01/Tensorflow/","link":"","permalink":"WangHngLeee.github.io/2019/03/01/Tensorflow/","excerpt":"Tensorflow graphs Tensorflow is a graph based parallel computing model (refer to the official document) Circular or square nodes are called nodes, and the streams of data that flow through them are called tensors. More about tensor in the official documentation. The zero order tensor == scalar1 order tensor == Vector (one-dimensional array)2 order tensor == 2 d arrayâ€¦n order tensor == n d array","text":"Tensorflow graphs Tensorflow is a graph based parallel computing model (refer to the official document) Circular or square nodes are called nodes, and the streams of data that flow through them are called tensors. More about tensor in the official documentation. The zero order tensor == scalar1 order tensor == Vector (one-dimensional array)2 order tensor == 2 d arrayâ€¦n order tensor == n d array The relationship between tensor and node: If the dimension of the input tensor is 5,000 by 64, 5000 x 64 means there are 5000 training samples, each sample has 64 characteristics, so the input layer must have 64 nodes to accept these characteristics. The three layers of the network shown in the figure above include the input layer (input in the figure), the hidden layer (named ReLU layer here to indicate that its activation function is ReLU), and the output layer (Logit layer in the figure). As you can see, each of these layers have their associated tensor Gradient nodes flowing into them to compute the Gradient, and then the Gradient tensor will go into the SGD Trainer node to do network optimization (which is to say, update the network parameters). It is through graph that Tensorflow represents the neural network to realize the parallel computation of the network and improve the efficiency. We will introduce the basic syntax of TensorFlow with a simple example. Examples A = calculated using Tensorflow (b + c) âˆ— (c + 2) A = (b + c) âˆ— (c + 2), Define data: import tensorflow as tf# First, create a TensorFlow constant =&gt;2=&gt;2const = tf.constant(2.0, name='const')# Create the TensorFlow variables b and cb = tf.Variable(2.0, name='b')c = tf.Variable(1.0, dtype=tf.float32, name='c') As mentioned above, in TensorFlow, constant is defined with tf.constant() and Variable is defined with tf.variable (). Tensorflow can perform data type detection automatically, for example: assignment 2.0 defaults to tf.float32, but is best defined explicitly.For more information on the TensorFlow data type, see the official documentation. Define operation (also known as TensorFlow operation) : # create operationd = tf.add(b, c, name='d')e = tf.add(c, const, name='e')a = tf.multiply(d, e, name='a') In TensorFlow, + has its own special function representation. In fact, TensorFlow defines enough functions to represent all of the math, and of course overloads some of the math, but to be on the safe side, it is recommended to use functions instead of operators. All variables in TensorFlow must be initialized before they can be used. Initialization consists of two steps: Define initialization operation Run initialization operation # 1. define init operationinit_op = tf.global_variables_initializer() The construction of TensorFlow graph has been completed above. The next step is to calculate and output. To run graph, we need to call the tf.session () function to create a Session.The session is the handle that interacts with the graph. # sessionwith tf.Session() as sess: # 2. init operation sess.run(init_op) # caculate a_out = sess.run(a) print(\"Variable a is &#123;&#125;\".format(a_out)) TensorFlow has an excellent visualization tool called TensorBoard(see the official documentation) An improvement to the above example: make the variable b accept any value.Values are received in TensorFlow as placeholders, created through tf.placeholder(). # create placeholderb = tf.placeholder(tf.float32, [None, 1], name='b') The value of the second parameter is [None, 1], where None indicates uncertainty, namely the size of the first dimension, which can be any size.In particular, the number of tensor inputs (or the number of samples) will be 32, 64â€¦ Now, if you get the result of the calculation, you need the value of feed placeholder b during the run by changing a_out = sess.run(a) to: a_out = sess.run(a, feed_dict=&#123;b: np.arange(0, 10)[:, np.newaxis]&#125;) Outputï¼š Variable a is [[ 3.] [ 6.] [ 9.] [ 12.] [ 15.] [ 18.] [ 21.] [ 24.] [ 27.] [ 30.]]","categories":[{"name":"Deep-Learning","slug":"Deep-Learning","permalink":"WangHngLeee.github.io/categories/Deep-Learning/"}],"tags":[{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"WangHngLeee.github.io/tags/TensorFlow/"}]},{"title":"HOG Learning Notes (1)","slug":"HURF","date":"2019-03-01T16:07:54.000Z","updated":"2019-06-21T05:14:16.000Z","comments":true,"path":"2019/03/01/HURF/","link":"","permalink":"WangHngLeee.github.io/2019/03/01/HURF/","excerpt":"HOG features Currently, HOG (Histogram of Oriented Gradient) is one of the mainstream feature descriptors of pedestrian detection based on machine learning method. HOG feature is a feature descriptor used for target detection. It forms features by calculating and counting the histogram of gradient direction in the local area of the image, and describes the image with these features. This method is similar to the histogram of edge direction and scale-invariant feature transform, but hogâ€™s computation is based on the density matrix of consistent space to improve the accuracy. Navneet Dalal and Bill Triggs first proposed HOG in 2005â€™s CVPR for pedestrian detection in static images or video.","text":"HOG features Currently, HOG (Histogram of Oriented Gradient) is one of the mainstream feature descriptors of pedestrian detection based on machine learning method. HOG feature is a feature descriptor used for target detection. It forms features by calculating and counting the histogram of gradient direction in the local area of the image, and describes the image with these features. This method is similar to the histogram of edge direction and scale-invariant feature transform, but hogâ€™s computation is based on the density matrix of consistent space to improve the accuracy. Navneet Dalal and Bill Triggs first proposed HOG in 2005â€™s CVPR for pedestrian detection in static images or video. The feature of Histogram of Oriented Gradient (HOG) is a descriptor used for object detection in computer vision and image processing. By calculating and statistics the gradient direction histogram of the local area to form the feature. Hog feature combining SVM classifier has been widely used in image recognition, especially in pedestrian detection, which has achieved great success. Nowadays, although many pedestrian detection algorithms are constantly proposed, they are mainly based on HOG + SVM. Principle of HOG characteristics Core method HOG core method is the detection of local object shape can be the distribution of light intensity gradient or the edge direction described, through the image segmentation into small connection area (called cells), each cell to generate a gradient direction histogram or cell edge pixel in image, the histogram of combination can be expressed by detecting target of the target descriptor. In order to improve the accuracy, the local histogram can be compared and standardized by calculating the light intensity of a large area in the image (called block) as the measure, and then use this value (measure) to normalize all cells in the block. This normalization process achieves better light/shadow invariance. The main steps Grayscale an image, that is, treat the image as a three-dimensional image of x,y and z, where z is the grayscale value. Divide into small connected areas called cells (2x2) Calculate the gradient or edge orientation histogram of each pixel in each cells Count the gradient histogram of each cell (the number of different gradients) to form the feature descriptor of each cell. The differences and applications between HOG/SIFT/ PCA-SIFT The HOG feature has no rotation and scale invariance, so the computation is small Each feature in SIFT needs to be described by 128-dimensional vectors, so the computation is relatively large 3 Since SIFT cannot be used for pedestrian detection due to its huge computation, the pca-sift method filters out a lot of dimensional information and only retains 20 principal components, so it is only applicable for object detection with little change in behavior. HOG feature extraction is realized with python+opencv Read in the required detection target, i.e. the input image Grayscale the image (convert the r,g and b values of the input color image into grayscale values through a specific formula) Use Gamma correction method to normalize the color space of the input image (normalization) Calculate the gradient (including size and direction) of each pixel of the image, and capture the contour information Count the gradient histogram (number of different gradients) of each cell to form the descriptor of each cell Every few cells are grouped into a block (take 3*3 as an example), and all cell features in a block are strung together to get the HOG feature descriptor of the block HOG feature descriptor of all blocks in the image is concatenated to obtain the HOG feature descriptor of the image (detection target), which is the final classification feature vector (HOG parameter setting is: 22 cells/interval, 88 pixels/cell, 8 histogram channels, step size is 1)","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"WangHngLeee.github.io/categories/Machine-Learning/"},{"name":"Algorithm","slug":"Machine-Learning/Algorithm","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/"},{"name":"Models","slug":"Machine-Learning/Algorithm/Models","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/Models/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"HOG","slug":"HOG","permalink":"WangHngLeee.github.io/tags/HOG/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"}]},{"title":"Python & Web","slug":"pythonEmail","date":"2019-02-27T13:35:09.000Z","updated":"2019-06-21T05:14:22.000Z","comments":true,"path":"2019/02/27/pythonEmail/","link":"","permalink":"WangHngLeee.github.io/2019/02/27/pythonEmail/","excerpt":"Python network programming Python provides two levels of access to network services: Low-level network services support basic Sockets, which provide the standard BSD Sockets API and access to all methods of the Socket interface of the underlying operating system. Advanced network service module SocketServer, which provides a server center class, can simplify the development of network server.","text":"Python network programming Python provides two levels of access to network services: Low-level network services support basic Sockets, which provide the standard BSD Sockets API and access to all methods of the Socket interface of the underlying operating system. Advanced network service module SocketServer, which provides a server center class, can simplify the development of network server. Socket Socket also known as the â€œSocketâ€, the application usually through the â€œSocketâ€ to the network to make a request or reply to the network request, so that the host or a computer between the process can communicate. Socket() function In Python, socket () function is used to create socket. The syntax format is as follows: socket.socket([family[, type[, proto]]]) Parameters: Family: the socket family can be AF_UNIX or AF_INET Type: socket types can be classified as SOCK_STREAM or SOCK_DGRAM depending on whether they are connection-oriented or connection-free Protocol: donâ€™t use 0 as the default. The service side Use the socket function of the socket module to create a socket object.A socket object can set up a socket service by calling other functions. Now we can specify the port of the service by calling the bind(hostname, port) function. Next, call the accept method of the socket object. This method waits for the client to connect and returns a connection object indicating that it is connected to the client. The complete code is as follows: #!/usr/bin/python# -*- coding: UTF-8 -*-# file nameï¼šserver.pyimport socket # input socket models = socket.socket() # create socket objecthost = socket.gethostname() # Gets the localhost nameport = 12345 # Set ports.bind((host, port)) # Binding ports.listen(5) # Wait for client connectionwhile True: c, addr = s.accept() # Establish a client connection. print 'Address:', addr c.send('Welcome to the rookie tutorial!') c.close() # close the connection The client Next, write a simple client instance that connects to the service created above.The port number is 12345. The socket.connect(hosname, port) method opens a TCP connection to a service provider that has a hostname of port.After the connection. We can then retrieve the data from the server and remember to close the connection when the operation is complete. The complete code is as follows: #!/usr/bin/python# -*- coding: UTF-8 -*-# file nameï¼šclient.pyimport socket # import socket models = socket.socket() # create socket objecthost = socket.gethostname() # Gets the localhost nameport = 12345 # Set ports.connect((host, port))print s.recv(1024)s.close() Now we open the two terminals. The first terminal executes the server.py ï¼š $ python server.py Second terminal execution client.py ï¼š $ python client.py Welcome to the rookie tutorial! When we open the first terminal, we will see the following information output: Addressï¼š ('192.168.0.118', 62461)","categories":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"Web","slug":"Web","permalink":"WangHngLeee.github.io/tags/Web/"}]},{"title":"Using python-turtle to create images","slug":"tree1","date":"2019-02-21T13:35:09.000Z","updated":"2019-06-21T05:14:28.000Z","comments":true,"path":"2019/02/21/tree1/","link":"","permalink":"WangHngLeee.github.io/2019/02/21/tree1/","excerpt":"Turtle Urzig has created a language for children to learn to program â€“ LOGO language, which features a programming command for a turtle to draw on a screen. Turtle Graphics were later ported to various high-level languages, and the Python library was built in, essentially 100% duplicating all the functionality of the original Turtle Graphics.","text":"Turtle Urzig has created a language for children to learn to program â€“ LOGO language, which features a programming command for a turtle to draw on a screen. Turtle Graphics were later ported to various high-level languages, and the Python library was built in, essentially 100% duplicating all the functionality of the original Turtle Graphics. The first one is the one with the falling leaves effect, which Iâ€™ll talk about later. Letâ€™s start with a simple tree. The code is as follows: from turtle import *from random import *from math import *def tree(n, l): pd() # put the pen down # shadow effect t = cos(radians(heading() + 45)) / 8 + 0.25 pencolor(t, t, t) pensize(n / 3) forward(l) # draw the twigsif n &gt; 0: b = random() * 15 + 10 # Right branch deflection Angle c = random() * 15 + 10 # Left branch deflection Angle d = l * (random() * 0.25 + 0.7) # The length of the next branch # Turn right at an Angle and draw the right branch right(b) tree(n - 1, d) # Turn left at an Angle and draw the left branch left(b + c) tree(n - 1, d) # turn back right(c)else:# draw the leaves right(90) n = cos(radians(heading() - 45)) / 4 + 0.5 pencolor(n, n, n) circle(3) left(90) pu() # pen up backward(l) # backwardbgcolor(0.5, 0.5, 0.5) # backgroundht() # hide turtlespeed(0) # speedï¼Œslow down from 1-10ï¼Œ0 is the fastesttracer(0, 0)left(90) # turn left for 90 anglespu() # pen upbackward(300) # backward 300tree(13, 100) # recursive 7 layersdone() Run the code with PythonIDLEï¼š Add fallen leaves Replace all the codes after drawing the leaves with: if(random()&gt;0.7): pu()#falling t = heading() an = -40 +random()*40 setheading(an) dis = int(800*random()*0.5 + 400*random()*0.3 + 200*random()*0.2) # set the falling equation forward(dis) setheading(t) # draw leaves pd() #pen up right(90) n = cos(radians(heading()-45))/4+0.5 pencolor(n*0.5+0.5,0.4+n*0.4,0.4+n*0.4) circle(2) left(90) pu() #back t=heading() setheading(an) backward(dis) setheading(t) pu() backward(l) #backwardbgcolor(0.5,0.5,0.5) #backgroundht() #hide turtlespeed(0) #speedtracer(0,0)pu() backward(100)left(90) pu() backward(300) tree(12,100) done() The effect after running: At this point, a basic tree is drawn, and the tutrl library still has a lot for me to learn.","categories":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"Turtle","slug":"Turtle","permalink":"WangHngLeee.github.io/tags/Turtle/"}]},{"title":"Talk is cheap. Show me the code.","slug":"hello-world","date":"2019-02-20T13:35:09.000Z","updated":"2019-11-08T04:51:08.897Z","comments":true,"path":"2019/02/20/hello-world/","link":"","permalink":"WangHngLeee.github.io/2019/02/20/hello-world/","excerpt":"","text":"Hiï¼ Hi, here is my personal website and my first blog. From the beginning of the determination to switch to the code farmers, I have always hoped to have a home in the network world. Because I have been busy studying abroad, I am now on the winter vacation and can finally free up time to build my own blog. Non-technical origin, from the front-end basic language, to the popular front-end framework React, Angular, Spring, Firebase, etc., slowly explored by themselves, relying on interest and perseverance. I hope that when I lose the last line of code, the entire website appears completely in front of me, and I have no hard work. Of course, this is just a simple beginning. There are still many things to learn. Keep hungry and keep learning. å—¨ï¼ å—¨ï¼Œè¿™é‡Œæ˜¯æˆ‘ä¸ªäººç½‘ç«™ï¼Œä¹Ÿæ˜¯æˆ‘çš„ç¬¬ä¸€ä¸ªåšå®¢ã€‚ä»ä¸‹å®šå†³å¿ƒè½¬è¡Œç å†œå¼€å§‹ï¼Œå°±ä¸€ç›´å¸Œæœ›èƒ½åœ¨ç½‘ç»œä¸–ç•Œé‡Œé‡Œæœ‰ä¸€ä¸ªå±äºè‡ªå·±çš„å®¶ã€‚ç”±äºä¹‹å‰ä¸€ç›´åœ¨å¿™ç•™å­¦çš„äº‹æƒ…ï¼Œç°åœ¨æ”¾å¯’å‡äº†ï¼Œç»ˆäºèƒ½ç©ºå‡ºæ—¶é—´æ¥æ‰“é€ ä¸€ä¸ªè‡ªå·±çš„Blogã€‚ éç§‘ç­å‡ºèº«ï¼Œä»å‰ç«¯çš„åŸºæœ¬è¯­è¨€ï¼Œå†åˆ°æµè¡Œå‰åç«¯æ¡†æ¶React,Angular,Spring,Firebaseç­‰ï¼Œè‡ªå·±æ…¢æ…¢æ‘¸ç´¢ï¼Œå…¨é å…´è¶£å’Œæ¯…åŠ›æ”¯æ’‘ã€‚å¦‚æ„¿ä»¥å¿åœ°ï¼Œå½“æˆ‘è¾“å®Œæœ€åä¸€è¡Œä»£ç çš„æ—¶å€™ï¼Œæ•´ä¸ªç½‘ç«™å®Œæ•´åœ°å‡ºç°åœ¨æˆ‘çœ¼å‰ï¼Œä¹Ÿç®—æ²¡æœ‰ç™½åŠªåŠ›å§ã€‚å½“ç„¶ï¼Œè¿™åªæ˜¯ä¸€ä¸ªç®€å•çš„å¼€å§‹ï¼Œè¦å­¦ä¹ çš„è¿˜æœ‰å¾ˆå¤šï¼Œå°‘è¯´å¤šåšã€‚Keep hungry and keep learningã€‚","categories":[],"tags":[]}],"categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"},{"name":"Depolyed Web App","slug":"Depolyed-Web-App","permalink":"WangHngLeee.github.io/categories/Depolyed-Web-App/"},{"name":"å‰ç«¯æ¡†æ¶","slug":"å‰ç«¯æ¡†æ¶","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/"},{"name":"React","slug":"å‰ç«¯æ¡†æ¶/React","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/React/"},{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"},{"name":"Vue","slug":"å‰ç«¯æ¡†æ¶/Vue","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/"},{"name":"Interview","slug":"å‰ç«¯æ¡†æ¶/Vue/Interview","permalink":"WangHngLeee.github.io/categories/å‰ç«¯æ¡†æ¶/Vue/Interview/"},{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"},{"name":"JS","slug":"Interview/JS","permalink":"WangHngLeee.github.io/categories/Interview/JS/"},{"name":"Language","slug":"Language","permalink":"WangHngLeee.github.io/categories/Language/"},{"name":"IBM-OA","slug":"IBM-OA","permalink":"WangHngLeee.github.io/categories/IBM-OA/"},{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/categories/ruby/"},{"name":"web/appå¼€å‘ï¼Œæ¡†æ¶","slug":"web-appå¼€å‘ï¼Œæ¡†æ¶","permalink":"WangHngLeee.github.io/categories/web-appå¼€å‘ï¼Œæ¡†æ¶/"},{"name":"Life","slug":"Life","permalink":"WangHngLeee.github.io/categories/Life/"},{"name":"lazyday","slug":"lazyday","permalink":"WangHngLeee.github.io/categories/lazyday/"},{"name":"Image Recognition","slug":"Image-Recognition","permalink":"WangHngLeee.github.io/categories/Image-Recognition/"},{"name":"Deep-Learning","slug":"Deep-Learning","permalink":"WangHngLeee.github.io/categories/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"WangHngLeee.github.io/categories/Machine-Learning/"},{"name":"Algorithm","slug":"Machine-Learning/Algorithm","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/"},{"name":"Models","slug":"Machine-Learning/Algorithm/Models","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/Models/"},{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Problems List","slug":"Problems-List","permalink":"WangHngLeee.github.io/tags/Problems-List/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"},{"name":"Web Application","slug":"Web-Application","permalink":"WangHngLeee.github.io/tags/Web-Application/"},{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"},{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"},{"name":"SilidingWindow","slug":"SilidingWindow","permalink":"WangHngLeee.github.io/tags/SilidingWindow/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"Topological","slug":"Topological","permalink":"WangHngLeee.github.io/tags/Topological/"},{"name":"Tricky","slug":"Tricky","permalink":"WangHngLeee.github.io/tags/Tricky/"},{"name":"Partition","slug":"Partition","permalink":"WangHngLeee.github.io/tags/Partition/"},{"name":"Presum","slug":"Presum","permalink":"WangHngLeee.github.io/tags/Presum/"},{"name":"Golang","slug":"Golang","permalink":"WangHngLeee.github.io/tags/Golang/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"WangHngLeee.github.io/tags/TwoPointers/"},{"name":"BucketSort","slug":"BucketSort","permalink":"WangHngLeee.github.io/tags/BucketSort/"},{"name":"Sort","slug":"Sort","permalink":"WangHngLeee.github.io/tags/Sort/"},{"name":"Interval","slug":"Interval","permalink":"WangHngLeee.github.io/tags/Interval/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"},{"name":"tree","slug":"tree","permalink":"WangHngLeee.github.io/tags/tree/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"},{"name":"OnlineAssignments","slug":"OnlineAssignments","permalink":"WangHngLeee.github.io/tags/OnlineAssignments/"},{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/tags/ruby/"},{"name":"OOP","slug":"OOP","permalink":"WangHngLeee.github.io/tags/OOP/"},{"name":"React-Native","slug":"React-Native","permalink":"WangHngLeee.github.io/tags/React-Native/"},{"name":"app","slug":"app","permalink":"WangHngLeee.github.io/tags/app/"},{"name":"webapp","slug":"webapp","permalink":"WangHngLeee.github.io/tags/webapp/"},{"name":"F-1 VISA","slug":"F-1-VISA","permalink":"WangHngLeee.github.io/tags/F-1-VISA/"},{"name":"é¸½","slug":"é¸½","permalink":"WangHngLeee.github.io/tags/é¸½/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"OpenCv","slug":"OpenCv","permalink":"WangHngLeee.github.io/tags/OpenCv/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"WangHngLeee.github.io/tags/TensorFlow/"},{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"HOG","slug":"HOG","permalink":"WangHngLeee.github.io/tags/HOG/"},{"name":"Web","slug":"Web","permalink":"WangHngLeee.github.io/tags/Web/"},{"name":"Turtle","slug":"Turtle","permalink":"WangHngLeee.github.io/tags/Turtle/"}]}