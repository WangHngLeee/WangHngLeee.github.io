{"meta":{"title":"Leee's World","subtitle":"Talk is Cheap. Show me the code.","description":null,"author":"HomLee","url":"WangHngLeee.github.io","root":"/"},"pages":[{"title":"404 Error","date":"2019-10-13T19:49:05.000Z","updated":"2020-06-13T02:23:33.664Z","comments":true,"path":"/404.html","permalink":"WangHngLeee.github.io//404.html","excerpt":"","text":"Oops! The page doesn‚Äôt exist. Please refresh the page."},{"title":"Categories","date":"2019-02-28T21:39:53.000Z","updated":"2019-03-03T02:14:08.000Z","comments":true,"path":"categories/index.html","permalink":"WangHngLeee.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-02-28T21:39:40.000Z","updated":"2019-03-03T02:14:22.000Z","comments":true,"path":"tags/index.html","permalink":"WangHngLeee.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-19T19:25:18.595Z","updated":"2019-03-03T02:14:20.000Z","comments":true,"path":"top/index.html","permalink":"WangHngLeee.github.io/top/index.html","excerpt":"","text":"AV.initialize(\"osOa9nOdMvJ7waVycMHyXcpL-gzGzoHsz\", \"k2MfP5O1nYredg5XqqbEH6DC\"); var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit(1000); query.find().then(function (todo) { for (var i=0;i"},{"title":"AboutMe | Leee‚Äòs Info","date":"2019-02-28T21:56:13.000Z","updated":"2020-05-19T03:23:42.300Z","comments":true,"path":"about/index.html","permalink":"WangHngLeee.github.io/about/index.html","excerpt":"","text":"Contact me Social Link Github Link WeChat/ÂæÆ‰ø°: whl6596245 LinkedIn Profile E-mail hwang85@ncsu.edu 1023836798@qq.com hongli9749@gmail.com Achievements Projects My Portfolio page; https://leeeinfo.com Personal Website( keep updating ): https://leeemask.com React Online Hotel Reserve( keep updating ): https://bookinghotel-react.netlify.com Streaming Web Application https://github.com/WangHngLeee/Streamy Online Chatting Room https://github.com/WangHngLeee/online-chating Skills Programming Language: Python, Java, JavaScript, C/ C++, HTML, CSS/SCSS, Ruby Database : MySQL, Oracle, MongoDB, Firebase, NoSQL Tools: AWS,Gulp, Docker, Mesos, Swagger, Kafka Framework: React.JS, Vue.jsÔºåAngular, ReactNative, Node.JS, jQuery,Zepto, Flask, Django, Spring, Ajax, Bootstrap, Ruby on rails Paper Application of Machine Learning Algorithm in Medical Data Analysis First Author Submitted to Applied Intelligence, a CCF-C journal. Awards 2015-2018 Second and Third Prizes of Excellent University Scholarship for 3 years 08/2018 NXP Semiconductors National Smart Car Race, Second Prize 06/2018 Biomimetic Climbing Robots, Provincial Prize of University Student Innovation Competition"}],"posts":[{"title":"Review Problems List üìå","slug":"problemslist","date":"9999-12-31T16:13:23.000Z","updated":"2020-07-22T05:27:38.047Z","comments":true,"path":"9999/12/31/problemslist/","link":"","permalink":"WangHngLeee.github.io/9999/12/31/problemslist/","excerpt":"","text":"ËÆ∞ÂΩïProblems listÁöÑÂÆåÊàêÊÉÖÂÜµ ÊØèÊó•Êõ¥Êñ∞„ÄÇ üîó Problems List Link Github Leetcode Summary ÂêåÊ≠•Êõ¥Êñ∞„ÄÇ üîó Github Summary Link","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Problems List","slug":"Problems-List","permalink":"WangHngLeee.github.io/tags/Problems-List/"}]},{"title":"Review | Hard | 1192. Critical Connections in a Network","slug":"1192. Critical Connections in a Network","date":"2020-09-10T20:27:29.000Z","updated":"2020-09-10T23:49:59.728Z","comments":true,"path":"2020/09/10/1192. Critical Connections in a Network/","link":"","permalink":"WangHngLeee.github.io/2020/09/10/1192. Critical Connections in a Network/","excerpt":"1192. Critical Connections in a Network üîó Question Link Examples There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network. A critical connection is a connection that, if removed, will make some server unable to reach some other server. Return all critical connections in the network in any order. Example 1: Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]Output: [[1,3]]Explanation: [[3,1]] is also accepted. Constraints: 1 &lt;= n &lt;= 10^5 n-1 &lt;= connections.length &lt;= 10^5 connections[i][0] != connections[i][1] There are no repeated connections.","text":"1192. Critical Connections in a Network üîó Question Link Examples There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network. A critical connection is a connection that, if removed, will make some server unable to reach some other server. Return all critical connections in the network in any order. Example 1: Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]Output: [[1,3]]Explanation: [[3,1]] is also accepted. Constraints: 1 &lt;= n &lt;= 10^5 n-1 &lt;= connections.length &lt;= 10^5 connections[i][0] != connections[i][1] There are no repeated connections. Solution It‚Äôs a typical Tarjan solution. We need to find the parts that are not strong components. Detailed information about Tarjan can be found in this post. CSDN Link Time: the time that the node be visited Low: the lowest time that current node‚Äôs parent nodes have. findTime: the time stamp that increases by itself. We first create a graph to store v and u. Then perfom DFS on each unvisited node v in graph[u]. If v is unvisited, recursively call the function DFS. Then update the low[u]. If low[v] &gt; time[u], it means the current node v can not go back to it‚Äôs parrent node u. So this is an critical connection and we add them to res. Otherwise, we update low[u] with Math.min(low[u], time[v]) Code class Solution &#123; int[] time, low; List&lt;List&lt;Integer&gt;&gt; res; int findTime = 0; public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int n, List&lt;List&lt;Integer&gt;&gt; connections) &#123; res = new ArrayList&lt;&gt;(); time = new int[n]; low = new int[n]; Arrays.fill(time,-1); List&lt;Integer&gt;[] graph = new ArrayList[n]; for(int i=0; i&lt;n; i++)&#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int i=0; i&lt;connections.size(); i++)&#123; int start = connections.get(i).get(0); int end = connections.get(i).get(1); graph[start].add(end); graph[end].add(start); &#125; for(int i=0; i&lt;n; i++)&#123; if(time[i] == -1)&#123; dfs(graph, i, i); &#125; &#125; return res; &#125; public void dfs(List&lt;Integer&gt;[] graph, int u, int prev)&#123; time[u] = low[u] = ++findTime; for(int k=0; k&lt;graph[u].size(); k++)&#123; int v = graph[u].get(k); if(v == prev)continue; if(time[v] == -1)&#123; dfs(graph,v,u); low[u] = Math.min(low[u],low[v]); if( low[v] &gt; time[u])&#123; res.add(Arrays.asList(u,v)); &#125; &#125;else&#123; low[u] = Math.min(low[u], time[v]); &#125; &#125; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Review | Easy | 733. Flood Fill","slug":"733. Flood Fill","date":"2020-08-16T14:30:29.000Z","updated":"2020-08-16T15:53:40.644Z","comments":true,"path":"2020/08/16/733. Flood Fill/","link":"","permalink":"WangHngLeee.github.io/2020/08/16/733. Flood Fill/","excerpt":"733. Flood Fill üîó LeetCode Link Examples An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, ‚Äúflood fill‚Äù the image. To perform a ‚Äúflood fill‚Äù, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor. At the end, return the modified image. Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].","text":"733. Flood Fill üîó LeetCode Link Examples An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, ‚Äúflood fill‚Äù the image. To perform a ‚Äúflood fill‚Äù, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor. At the end, return the modified image. Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2Output: [[2,2,2],[2,2,0],[2,0,1]]Explanation: From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color.Note the bottom corner is not colored 2, because it is not 4-directionally connectedto the starting pixel. Note: The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535]. Solution Take care of corner case that cause many times in my submission. Just return the image when the newColor is same as start point‚Äôs color. BFS It‚Äôs traditional BFS solution. Using template for BFS is enough. DFS It‚Äôs traditional DFS solution. Using template for DFS is enough. Code DFS class Solution &#123; int m; int n; int old; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if(image[sr][sc] == newColor)return image; m = image.length; n = image[0].length; old = image[sr][sc]; dfs(image,sr,sc,newColor); return image; &#125; public void dfs(int[][] image, int row, int col, int newColor)&#123; if(row&lt;0 || row &gt;= m || col &lt; 0 || col &gt;= n || image[row][col] != old)&#123; return; &#125; image[row][col] = newColor; dfs(image,row-1,col,newColor); dfs(image,row+1,col,newColor); dfs(image,row,col-1,newColor); dfs(image,row,col+1,newColor); &#125;&#125; BFS class Solution &#123; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1,0&#125;,&#123;-1,0&#125;&#125;; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if (image[sr][sc] == newColor) return image; int m = image.length; int n = image[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(new int[]&#123;sr, sc&#125;); int color = image[sr][sc]; while (!queue.isEmpty()) &#123; int[] temp = queue.poll(); image[temp[0]][temp[1]] = newColor; for (int[] dir : dirs) &#123; int x = temp[0] + dir[0]; int y = temp[1] + dir[1]; if (x&gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y&lt; n &amp;&amp; image[x][y] == color) &#123; image[x][y] = newColor; queue.offer(new int[]&#123;x,y&#125;); &#125; &#125; &#125; return image; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Review | Hard | 675. Cut Off Trees for Golf Event","slug":"675. Cut Off Trees for Golf Event","date":"2020-08-16T14:27:29.000Z","updated":"2020-08-16T15:16:02.322Z","comments":true,"path":"2020/08/16/675. Cut Off Trees for Golf Event/","link":"","permalink":"WangHngLeee.github.io/2020/08/16/675. Cut Off Trees for Golf Event/","excerpt":"675. Cut Off Trees for Golf Event üîó LeetCode Link Example You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map: 0 represents the obstacle can‚Äôt be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree‚Äôs height. In one step you can walk in any of the four directions top, bottom, left and right also when standing in a point which is a tree you can decide whether or not to cut off the tree. You are asked to cut off all the trees in this forest in the order of tree‚Äôs height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can‚Äôt cut off all the trees, output -1 in that situation. You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off. Example 1: Input: [ [1,2,3], [0,0,4], [7,6,5]]Output: 6 Example 2: Input: [ [1,2,3], [0,0,0], [7,6,5]]Output: -1 Example 3: Input: [ [2,3,4], [0,0,5], [8,7,6]]Output: 6Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking. Constraints: 1 &lt;= forest.length &lt;= 50 1 &lt;= forest[i].length &lt;= 50 0 &lt;= forest[i][j] &lt;= 10^9","text":"675. Cut Off Trees for Golf Event üîó LeetCode Link Example You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map: 0 represents the obstacle can‚Äôt be reached. 1 represents the ground can be walked through. The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree‚Äôs height. In one step you can walk in any of the four directions top, bottom, left and right also when standing in a point which is a tree you can decide whether or not to cut off the tree. You are asked to cut off all the trees in this forest in the order of tree‚Äôs height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1). You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can‚Äôt cut off all the trees, output -1 in that situation. You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off. Example 1: Input: [ [1,2,3], [0,0,4], [7,6,5]]Output: 6 Example 2: Input: [ [1,2,3], [0,0,0], [7,6,5]]Output: -1 Example 3: Input: [ [2,3,4], [0,0,5], [8,7,6]]Output: 6Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking. Constraints: 1 &lt;= forest.length &lt;= 50 1 &lt;= forest[i].length &lt;= 50 0 &lt;= forest[i][j] &lt;= 10^9 Solution Apparently we can using BFS. Using priority queue to sort the node by it‚Äôs value. We start from the (0,0). Keep record of the next tree that we want to cut , after BFS we need to update the current start with last next tree. Using BFS to find the best steps from the current tree to the next target tree. Code class Solution &#123; int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; if(forest == null || forest.size() == 0)return 0; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt;(a[2] - b[2])); int m = forest.size(); int n = forest.get(0).size(); for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; queue.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;); &#125; &#125; &#125; int sum = 0; int[] start = new int[2]; while(!queue.isEmpty())&#123; int[] tree = queue.poll(); int step = help(forest,start,tree,m,n); if(step == -1)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; public int help(List&lt;List&lt;Integer&gt;&gt; forest, int[] start, int[] tree, int m, int n)&#123; boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; int step = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; int[] temp = queue.poll(); if(temp[0] == tree[0] &amp;&amp; temp[1] == tree[1])return step; for(int[] dir : dirs)&#123; int x = temp[0]+dir[0]; int y = temp[1]+dir[1]; if(x&gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125;&#125; T:O(m^2 * n^2) S:O(m*n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"}]},{"title":"Review | Medium | 314. Binary Tree Vertical Order Traversal","slug":"314. Binary Tree Vertical Order Traversal","date":"2020-08-10T12:30:29.000Z","updated":"2020-08-10T13:28:21.853Z","comments":true,"path":"2020/08/10/314. Binary Tree Vertical Order Traversal/","link":"","permalink":"WangHngLeee.github.io/2020/08/10/314. Binary Tree Vertical Order Traversal/","excerpt":"314. Binary Tree Vertical Order Traversal üîó Leetcode Link üîó Similar Questoin 987 link Examples Given a binary tree, return the vertical order traversal of its nodes‚Äô values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples 1: Input: [3,9,20,null,null,15,7] 3 /\\ / \\ 9 20 /\\ / \\ 15 7 Output:[ [9], [3,15], [20], [7]]","text":"314. Binary Tree Vertical Order Traversal üîó Leetcode Link üîó Similar Questoin 987 link Examples Given a binary tree, return the vertical order traversal of its nodes‚Äô values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples 1: Input: [3,9,20,null,null,15,7] 3 /\\ / \\ 9 20 /\\ / \\ 15 7 Output:[ [9], [3,15], [20], [7]] Solution This question has the same solution with question 987. Vertical Order Traversal of a Binary Tree 1. Pair Class with BFS According to the question, we need to store the position of both x and y and it‚Äôs node. We can just define another simple class instead of using other TreeMap or PriorityQueue. What we need to do is just store the node that have same x in the HashMap using BFS/ Level Traversal. 2. Two Queue and BFS Using two queue to store position of x/col and nodes. Using Map to store the nodes that have same x/ col We follow the order of root -&gt; left -&gt; right to add both x/col and node into queue. So each time we just need to poll up the latest one to update the x/col and node. Also remember to keep track of leftmost left and rightmost right for the later loop. Code Pair class + BFS class Solution &#123; class pair&#123; TreeNode node; int x; int y; public pair(int x, int y, TreeNode n)&#123; this.x = x; this.y = y; this.node = n; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; // corner case Map&lt;Integer, List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); //BFS queue.add(new pair(0,0,root)); int left = 0; // leftmost x int right = 0; // rightmost x while(!queue.isEmpty())&#123; pair temp = queue.poll(); left = Math.min(left, temp.x); right = Math.max(right,temp.x); if(!map.containsKey(temp.x))&#123; map.put(temp.x, new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(new pair(temp.x, temp.y, temp.node)); if(temp.node.left != null)queue.add(new pair(temp.x-1, temp.y+1, temp.node.left)); if(temp.node.right != null)queue.add(new pair(temp.x+1, temp.y+1, temp.node.right)); &#125; for(int i=left; i&lt;=right; i++)&#123; Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y); // sort the node that have same y value List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j=0; j&lt; map.get(i).size(); j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; Two Queue + BFS class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; // check the input Map&lt;Integer,ArrayList&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; node_queue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; cols = new LinkedList&lt;&gt;(); int leftmost = 0; int rightmost = 0; node_queue.add(root); cols.add(0); while(!node_queue.isEmpty())&#123; TreeNode node = node_queue.poll(); int col = cols.poll(); if(!map.containsKey(col))&#123; map.put(col,new ArrayList&lt;&gt;()); &#125; map.get(col).add(node.val); if(node.left!=null)&#123; node_queue.add(node.left); cols.add(col-1); leftmost = Math.min(leftmost,col-1); &#125; if(node.right!=null)&#123; node_queue.add(node.right); cols.add(col+1); rightmost = Math.max(rightmost,col+1); &#125; &#125; for(int i= leftmost ; i &lt;= rightmost ; i++)&#123; res.add(map.get(i)); &#125; return res; &#125; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"}]},{"title":"Review | Hard | 815. Bus Routes","slug":"815. Bus Routes","date":"2020-08-08T14:27:29.000Z","updated":"2020-08-08T15:24:10.566Z","comments":true,"path":"2020/08/08/815. Bus Routes/","link":"","permalink":"WangHngLeee.github.io/2020/08/08/815. Bus Routes/","excerpt":"815. Bus Routes üîó LeetCode Link Example We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;‚Ä¶ forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example:Input: routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6Output: 2Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Constraints: 1 &lt;= routes.length &lt;= 500. 1 &lt;= routes[i].length &lt;= 10^5. 0 &lt;= routes[i][j] &lt; 10 ^ 6.","text":"815. Bus Routes üîó LeetCode Link Example We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&gt;5-&gt;7-&gt;1-&gt;5-&gt;7-&gt;1-&gt;‚Ä¶ forever. We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible. Example:Input: routes = [[1, 2, 7], [3, 6, 7]]S = 1T = 6Output: 2Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. Constraints: 1 &lt;= routes.length &lt;= 500. 1 &lt;= routes[i].length &lt;= 10^5. 0 &lt;= routes[i][j] &lt; 10 ^ 6. Solution Using BFS. We can think from the other point. Assume in real life, we are at stop 1, and there a several buses can stop here, so we can choose anyone we want. So it‚Äôs simple that we can store the buses and stop in the map, with key of stop and value of buses that stop here. Inorder to prevent the duplicate bus, we can using an array of bus number to check whether the bus has been visited. Then transfer the map into a graph like below. Code class Solution &#123; public int numBusesToDestination(int[][] routes, int S, int T) &#123; int res = 0; if(S == T)return 0; Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;routes.length; i++)&#123; for(int j=0; j&lt;routes[i].length; j++)&#123; List&lt;Integer&gt; buses = map.getOrDefault(routes[i][j],new ArrayList&lt;&gt;()); buses.add(i); map.put(routes[i][j], buses); &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int[] seen = new int[routes.length]; queue.add(S); while(!queue.isEmpty())&#123; int size = queue.size(); res++; for(int i = 0; i&lt;size; i++)&#123; int temp = queue.poll(); List&lt;Integer&gt; buses = map.get(temp); for(int bus : buses)&#123; if(seen[bus] == 1)continue; seen[bus] = 1; for(int k=0; k&lt;routes[bus].length; k++)&#123; if(routes[bus][k] == T)return res; queue.offer(routes[bus][k]); &#125; &#125; &#125; &#125; return -1; &#125;&#125; T: O(M*N) S: O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"}]},{"title":"Review | Hard | 992. Subarrays with K Different Integers","slug":"992. Subarrays with K Different Integers","date":"2020-08-07T22:27:29.000Z","updated":"2020-08-07T23:50:13.935Z","comments":true,"path":"2020/08/07/992. Subarrays with K Different Integers/","link":"","permalink":"WangHngLeee.github.io/2020/08/07/992. Subarrays with K Different Integers/","excerpt":"992. Subarrays with K Different Integers üîó LeetCode Link Example Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A. Example 1: Input: A = [1,2,1,2,3], K = 2Output: 7Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Example 2: Input: A = [1,2,1,3,4], K = 3Output: 3Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= A.length 1 &lt;= K &lt;= A.length","text":"992. Subarrays with K Different Integers üîó LeetCode Link Example Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. (For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.) Return the number of good subarrays of A. Example 1: Input: A = [1,2,1,2,3], K = 2Output: 7Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Example 2: Input: A = [1,2,1,3,4], K = 3Output: 3Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4]. Note: 1 &lt;= A.length &lt;= 20000 1 &lt;= A[i] &lt;= A.length 1 &lt;= K &lt;= A.length Solution It‚Äôs a bit different from previous at most K different/distinct problem. This question need justK different integers. However, it‚Äôs straightforward to prove that Just(K) = AtMost(K) - AtMost(K-1), so we can call the previous kinda code twice and substract them then will get the res. Code class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return help(A,K) - help(A,K-1); &#125; public int help(int[] A, int K)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; int ans = 0; for(int j = 0 ; j &lt; A.length ;j++)&#123; map.put(A[j],map.getOrDefault(A[j],0)+1); while(map.size() &gt; K)&#123; map.put(A[i],map.get(A[i])-1); if(map.get(A[i]) == 0)&#123; map.remove(A[i]); &#125; i++; &#125; ans += j-i+1; &#125; return ans; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 340. Longest Substring with At Most K Distinct Characters","slug":"340. Longest Substring with At Most K Distinct Characters","date":"2020-08-07T19:30:29.000Z","updated":"2020-08-07T23:50:38.324Z","comments":true,"path":"2020/08/07/340. Longest Substring with At Most K Distinct Characters/","link":"","permalink":"WangHngLeee.github.io/2020/08/07/340. Longest Substring with At Most K Distinct Characters/","excerpt":"340. Longest Substring with At Most K Distinct Characters üîó Leetcode Link Examples Given a string, find the length of the longest substring T that contains at most k distinct characters. Example 1: Input: s = &quot;eceba&quot;, k = 2Output: 3Explanation: T is &quot;ece&quot; which its length is 3. Example 2: Input: s = &quot;aa&quot;, k = 1Output: 2Explanation: T is &quot;aa&quot; which its length is 2.","text":"340. Longest Substring with At Most K Distinct Characters üîó Leetcode Link Examples Given a string, find the length of the longest substring T that contains at most k distinct characters. Example 1: Input: s = &quot;eceba&quot;, k = 2Output: 3Explanation: T is &quot;ece&quot; which its length is 3. Example 2: Input: s = &quot;aa&quot;, k = 1Output: 2Explanation: T is &quot;aa&quot; which its length is 2. Solution Typical sliding window question. Using left and right pointer to scan the string, and keep each character‚Äôs frequency in a HashMap. When the size of map ( which is also the total num of distinct characters) is greater than k, we need to substract chars from left. When the map size &lt;= 2, we update the res. This question can share the same code template with question 159. Longest Substring with At Most Two Distinct Characters Code class Solution &#123; public int lengthOfLongestSubstringKDistinct(String s, int k) &#123; //corner case if(s == null || s.length() ==0)return 0; int left = 0; int res = 0; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int right =0; right &lt; s.length(); right++)&#123; char temp = s.charAt(right); map.put(temp, map.getOrDefault(temp,0)+1); while(map.size() &gt; k)&#123; char leftchar = s.charAt(left); if(map.containsKey(leftchar))&#123; map.put(leftchar,map.get(leftchar)-1); if(map.get(leftchar) == 0)&#123; map.remove(leftchar); &#125; &#125; left++; &#125; res = Math.max(res, right - left+1); &#125; return res; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Review | Medium | 3. Longest Substring Without Repeating Characters","slug":"3. Longest Substring Without Repeating Characters","date":"2020-08-07T14:30:29.000Z","updated":"2020-08-07T22:34:24.443Z","comments":true,"path":"2020/08/07/3. Longest Substring Without Repeating Characters/","link":"","permalink":"WangHngLeee.github.io/2020/08/07/3. Longest Substring Without Repeating Characters/","excerpt":"3. Longest Substring Without Repeating Characters üîó Leetcode Link Examples Given a string, find the length of the longest substring without repeating characters. Example 1: Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.","text":"3. Longest Substring Without Repeating Characters üîó Leetcode Link Examples Given a string, find the length of the longest substring without repeating characters. Example 1: Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Solution Using two pointers and HashSet to store the current chars. It set contains current char, it means we have seen this before, then move the left point. Update the max after we add a char to the set. Code class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s == null || s.length() == 0)return 0; int left = 0; int right = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int max = 0; while(left &lt; s.length() &amp;&amp; right &lt;s.length())&#123; if(!set.contains(s.charAt(right)))&#123; set.add(s.charAt(right)); right++; max = Math.max(max,set.size()); &#125;else&#123; set.remove(s.charAt(left)); left++; &#125; &#125; return max; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Review | Medium | 5. Longest Palindromic Substring","slug":"5. Longest Palindromic Substring","date":"2020-08-06T20:30:29.000Z","updated":"2020-08-07T22:27:54.361Z","comments":true,"path":"2020/08/06/5. Longest Palindromic Substring/","link":"","permalink":"WangHngLeee.github.io/2020/08/06/5. Longest Palindromic Substring/","excerpt":"5. Longest Palindromic Substring üîó Leetcode Link Examples Given a string s, find the longest palindromic subsequence‚Äôs length in s. You may assume that the maximum length of s is 1000. Example 1: Input: &quot;bbbab&quot; Output: 4 One possible longest palindromic subsequence is ‚Äúbbbb‚Äù. Example 2: Input: &quot;cbbd&quot; Output: 2 One possible longest palindromic subsequence is ‚Äúbb‚Äù. Constraints: 1 &lt;= s.length &lt;= 1000 s consists only of lowercase English letters.","text":"5. Longest Palindromic Substring üîó Leetcode Link Examples Given a string s, find the longest palindromic subsequence‚Äôs length in s. You may assume that the maximum length of s is 1000. Example 1: Input: &quot;bbbab&quot; Output: 4 One possible longest palindromic subsequence is ‚Äúbbbb‚Äù. Example 2: Input: &quot;cbbd&quot; Output: 2 One possible longest palindromic subsequence is ‚Äúbb‚Äù. Constraints: 1 &lt;= s.length &lt;= 1000 s consists only of lowercase English letters. Solution Two Pointers The first navie solution is using two pointers to scan both 1 chars or 2 chars from itself. Like aabbaabb we can start scaling from a or aa, because palindrome can only form with 1 or 2 chars.( 3 is based on 1). DP It can also be solved by using DP. It‚Äôs a bit like problem 516. Longest Palindromic Subsequence . We expand from inside to outside. The only difference in this question is that : we only keep record of boolean array to see whether dp[i][j] can form a palindrome substring from i to j. Only the situation meet the requirements of following can be a palindrome substring: s.charAt(i) == s.charAt(j): Two chars need to be same. j-i&lt;3: means only 2 or 1 letters in the current range. Like aa or a. dp[i+1][j-1] = true : It means that the smaller range from i+1 to j-1 can form a palindrome, so the current range from i to j can also be true. After updating the current dp state, we need to update the max length of substring and the start point. FInally we just return the substring from start to start + max. Code Two Pointers class Solution &#123; int start, max; public String longestPalindrome(String s) &#123; if(s == null || s.length() == 0)return \"\"; for(int i=0; i&lt;s.length(); i++)&#123; check(s,i,i); check(s,i,i+1); &#125; return s.substring(start,start + max); &#125; private void check(String s, int left, int right)&#123; while( left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; if(right - left &gt; max)&#123; max = right - left - 1; start = left + 1; &#125; &#125;&#125; T:O(N) S:O(N) DP class Solution &#123; public String longestPalindrome(String s) &#123; if(s == null || s.length() == 0)return \"\"; int n = s.length(); boolean[][] dp = new boolean[n][n]; int start = 0, max = 0; for(int i=n-1; i&gt;=0;i--)&#123; for(int j=i; j&lt;n;j++)&#123; dp[i][j] = ( s.charAt(i) == s.charAt(j) &amp;&amp; ( j-i&lt;3 || dp[i+1][j-1] )); if(dp[i][j] &amp;&amp; (j-i+1 &gt; max))&#123; max = j - i + 1; start = i; &#125; &#125; &#125; return s.substring(start, start + max); &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Palindromic","slug":"Palindromic","permalink":"WangHngLeee.github.io/tags/Palindromic/"}]},{"title":"Review | Medium | 516. Longest Palindromic Subsequence","slug":"516. Longest Palindromic Subsequence","date":"2020-08-06T14:30:29.000Z","updated":"2020-08-06T21:40:14.155Z","comments":true,"path":"2020/08/06/516. Longest Palindromic Subsequence/","link":"","permalink":"WangHngLeee.github.io/2020/08/06/516. Longest Palindromic Subsequence/","excerpt":"516. Longest Palindromic Subsequence üîó Leetcode Link Exapmles Given a string s, find the longest palindromic subsequence&apos;s length in s. You may assume that the maximum length of s is 1000.Example 1:Input:&quot;bbbab&quot;Output:4One possible longest palindromic subsequence is &quot;bbbb&quot;. Example 2:Input:&quot;cbbd&quot;Output:2One possible longest palindromic subsequence is &quot;bb&quot;.","text":"516. Longest Palindromic Subsequence üîó Leetcode Link Exapmles Given a string s, find the longest palindromic subsequence&apos;s length in s. You may assume that the maximum length of s is 1000.Example 1:Input:&quot;bbbab&quot;Output:4One possible longest palindromic subsequence is &quot;bbbb&quot;. Example 2:Input:&quot;cbbd&quot;Output:2One possible longest palindromic subsequence is &quot;bb&quot;. Solution It‚Äôs a typical palindromic string problem. When we see subsequence instead of substring, it means it can be interruptted and not continous, and we always using DP to solve that kind of uncontinous problem. We first create a two-dimension DP array to store the length. dp[i][j] means the max palindromic subsequence between start of i and end ofj in the string s Transition Function : When s.charAt(i) == s.charAt(j) : dp[i][j] = dp[i+1][j-1] + 2 It looks like we expand the range of current i+1, j-1 to i,j, which is extremely like two pointers , one with left+1, and one with right-1. Instead, in this problem we solve from inside to outside. When s.charAt(i) != s.charAt(j) : dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]) If ther are not the same, we just choosing the range from left+1,right or left,right-1 because the subsequence can be interuppted. Code class Solution &#123; public int longestPalindromeSubseq(String s) &#123; int n = s.length(); int[][] dp = new int[n+1][n+1]; for(int i = n-1; i&gt;=0; i--)&#123; dp[i][i] = 1; for(int j=i+1; j&lt;n; j++)&#123; if(s.charAt(i) == s.charAt(j))&#123; dp[i][j] = dp[i+1][j-1] +2; &#125;else&#123; dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125; T:O(N^2) S:O(N^2)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Palindromic","slug":"Palindromic","permalink":"WangHngLeee.github.io/tags/Palindromic/"}]},{"title":"Review | Hard | 23. Merge k Sorted Lists","slug":"23. Merge k Sorted Lists","date":"2020-08-04T00:27:29.000Z","updated":"2020-08-04T02:30:15.811Z","comments":true,"path":"2020/08/03/23. Merge k Sorted Lists/","link":"","permalink":"WangHngLeee.github.io/2020/08/03/23. Merge k Sorted Lists/","excerpt":"23. Merge k Sorted Lists üîó LeetCode Link Example Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6","text":"23. Merge k Sorted Lists üîó LeetCode Link Example Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 Solution Using self-design PriorityQueue to store each head of list in the lists. Then loop each head and add their next listnode into the priorityqueue. Finally we can get a sorted linkedlist. Code class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists == null || lists.length == 0)return null; ListNode dummy = new ListNode(0); ListNode head = dummy; PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt; a.val - b.val); for(ListNode list : lists)&#123; if(list != null)&#123; pq.add(list); &#125; &#125; while(!pq.isEmpty())&#123; head.next = pq.poll(); head = head.next; if(head.next!=null)&#123; pq.add(head.next); &#125; &#125; return dummy.next; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"LinkedList","slug":"LinkedList","permalink":"WangHngLeee.github.io/tags/LinkedList/"}]},{"title":"Review | Hard | 4. Median of Two Sorted Arrays","slug":"4. Median of Two Sorted Arrays","date":"2020-08-03T22:27:29.000Z","updated":"2020-08-05T00:03:59.529Z","comments":true,"path":"2020/08/03/4. Median of Two Sorted Arrays/","link":"","permalink":"WangHngLeee.github.io/2020/08/03/4. Median of Two Sorted Arrays/","excerpt":"4. Median of Two Sorted Arrays üîó LeetCode Link Example There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5","text":"4. Median of Two Sorted Arrays üîó LeetCode Link Example There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Solution Brute force The first solution we can come up with is getting two arrays into one and sort the final array, then try to get the middle index number. But it will cost O(nlogn), which doesn‚Äôt meet the time complexity requirement of log(m+n). Apparently, the O(log(n+m)) can be approached only by Binary Search. Binary Search Idea copied from @YaokaiYang In order to solve this question, we need to first understand what a median is. A median is the middle value of a dataset. Since we have 2 seperately sorted array in this question, to find the middle value is somewhat complicated. However, keep in mind that we do not care about the actual value of the numbers, what we want is the middle point from the combination of 2 arrays. In other words, we are looking for the middle index of the 2 arrays. Thus approach like binary search could be employed. Based on the fact that the 2 arrays are sorted seperatedly, we could try to get the submedian of the 2 arrays in each round. Than compare them. And the basic idea is that the left half of the array with a smaller submedian can never contains the common median. if (mid1 &lt; mid2) keep nums1.right + nums2else keep nums1 + nums2.right Code Navie Brute Force class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] arr = new int[m+n]; for(int i = 0 ;i&lt;m ;i++)&#123; arr[i] = nums1[i]; &#125; for(int j = 0 ;j&lt;n;j++)&#123; arr[m+j] = nums2[j]; &#125; Arrays.sort(arr); int k = arr.length; if(k%2 != 0)return (double)arr[k/2]; else return ((double)(arr[(k/2) - 1] + arr[(k/2)])/2); &#125;&#125; T:O(NlogN) S:O(N) Binary Search class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int left = (m + n + 1)/2; int right = (m + n + 2)/2; return (help(nums1,0,nums2,0,left) + help(nums1, 0, nums2, 0, right)) / 2.0; &#125; public int help(int[] nums1, int s1, int[]nums2, int s2, int position)&#123; if( s1 &gt; nums1.length-1)return nums2[s2 + position - 1]; if( s2 &gt; nums2.length-1)return nums1[s1 + position - 1]; if(position == 1) return Math.min(nums1[s1], nums2[s2]); int mid1 = Integer.MAX_VALUE; int mid2 = Integer.MAX_VALUE; if(s1 + position/2 - 1 &lt; nums1.length)mid1 = nums1[s1 + position/2 -1]; if(s2 + position/2 - 1 &lt; nums2.length)mid2 = nums2[s2 + position/2 -1]; if(mid1 &lt; mid2)&#123; return help(nums1,s1 + position/2, nums2, s2, position - position/2); &#125;else&#123; return help(nums1,s1,nums2,s2 + position/2, position - position/2); &#125; &#125;&#125; T:O(log(M+N)) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Easy | 125. Valid Palindrome","slug":"125. Valid Palindrome","date":"2020-08-03T12:30:29.000Z","updated":"2020-08-03T14:07:08.283Z","comments":true,"path":"2020/08/03/125. Valid Palindrome/","link":"","permalink":"WangHngLeee.github.io/2020/08/03/125. Valid Palindrome/","excerpt":"125. Valid Palindrome LeetCode Link Examples Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome‚Ä¶ Example 1:Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueExample 2:Input: &quot;race a car&quot;Output: false","text":"125. Valid Palindrome LeetCode Link Examples Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome‚Ä¶ Example 1:Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueExample 2:Input: &quot;race a car&quot;Output: false Solution Using two pointers to scan the string from start and end. Skip all unletterOrDigit character like ‚Äô ‚Äô and ‚Äò.‚Äô and other signs. Then check two characters is same or not. Code class Solution &#123; public boolean isPalindrome(String s) &#123; if(s == null || s.length() == 0)return true; int left = 0; int right = s.length()-1; while(left &lt;= right)&#123; char l = s.charAt(left); char r = s.charAt(right); if(!Character.isLetterOrDigit(l))&#123; left++; &#125; else if(!Character.isLetterOrDigit(r))&#123; right--; &#125; else&#123; if(Character.toLowerCase(l) != Character.toLowerCase(r))&#123; return false; &#125; left++; right--; &#125; &#125; return true; &#125;&#125; T:O(N) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"}]},{"title":"Review | Easy | 359. Logger Rate Limiter","slug":"359. Logger Rate Limiter","date":"2020-08-02T12:30:29.000Z","updated":"2020-08-03T01:47:19.573Z","comments":true,"path":"2020/08/02/359. Logger Rate Limiter/","link":"","permalink":"WangHngLeee.github.io/2020/08/02/359. Logger Rate Limiter/","excerpt":"359. Logger Rate Limiter LeetCode Link Examples Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds. Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false. It is possible that several messages arrive roughly at the same time. Example: Logger logger = new Logger();// logging string &quot;foo&quot; at timestamp 1logger.shouldPrintMessage(1, &quot;foo&quot;); returns true;// logging string &quot;bar&quot; at timestamp 2logger.shouldPrintMessage(2,&quot;bar&quot;); returns true;// logging string &quot;foo&quot; at timestamp 3logger.shouldPrintMessage(3,&quot;foo&quot;); returns false;// logging string &quot;bar&quot; at timestamp 8logger.shouldPrintMessage(8,&quot;bar&quot;); returns false;","text":"359. Logger Rate Limiter LeetCode Link Examples Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds. Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false. It is possible that several messages arrive roughly at the same time. Example: Logger logger = new Logger();// logging string &quot;foo&quot; at timestamp 1logger.shouldPrintMessage(1, &quot;foo&quot;); returns true;// logging string &quot;bar&quot; at timestamp 2logger.shouldPrintMessage(2,&quot;bar&quot;); returns true;// logging string &quot;foo&quot; at timestamp 3logger.shouldPrintMessage(3,&quot;foo&quot;); returns false;// logging string &quot;bar&quot; at timestamp 8logger.shouldPrintMessage(8,&quot;bar&quot;); returns false; Solution Navie It‚Äôs obvious that we can use a HashMap to store each message‚Äôs timestamp. Each time we meet a previous existed message, we only need check whether current timestamp - map.get(message) &gt; 10, if not return false. Otherwise update the message‚Äôs timestamp and return true. However, using hashmap in some huge date stream can cause memory usage keeps growing, which is a waste of performance. So we have to think a better solution to save memory. Cicular buffer Using Set and bucket array to store at most 10 seconds before. After that we clear the set. Give each timestamp % 10 a new set to store message. Two HashMap starttime record the start time of the newmap. newmap keeps the messages of [starttime, starttime +10); oldmap keeps messages at most 20 seconds before. Code Navie class Logger &#123; Map&lt;String,Integer&gt; map; public Logger() &#123; map = new HashMap&lt;&gt;(); &#125; public boolean shouldPrintMessage(int timestamp, String message) &#123; if(!map.containsKey(message))&#123; map.put(message,timestamp); &#125;else&#123; if(timestamp - map.get(message) &lt; 10)return false; map.put(message,timestamp); &#125; return true; &#125;&#125; T:O(1) S:O(N) Circular buffer class Logger &#123; int[] bucket; Set[] sets; public Logger() &#123; sets = new Set[10]; bucket = new int[10]; for(int i=0; i&lt;sets.length;i++)&#123; sets[i] = new HashSet&lt;&gt;(); &#125; &#125; public boolean shouldPrintMessage(int timestamp, String message) &#123; int index = timestamp % 10; if(timestamp != bucket[index])&#123; sets[index].clear(); bucket[index] = timestamp; &#125; for(int i=0; i&lt;bucket.length; i++)&#123; if(timestamp - bucket[i] &lt; 10)&#123; if(sets[i].contains(message))&#123; return false; &#125; &#125; &#125; sets[index].add(message); return true; &#125;&#125; T:O(1) S:O(N) Two HashMaps class Logger &#123; Map&lt;String, Integer&gt; oldmap; Map&lt;String, Integer&gt; newmap; int startime; public Logger() &#123; oldmap = new HashMap&lt;String, Integer&gt;(); newmap = new HashMap&lt;String, Integer&gt;(); starttime = 0; &#125; public boolean shouldPrintMessage(int timestamp, String message) &#123; if(timestamp &gt;= latest + 20)&#123; // both map need refresh oldmap.clear(); newmap.clear(); starttime = timestamp; &#125;else if(timestamp &gt;= latest + 10)&#123; // refresh new map and assign old map with the value of new map oldmap = new HashMap&lt;&gt;(newmap); newmap.clear(); starttime = timestamp; &#125; if(newmap.containsKey(message)) return false; if(oldmap.containsKey(message))&#123; int last = oldmap.get(message); if(last + 10 &gt; timestamp) return false; &#125; newmap.put(message, timestamp); return true; &#125;&#125; T:O(1) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Design","slug":"Design","permalink":"WangHngLeee.github.io/tags/Design/"}]},{"title":"Review | Easy | 844. Backspace String Compare","slug":"844. Backspace String Compare","date":"2020-07-29T23:30:29.000Z","updated":"2020-07-30T02:47:33.840Z","comments":true,"path":"2020/07/29/844. Backspace String Compare/","link":"","permalink":"WangHngLeee.github.io/2020/07/29/844. Backspace String Compare/","excerpt":"844. Backspace String Compare üîó LeetCode Link Examples Note that after backspacing an empty text, the text will continue empty. Example 1: Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;. Example 2: Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;. Example 3: Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;Output: trueExplanation: Both S and T become &quot;c&quot;.","text":"844. Backspace String Compare üîó LeetCode Link Examples Note that after backspacing an empty text, the text will continue empty. Example 1: Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;. Example 2: Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;. Example 3: Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;Output: trueExplanation: Both S and T become &quot;c&quot;. Solution Navie We can using stack to simulate backspacing option. When we meet # we just pop up the top element in the stack. Finally we only need to compare the two stacks. Backforward Starting from the last element, keep count of the #. If current is #, we increase by 1. Otherwise, if count is larger than 0, it means current char is before # and need to be deleted. If count is equal to 0, we add current char to the res. Optimized - Two pointers with O(1) space Follow up : Can you make up only O(1) space ? Apparently we can only using two pointers to achieve O(1) spce without any other space. Start from both tails, keep record the number of ‚Äò#‚Äô. It will eventually stop at the final char of res. Then we can check the rest of chars to see whether they are the same. If not, we have to check whether they both have been cleaned up with index of -1. Code Navie class Solution&#123; public boolean backspaceCompare(String S, String T) &#123; return help(S).equals(help(T)); &#125; private Stack&lt;Character&gt; help(String str)&#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(int i=0; i&lt;str.length(); i++)&#123; if(str.charAt(i) != '#')stack.push(str.charAt(i)); else if(!stack.isEmpty())&#123; stack.pop(); &#125; &#125; return stack; &#125;&#125; T:O(N) S:O(N) Backforward class Solution &#123; public boolean backspaceCompare(String S, String T) &#123; return help(S).equals(help(T)); &#125; private String help(String s)&#123; int n = s.length(); String res = \"\"; int count = 0; for(int i=n-1; i&gt;=0 ;i--)&#123; char c = s.charAt(i); if(c == '#')count++; else&#123; if(count &gt; 0)count--; else&#123; res+=c; &#125; &#125; &#125; return res; &#125;&#125; T:O(N) S:O(N) Two pointers class Solution &#123; public boolean backspaceCompare(String S, String T) &#123; if(S == null || T == null)return S == T; int m = S.length(); int n = T.length(); int cnt1 = 0, cnt2 = 0; int i = m-1; int j = n-1; while(i&gt;=0 || j&gt;=0)&#123; while(i&gt;=0 &amp;&amp; (S.charAt(i) == '#' || cnt1 &gt; 0))&#123; if(S.charAt(i) == '#')cnt1++; else&#123; cnt1--; &#125; i--; &#125; while(j&gt;=0 &amp;&amp; (T.charAt(j) == '#' || cnt2 &gt; 0))&#123; if(T.charAt(j) == '#')cnt2++; else&#123; cnt2--; &#125; j--; &#125; if( j&gt;=0 &amp;&amp; i&gt;=0 &amp;&amp; S.charAt(i) == T.charAt(j))&#123; j--; i--; &#125; else&#123; return i == -1 &amp;&amp; j == -1; &#125; &#125; return true; &#125;&#125; T:O(N) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"Stack","slug":"Stack","permalink":"WangHngLeee.github.io/tags/Stack/"}]},{"title":"Review | Hard | 683. K Empty Slots","slug":"683. K Empty Slots","date":"2020-07-29T19:27:29.000Z","updated":"2020-07-29T21:43:43.953Z","comments":true,"path":"2020/07/29/683. K Empty Slots/","link":"","permalink":"WangHngLeee.github.io/2020/07/29/683. K Empty Slots/","excerpt":"683. K Empty Slots üîó LeetCode Link Example You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days. You are given an array bulbs of length N where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed. Given an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactly K bulbs between them that are all turned off. If there isn‚Äôt such day, return -1. Example 1:Input:bulbs: [1,3,2]K: 1Output: 2Explanation:On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]We return 2 because on the second day, there were two on bulbs with one off bulb between them.","text":"683. K Empty Slots üîó LeetCode Link Example You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days. You are given an array bulbs of length N where bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position x where i is 0-indexed and x is 1-indexed. Given an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactly K bulbs between them that are all turned off. If there isn‚Äôt such day, return -1. Example 1:Input:bulbs: [1,3,2]K: 1Output: 2Explanation:On the first day: bulbs[0] = 1, first bulb is turned on: [1,0,0]On the second day: bulbs[1] = 3, third bulb is turned on: [1,0,1]On the third day: bulbs[2] = 2, second bulb is turned on: [1,1,1]We return 2 because on the second day, there were two on bulbs with one off bulb between them. Solution TreeSet Using TreeSet to get the higher and lower pos of bulb in the previous. The only requirement is currentDay - lower - 1 == K || higher - currentDay - 1 == K. set.lower(pos) is going to find the first lower element from pos in the set. set.higher(pos) is going to find the first higher element from pos in the set. Straight Forward Checking by date. Create a new array of days to store the open time of each position bulb. The only thing we need to do is keeping a window of size K and check left,right and current bulb‚Äôs open day. If days[left] &lt; currentDay &amp;&amp; days[right] &lt; currentDay, it means both left and right bulb will open before the currentDay. Like ..open - close - open.. , assuming K is 1, meeting the requirement of the question. Code TreeSet class Solution &#123; public int kEmptySlots(int[] bulbs, int k) &#123; int n = bulbs.length; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); for(int day = 1; day&lt;=n; day++)&#123; int pos = bulbs[day-1]; set.add(pos); Integer lower = set.lower(pos); Integer higher = set.higher(pos); if(lower != null &amp;&amp; pos - lower -1 == k)return day; if(higher != null &amp;&amp; higher - pos - 1 == k)return day; &#125; return -1; &#125;&#125; T: O(NlogN) S:O(N) Straight Forward class Solution &#123; public int kEmptySlots(int[] bulbs, int k) &#123; if(bulbs == null || bulbs.length == 0)return -1; int n = bulbs.length; int[] days = new int[n]; for(int i=0; i&lt;n; i++)&#123; days[bulbs[i]-1] = i + 1; &#125; int res = Integer.MAX_VALUE; int left = 0; int right = k + 1; for(int i = 1; right &lt; n; i++)&#123; if(days[i] &gt; days[left] &amp;&amp; days[i] &gt; days[right])&#123; continue; &#125; if( i == right)&#123; res = Math.min(res, Math.max(days[left], days[right])); &#125; left = i; right = left + k + 1; &#125; return res == Integer.MAX_VALUE ? -1 : res; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 1248. Count Number of Nice Subarrays","slug":"1248. Count Number of Nice Subarrays","date":"2020-07-29T13:27:29.000Z","updated":"2020-07-29T15:08:31.889Z","comments":true,"path":"2020/07/29/1248. Count Number of Nice Subarrays/","link":"","permalink":"WangHngLeee.github.io/2020/07/29/1248. Count Number of Nice Subarrays/","excerpt":"1248. Count Number of Nice Subarrays üîó LeetCode Link Examples Given an array of integers nums and an integer k. A subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Example 1:Input: nums = [1,1,2,1,1], k = 3Output: 2Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].Example 2:Input: nums = [2,4,6], k = 1Output: 0Explanation: There is no odd numbers in the array.Example 3:Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2Output: 16","text":"1248. Count Number of Nice Subarrays üîó LeetCode Link Examples Given an array of integers nums and an integer k. A subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Example 1:Input: nums = [1,1,2,1,1], k = 3Output: 2Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].Example 2:Input: nums = [2,4,6], k = 1Output: 0Explanation: There is no odd numbers in the array.Example 3:Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2Output: 16 Solution Navie Solution Apparently using sliding window. Keep the window that matain K odd numbers. Then perform atMost algo, to get the number of subarray with exactly k odd numbers. k = atMost(k) - atMost(k-1) Optimized Solution Based on the sliding window, we record the number of even num and to get all the subarray number. It‚Äôs true that when we add the even number from 0 to max one , then we can get all the possible nums of combination. Code Sliding Window with atMost class Solution&#123; public int numberOfSubarrays(int[] A, int k) &#123; return atMost(A, k) - atMost(A, k - 1); &#125; public int atMost(int[] A, int k) &#123; int res = 0, i = 0, n = A.length; for (int j = 0; j &lt; n; j++) &#123; k -= A[j] % 2; while (k &lt; 0)&#123; k+=A[i] % 2; i++; &#125; res += j - i + 1; &#125; return res; &#125;&#125; T:O(n) S:O(1) Optimized Solution class Solution&#123; public int numberOfSubarrays(int[] A, int k) &#123; int n = A.length; int res = 0,count = 0; for(int start = 0, end = 0; end &lt; n; end++)&#123; if(A[end] % 2 == 1)&#123; k--; count = 0; &#125; while( k == 0)&#123; k+=A[start++]%2; count++; &#125; res+=count; &#125; return res; &#125;&#125; T:O(n) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 1004. Max Consecutive Ones III","slug":"1004. Max Consecutive Ones III","date":"2020-07-28T23:27:29.000Z","updated":"2020-07-29T04:18:59.153Z","comments":true,"path":"2020/07/28/1004. Max Consecutive Ones III/","link":"","permalink":"WangHngLeee.github.io/2020/07/28/1004. Max Consecutive Ones III/","excerpt":"946. Validate Stack Sequences üîó Leetcode Link Example Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. Example 1:Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2Output: 6Explanation:[1,1,1,0,0,1,1,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.Example 2:Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3Output: 10Explanation:[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.","text":"946. Validate Stack Sequences üîó Leetcode Link Example Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. Example 1:Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2Output: 6Explanation:[1,1,1,0,0,1,1,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.Example 2:Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3Output: 10Explanation:[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Solution Using sliding window to maintain just at most K zeros in the window. Code class Solution &#123; public int longestOnes(int[] A, int K) &#123; int res = 0; for(int start = 0, end = 0; end &lt; A.length; end++)&#123; if(A[end] == 0)K--; while(start &lt;= end &amp;&amp; K&lt;0)&#123; if(A[start] == 0)K++; start++; &#125; res = Math.max(res,end - start+1); &#125; return res; &#125;&#125; Actually we can just using if instead of while cause we need the max length of 1s. So we can either matain the same size or increasing the size of window instead decrease it. class Solution &#123; public int longestOnes(int[] A, int K) &#123; int res = 0; for(int start = 0, end = 0; end &lt; A.length; end++)&#123; if(A[end] == 0)K--; if(K&lt;0)&#123; if(A[start] == 0)K++; start++; &#125; res = Math.max(res,end - start+1); &#125; return res; &#125;&#125; T:O(n) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"}]},{"title":"Review | Easy | 234. Palindrome Linked List","slug":"234-Palindrome-Linked-List","date":"2020-07-28T19:30:29.000Z","updated":"2020-07-28T22:43:18.439Z","comments":true,"path":"2020/07/28/234-Palindrome-Linked-List/","link":"","permalink":"WangHngLeee.github.io/2020/07/28/234-Palindrome-Linked-List/","excerpt":"234. Palindrome Linked List LeetCode Link Examples Given a singly linked list, determine if it is a palindrome. Example 1:Input: 1-&gt;2Output: falseExample 2:Input: 1-&gt;2-&gt;2-&gt;1Output: true","text":"234. Palindrome Linked List LeetCode Link Examples Given a singly linked list, determine if it is a palindrome. Example 1:Input: 1-&gt;2Output: falseExample 2:Input: 1-&gt;2-&gt;2-&gt;1Output: true Solution Using two pointers to find the two half of linkedlist, and reverse one of them. Then start comparation one by one. Code class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; if(fast!=null )&#123; slow = slow.next; &#125; slow = reverse(slow); fast = head; while(slow != null &amp;&amp; fast!=null)&#123; if(slow.val != fast.val)return false; slow = slow.next; fast = fast.next; &#125; return true; &#125; private ListNode reverse(ListNode head)&#123; ListNode prev = null; while(head!=null)&#123; ListNode next = head.next; head.next = prev; prev = head; head = next; &#125; return prev; &#125;&#125; T:O(n) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"LinkedList","slug":"LinkedList","permalink":"WangHngLeee.github.io/tags/LinkedList/"}]},{"title":"Review | Easy | 53. Maximum Subarray","slug":"53-Maximum-Subarray","date":"2020-07-28T19:30:29.000Z","updated":"2020-07-28T22:43:27.531Z","comments":true,"path":"2020/07/28/53-Maximum-Subarray/","link":"","permalink":"WangHngLeee.github.io/2020/07/28/53-Maximum-Subarray/","excerpt":"53. Maximum Subarray LeetCode Link Examples Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example:Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Follow Up If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.","text":"53. Maximum Subarray LeetCode Link Examples Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example:Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Follow Up If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Solution Greedy It‚Äôs the first navie solution we can come with. Keep a record of sum and update only when the new sum is positive. Otherwise let current num be the sum value. DP Based on the greedy solution, we can using DP to easily solve it. The basic idea is same. The transition function is dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0). Only add nums[i] to previous sum only when the sum is positive, otherwise only set dp[i] with current nums[i] Divide and Conquer Follow up solution. Just divide array into left and right part, and caculate another left and right parts of each part. Then reutrn the sum. If leftsum is bigger than both rightsum and crosssum, just return it. Same as rightsum and crosssum. Code Greedy class Solution &#123; public int maxSubArray(int[] nums)&#123; int max = Integer.MIN_VALUE; int sum = 0; for(int num : nums)&#123; if(sum &lt; 0)&#123; sum = num; &#125;else&#123; sum+=num; &#125; max = Math.max(sum,max); &#125; return max; &#125;&#125; T:O(n) S:O(1) DP class Solution &#123; public int maxSubArray(int[] nums)&#123; int[] dp = new int[nums.length+1]; dp[0] = nums[0]; int max = dp[0]; for(int i=1; i&lt;nums.length; i++)&#123; dp[i] = nums[i] + (dp[i-1] &gt; 0 ? dp[i-1] : 0); max = Math.max(max, dp[i]); &#125; return max; &#125;&#125; T:O(n) S:O(n) Divide and Conquer class Solution &#123; public int maxSubArray(int[] nums)&#123; int maxsum = subArray(nums, 0, nums.length-1); return maxsum; &#125; private int subArray(int[] A, int left, int right)&#123; if (left == right)&#123; //base case return A[left]; &#125; int mid = left + (right-left)/2; int leftsum = subArray(A, left, mid); //left part of the subarray sum, condition 1 int rightsum = subArray(A, mid+1, right); //right part of the subarray sum, condition 2 int middlesum = midSubArray(A, left, mid, right); //cross part of the subarray sum, condition 3 if (leftsum &gt;= rightsum &amp;&amp; leftsum &gt;= middlesum)&#123; return leftsum; &#125; if (rightsum &gt;= leftsum &amp;&amp; rightsum &gt;= middlesum)&#123; return rightsum; &#125; return middlesum; &#125; private int midSubArray(int[] A, int left, int mid, int right)&#123; int leftsum = Integer.MIN_VALUE; int rightsum = Integer.MIN_VALUE; int sum = 0; for (int i = mid; i &gt;= left; i--)&#123; sum += A[i]; if (sum &gt; leftsum)&#123; leftsum = sum; &#125; &#125; sum = 0; for (int j = mid + 1; j &lt;= right; j++)&#123; sum += A[j]; if (sum &gt; rightsum)&#123; rightsum = sum; &#125; &#125; return leftsum + rightsum; &#125;&#125; T:O(nlogn) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Hard | 1153. String Transforms Into Another String","slug":"1153. String Transforms Into Another String","date":"2020-07-27T23:27:29.000Z","updated":"2020-07-28T02:32:13.941Z","comments":true,"path":"2020/07/27/1153. String Transforms Into Another String/","link":"","permalink":"WangHngLeee.github.io/2020/07/27/1153. String Transforms Into Another String/","excerpt":"1153. String Transforms Into Another String üîó Question Link Examples Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions. In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character. Return true if and only if you can transform str1 into str2. Example 1:Input: str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot;Output: trueExplanation: Convert &apos;c&apos; to &apos;e&apos; then &apos;b&apos; to &apos;d&apos; then &apos;a&apos; to &apos;c&apos;. Note that the order of conversions matter.Example 2:Input: str1 = &quot;leetcode&quot;, str2 = &quot;codeleet&quot;Output: falseExplanation: There is no way to transform str1 to str2.","text":"1153. String Transforms Into Another String üîó Question Link Examples Given two strings str1 and str2 of the same length, determine whether you can transform str1 into str2 by doing zero or more conversions. In one conversion you can convert all occurrences of one character in str1 to any other lowercase English character. Return true if and only if you can transform str1 into str2. Example 1:Input: str1 = &quot;aabcc&quot;, str2 = &quot;ccdee&quot;Output: trueExplanation: Convert &apos;c&apos; to &apos;e&apos; then &apos;b&apos; to &apos;d&apos; then &apos;a&apos; to &apos;c&apos;. Note that the order of conversions matter.Example 2:Input: str1 = &quot;leetcode&quot;, str2 = &quot;codeleet&quot;Output: falseExplanation: There is no way to transform str1 to str2. Solution Tricky Part We can use HashMap to store the link of chars. For example, a -&gt; b, b-&gt;c , c-&gt;d So each time when we scan from both str1 and str2, we check the str2 character with the one stored in map of str1, if it non exist then set default one with str2‚Äô char. Otherwise, if they are different, like the link in map is a-&gt;c but the reality is a-&gt;d then return false, because one character can‚Äôt transform to two different chars at same time. Special/Edge case : First case is two string are equal then we return true. Second one is like the unique chars of both strs are same and have 26 chars. But in order to transform one to another we need a temp char that is unused, like temp -&gt; a, a -&gt; b , b-&gt; c , c-&gt; temp. Same as swap two number in array. So in this case we can‚Äôt perform the transformation, because there is just 26 chars and no more for us to mark as temp, so just return false. Code class Solution &#123; public boolean canConvert(String str1, String str2) &#123; HashMap&lt;Character,Character&gt; map = new HashMap&lt;&gt;(); if(str1.equals(str2))return true; if(str1 == null || str1.length() == 0)return true; for(int i=0; i&lt;str1.length(); i++)&#123; if(map.getOrDefault(str1.charAt(i), str2.charAt(i)) != str2.charAt(i))&#123; return false; &#125; map.put(str1.charAt(i),str2.charAt(i)); &#125; Set&lt;Character&gt; set = new HashSet&lt;&gt;(map.values()); return set.size() &lt; 26; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Review | Medium | 785. Is Graph Bipartite","slug":"785. Is Graph Bipartite","date":"2020-07-27T22:30:29.000Z","updated":"2020-07-29T21:34:21.559Z","comments":true,"path":"2020/07/27/785. Is Graph Bipartite/","link":"","permalink":"WangHngLeee.github.io/2020/07/27/785. Is Graph Bipartite/","excerpt":"785. Is Graph Bipartite üîó Leetcode Link Examples Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it‚Äôs set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn‚Äôt contain any element twice. Example 1:Input: [[1,3], [0,2], [1,3], [0,2]]Output: trueExplanation:The graph looks like this:0----1| || |3----2We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.Example 2:Input: [[1,2,3], [0,2], [0,1,3], [0,2]]Output: falseExplanation:The graph looks like this:0----1| \\ || \\ |3----2We cannot find a way to divide the set of nodes into two independent subsets.","text":"785. Is Graph Bipartite üîó Leetcode Link Examples Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it‚Äôs set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn‚Äôt contain any element twice. Example 1:Input: [[1,3], [0,2], [1,3], [0,2]]Output: trueExplanation:The graph looks like this:0----1| || |3----2We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.Example 2:Input: [[1,2,3], [0,2], [0,1,3], [0,2]]Output: falseExplanation:The graph looks like this:0----1| \\ || \\ |3----2We cannot find a way to divide the set of nodes into two independent subsets. Soluiton We can use both DFS and BFS to check whether a node is both current and neighboor. The main idea is using two different state to mark the current node and its all neighboors. If any neighboor has been already marked, just check that neighboor‚Äôs state equals to the target color or not, which is also the next color that we want to color the neighboor. It‚Äôs kinda like loop each level, but mark each level with different color like black -1 or white 1, which is repeatedly. Code DFS class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if(graph == null || graph.length == 0)return false; int m = graph.length; int[] color = new int[m]; for(int i=0; i&lt;m; i++)&#123; if(color[i] == 0 &amp;&amp; !DFS(graph,color,1,i))&#123; return false; &#125; &#125; return true; &#125; public boolean DFS(int[][] graph, int[] color, int target_color, int i)&#123; if(color[i] != 0)&#123; return color[i] == target_color; &#125; color[i] = target_color; for(int num : graph[i])&#123; if(!DFS(graph,color,-target_color,num))&#123; return false; &#125; &#125; return true; &#125;&#125; BFS class Solution &#123; public boolean isBipartite(int[][] graph) &#123; if(graph == null || graph.length == 0)return false; int m = graph.length; int[] color = new int[m]; for(int i=0; i&lt;m; i++)&#123; if(color[i] != 0)continue; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(i); color[i] = 1; while(!queue.isEmpty())&#123; int temp = queue.poll(); for(int next : graph[temp])&#123; if(color[next] == 0)&#123; queue.add(next); color[next] = -color[temp]; &#125;else if(color[next] != -color[temp])&#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Medium | 209. Minimum Size Subarray Sum","slug":"209. Minimum Size Subarray Sum","date":"2020-07-25T22:30:29.000Z","updated":"2020-07-26T04:30:03.151Z","comments":true,"path":"2020/07/25/209. Minimum Size Subarray Sum/","link":"","permalink":"WangHngLeee.github.io/2020/07/25/209. Minimum Size Subarray Sum/","excerpt":"209. Minimum Size Subarray Sum üîó Leetcode Link Example Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ‚â• s. If there isn‚Äôt one, return 0 instead. Example:Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint.Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).","text":"209. Minimum Size Subarray Sum üîó Leetcode Link Example Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ‚â• s. If there isn‚Äôt one, return 0 instead. Example:Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint.Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). Solution Two pointers + Sliding window Since the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don‚Äôt have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices. Binary search + Presum array Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search. Code Two pointers class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0)return 0; int len = nums.length; int start = 0, end = 0; int sum = 0; int res = Integer.MAX_VALUE; while(end &lt; len)&#123; sum+=nums[end]; while(start &lt;= end &amp;&amp; sum&gt;= s)&#123; sum-=nums[start]; res = Math.min(res, end - start + 1); start++; &#125; end++; &#125; return res == Integer.MAX_VALUE ? 0 : res; &#125;&#125; T:O(n) S:O(1) Binary Search class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int n = nums.length; int[] preSum = new int[n + 1]; for (int i = 1; i &lt;= n; i++) preSum[i] = preSum[i - 1] + nums[i - 1]; int res = n + 1; for (int i = 0; i &lt; n; i++) &#123; // preSum[i] for i in [0, n-1], preSum[j] for j in [i+1, n] int j = binarySearch(i + 1, n + 1 , preSum, s + preSum[i]); if (j != -1) &#123; res = Math.min(res, j - i); &#125; &#125; return res == n + 1 ? 0 : res; &#125; private int binarySearch(int low, int high, int[] preSum, int key) &#123; int l = low, r = high; while (l &lt; r) &#123; int mid = l + (r - l) / 2; if (preSum[mid] &gt;= key) &#123; r = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return l == high ? -1 : l; &#125;&#125; T:O(nlogn) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Hard | 269. Alien Dictionary","slug":"269. Alien Dictionary","date":"2020-07-25T22:27:29.000Z","updated":"2020-07-26T04:29:08.519Z","comments":true,"path":"2020/07/25/269. Alien Dictionary/","link":"","permalink":"WangHngLeee.github.io/2020/07/25/269. Alien Dictionary/","excerpt":"269. Alien Dictionary üîó Question Link Example There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. Example 1:Input:[ &quot;wrt&quot;, &quot;wrf&quot;, &quot;er&quot;, &quot;ett&quot;, &quot;rftt&quot;]Output: &quot;wertf&quot;","text":"269. Alien Dictionary üîó Question Link Example There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. Example 1:Input:[ &quot;wrt&quot;, &quot;wrf&quot;, &quot;er&quot;, &quot;ett&quot;, &quot;rftt&quot;]Output: &quot;wertf&quot; Solution It‚Äôs simple to come up with DFS and BFS solutions. DFS We can build a graph of connectin characters and make a topological sort using DFS. We can define different state of a character during DFS. state[i] = -1 : Not even exist. state[i] = 0 : Exist. Non-visited. state[i] = 1 : Visiting. state[i] = 2 : Visited. BFS We can using solution like indegree sorting to create a indegree of each character. And also create a set of other characters that ranks after current character. Eg: wrf -&gt; w : r Edge case consideration In the new test cases ,there exist some cases like 'abc', 'ab',which will occur ERROR when we using original code. So we have to add some code to return this case with ‚Äú‚Äù. Only thing we need to do is just compare the two adjcent string to check whether the first one can be made up with the whole next one. Code DFS class Solution&#123;// private final int N = 26; StringBuilder sb = new StringBuilder(); boolean[][] cnt = new boolean[26][26]; int[] state = new int[26]; public String alienOrder(String[] words) &#123; if(words == null || words.length == 0)return \"\"; if(!build(words))return \"\"; for(int i=0; i&lt;26;i++)&#123; if(state[i]==0)&#123; if(!dfs(words,i))return\"\"; &#125; &#125; return sb.reverse().toString(); &#125; public boolean dfs(String[] words, int i)&#123; state[i] = 1; // visiting for(int j=0; j&lt;26;j++)&#123; if(cnt[i][j])&#123; if(state[j] == 1)return false; if(state[j] == 0)&#123; if(!dfs(words,j))&#123; return false; &#125; &#125; &#125; &#125; state[i] = 2; sb.append((char)(i+'a')); return true; &#125; public boolean build(String[] words)&#123; Arrays.fill(state,-1); for(int i=0; i&lt;words.length; i++)&#123; for(char c : words[i].toCharArray())&#123; state[c-'a'] = 0; if(i&gt;0)&#123; String w1 = words[i-1]; String w2 = words[i]; int len = Math.min(w1.length(), w2.length()); for(int k=0; k&lt;len; k++)&#123; char c1 = w1.charAt(k); char c2 = w2.charAt(k); if(c1 != c2)&#123; cnt[c1-'a'][c2-'a'] = true; break; &#125; if(w1.length() &gt; w2.length() &amp;&amp; w1.substring(0,len).equals(w2.substring(0,len)))&#123; return false; &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125; BFS class Solution &#123; public String alienOrder(String[] words) &#123; Map&lt;Character, Set&lt;Character&gt;&gt; map=new HashMap&lt;Character, Set&lt;Character&gt;&gt;(); Map&lt;Character, Integer&gt; degree=new HashMap&lt;Character, Integer&gt;(); String result=\"\"; if(words==null || words.length==0) return result; for(String s: words)&#123; for(char c: s.toCharArray())&#123; degree.put(c,0); &#125; &#125; for(int i=0; i&lt;words.length-1; i++)&#123; String cur=words[i]; String next=words[i+1]; if (cur.length() &gt; next.length() &amp;&amp; cur.startsWith(next)) &#123; return \"\"; &#125; int length=Math.min(cur.length(), next.length()); for(int j=0; j&lt;length; j++)&#123; char c1=cur.charAt(j); char c2=next.charAt(j); if(c1!=c2)&#123; Set&lt;Character&gt; set=new HashSet&lt;Character&gt;(); if(map.containsKey(c1)) set=map.get(c1); if(!set.contains(c2))&#123; set.add(c2); map.put(c1, set); degree.put(c2, degree.get(c2)+1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; q=new LinkedList&lt;Character&gt;(); for(char c: degree.keySet())&#123; if(degree.get(c)==0) q.add(c); &#125; while(!q.isEmpty())&#123; char c=q.remove(); result+=c; if(map.containsKey(c))&#123; for(char c2: map.get(c))&#123; degree.put(c2,degree.get(c2)-1); if(degree.get(c2)==0) q.add(c2); &#125; &#125; &#125; if(result.length()!=degree.size()) return \"\"; return result; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Medium | 138. Copy List with Random Pointer","slug":"138. Copy List with Random Pointer","date":"2020-07-23T22:30:29.000Z","updated":"2020-07-28T02:32:17.458Z","comments":true,"path":"2020/07/23/138. Copy List with Random Pointer/","link":"","permalink":"WangHngLeee.github.io/2020/07/23/138. Copy List with Random Pointer/","excerpt":"138. Copy List with Random Pointer üîó Leetcode Link üîó Leetcode-CN Link Example A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node. Example 1:Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]","text":"138. Copy List with Random Pointer üîó Leetcode Link üîó Leetcode-CN Link Example A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val: an integer representing Node.val random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node. Example 1:Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]] Solution Easy to come up with HashMap solution. Keep record of the node and it‚Äôs new copied one. And assign each next and ramdon to the copied one. Code class Solution &#123; public Node copyRandomList(Node head) &#123; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node node = head; while(node!=null)&#123; map.put(node, new Node(node.val)); node = node.next; &#125; node = head; while(node!=null)&#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head); &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"LinkedList","slug":"LinkedList","permalink":"WangHngLeee.github.io/tags/LinkedList/"}]},{"title":"Review | Medium | 426. Convert Binary Search Tree to Sorted Doubly Linked List","slug":"426. Convert Binary Search Tree to Sorted Doubly Linked List","date":"2020-07-23T22:30:29.000Z","updated":"2020-07-24T04:02:41.178Z","comments":true,"path":"2020/07/23/426. Convert Binary Search Tree to Sorted Doubly Linked List/","link":"","permalink":"WangHngLeee.github.io/2020/07/23/426. Convert Binary Search Tree to Sorted Doubly Linked List/","excerpt":"426. Convert Binary Search Tree to Sorted Doubly Linked List üîó Leetcode Link üîó Leetcode-CN Link Example Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. Example 1:Input: root = [4,2,5,1,3] Output: [1,2,3,4,5] Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.","text":"426. Convert Binary Search Tree to Sorted Doubly Linked List üîó Leetcode Link üîó Leetcode-CN Link Example Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place. You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element. We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list. Example 1:Input: root = [4,2,5,1,3] Output: [1,2,3,4,5] Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship. Solution Using the benifit of inorder to traverse the tree. As we all know that inorder is an assending array. So we can using DFS to inorder traverse the whole tree. Hence during the middle line code, all we need to do is linking the nodes and reassign the new node to the variables. Code class Solution &#123; Node pre = null, head = null; public Node treeToDoublyList(Node root) &#123; if(root == null)return null; dfs(root); pre.right = head; // link the pre.right to the head head.left = pre; // link the head.left to the pre. In order to make the listnode cycled. return head; &#125; public void dfs(Node cur)&#123; if(cur == null)return; dfs(cur.left); if(pre == null)head = cur; // pre is used to store the left node of cur. If pre is null, it means cur has no node in the left, so the head should be cur. else&#123; pre.right = cur; // otherwise we link pre node to cur using pre.right = cur like `pre-&gt;cur`; &#125; cur.left = pre; // linking pre to the cur node like `pre&lt;-cur` (We have link those two before from `pre-&gt;cur`) pre = cur; // updating the value of pre and keeping dfs. dfs(cur.right); &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"LinkedList","slug":"LinkedList","permalink":"WangHngLeee.github.io/tags/LinkedList/"},{"name":"BST","slug":"BST","permalink":"WangHngLeee.github.io/tags/BST/"}]},{"title":"Review | Hard | 297. Serialize and Deserialize Binary Tree","slug":"297. Serialize and Deserialize Binary Tree","date":"2020-07-23T22:27:29.000Z","updated":"2020-07-24T04:02:52.965Z","comments":true,"path":"2020/07/23/297. Serialize and Deserialize Binary Tree/","link":"","permalink":"WangHngLeee.github.io/2020/07/23/297. Serialize and Deserialize Binary Tree/","excerpt":"297. Serialize and Deserialize Binary Tree üîó Leetcode Link üîó Leetcode-CN Link Example Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5as &quot;[1,2,3,null,null,4,5]&quot; Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.","text":"297. Serialize and Deserialize Binary Tree üîó Leetcode Link üîó Leetcode-CN Link Example Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5as &quot;[1,2,3,null,null,4,5]&quot; Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Solution Serialize: Using stringbuilder to take tree into a string split with &quot; &quot; using preorder + dfs. Deserialize: Using the result from serialize to form a new tree preorderly. Code public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder res = new StringBuilder(); serial(root,res); return res.toString(); &#125; public void serial(TreeNode root, StringBuilder res)&#123; if(root == null)res.append(\"null\").append(\" \"); else&#123; res.append(root.val).append(\" \"); serial(root.left,res); serial(root.right,res); &#125; &#125; public TreeNode deserialize(String source)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = source.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return des(queue); &#125; public TreeNode des(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"null\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = des(queue); node.right = des(queue); return node; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Review | Medium | 113. Path Sum II","slug":"113. Path Sum II","date":"2020-07-22T22:30:29.000Z","updated":"2020-07-24T04:02:57.433Z","comments":true,"path":"2020/07/22/113. Path Sum II/","link":"","permalink":"WangHngLeee.github.io/2020/07/22/113. Path Sum II/","excerpt":"113. Path Sum II üîó Leetcode Link üîó Leetcode-CN Link Example Given a binary tree and a sum, find all root-to-leaf paths where each path‚Äôs sum equals the given sum. Note: A leaf is a node with no children. Example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1Return:[ [5,4,11,2], [5,8,4,5]]","text":"113. Path Sum II üîó Leetcode Link üîó Leetcode-CN Link Example Given a binary tree and a sum, find all root-to-leaf paths where each path‚Äôs sum equals the given sum. Note: A leaf is a node with no children. Example:Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1Return:[ [5,4,11,2], [5,8,4,5]] Solution It‚Äôs simple and clear we have to use DFS + backtracking to get all the possible paths. Code class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res,sum,templist); return res; &#125; public void help(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int sum, List&lt;Integer&gt; templist)&#123; if(root == null)return; templist.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123; res.add(new ArrayList&lt;&gt;(templist)); &#125; help(root.left,res,sum - root.val, templist); help(root.right,res,sum-root.val, templist); templist.remove(templist.size() -1); &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 255. Verify Preorder Sequence in Binary Search Tree","slug":"255. Verify Preorder Sequence in Binary Search Tree","date":"2020-07-22T22:30:29.000Z","updated":"2020-07-24T04:02:54.736Z","comments":true,"path":"2020/07/22/255. Verify Preorder Sequence in Binary Search Tree/","link":"","permalink":"WangHngLeee.github.io/2020/07/22/255. Verify Preorder Sequence in Binary Search Tree/","excerpt":"255. Verify Preorder Sequence in Binary Search Tree üîó Leetcode Link üîó Leetcode-CN Link Example Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree. You may assume each number in the sequence is unique. Consider the following binary search tree: 5 / \\ 2 6 / \\1 3 Example 1:Input: [5,2,6,1,3]Output: falseExample 2:Input: [5,2,1,3,6]Output: true","text":"255. Verify Preorder Sequence in Binary Search Tree üîó Leetcode Link üîó Leetcode-CN Link Example Given an array of numbers, verify whether it is the correct preorder traversal sequence of a binary search tree. You may assume each number in the sequence is unique. Consider the following binary search tree: 5 / \\ 2 6 / \\1 3 Example 1:Input: [5,2,6,1,3]Output: falseExample 2:Input: [5,2,1,3,6]Output: true Solution Using DFS and loop the whole array to find the bigger index, then dfs the left and right part. Using stack to iterate the tree. When current node is bigger than the peek in the stack, let low equal to the popped one, until the peek is greater than current node. Code DFS class Solution&#123; public boolean verifyPreorder(int[] preorder) &#123; if(preorder == null || preorder.length == 0) return true; return help(preorder, 0, preorder.length - 1); &#125; public boolean help(int[] a, int start, int end) &#123; if(start &gt;= end) return true; int temp = a[start]; int max = -1; for(int i = start + 1; i &lt;= end; i++) &#123; if(max == -1 &amp;&amp; a[i] &gt; temp) max = i; if(max != -1 &amp;&amp; a[i] &lt; temp) return false; &#125; if(bigger == -1) &#123; return help(a, start + 1, end); &#125; else &#123; return help(a, start + 1, max - 1) &amp;&amp; help(a, max, end); &#125; &#125;&#125; Stack class Solution&#123; public boolean verifyPreorder(int[] preorder) &#123; int low = Integer.MIN_VALUE; Stack&lt;Integer&gt; path = new Stack(); for (int p : preorder) &#123; if (p &lt; low) return false; while (!path.empty() &amp;&amp; p &gt; path.peek()) low = path.pop(); path.push(p); &#125; return true; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 946. Validate Stack Sequences","slug":"946. Validate Stack Sequences","date":"2020-07-22T22:30:29.000Z","updated":"2020-07-24T04:02:43.229Z","comments":true,"path":"2020/07/22/946. Validate Stack Sequences/","link":"","permalink":"WangHngLeee.github.io/2020/07/22/946. Validate Stack Sequences/","excerpt":"946. Validate Stack Sequences üîó Leetcode Link üîó Leetcode-CN Link Example Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1:Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1Example 2:Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: false","text":"946. Validate Stack Sequences üîó Leetcode Link üîó Leetcode-CN Link Example Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. Example 1:Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]Output: trueExplanation: We might do the following sequence:push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1Example 2:Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]Output: false Solution We can solve this by simulating a real stack. We first Loop through the pushed array, keep pushing pushed elements into stack if the top element on the stack is different from the current one of popped; Keep poping out of the top element from stack if it is same as the current one of popped; Check if the stack is empty after loop. Code class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int idx = 0; for(int num : pushed)&#123; stack.push(num); while(!stack.isEmpty() &amp;&amp; idx &lt; popped.length &amp;&amp; stack.peek() == popped[idx])&#123; stack.pop(); idx++; &#125; &#125; return idx == popped.length; &#125;&#125; T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 79. Word Search","slug":"79. Word Search","date":"2020-07-21T22:30:29.000Z","updated":"2020-07-24T04:02:58.561Z","comments":true,"path":"2020/07/21/79. Word Search/","link":"","permalink":"WangHngLeee.github.io/2020/07/21/79. Word Search/","excerpt":"341. Flatten Nested List Iterator üîó Leetcode Link üîó Leetcode-CN Link Examples Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where ‚Äúadjacent‚Äù cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.","text":"341. Flatten Nested List Iterator üîó Leetcode Link üîó Leetcode-CN Link Examples Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where ‚Äúadjacent‚Äù cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. Solution Clearly we can using DFS and Backtracking to find the matched path in four different directions. Temperaily changing borad[i][j] to '#' before next DFS. Code class Solution &#123; int m,n; public boolean exist(char[][] board, String word) &#123; if(word == null || word.length() == 0)return false; m = board.length; n = board[0].length; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(dfs(board,word,i,j,0))&#123; return true; &#125; &#125; &#125; return false; &#125; public boolean dfs(char[][] board, String word, int i, int j, int start)&#123; if(start == word.length())return true; if( i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || board[i][j] != word.charAt(start))return false; board[i][j] = '#'; boolean res = dfs(board,word,i+1,j,start+1)|| dfs(board,word,i-1,j,start+1)|| dfs(board,word,i,j+1,start+1)|| dfs(board,word,i,j-1,start+1); board[i][j] = word.charAt(start); return res; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Medium | 341. Flatten Nested List Iterator","slug":"341. Flatten Nested List Iterator","date":"2020-07-20T22:30:29.000Z","updated":"2020-07-24T04:02:48.745Z","comments":true,"path":"2020/07/20/341. Flatten Nested List Iterator/","link":"","permalink":"WangHngLeee.github.io/2020/07/20/341. Flatten Nested List Iterator/","excerpt":"341. Flatten Nested List Iterator üîó Question Link Examples Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list ‚Äì whose elements may also be integers or other lists. Example 1:Input: [[1,1],2,[1,1]]Output: [1,1,2,1,1]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].Example 2:Input: [1,[4,[6]]]Output: [1,4,6]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].","text":"341. Flatten Nested List Iterator üîó Question Link Examples Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list ‚Äì whose elements may also be integers or other lists. Example 1:Input: [[1,1],2,[1,1]]Output: [1,1,2,1,1]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].Example 2:Input: [1,[4,[6]]]Output: [1,4,6]Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Solution Typical flatten array question. We can using stack to add each part from right to left, in order to keep the leftmost at the top of stack. In hasNext() we have to check the peek, if the peek is integer then we just return true. If not it means it‚Äôa nestedList so we have to flatten it and push back to the stack. Code public class NestedIterator implements Iterator&lt;Integer&gt; &#123; Stack&lt;NestedInteger&gt; stack; public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; stack = new Stack&lt;&gt;(); help(nestedList); &#125; @Override public Integer next() &#123; return hasNext() ? stack.pop().getInteger() : null; &#125; @Override public boolean hasNext() &#123; while(!stack.isEmpty())&#123; if(stack.peek().isInteger())return true; help(stack.pop().getList()); &#125; return false; &#125; public void help(List&lt;NestedInteger&gt; list)&#123; for(int i=list.size()-1; i&gt;=0; i--)&#123; stack.push(list.get(i)); &#125; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"Design","slug":"Design","permalink":"WangHngLeee.github.io/tags/Design/"}]},{"title":"Review | Easy | 346. Moving Average from Data Stream","slug":"346. Moving Average from Data Stream","date":"2020-07-20T22:30:29.000Z","updated":"2020-07-24T04:02:45.515Z","comments":true,"path":"2020/07/20/346. Moving Average from Data Stream/","link":"","permalink":"WangHngLeee.github.io/2020/07/20/346. Moving Average from Data Stream/","excerpt":"346. Moving Average from Data Stream üîó Question Link Examples Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Example:MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3","text":"346. Moving Average from Data Stream üîó Question Link Examples Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Example:MovingAverage m = new MovingAverage(3);m.next(1) = 1m.next(10) = (1 + 10) / 2m.next(3) = (1 + 10 + 3) / 3m.next(5) = (10 + 3 + 5) / 3 Solution Simple question that we can using circular queue to solve it. When the queue reach size then we poll one element and substract it from the sum. Code class MovingAverage &#123; Queue&lt;Integer&gt; queue; double sum; int s; /** Initialize your data structure here. */ public MovingAverage(int size) &#123; queue = new LinkedList&lt;&gt;(); s = size; &#125; public double next(int val) &#123; if(queue.size() == s)&#123; sum-=queue.poll(); &#125; queue.add(val); sum+=val; return sum/queue.size(); &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"Design","slug":"Design","permalink":"WangHngLeee.github.io/tags/Design/"}]},{"title":"Review | Easy | 350. Intersection of Two Arrays II","slug":"350. Intersection of Two Arrays II","date":"2020-07-20T22:30:29.000Z","updated":"2020-07-28T19:40:15.658Z","comments":true,"path":"2020/07/20/350. Intersection of Two Arrays II/","link":"","permalink":"WangHngLeee.github.io/2020/07/20/350. Intersection of Two Arrays II/","excerpt":"350. Intersection of Two Arrays II üîóQuestion Link Examples Given two arrays, write a function to compute their intersection. Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]","text":"350. Intersection of Two Arrays II üîóQuestion Link Examples Given two arrays, write a function to compute their intersection. Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9] Solution We can using one hashmap to store each number‚Äôs frequency in the nums1 array. Then make a loop in nums2. If the num in nums2 exist in map and it‚Äôs frequency is bigger than 0 then add it to res. Code class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums1)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int num : nums2)&#123; if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0)&#123; res.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] ans = new int[res.size()]; int index = 0; for(int i=0; i&lt;res.size(); i++)&#123; ans[index++]=res.get(i); &#125; return ans; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Review | Medium | 802. Find Eventual Safe States","slug":"802. Find Eventual Safe States","date":"2020-07-20T22:30:29.000Z","updated":"2020-07-24T04:02:41.987Z","comments":true,"path":"2020/07/20/802. Find Eventual Safe States/","link":"","permalink":"WangHngLeee.github.io/2020/07/20/802. Find Eventual Safe States/","excerpt":"802. Find Eventual Safe States üîó Question Link Examples In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe? Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ‚Ä¶, N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example:Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]Output: [2,4,5,6]Here is a diagram of the above graph.","text":"802. Find Eventual Safe States üîó Question Link Examples In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe? Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ‚Ä¶, N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example:Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]Output: [2,4,5,6]Here is a diagram of the above graph. Solution 1. Topological + DFS We can use Topological sort and DFS to get the circle. Using seen[] to keep record of each node‚Äôs state in the looping. Three different states: 0 means unvisited unsafe 1 means visiting unsafe 2 means visited safe We only need to add the node that has state == 2, which is the safe state. 2. Topologial + BFS degree solution Originally we using BFS to find a circle in an indegree array. In this question we have to loop from the end point, so we need to reverse the whole graph to a indegree array. Then we just add the node with degree of 0 into the res array. Code Topological + DFS class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(graph == null || graph.length == 0)return res; int[] state = new int[graph.length]; for(int i=0; i&lt;graph.length; i++)&#123; if(dfs(graph,i,state))&#123; res.add(i); &#125; &#125; return res; &#125; public boolean dfs(int[][] graph, int node, int[] state)&#123; if(state[node] !=0 )return state[node] == 2; state[node] = 1; for(int num : graph[node])&#123; if(!dfs(graph,num,state))&#123; return false; &#125; &#125; state[node] = 2; return true; &#125;&#125; T:O(V+E) S:O(V) Topological + BFS + Reverse Graph class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; int n = graph.length; List&lt;Integer&gt;[] map = new List[n]; for(int i=0; i&lt;n; i++)&#123; map[i] = new ArrayList&lt;&gt;(); &#125; int[] indegree = new int[n]; for(int i=0; i&lt;n; i++)&#123; for(int num : graph[i])&#123; map[num].add(i); indegree[i]++; &#125; &#125; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0; i&lt;n; i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while(!queue.isEmpty())&#123; int node = queue.poll(); res.add(node); for(int num : map[node])&#123; indegree[num]--; if(indegree[num] == 0)&#123; queue.add(num); &#125; &#125; &#125; Collections.sort(res); return res; &#125;&#125; T:O(V+E) S:O(V)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Medium | 351. Android Unlock Patterns","slug":"351. Android Unlock Patterns","date":"2020-07-17T22:30:29.000Z","updated":"2020-07-24T04:02:39.398Z","comments":true,"path":"2020/07/17/351. Android Unlock Patterns/","link":"","permalink":"WangHngLeee.github.io/2020/07/17/351. Android Unlock Patterns/","excerpt":"351. Android Unlock Patterns üîó Question Link Examples Given an Android 3x3 key lock screen and two integers m and n, where 1 ‚â§ m ‚â§ n ‚â§ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys. Rules for a valid pattern: Each pattern must connect at least m keys and at most n keys. All the keys must be distinct. If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed. The order of keys used matters. Explanation: | 1 | 2 | 3 || 4 | 5 | 6 || 7 | 8 | 9 |Invalid move: 4 - 1 - 3 - 6Line 1 - 3 passes through key 2 which had not been selected in the pattern.Invalid move: 4 - 1 - 9 - 2Line 1 - 9 passes through key 5 which had not been selected in the pattern.Valid move: 2 - 4 - 1 - 3 - 6Line 1 - 3 is valid because it passes through key 2, which had been selected in the patternValid move: 6 - 5 - 4 - 1 - 9 - 2Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern.","text":"351. Android Unlock Patterns üîó Question Link Examples Given an Android 3x3 key lock screen and two integers m and n, where 1 ‚â§ m ‚â§ n ‚â§ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys. Rules for a valid pattern: Each pattern must connect at least m keys and at most n keys. All the keys must be distinct. If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed. The order of keys used matters. Explanation: | 1 | 2 | 3 || 4 | 5 | 6 || 7 | 8 | 9 |Invalid move: 4 - 1 - 3 - 6Line 1 - 3 passes through key 2 which had not been selected in the pattern.Invalid move: 4 - 1 - 9 - 2Line 1 - 9 passes through key 5 which had not been selected in the pattern.Valid move: 2 - 4 - 1 - 3 - 6Line 1 - 3 is valid because it passes through key 2, which had been selected in the patternValid move: 6 - 5 - 4 - 1 - 9 - 2Line 1 - 9 is valid because it passes through key 5, which had been selected in the pattern. Solution First thought is using DFS to find all the possible path and count it‚Äôs total count. But it can be optimized by using a skip array. The optimization idea is that 1,3,7,9 are symmetric, 2,4,6,8 are also symmetric. Hence we only calculate one among each group and multiply by 4. Skip array store the number that between two numbers with only one interval. Code class Solution &#123; // cur: the current position // remain: the steps remaining int[][] skip = new int[10][10]; boolean seen[] = new boolean[10]; public int DFS(int cur, int remain) &#123; if(remain &lt; 0) return 0; if(remain == 0) return 1; seen[cur] = true; int res = 0; for(int i = 1; i &lt;= 9; ++i) &#123; // If vis[i] is not visited and (two numbers are adjacent or skip number is already visited) if(!seen[i] &amp;&amp; (skip[cur][i] == 0 || seen[skip[cur][i]])) &#123; res+= DFS(i, remain - 1); &#125; &#125; seen[cur] = false; return res; &#125; public int numberOfPatterns(int m, int n) &#123; skip[1][3] = skip[3][1] = 2; skip[1][7] = skip[7][1] = 4; skip[3][9] = skip[9][3] = 6; skip[7][9] = skip[9][7] = 8; skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5; int res = 0; // DFS search each length from m to n for(int i = m; i &lt;= n; ++i) &#123; res+= DFS(1, i - 1) * 4; // start with 1(same as 3, 7, 9 ), so we multiply 4 here. res+= DFS(2, i - 1) * 4; // start with 2(same as 4,6,8), so we multiply 4 here. res+= DFS(5, i - 1); // start with 5 &#125; return res; &#125;&#125; T:O(V^2) S:O(V)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Hard | 329. Longest Increasing Path in a Matrix","slug":"329. Longest Increasing Path in a Matrix","date":"2020-07-17T22:27:29.000Z","updated":"2020-07-29T21:38:27.017Z","comments":true,"path":"2020/07/17/329. Longest Increasing Path in a Matrix/","link":"","permalink":"WangHngLeee.github.io/2020/07/17/329. Longest Increasing Path in a Matrix/","excerpt":"329. Longest Increasing Path in a Matrix üîó LeetCode Link Example Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1:Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.","text":"329. Longest Increasing Path in a Matrix üîó LeetCode Link Example Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1:Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].Example 2:Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. Solution It is a typical recursive + memo question. We might think using db at first, but it is unnecessary. We can just DFS every number and keep a memo of it‚Äôs max length of increasing path in memo[i][j]. Code class Solution&#123; int[][] dirs = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; int[][] memo; int m, n; public int longestIncreasingPath(int[][] matrix) &#123; if(matrix.length == 0) return 0; memo = new int[m][n]; m = matrix.length; n = matrix[0].length; int[][] memo = new int[m][n]; int max = 1; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; int len = dfs(matrix, i, j, memo); max = Math.max(max, len); &#125; &#125; return max; &#125; public int dfs(int[][] matrix, int i, int j, int[][] memo) &#123; if(memo[i][j] != 0) return memo[i][j]; int max = 1; for(int[] dir: dirs) &#123; int x = i + dir[0]; int y = j + dir[1]; if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) continue; max = Math.max(max, 1 + dfs(matrix, x, y, memo)); &#125; memo[i][j] = max; return max; &#125;&#125; T: O(n^2) S: O(n^2)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Review | Medium | 348. Design Tic-Tac-Toe","slug":"348. Design Tic-Tac-Toe","date":"2020-07-17T22:27:29.000Z","updated":"2020-07-24T04:02:44.585Z","comments":true,"path":"2020/07/17/348. Design Tic-Tac-Toe/","link":"","permalink":"WangHngLeee.github.io/2020/07/17/348. Design Tic-Tac-Toe/","excerpt":"348. Design Tic-Tac-Toe üîó Question Link Examples Design a Tic-tac-toe game that is played between two players on a n x n grid. You may assume the following rules: A move is guaranteed to be valid and is placed on an empty block. Once a winning condition is reached, no more moves is allowed. A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game. Example:Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.TicTacToe toe = new TicTacToe(3);toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)|X| | || | | | // Player 1 makes a move at (0, 0).| | | |toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 2 makes a move at (0, 2).| | | |toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 1 makes a move at (2, 2).| | |X|toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 2 makes a move at (1, 1).| | |X|toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 1 makes a move at (2, 0).|X| |X|toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)|X| |O||O|O| | // Player 2 makes a move at (1, 0).|X| |X|toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)|X| |O||O|O| | // Player 1 makes a move at (2, 1).|X|X|X|","text":"348. Design Tic-Tac-Toe üîó Question Link Examples Design a Tic-tac-toe game that is played between two players on a n x n grid. You may assume the following rules: A move is guaranteed to be valid and is placed on an empty block. Once a winning condition is reached, no more moves is allowed. A player who succeeds in placing n of their marks in a horizontal, vertical, or diagonal row wins the game. Example:Given n = 3, assume that player 1 is &quot;X&quot; and player 2 is &quot;O&quot; in the board.TicTacToe toe = new TicTacToe(3);toe.move(0, 0, 1); -&gt; Returns 0 (no one wins)|X| | || | | | // Player 1 makes a move at (0, 0).| | | |toe.move(0, 2, 2); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 2 makes a move at (0, 2).| | | |toe.move(2, 2, 1); -&gt; Returns 0 (no one wins)|X| |O|| | | | // Player 1 makes a move at (2, 2).| | |X|toe.move(1, 1, 2); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 2 makes a move at (1, 1).| | |X|toe.move(2, 0, 1); -&gt; Returns 0 (no one wins)|X| |O|| |O| | // Player 1 makes a move at (2, 0).|X| |X|toe.move(1, 0, 2); -&gt; Returns 0 (no one wins)|X| |O||O|O| | // Player 2 makes a move at (1, 0).|X| |X|toe.move(2, 1, 1); -&gt; Returns 1 (player 1 wins)|X| |O||O|O| | // Player 1 makes a move at (2, 1).|X|X|X| Solution It‚Äôs a simple question. We can use two array to store the score in rows and cols. And keep two record for diag and antidiag directions. If anyone of them reach to the size, then return current player. Otherwise just return 0. Code class TicTacToe &#123; int[] rows; int[] cols; int diag; int antidiag; /** Initialize your data structure here. */ public TicTacToe(int n) &#123; rows = new int[n]; cols = new int[n]; diag = 0; antidiag = 0; &#125; /** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;). @param row The row of the board. @param col The column of the board. @param player The player, can be either 1 or 2. @return The current winning condition, can be either: 0: No one wins. 1: Player 1 wins. 2: Player 2 wins. */ public int move(int row, int col, int player) &#123; int step = player == 1 ? 1 : -1; rows[row] += step; cols[col] += step; if(row == col)&#123; diag+=step; &#125; if(col == cols.length - row - 1)&#123; antidiag+=step; &#125; int size = rows.length; if(Math.abs(rows[row]) == size || Math.abs(cols[col]) == size || Math.abs(diag) == size || Math.abs(antidiag) == size)return player; return 0; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Design","slug":"Design","permalink":"WangHngLeee.github.io/tags/Design/"}]},{"title":"Leetcode EveryDay 106 / Review 01","slug":"review1","date":"2020-07-10T16:27:29.000Z","updated":"2020-07-18T01:09:15.665Z","comments":true,"path":"2020/07/10/review1/","link":"","permalink":"WangHngLeee.github.io/2020/07/10/review1/","excerpt":"398. Random Pick Index üîó Question Link Examples Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example:int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); Solution class Solution &#123; int[] nums; Random rand; public Solution(int[] nums) &#123; this.nums = nums; this.rand = new Random(); &#125; public int pick(int target) &#123; int total = 0; int res = -1; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != target)&#123; continue; &#125;else&#123; // current num is the target total++; // caculate the total if(rand.nextInt(total) == 0)&#123; res = i; &#125; &#125; &#125; return res; &#125;&#125; Consider the example like &#123;1,2,3,3,3&#125; with target 3 We want to select 2,3,4 with a probability of 1/3 each. 2 : It‚Äôs probability of selection is 1 * (1/2) * (2/3) = 1/3 3 : It‚Äôs probability of selection is (1/2) * (2/3) = 1/3 4 : It‚Äôs probability of selection is just 1/3 So they are each randomly selected.","text":"398. Random Pick Index üîó Question Link Examples Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note: The array size can be very large. Solution that uses too much extra space will not pass the judge. Example:int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); Solution class Solution &#123; int[] nums; Random rand; public Solution(int[] nums) &#123; this.nums = nums; this.rand = new Random(); &#125; public int pick(int target) &#123; int total = 0; int res = -1; for(int i=0; i&lt;nums.length; i++)&#123; if(nums[i] != target)&#123; continue; &#125;else&#123; // current num is the target total++; // caculate the total if(rand.nextInt(total) == 0)&#123; res = i; &#125; &#125; &#125; return res; &#125;&#125; Consider the example like &#123;1,2,3,3,3&#125; with target 3 We want to select 2,3,4 with a probability of 1/3 each. 2 : It‚Äôs probability of selection is 1 * (1/2) * (2/3) = 1/3 3 : It‚Äôs probability of selection is (1/2) * (2/3) = 1/3 4 : It‚Äôs probability of selection is just 1/3 So they are each randomly selected. 394. Decode String üîó Question Link Examples Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won‚Äôt be input like 3a or 2[4]. Example 1:Input: s = &quot;3[a]2[bc]&quot;Output: &quot;aaabcbc&quot;Example 2:Input: s = &quot;3[a2[c]]&quot;Output: &quot;accaccacc&quot; Solution class Solution &#123; public String decodeString(String s) &#123; if(s == null || s.length() == 0)return \"\"; //corner case StringBuilder sb = new StringBuilder(); Stack&lt;StringBuilder&gt; sbstack = new Stack&lt;&gt;(); Stack&lt;Integer&gt; intstack = new Stack&lt;&gt;(); int tempcount = 0; for(char c : s.toCharArray())&#123; if(Character.isDigit(c))&#123; tempcount = tempcount*10 + c -'0'; &#125; else if(c == '[')&#123; // start intstack.push(tempcount); sbstack.push(sb); tempcount = 0; // reset count sb = new StringBuilder(); //reset stringbuilder &#125; else if(c == ']')&#123; StringBuilder swap = sb; sb = sbstack.pop(); for(int i=intstack.pop(); i&gt;0; i--)&#123; sb.append(swap); &#125; &#125; else&#123; sb.append(c); &#125; &#125; return sb.toString(); &#125;&#125; Keep two stack of both index and stringbuilder. When we meet [ then we add previous stringbuilder and count to the stack, and reset both stringbuider and count. When we meet ] we have to add current stringbuilder to the previous stringbuilder in the stack. 385. Mini Parser üîó Question Link Examples Given a nested list of integers represented as a string, implement a parser to deserialize it. Each element is either an integer, or a list ‚Äì whose elements may also be integers or other lists. Note: You may assume that the string is well-formed: String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - , ]. Example 1:Given s = &quot;324&quot;,You should return a NestedInteger object which contains a single integer 324.Example 2:Given s = &quot;[123,[456,[789]]]&quot;,Return a NestedInteger object containing a nested list with 2 elements:1. An integer containing value 123.2. A nested list containing two elements: i. An integer containing value 456. ii. A nested list with one element: a. An integer containing value 789. Solution class Solution &#123; public NestedInteger deserialize(String s) &#123; if(!s.startsWith(\"[\"))&#123; return new NestedInteger(Integer.valueOf(s)); &#125; Stack&lt;NestedInteger&gt; stack = new Stack&lt;&gt;(); NestedInteger res = new NestedInteger(); stack.push(res); int start = 1; for(int i=1; i&lt;s.length(); i++)&#123; char c = s.charAt(i); if(c == '[')&#123; NestedInteger cur = new NestedInteger(); stack.peek().add(cur); stack.push(cur); start =i+ 1; &#125;else if(c == ']' || c ==',')&#123; if(i &gt; start)&#123; Integer val = Integer.valueOf(s.substring(start,i)); stack.peek().add(new NestedInteger(val)); &#125; start=i+1; if( c == ']')&#123; stack.pop(); &#125; &#125; &#125; return res; &#125;&#125; When we meet [ it means we have to add new nestedinteger into the peek one in stack.And then add current into the stack to prepare for the upcoming nestedinteger list. When we meet ] it means we get the end of current nestedinteger. So we just pop up the current peek of stack. 384. Shuffle an Array üîó Question Link Examples Shuffle a set of numbers without duplicates. Example:// Init an array with set 1, 2, and 3.int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();// Resets the array back to its original configuration [1,2,3].solution.reset();// Returns the random shuffling of array [1,2,3].solution.shuffle(); Solution class Solution &#123; int[] nums; Random rand; public Solution(int[] nums) &#123; this.nums = nums; rand = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return nums; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; if(nums == null)return null; int[] clone = nums.clone(); for(int i=0; i&lt;nums.length; i++)&#123; int j = rand.nextInt(i+1); swap(clone, i, j); &#125; return clone; &#125; public void swap(int[] clone, int i, int j)&#123; int temp = clone[i]; clone[i] = clone[j]; clone[j] = temp; &#125;&#125; It‚Äôs a bit like question 398, both need to use Random to generate a random index in order to make sure the posibility is equal to each num. In this question, when loop each num in the array, we have to get a random index. Proof: Suppose this algorithm works, i.e. for each position j (starting from 0), the probability of any number in the range[0,j] to be at position j is 1/(1+j). int i = random.nextInt(j + 1): (1) If i == j, nums[j] does not need to change its position, which has probability 1/(1+j). (2) if i !=j, nums[j] needs to be swapped with nums[i]. The probability of any number x in the range [0,j-1] to be at position j = nums[j] changes its position * x is at position i = (1-1/(1+j)) * (1/j) = 1/(1+j) Each number has equal probability to be at any position.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Second-Round","slug":"Second-Round","permalink":"WangHngLeee.github.io/tags/Second-Round/"}]},{"title":"Leetcode EveryDay 105 / String(3) üí™","slug":"string03","date":"2020-07-04T17:53:35.000Z","updated":"2020-07-04T20:59:43.751Z","comments":true,"path":"2020/07/04/string03/","link":"","permalink":"WangHngLeee.github.io/2020/07/04/string03/","excerpt":"1268. Search Suggestions Systeme üîóQuestion Link Example Given an array of strings products and a string searchWord. We want to design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return list of lists of the suggested products after each character of searchWord is typed. Example 1:Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;Output: [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]Explanation: products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;] Solution 1. Trie class Solution &#123; class Trie&#123; Trie[] children = new Trie[26]; List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#125; public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; Arrays.sort(products); Trie root = new Trie(); for(String p : products)&#123; insert(p,root); &#125; return search(searchWord,root); &#125; public void insert(String p, Trie root)&#123; for(char c : p.toCharArray())&#123; if(root.children[c-'a'] == null)&#123; root.children[c-'a'] = new Trie(); &#125; root = root.children[c-'a']; if(root.list.size()&lt;3)&#123; root.list.add(p); &#125; &#125; &#125; public List&lt;List&lt;String&gt;&gt; search(String str, Trie root)&#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); for(char c : str.toCharArray())&#123; if(root != null)&#123; root = root.children[c-'a']; &#125; res.add(root == null ? Arrays.asList() : root.list); &#125; return res; &#125;&#125; It‚Äôs clearly that it‚Äôs trie problem at first. So we can define a new class called Trie and initialize a new Trie structure. First we sort the products list. Then we insert 3 produsts to each character node. Then we search from the start of searchWord . If no trie exist then we just add a blank array to res. T: O(m * n + L) Sorting cost time O(m * n), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n). S: O(m * n + L * m) Including return list ans, where m = average length of products, n = products.length, L = searchWord.length(). 2. Binary Search","text":"1268. Search Suggestions Systeme üîóQuestion Link Example Given an array of strings products and a string searchWord. We want to design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products. Return list of lists of the suggested products after each character of searchWord is typed. Example 1:Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;Output: [[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;],[&quot;mouse&quot;,&quot;mousepad&quot;]]Explanation: products sorted lexicographically = [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;]After typing m and mo all products match and we show user [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;]After typing mou, mous and mouse the system suggests [&quot;mouse&quot;,&quot;mousepad&quot;] Solution 1. Trie class Solution &#123; class Trie&#123; Trie[] children = new Trie[26]; List&lt;String&gt; list = new ArrayList&lt;&gt;(); &#125; public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; Arrays.sort(products); Trie root = new Trie(); for(String p : products)&#123; insert(p,root); &#125; return search(searchWord,root); &#125; public void insert(String p, Trie root)&#123; for(char c : p.toCharArray())&#123; if(root.children[c-'a'] == null)&#123; root.children[c-'a'] = new Trie(); &#125; root = root.children[c-'a']; if(root.list.size()&lt;3)&#123; root.list.add(p); &#125; &#125; &#125; public List&lt;List&lt;String&gt;&gt; search(String str, Trie root)&#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); for(char c : str.toCharArray())&#123; if(root != null)&#123; root = root.children[c-'a']; &#125; res.add(root == null ? Arrays.asList() : root.list); &#125; return res; &#125;&#125; It‚Äôs clearly that it‚Äôs trie problem at first. So we can define a new class called Trie and initialize a new Trie structure. First we sort the products list. Then we insert 3 produsts to each character node. Then we search from the start of searchWord . If no trie exist then we just add a blank array to res. T: O(m * n + L) Sorting cost time O(m * n), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n). S: O(m * n + L * m) Including return list ans, where m = average length of products, n = products.length, L = searchWord.length(). 2. Binary Search class Solution &#123; public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Arrays.sort(products); List&lt;String&gt; productsList = Arrays.asList(products); TreeMap&lt;String,Integer&gt; treemap = new TreeMap&lt;&gt;(); // adding products into treemap for(int i=0; i&lt;products.length; i++)&#123; treemap.put(products[i],i); &#125; // start binary search String key = \"\"; for(char c : searchWord.toCharArray())&#123; key+=c; String lowerbound = treemap.ceilingKey(key); String upperbound = treemap.floorKey(key+\"~\"); if(lowerbound == null || upperbound == null)break; res.add(productsList.subList( treemap.get(lowerbound), Math.min(treemap.get(lowerbound)+3, treemap.get(upperbound)+1))); &#125; while(res.size() &lt; searchWord.length())&#123; res.add(new ArrayList&lt;&gt;()); &#125; return res; &#125;&#125; For example, if A[i] is a prefix of A[j], A[i] must be the prefix of A[i + 1], A[i + 2], ‚Ä¶, A[j]. We can utilize the advantage of TreeMap like auto-sorting and cellingKey / floorKey functions. After the strings are sorted in treemap, then we can using ceilingKey to find the max one that is less than current string and floorKey to find the min one that is larget than current string. Then we can add the strings that between the upperbound and lowerbound to the res. T:O(NlogN) for sorting S:O(logN) for quick sort. 539. Minimum Time Difference üîóQuestion Link Example Given a list of 24-hour clock time points in ‚ÄúHour:Minutes‚Äù format, find the minimum minutes difference between any two time points in the list. Example 1:Input: [&quot;23:59&quot;,&quot;00:00&quot;]Output: 1 Note:The number of time points in the given list is at least 2 and won&apos;t exceed 20000.The input time is legal and ranges from 00:00 to 23:59. Solution class Solution &#123; public int findMinDifference(List&lt;String&gt; timePoints) &#123; if(timePoints == null || timePoints.size() == 0)return 0; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; int[] bucket = new int[24*60]; for(String str: timePoints)&#123; String[] temp = str.split(\":\"); int hour = Integer.valueOf(temp[0]); int minute = Integer.valueOf(temp[1]); if(bucket[hour*60+minute] == 1)&#123; return 0; &#125; min = Math.min(min,hour*60+minute); max = Math.max(max,hour*60+minute); bucket[hour*60+minute] = 1; &#125; int min_diff = Integer.MAX_VALUE; int prev = 0; for(int i=min; i&lt;=max; i++)&#123; if(bucket[i] == 1)&#123; if( i == min)&#123; min_diff = Math.min(min_diff, Math.min(max-min, 1440-max+min)); &#125;else&#123; min_diff = Math.min(min_diff,i-prev); &#125; prev = i; &#125; &#125; return min_diff; &#125;&#125; The idea is simple. There is 24*60=1440 minutes per day, so we can create an array with size of 1440 to store the each timepoint to check whether they have appeared before. If so then we just return 0 beause the difference is 0 between two same time points. Otherwise we need to find the min and max points in the given list. And using prev to store the previous timepoints. The graph of the timeline is like this: 0 - - - min - - - max - - -1440 -‚¨ÜÔ∏è - - - - - - - - - - - - - - - ‚¨áÔ∏è // actually 1440 and 0 are the same point And there is two situations: Current timepoint is min: So we only have two part to compare: max - min, 1440-(max-min), which is the parts that the timepoints of 0 -&gt; min and max -&gt;1440 Current timepoint is not min : Just using curr-prev to get the temp time difference and compare it with min_diff. T:O(N) S:O(1) 443. String Compression üîó Question Link Example Given an array of characters, compress it in-place. The length after compression must always be smaller than or equal to the original array. Every element of the array should be a character (not int) of length 1. After you are done modifying the input array in-place, return the new length of the array. Follow up: Could you solve it using only O(1) extra space? Example 1:Input:[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]Output:Return 6, and the first 6 characters of the input array should be: [&quot;a&quot;,&quot;2&quot;,&quot;b&quot;,&quot;2&quot;,&quot;c&quot;,&quot;3&quot;]Explanation:&quot;aa&quot; is replaced by &quot;a2&quot;. &quot;bb&quot; is replaced by &quot;b2&quot;. &quot;ccc&quot; is replaced by &quot;c3&quot;. Solution At first we can easily come up with the HashMap solution. But it doesn‚Äôt meet the O(1) space requirement. So here is the standard solution. class Solution &#123; public int compress(char[] chars) &#123; if(chars == null || chars.length == 0)return 0; int resindex = 0; int index = 0; while(index &lt; chars.length)&#123; char currchar = chars[index]; int count = 0; while(index &lt; chars.length &amp;&amp; currchar == chars[index] )&#123; index++; count++; &#125; chars[resindex] = currchar; resindex++; if(count!=1)&#123; for(char c : Integer.toString(count).toCharArray())&#123; chars[resindex] = c; resindex++; &#125; &#125; &#125; return resindex; &#125;&#125; Kind of brute force. Keep track of current index and the final index. Then add the count of each char to array after itself. Finally return the final resindex which is the length of new array. T:O(N) S:O(1)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Leetcode EveryDay 104 / DP(1) üí™","slug":"DP01","date":"2020-07-03T17:53:35.000Z","updated":"2020-07-03T22:24:50.131Z","comments":true,"path":"2020/07/03/DP01/","link":"","permalink":"WangHngLeee.github.io/2020/07/03/DP01/","excerpt":"256. Paint House üîó Question Link Example There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on‚Ä¶ Find the minimum cost to paint all houses. Note:All costs are positive integers. Example:Input: [[17,2,17],[16,16,5],[14,3,19]]Output: 10Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. Solution class Solution &#123; public int minCost(int[][] costs) &#123; if(costs == null || costs.length == 0)return 0; //corner case for(int i=1; i&lt;costs.length; i++)&#123; costs[i][0] += Math.min(costs[i-1][1],costs[i-1][2]); costs[i][1] += Math.min(costs[i-1][0],costs[i-1][2]); costs[i][2] += Math.min(costs[i-1][1],costs[i-1][0]); &#125; int n = costs.length-1; return Math.min(Math.min(costs[n][0],costs[n][1]),costs[n][2]); &#125;&#125; Because there is only 3 colors, so we can easily updating different colors. The 1st row is the prices for the 1st house, we can change the matrix to present sum of prices from the 2nd row. i.e, the costs[1][0] represent minimum price to paint the second house red plus the 1st house. Choosing min value between the different color of the above line. T:O(N) S:O(1)","text":"256. Paint House üîó Question Link Example There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on‚Ä¶ Find the minimum cost to paint all houses. Note:All costs are positive integers. Example:Input: [[17,2,17],[16,16,5],[14,3,19]]Output: 10Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. Minimum cost: 2 + 5 + 3 = 10. Solution class Solution &#123; public int minCost(int[][] costs) &#123; if(costs == null || costs.length == 0)return 0; //corner case for(int i=1; i&lt;costs.length; i++)&#123; costs[i][0] += Math.min(costs[i-1][1],costs[i-1][2]); costs[i][1] += Math.min(costs[i-1][0],costs[i-1][2]); costs[i][2] += Math.min(costs[i-1][1],costs[i-1][0]); &#125; int n = costs.length-1; return Math.min(Math.min(costs[n][0],costs[n][1]),costs[n][2]); &#125;&#125; Because there is only 3 colors, so we can easily updating different colors. The 1st row is the prices for the 1st house, we can change the matrix to present sum of prices from the 2nd row. i.e, the costs[1][0] represent minimum price to paint the second house red plus the 1st house. Choosing min value between the different color of the above line. T:O(N) S:O(1) 265. Paint House II üîó¬óQuestion Link Example There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on‚Ä¶ Find the minimum cost to paint all houses. Note:All costs are positive integers. Example:Input: [[1,5,3],[2,9,4]]Output: 5Explanation: Paint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; Or paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5. Solution Different from the previous painting problem, this question need k different colors. class Solution &#123; public int minCostII(int[][] costs) &#123; if (costs == null || costs.length == 0 || costs[0].length == 0) return 0; int m = costs.length; int n = costs[0].length; int[][] dp = new int[m + 1][n]; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int min = Integer.MAX_VALUE; for (int k = 0; k &lt; n; k++) &#123; if (k == j) continue; min = Math.min(min, dp[i - 1][k]); &#125; dp[i][j] = (min == Integer.MAX_VALUE ? 0 : min) + costs[i - 1][j]; &#125; &#125; int res = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) &#123; res = Math.min(res, dp[m][i]); &#125; return res; &#125;&#125; DP dp[i][k] means paint ith house using k color. To compute dp[i][j], we need to find out the minimum cost of previous house using different color. Iterate all possible color of previous house except the color of current house to find min cost. T:O(N * k^2) S:O(N*k) 1277. Count Square Submatrices with All Ones üîóQuestion Link Example Given a m * n matrix of ones and zeros, return how many square submatrices have all ones. Example 1:Input: matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]Output: 15Explanation: There are 10 squares of side 1.There are 4 squares of side 2.There is 1 square of side 3.Total number of squares = 10 + 4 + 1 = 15. Solution class Solution &#123; public int countSquares(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return 0; int res = 0; int m = matrix.length; int n = matrix[0].length; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(matrix[i][j] == 1)&#123; if(i&gt;0 &amp;&amp; j&gt;0)&#123; matrix[i][j] = Math.min(Math.min(matrix[i][j-1],matrix[i-1][j]),matrix[i-1][j-1])+1; &#125; res+=matrix[i][j]; &#125;else&#123; continue; &#125; &#125; &#125; return res; &#125;&#125; Key point is that we take the right-bottom most point to find the side of square. In DP process, we choose the min side from the previous position ( left, up and left-up). Then we change the current dp[i][j] to be that value. And add it to the res. T:O(MN) S:O(N) 1220. Count Vowels Permutation üîó¬óQuestion Link Example Given an integer n, your task is to count how many strings of length n can be formed under the following rules: Each character is a lower case vowel (‚Äòa‚Äô, ‚Äòe‚Äô, ‚Äòi‚Äô, ‚Äòo‚Äô, ‚Äòu‚Äô) Each vowel ‚Äòa‚Äô may only be followed by an ‚Äòe‚Äô. Each vowel ‚Äòe‚Äô may only be followed by an ‚Äòa‚Äô or an ‚Äòi‚Äô. Each vowel ‚Äòi‚Äô may not be followed by another ‚Äòi‚Äô. Each vowel ‚Äòo‚Äô may only be followed by an ‚Äòi‚Äô or a ‚Äòu‚Äô. Each vowel ‚Äòu‚Äô may only be followed by an ‚Äòa‚Äô. Since the answer may be too large, return it modulo 10^9 + 7. Example 1:Input: n = 1Output: 5Explanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;. Solution class Solution &#123; public int countVowelPermutation(int n) &#123; int MOD = (int) (1e9 + 7); long[][] dp = new long[n + 1][5]; for (int i = 0; i &lt; 5; i++) &#123; dp[1][i] = 1; &#125; /* 0: a 1: e 2: i 3: o 4: u */ for (int i = 1; i &lt; n; i++) &#123; dp[i+1][0] = (dp[i][4] + dp[i][1] + dp[i][2]) % MOD; dp[i+1][1] = (dp[i][0] + dp[i][2]) % MOD; dp[i+1][2] = (dp[i][3] + dp[i][1]) % MOD; dp[i+1][3] = (dp[i][2]) % MOD; dp[i+1][4] = (dp[i][2] + dp[i][3]) % MOD; &#125; long ans = 0; for (int i = 0; i &lt; 5; i++) ans = (ans + dp[n][i]) % MOD; return (int) ans; &#125;&#125; Using long instead of int in dp[] array. We also need to mod intermediate result. Transition function is easily to get. Which is updating the current sum by adding all possible words after the current character. T:O(N) S:O(N)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Leetcode EveryDay 103 / Array(3) üí™","slug":"array03","date":"2020-07-02T17:53:35.000Z","updated":"2020-07-02T21:26:13.111Z","comments":true,"path":"2020/07/02/array03/","link":"","permalink":"WangHngLeee.github.io/2020/07/02/array03/","excerpt":"643. Maximum Average Subarray I üîó Question Link Example Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1:Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note:1 &lt;= k &lt;= n &lt;= 30,000.Elements of the given array will be in the range [-10,000, 10,000]. Solution class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; long sum = 0; for(int i=0; i&lt;k; i++)&#123; sum+=nums[i]; &#125; long max = sum; for(int i=k; i&lt;nums.length; i++)&#123; sum+=nums[i] - nums[i-k]; max = Math.max(max,sum); &#125; return max/1.0/k; &#125;&#125; Using sliding window to caculate each k continous array‚Äôs average. Remember to change max to double first using /1.0. T:O(N) S:O(1)","text":"643. Maximum Average Subarray I üîó Question Link Example Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. Example 1:Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note:1 &lt;= k &lt;= n &lt;= 30,000.Elements of the given array will be in the range [-10,000, 10,000]. Solution class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; long sum = 0; for(int i=0; i&lt;k; i++)&#123; sum+=nums[i]; &#125; long max = sum; for(int i=k; i&lt;nums.length; i++)&#123; sum+=nums[i] - nums[i-k]; max = Math.max(max,sum); &#125; return max/1.0/k; &#125;&#125; Using sliding window to caculate each k continous array‚Äôs average. Remember to change max to double first using /1.0. T:O(N) S:O(1) 299. Bulls and Cows üîó Question Link Examples You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called ‚Äúbulls‚Äù) and how many digits match the secret number but locate in the wrong position (called ‚Äúcows‚Äù). Your friend will use successive guesses and hints to eventually derive the secret number. Write a function to return a hint according to the secret number and friend‚Äôs guess, use A to indicate the bulls and B to indicate the cows. Please note that both secret number and friend‚Äôs guess may contain duplicate digits. Example 1:Input: secret = &quot;1807&quot;, guess = &quot;7810&quot;Output: &quot;1A3B&quot;Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.Example 2:Input: secret = &quot;1123&quot;, guess = &quot;0111&quot;Output: &quot;1A1B&quot;Explanation: The 1st 1 in friend&apos;s guess is a bull, the 2nd or 3rd 1 is a cow. Solution class Solution &#123; public String getHint(String secret, String guess) &#123; if(secret == null || guess == null)return \"\"; int cows = 0; int bulls = 0; int[] secarr = new int[10]; int[] guessarr = new int[10]; for(int i=0; i&lt; secret.length(); i++)&#123; if(guess.charAt(i) == secret.charAt(i))&#123; bulls++; &#125;else&#123; secarr[secret.charAt(i)-'0']++; guessarr[guess.charAt(i)-'0']++; &#125; &#125; for(int i=0; i&lt;=9; i++)&#123; cows+=Math.min(secarr[i],guessarr[i]); &#125; return \"\" + bulls +\"A\"+ cows +\"B\"; &#125;&#125; Using bucket to store each number‚Äôs frequency. When the same position of secret and guess are same then we increase bulls. Ohterwise we increase both positions in two arrays by 1. After the first loop of the array, we then loop the number from 0 - 9. We only add min frequency one to the cows. Finally we return the constructed string. T:O(N) S:O(N) 658. Find K Closest Elements üîóQuestion Link Example Given a sorted array arr, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred. Example 1:Input: arr = [1,2,3,4,5], k = 4, x = 3Output: [1,2,3,4]Example 2:Input: arr = [1,2,3,4,5], k = 4, x = -1Output: [1,2,3,4] Solution class Solution &#123; public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int left = 0; int right = arr.length-1; while(right-left&gt;=k)&#123; if(Math.abs(arr[left]-x) &gt; Math.abs(arr[right]-x))&#123; left++; &#125;else&#123; right--; &#125; &#125; for(int i=left; i&lt;=right; i++)&#123; res.add(arr[i]); &#125; return res; &#125;&#125; Using two pointers to keep track of the left and right position. Cacualting the abs value of difference between current num and x. We increase by 1 on the large side. Finally we just loop from the left to right and add each number in this range to the res. T:O(N) S:O(N) 719. Find K-th Smallest Pair Distance üîó¬óQuestion Link Example Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. Example 1:Input:nums = [1,3,1]k = 1Output: 0 Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1st smallest distance pair is (1,1), and its distance is 0. Solution class Solution &#123; public int smallestDistancePair(int a[], int k) &#123; int n = a.length; Arrays.sort(a); int low = 0; int high = a[n - 1] - a[0]; while (low &lt; high) &#123; int mid = low + (high - low) / 2; if (count(a, mid) &lt; k) low = mid + 1; else high = mid; &#125; return low; &#125; private int count(int[] nums, int max) &#123; int res = 0; int n = nums.length; int j = 1; for (int i = 0; i &lt; n; i++) &#123; while (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= max) &#123; j++; &#125; res += j - i - 1; &#125; return res; &#125;&#125; First idea we can come up with is generating all the possible pairs and the using customed Max/Min PriorityQueue /sort function to get the top k smallest pairs, but it will cause TLE error. So we only have to using binary searching to reduce the time complexity. If we sort the array, then we can easily count the numbers of pairs whose distance is smaller than a number. (Only takes O(n)) The number of valid pairs and max distance hava a monotonic relationship. If distance max is small, the valid pairs will be small. If distance max is large, all pairs will be valid. Then we could use binary search! For a given max, count the number of valid pairs. If num &gt;= k, we could decrease max value. If num &lt; k , we must increase max value.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Front-end Interview Note 9 üí™","slug":"frontend-interview-09","date":"2020-06-28T12:05:35.000Z","updated":"2020-06-28T03:16:17.684Z","comments":true,"path":"2020/06/28/frontend-interview-09/","link":"","permalink":"WangHngLeee.github.io/2020/06/28/frontend-interview-09/","excerpt":"Vue ÁîüÂëΩÂë®ÊúüÈí©Â≠êÂáΩÊï∞ Âú® beforeCreate Èí©Â≠êÂáΩÊï∞Ë∞ÉÁî®ÁöÑÊó∂ÂÄôÔºåÊòØËé∑Âèñ‰∏çÂà∞ props ÊàñËÄÖ data ‰∏≠ÁöÑÊï∞ÊçÆÁöÑÔºåÂõ†‰∏∫Ëøô‰∫õÊï∞ÊçÆÁöÑÂàùÂßãÂåñÈÉΩÂú® initState ‰∏≠„ÄÇ ÁÑ∂Âêé‰ºöÊâßË°å created Èí©Â≠êÂáΩÊï∞ÔºåÂú®Ëøô‰∏ÄÊ≠•ÁöÑÊó∂ÂÄôÂ∑≤ÁªèÂèØ‰ª•ËÆøÈóÆÂà∞‰πãÂâç‰∏çËÉΩËÆøÈóÆÂà∞ÁöÑÊï∞ÊçÆÔºå‰ΩÜÊòØËøôÊó∂ÂÄôÁªÑ‰ª∂ËøòÊ≤°Ë¢´ÊåÇËΩΩÔºåÊâÄ‰ª•Áúã‰∏çÂà∞„ÄÇ Êé•‰∏ãÊù•‰ºöÂÖàÊâßË°å beforeMount Èí©Â≠êÂáΩÊï∞ÔºåÂºÄÂßãÂàõÂª∫ VDOMÔºåÊúÄÂêéÊâßË°å mounted Èí©Â≠êÔºåÂπ∂Â∞Ü VDOMÊ∏≤Êüì‰∏∫ÁúüÂÆû DOM Âπ∂‰∏îÊ∏≤ÊüìÊï∞ÊçÆ„ÄÇÁªÑ‰ª∂‰∏≠Â¶ÇÊûúÊúâÂ≠êÁªÑ‰ª∂ÁöÑËØùÔºå‰ºöÈÄíÂΩíÊåÇËΩΩÂ≠êÁªÑ‰ª∂ÔºåÂè™ÊúâÂΩìÊâÄÊúâÂ≠êÁªÑ‰ª∂ÂÖ®ÈÉ®ÊåÇËΩΩÂÆåÊØïÔºåÊâç‰ºöÊâßË°åÊ†πÁªÑ‰ª∂ÁöÑÊåÇËΩΩÈí©Â≠ê„ÄÇ Êé•‰∏ãÊù•ÊòØÊï∞ÊçÆÊõ¥Êñ∞Êó∂‰ºöË∞ÉÁî®ÁöÑÈí©Â≠êÂáΩÊï∞ beforeUpdate Âíå updatedÔºåÂàÜÂà´Âú®Êï∞ÊçÆÊõ¥Êñ∞ÂâçÂíåÊõ¥Êñ∞Âêé‰ºöË∞ÉÁî®„ÄÇ Âè¶Â§ñËøòÊúâ keep-alive Áã¨ÊúâÁöÑÁîüÂëΩÂë®ÊúüÔºåÂàÜÂà´‰∏∫ activated Âíå deactivated „ÄÇÁî® keep-alive ÂåÖË£πÁöÑÁªÑ‰ª∂Âú®ÂàáÊç¢Êó∂‰∏ç‰ºöËøõË°åÈîÄÊØÅÔºåËÄåÊòØÁºìÂ≠òÂà∞ÂÜÖÂ≠ò‰∏≠Âπ∂ÊâßË°å deactivated Èí©Â≠êÂáΩÊï∞ÔºåÂëΩ‰∏≠ÁºìÂ≠òÊ∏≤ÊüìÂêé‰ºöÊâßË°å actived Èí©Â≠êÂáΩÊï∞„ÄÇ ÊúÄÂêéÂ∞±ÊòØÈîÄÊØÅÁªÑ‰ª∂ÁöÑÈí©Â≠êÂáΩÊï∞ beforeDestroy Âíå destroyed„ÄÇÂâçËÄÖÈÄÇÂêàÁßªÈô§‰∫ã‰ª∂„ÄÅÂÆöÊó∂Âô®Á≠âÁ≠âÔºåÂê¶ÂàôÂèØËÉΩ‰ºöÂºïËµ∑ÂÜÖÂ≠òÊ≥ÑÈú≤ÁöÑÈóÆÈ¢ò„ÄÇÁÑ∂ÂêéËøõË°å‰∏ÄÁ≥ªÂàóÁöÑÈîÄÊØÅÊìç‰ΩúÔºåÂ¶ÇÊûúÊúâÂ≠êÁªÑ‰ª∂ÁöÑËØùÔºå‰πü‰ºöÈÄíÂΩíÈîÄÊØÅÂ≠êÁªÑ‰ª∂ÔºåÊâÄÊúâÂ≠êÁªÑ‰ª∂ÈÉΩÈîÄÊØÅÂÆåÊØïÂêéÊâç‰ºöÊâßË°åÊ†πÁªÑ‰ª∂ÁöÑ destroyed Èí©Â≠êÂáΩÊï∞ ÁªÑ‰ª∂ÈÄö‰ø° ÁªÑ‰ª∂ÈÄö‰ø°‰∏ÄËà¨ÂàÜ‰∏∫‰ª•‰∏ãÂá†ÁßçÊÉÖÂÜµÔºö","text":"Vue ÁîüÂëΩÂë®ÊúüÈí©Â≠êÂáΩÊï∞ Âú® beforeCreate Èí©Â≠êÂáΩÊï∞Ë∞ÉÁî®ÁöÑÊó∂ÂÄôÔºåÊòØËé∑Âèñ‰∏çÂà∞ props ÊàñËÄÖ data ‰∏≠ÁöÑÊï∞ÊçÆÁöÑÔºåÂõ†‰∏∫Ëøô‰∫õÊï∞ÊçÆÁöÑÂàùÂßãÂåñÈÉΩÂú® initState ‰∏≠„ÄÇ ÁÑ∂Âêé‰ºöÊâßË°å created Èí©Â≠êÂáΩÊï∞ÔºåÂú®Ëøô‰∏ÄÊ≠•ÁöÑÊó∂ÂÄôÂ∑≤ÁªèÂèØ‰ª•ËÆøÈóÆÂà∞‰πãÂâç‰∏çËÉΩËÆøÈóÆÂà∞ÁöÑÊï∞ÊçÆÔºå‰ΩÜÊòØËøôÊó∂ÂÄôÁªÑ‰ª∂ËøòÊ≤°Ë¢´ÊåÇËΩΩÔºåÊâÄ‰ª•Áúã‰∏çÂà∞„ÄÇ Êé•‰∏ãÊù•‰ºöÂÖàÊâßË°å beforeMount Èí©Â≠êÂáΩÊï∞ÔºåÂºÄÂßãÂàõÂª∫ VDOMÔºåÊúÄÂêéÊâßË°å mounted Èí©Â≠êÔºåÂπ∂Â∞Ü VDOMÊ∏≤Êüì‰∏∫ÁúüÂÆû DOM Âπ∂‰∏îÊ∏≤ÊüìÊï∞ÊçÆ„ÄÇÁªÑ‰ª∂‰∏≠Â¶ÇÊûúÊúâÂ≠êÁªÑ‰ª∂ÁöÑËØùÔºå‰ºöÈÄíÂΩíÊåÇËΩΩÂ≠êÁªÑ‰ª∂ÔºåÂè™ÊúâÂΩìÊâÄÊúâÂ≠êÁªÑ‰ª∂ÂÖ®ÈÉ®ÊåÇËΩΩÂÆåÊØïÔºåÊâç‰ºöÊâßË°åÊ†πÁªÑ‰ª∂ÁöÑÊåÇËΩΩÈí©Â≠ê„ÄÇ Êé•‰∏ãÊù•ÊòØÊï∞ÊçÆÊõ¥Êñ∞Êó∂‰ºöË∞ÉÁî®ÁöÑÈí©Â≠êÂáΩÊï∞ beforeUpdate Âíå updatedÔºåÂàÜÂà´Âú®Êï∞ÊçÆÊõ¥Êñ∞ÂâçÂíåÊõ¥Êñ∞Âêé‰ºöË∞ÉÁî®„ÄÇ Âè¶Â§ñËøòÊúâ keep-alive Áã¨ÊúâÁöÑÁîüÂëΩÂë®ÊúüÔºåÂàÜÂà´‰∏∫ activated Âíå deactivated „ÄÇÁî® keep-alive ÂåÖË£πÁöÑÁªÑ‰ª∂Âú®ÂàáÊç¢Êó∂‰∏ç‰ºöËøõË°åÈîÄÊØÅÔºåËÄåÊòØÁºìÂ≠òÂà∞ÂÜÖÂ≠ò‰∏≠Âπ∂ÊâßË°å deactivated Èí©Â≠êÂáΩÊï∞ÔºåÂëΩ‰∏≠ÁºìÂ≠òÊ∏≤ÊüìÂêé‰ºöÊâßË°å actived Èí©Â≠êÂáΩÊï∞„ÄÇ ÊúÄÂêéÂ∞±ÊòØÈîÄÊØÅÁªÑ‰ª∂ÁöÑÈí©Â≠êÂáΩÊï∞ beforeDestroy Âíå destroyed„ÄÇÂâçËÄÖÈÄÇÂêàÁßªÈô§‰∫ã‰ª∂„ÄÅÂÆöÊó∂Âô®Á≠âÁ≠âÔºåÂê¶ÂàôÂèØËÉΩ‰ºöÂºïËµ∑ÂÜÖÂ≠òÊ≥ÑÈú≤ÁöÑÈóÆÈ¢ò„ÄÇÁÑ∂ÂêéËøõË°å‰∏ÄÁ≥ªÂàóÁöÑÈîÄÊØÅÊìç‰ΩúÔºåÂ¶ÇÊûúÊúâÂ≠êÁªÑ‰ª∂ÁöÑËØùÔºå‰πü‰ºöÈÄíÂΩíÈîÄÊØÅÂ≠êÁªÑ‰ª∂ÔºåÊâÄÊúâÂ≠êÁªÑ‰ª∂ÈÉΩÈîÄÊØÅÂÆåÊØïÂêéÊâç‰ºöÊâßË°åÊ†πÁªÑ‰ª∂ÁöÑ destroyed Èí©Â≠êÂáΩÊï∞ ÁªÑ‰ª∂ÈÄö‰ø° ÁªÑ‰ª∂ÈÄö‰ø°‰∏ÄËà¨ÂàÜ‰∏∫‰ª•‰∏ãÂá†ÁßçÊÉÖÂÜµÔºö Áà∂Â≠êÁªÑ‰ª∂ÈÄö‰ø° ÂÖÑÂºüÁªÑ‰ª∂ÈÄö‰ø° Ë∑®Â§öÂ±ÇÁ∫ßÁªÑ‰ª∂ÈÄö‰ø° 1. Áà∂Â≠êÈÄö‰ø°(important) Áà∂ÁªÑ‰ª∂ÈÄöËøá props ‰º†ÈÄíÊï∞ÊçÆÁªôÂ≠êÁªÑ‰ª∂ÔºåÂ≠êÁªÑ‰ª∂ÈÄöËøá emit ÂèëÈÄÅ‰∫ã‰ª∂‰º†ÈÄíÊï∞ÊçÆÁªôÁà∂ÁªÑ‰ª∂ÔºåËøô‰∏§ÁßçÊñπÂºèÊòØÊúÄÂ∏∏Áî®ÁöÑÁà∂Â≠êÈÄö‰ø°ÂÆûÁé∞ÂäûÊ≥ï„ÄÇ ËøôÁßçÁà∂Â≠êÈÄö‰ø°ÊñπÂºè‰πüÂ∞±ÊòØÂÖ∏ÂûãÁöÑÂçïÂêëÊï∞ÊçÆÊµÅÔºåÁà∂ÁªÑ‰ª∂ÈÄöËøá props ‰º†ÈÄíÊï∞ÊçÆÔºåÂ≠êÁªÑ‰ª∂‰∏çËÉΩÁõ¥Êé•‰øÆÊîπ propsÔºåËÄåÊòØÂøÖÈ°ªÈÄöËøáÂèëÈÄÅ‰∫ã‰ª∂ÁöÑÊñπÂºèÂëäÁü•Áà∂ÁªÑ‰ª∂‰øÆÊîπÊï∞ÊçÆ„ÄÇ(ËøôÈáåÂíåreactÂæàÂÉè) Âè¶Â§ñËøô‰∏§ÁßçÊñπÂºèËøòÂèØ‰ª•‰ΩøÁî®ËØ≠Ê≥ïÁ≥ñ v-model Êù•Áõ¥Êé•ÂÆûÁé∞ÔºåÂõ†‰∏∫ v-model ÈªòËÆ§‰ºöËß£ÊûêÊàêÂêç‰∏∫ value ÁöÑ prop ÂíåÂêç‰∏∫ input ÁöÑ‰∫ã‰ª∂„ÄÇËøôÁßçËØ≠Ê≥ïÁ≥ñÁöÑÊñπÂºèÊòØÂÖ∏ÂûãÁöÑÂèåÂêëÁªëÂÆöÔºåÂ∏∏Áî®‰∫é UI Êéß‰ª∂‰∏äÔºåÊú¨Ë¥®‰∏äËøòÊòØÈÄöËøá‰∫ã‰ª∂ÁöÑÊñπÊ≥ïËÆ©Áà∂ÁªÑ‰ª∂‰øÆÊîπÊï∞ÊçÆ„ÄÇ ÂèØ‰ª•ÈÄöËøáËÆøÈóÆ $parent ÊàñËÄÖ $children ÂØπË±°Êù•ËÆøÈóÆÁªÑ‰ª∂ÂÆû‰æã‰∏≠ÁöÑÊñπÊ≥ïÂíåÊï∞ÊçÆ„ÄÇ Vue 2.3 Âèä‰ª•‰∏äÁâàÊú¨ÁöÑËØùÂèØ‰ª•‰ΩøÁî® $listeners Âíå .sync Ëøô‰∏§‰∏™Â±ûÊÄß„ÄÇ $listeners Â±ûÊÄß‰ºöÂ∞ÜÁà∂ÁªÑ‰ª∂‰∏≠ÁöÑ (‰∏çÂê´ .native ‰øÆÈ•∞Âô®ÁöÑ) v-on ‰∫ã‰ª∂ÁõëÂê¨Âô®‰º†ÈÄíÁªôÂ≠êÁªÑ‰ª∂ÔºåÂ≠êÁªÑ‰ª∂ÂèØ‰ª•ÈÄöËøáËÆøÈóÆ $listeners Êù•Ëá™ÂÆö‰πâÁõëÂê¨Âô®„ÄÇ .sync Â±ûÊÄßÊòØ‰∏™ËØ≠Ê≥ïÁ≥ñÔºåÂèØ‰ª•ÂæàÁÆÄÂçïÁöÑÂÆûÁé∞Â≠êÁªÑ‰ª∂‰∏éÁà∂ÁªÑ‰ª∂ÈÄö‰ø° &lt;!--Áà∂ÁªÑ‰ª∂‰∏≠--&gt;&lt;input :value.sync=\"value\" /&gt;&lt;!--‰ª•‰∏äÂÜôÊ≥ïÁ≠âÂêå‰∫é--&gt;&lt;input :value=\"value\" @update:value=\"v =&gt; value = v\"&gt;&lt;/comp&gt;&lt;!--Â≠êÁªÑ‰ª∂‰∏≠--&gt;&lt;script&gt; this.$emit('update:value', 1)&lt;/script&gt; 2. ÂÖÑÂºüÁªÑ‰ª∂ÈÄö‰ø° ÂØπ‰∫éËøôÁßçÊÉÖÂÜµÂèØ‰ª•ÈÄöËøáÊü•ÊâæÁà∂ÁªÑ‰ª∂‰∏≠ÁöÑÂ≠êÁªÑ‰ª∂ÂÆûÁé∞Ôºå‰πüÂ∞±ÊòØ this.$parent.$childrenÔºåÂú® $children ‰∏≠ÂèØ‰ª•ÈÄöËøáÁªÑ‰ª∂ name Êü•ËØ¢Âà∞ÈúÄË¶ÅÁöÑÁªÑ‰ª∂ÂÆû‰æãÔºåÁÑ∂ÂêéËøõË°åÈÄö‰ø°„ÄÇ 3. Ë∑®Â§öÂ±ÇÊ¨°ÁªÑ‰ª∂ÈÄö‰ø° ÂØπ‰∫éËøôÁßçÊÉÖÂÜµÂèØ‰ª•‰ΩøÁî® Vue 2.2 Êñ∞Â¢ûÁöÑ API provide / inject„ÄÇ ÂÅáËÆæÊúâÁà∂ÁªÑ‰ª∂ AÔºåÁÑ∂ÂêéÊúâ‰∏Ä‰∏™Ë∑®Â§öÂ±ÇÁ∫ßÁöÑÂ≠êÁªÑ‰ª∂ B // Áà∂ÁªÑ‰ª∂ Aexport default &#123; provide: &#123; data: 1 &#125;&#125;// Â≠êÁªÑ‰ª∂ Bexport default &#123; inject: ['data'], mounted() &#123; // Êó†ËÆ∫Ë∑®Âá†Â±ÇÈÉΩËÉΩËé∑ÂæóÁà∂ÁªÑ‰ª∂ÁöÑ data Â±ûÊÄß console.log(this.data) // =&gt; 1 &#125;&#125; ‰∏áËÉΩÂäûÊ≥ïËß£ÂÜ≥‰∏ÄÂàáÈÄö‰ø°ÈóÆÈ¢ò ‰ΩøÁî® Vuex ÊàñËÄÖ Event Bus Ëß£ÂÜ≥‰∏äËø∞ÊâÄÊúâÁöÑÈÄö‰ø°ÊÉÖÂÜµ„ÄÇ extend api ‰ΩúÁî® Ëøô‰∏™ API ÂæàÂ∞ëÁî®Âà∞Ôºå‰ΩúÁî®ÊòØÊâ©Â±ïÁªÑ‰ª∂ÁîüÊàê‰∏Ä‰∏™ÊûÑÈÄ†Âô®ÔºåÈÄöÂ∏∏‰ºö‰∏é $mount ‰∏ÄËµ∑‰ΩøÁî®„ÄÇ // ÂàõÂª∫ÁªÑ‰ª∂ÊûÑÈÄ†Âô®let Component = Vue.extend(&#123; template: '&lt;div&gt;test&lt;/div&gt;'&#125;)// ÊåÇËΩΩÂà∞ #app ‰∏änew Component().$mount('#app')// Èô§‰∫Ü‰∏äÈù¢ÁöÑÊñπÂºèÔºåËøòÂèØ‰ª•Áî®Êù•Êâ©Â±ïÂ∑≤ÊúâÁöÑÁªÑ‰ª∂let SuperComponent = Vue.extend(Component)new SuperComponent(&#123; created() &#123; console.log(1) &#125;&#125;)new SuperComponent().$mount('#app') computed Âíå watch Âå∫Âà´ computed ÊòØËÆ°ÁÆóÂ±ûÊÄßÔºå‰æùËµñÂÖ∂‰ªñÂ±ûÊÄßËÆ°ÁÆóÂÄºÔºåÂπ∂‰∏î computed ÁöÑÂÄºÊúâÁºìÂ≠òÔºåÂè™ÊúâÂΩìËÆ°ÁÆóÂÄºÂèòÂåñÊâç‰ºöËøîÂõûÂÜÖÂÆπ„ÄÇ watch ÁõëÂê¨Âà∞ÂÄºÁöÑÂèòÂåñÂ∞±‰ºöÊâßË°åÂõûË∞ÉÔºåÂú®ÂõûË∞É‰∏≠ÂèØ‰ª•ËøõË°å‰∏Ä‰∫õÈÄªËæëÊìç‰Ωú„ÄÇ ‰∏ÄËà¨Êù•ËØ¥ÈúÄË¶Å‰æùËµñÂà´ÁöÑÂ±ûÊÄßÊù•Âä®ÊÄÅËé∑ÂæóÂÄºÁöÑÊó∂ÂÄôÂèØ‰ª•‰ΩøÁî® computedÔºåÂØπ‰∫éÁõëÂê¨Âà∞ÂÄºÁöÑÂèòÂåñÈúÄË¶ÅÂÅö‰∏Ä‰∫õÂ§çÊùÇ‰∏öÂä°ÈÄªËæëÁöÑÊÉÖÂÜµÂèØ‰ª•‰ΩøÁî® watch„ÄÇ Âè¶Â§ñ computer Âíå watch ÈÉΩÊîØÊåÅÂØπË±°ÁöÑÂÜôÊ≥ï„ÄÇ vm.$watch('obj', &#123; // Ê∑±Â∫¶ÈÅçÂéÜ deep: true, // Á´ãÂç≥Ëß¶Âèë immediate: true, // ÊâßË°åÁöÑÂáΩÊï∞ handler: function(val, oldVal) &#123;&#125;&#125;)var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; aPlus: &#123; // this.aPlus Êó∂Ëß¶Âèë get: function () &#123; return this.a + 1 &#125;, // this.aPlus = 1 Êó∂Ëß¶Âèë set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;) keep-alive ÁªÑ‰ª∂‰ΩúÁî® Âú®ÈúÄË¶ÅÁªÑ‰ª∂ÂàáÊç¢ÁöÑÊó∂ÂÄôÔºå‰øùÂ≠ò‰∏Ä‰∫õÁªÑ‰ª∂ÁöÑÁä∂ÊÄÅÈò≤Ê≠¢Â§öÊ¨°Ê∏≤ÊüìÔºåÂ∞±ÂèØ‰ª•‰ΩøÁî® keep-alive ÁªÑ‰ª∂ÂåÖË£πÈúÄË¶Å‰øùÂ≠òÁöÑÁªÑ‰ª∂„ÄÇ ÂØπ‰∫é keep-alive ÁªÑ‰ª∂Êù•ËØ¥ÔºåÂÆÉÊã•Êúâ‰∏§‰∏™Áã¨ÊúâÁöÑÁîüÂëΩÂë®ÊúüÈí©Â≠êÂáΩÊï∞ÔºåÂàÜÂà´‰∏∫ activated Âíå deactivated „ÄÇÁî® keep-alive ÂåÖË£πÁöÑÁªÑ‰ª∂Âú®ÂàáÊç¢Êó∂‰∏ç‰ºöËøõË°åÈîÄÊØÅÔºåËÄåÊòØÁºìÂ≠òÂà∞ÂÜÖÂ≠ò‰∏≠Âπ∂ÊâßË°å deactivated Èí©Â≠êÂáΩÊï∞ÔºåÂëΩ‰∏≠ÁºìÂ≠òÊ∏≤ÊüìÂêé‰ºöÊâßË°å actived Èí©Â≠êÂáΩÊï∞„ÄÇ v-show ‰∏é v-if Âå∫Âà´ v-show Âè™ÊòØÂú® display: none Âíå display: block ‰πãÈó¥ÂàáÊç¢„ÄÇÊó†ËÆ∫ÂàùÂßãÊù°‰ª∂ÊòØ‰ªÄ‰πàÈÉΩ‰ºöË¢´Ê∏≤ÊüìÂá∫Êù•ÔºåÂêéÈù¢Âè™ÈúÄË¶ÅÂàáÊç¢ CSSÔºåDOM ËøòÊòØ‰∏ÄÁõ¥‰øùÁïôÁùÄÁöÑ„ÄÇÊâÄ‰ª•ÊÄªÁöÑÊù•ËØ¥ v-show Âú®ÂàùÂßãÊ∏≤ÊüìÊó∂ÊúâÊõ¥È´òÁöÑÂºÄÈîÄÔºå‰ΩÜÊòØÂàáÊç¢ÂºÄÈîÄÂæàÂ∞èÔºåÊõ¥ÈÄÇÂêà‰∫éÈ¢ëÁπÅÂàáÊç¢ÁöÑÂú∫ÊôØ„ÄÇ v-if ÁöÑËØùÂ∞±ÂæóËØ¥Âà∞ Vue Â∫ïÂ±ÇÁöÑÁºñËØë‰∫Ü„ÄÇÂΩìÂ±ûÊÄßÂàùÂßã‰∏∫ false Êó∂ÔºåÁªÑ‰ª∂Â∞±‰∏ç‰ºöË¢´Ê∏≤ÊüìÔºåÁõ¥Âà∞Êù°‰ª∂‰∏∫ trueÔºåÂπ∂‰∏îÂàáÊç¢Êù°‰ª∂Êó∂‰ºöËß¶ÂèëÈîÄÊØÅ/ÊåÇËΩΩÁªÑ‰ª∂ÔºåÂú®ÂàáÊç¢Êó∂ÂºÄÈîÄÊõ¥È´òÔºåÊõ¥ÈÄÇÂêà‰∏çÁªèÂ∏∏ÂàáÊç¢ÁöÑÂú∫ÊôØ„ÄÇ Âπ∂‰∏îÂü∫‰∫é v-if ÁöÑËøôÁßçÊÉ∞ÊÄßÊ∏≤ÊüìÊú∫Âà∂ÔºåÂèØ‰ª•Âú®ÂøÖË¶ÅÁöÑÊó∂ÂÄôÊâçÂéªÊ∏≤ÊüìÁªÑ‰ª∂ÔºåÂáèÂ∞ëÊï¥‰∏™È°µÈù¢ÁöÑÂàùÂßãÊ∏≤ÊüìÂºÄÈîÄ„ÄÇ ÁªÑ‰ª∂‰∏≠ data ‰ªÄ‰πàÊó∂ÂÄôÂèØ‰ª•‰ΩøÁî®ÂØπË±° ÁªÑ‰ª∂Â§çÁî®Êó∂ÊâÄÊúâÁªÑ‰ª∂ÂÆû‰æãÈÉΩ‰ºöÂÖ±‰∫´ dataÔºåÂ¶ÇÊûú data ÊòØÂØπË±°ÁöÑËØùÔºåÂ∞±‰ºöÈÄ†Êàê‰∏Ä‰∏™ÁªÑ‰ª∂‰øÆÊîπ data ‰ª•Âêé‰ºöÂΩ±ÂìçÂà∞ÂÖ∂‰ªñÊâÄÊúâÁªÑ‰ª∂ÔºåÊâÄ‰ª•ÈúÄË¶ÅÂ∞Ü data ÂÜôÊàêÂáΩÊï∞ÔºåÊØèÊ¨°Áî®Âà∞Â∞±Ë∞ÉÁî®‰∏ÄÊ¨°ÂáΩÊï∞Ëé∑ÂæóÊñ∞ÁöÑÊï∞ÊçÆ„ÄÇ ÂΩìÊàë‰ª¨‰ΩøÁî® new Vue() ÁöÑÊñπÂºèÁöÑÊó∂ÂÄôÔºåÊó†ËÆ∫Êàë‰ª¨Â∞Ü data ËÆæÁΩÆ‰∏∫ÂØπË±°ËøòÊòØÂáΩÊï∞ÈÉΩÊòØÂèØ‰ª•ÁöÑÔºåÂõ†‰∏∫ new Vue() ÁöÑÊñπÂºèÊòØÁîüÊàê‰∏Ä‰∏™Ê†πÁªÑ‰ª∂ÔºåËØ•ÁªÑ‰ª∂‰∏ç‰ºöÂ§çÁî®Ôºå‰πüÂ∞±‰∏çÂ≠òÂú®ÂÖ±‰∫´ data ÁöÑÊÉÖÂÜµ„ÄÇ","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 8 üí™","slug":"frontend-interview-08","date":"2020-06-27T12:05:35.000Z","updated":"2020-06-27T14:15:42.779Z","comments":true,"path":"2020/06/27/frontend-interview-08/","link":"","permalink":"WangHngLeee.github.io/2020/06/27/frontend-interview-08/","excerpt":"React React ‰∏≠ keys ÁöÑ‰ΩúÁî® KeysÊòØ React Áî®‰∫éËøΩË∏™Âì™‰∫õÂàóË°®‰∏≠ÂÖÉÁ¥†Ë¢´‰øÆÊîπ„ÄÅË¢´Ê∑ªÂä†ÊàñËÄÖË¢´ÁßªÈô§ÁöÑ ËæÖÂä©Ê†áËØÜ Âú®ÂºÄÂèë‰∏≠ÔºåÈúÄË¶Å‰øùËØÅÊüê‰∏™ÂÖÉÁ¥†ÁöÑ key Âú®ÂÖ∂ÂêåÁ∫ßÂÖÉÁ¥†‰∏≠ÂÖ∑ÊúâÂîØ‰∏ÄÊÄß„ÄÇÂú® React Diff ÁÆóÊ≥ï‰∏≠Ôºå React ‰ºöÂÄüÂä©ÂÖÉÁ¥†ÁöÑ Key ÂÄºÊù•Âà§Êñ≠ËØ•ÂÖÉÁ¥†ÊòØÊñ∞ËøëÂàõÂª∫ÁöÑËøòÊòØË¢´ÁßªÂä®ËÄåÊù•ÁöÑÂÖÉÁ¥†Ôºå‰ªéËÄåÂáèÂ∞ë‰∏çÂøÖË¶ÅÁöÑÂÖÉÁ¥†ÈáçÊ∏≤Êüì„ÄÇÊ≠§Â§ñÔºåReact ËøòÈúÄË¶ÅÂÄüÂä© Key ÂÄºÊù•Âà§Êñ≠ÂÖÉÁ¥†‰∏éÊú¨Âú∞Áä∂ÊÄÅÁöÑÂÖ≥ËÅîÂÖ≥Á≥ª„ÄÇ ‰º†ÂÖ• setState ÂáΩÊï∞ÁöÑÁ¨¨‰∫å‰∏™ÂèÇÊï∞ÁöÑ‰ΩúÁî® ËØ•ÂáΩÊï∞‰ºöÂú®setStateÂáΩÊï∞Ë∞ÉÁî®ÂÆåÊàêÂπ∂‰∏îÁªÑ‰ª∂ÂºÄÂßãÈáçÊ∏≤ÊüìÁöÑÊó∂ÂÄôË¢´Ë∞ÉÁî®ÔºåÂèØ‰ª•Áî®ËØ•ÂáΩÊï∞Êù•ÁõëÂê¨Ê∏≤ÊüìÊòØÂê¶ÂÆåÊàê„ÄÇ this.setState( &#123; username: 'tylermcginnis33' &#125;, () =&gt; console.log('setState has finished and the component has re-rendered.')//Ê∏≤ÊüìÂÆåÊàêÊâç‰ºöËæìÂá∫log) this.setState((prevState, props) =&gt; &#123; return &#123; streak: prevState.streak + props.count &#125;&#125;)","text":"React React ‰∏≠ keys ÁöÑ‰ΩúÁî® KeysÊòØ React Áî®‰∫éËøΩË∏™Âì™‰∫õÂàóË°®‰∏≠ÂÖÉÁ¥†Ë¢´‰øÆÊîπ„ÄÅË¢´Ê∑ªÂä†ÊàñËÄÖË¢´ÁßªÈô§ÁöÑ ËæÖÂä©Ê†áËØÜ Âú®ÂºÄÂèë‰∏≠ÔºåÈúÄË¶Å‰øùËØÅÊüê‰∏™ÂÖÉÁ¥†ÁöÑ key Âú®ÂÖ∂ÂêåÁ∫ßÂÖÉÁ¥†‰∏≠ÂÖ∑ÊúâÂîØ‰∏ÄÊÄß„ÄÇÂú® React Diff ÁÆóÊ≥ï‰∏≠Ôºå React ‰ºöÂÄüÂä©ÂÖÉÁ¥†ÁöÑ Key ÂÄºÊù•Âà§Êñ≠ËØ•ÂÖÉÁ¥†ÊòØÊñ∞ËøëÂàõÂª∫ÁöÑËøòÊòØË¢´ÁßªÂä®ËÄåÊù•ÁöÑÂÖÉÁ¥†Ôºå‰ªéËÄåÂáèÂ∞ë‰∏çÂøÖË¶ÅÁöÑÂÖÉÁ¥†ÈáçÊ∏≤Êüì„ÄÇÊ≠§Â§ñÔºåReact ËøòÈúÄË¶ÅÂÄüÂä© Key ÂÄºÊù•Âà§Êñ≠ÂÖÉÁ¥†‰∏éÊú¨Âú∞Áä∂ÊÄÅÁöÑÂÖ≥ËÅîÂÖ≥Á≥ª„ÄÇ ‰º†ÂÖ• setState ÂáΩÊï∞ÁöÑÁ¨¨‰∫å‰∏™ÂèÇÊï∞ÁöÑ‰ΩúÁî® ËØ•ÂáΩÊï∞‰ºöÂú®setStateÂáΩÊï∞Ë∞ÉÁî®ÂÆåÊàêÂπ∂‰∏îÁªÑ‰ª∂ÂºÄÂßãÈáçÊ∏≤ÊüìÁöÑÊó∂ÂÄôË¢´Ë∞ÉÁî®ÔºåÂèØ‰ª•Áî®ËØ•ÂáΩÊï∞Êù•ÁõëÂê¨Ê∏≤ÊüìÊòØÂê¶ÂÆåÊàê„ÄÇ this.setState( &#123; username: 'tylermcginnis33' &#125;, () =&gt; console.log('setState has finished and the component has re-rendered.')//Ê∏≤ÊüìÂÆåÊàêÊâç‰ºöËæìÂá∫log) this.setState((prevState, props) =&gt; &#123; return &#123; streak: prevState.streak + props.count &#125;&#125;) React ‰∏≠ refs ÁöÑ‰ΩúÁî® Refs ÊòØ React Êèê‰æõÁªôÁöÑËÉΩÂ§üÂÆâÂÖ®ËÆøÈóÆ DOM ÂÖÉÁ¥†ÊàñËÄÖÊüê‰∏™ÁªÑ‰ª∂ÂÆû‰æãÁöÑÂè•ÊüÑ ÂèØ‰ª•‰∏∫ÂÖÉÁ¥†Ê∑ªÂä†refÂ±ûÊÄßÔºåÁÑ∂ÂêéÂú®ÂõûË∞ÉÂáΩÊï∞‰∏≠Êé•ÂèóËØ•ÂÖÉÁ¥†Âú® DOM Ê†ë‰∏≠ÁöÑÂè•ÊüÑÔºåËØ•ÂÄº‰ºö‰Ωú‰∏∫ÂõûË∞ÉÂáΩÊï∞ÁöÑÁ¨¨‰∏Ä‰∏™ÂèÇÊï∞ËøîÂõû Âú®ÁîüÂëΩÂë®Êúü‰∏≠ÁöÑÂì™‰∏ÄÊ≠•Â∫îËØ•ÂèëËµ∑ AJAX ËØ∑Ê±Ç Â∫îÂ∞ÜAJAX ËØ∑Ê±ÇÊîæÂà∞ componentDidMount ÂáΩÊï∞‰∏≠ÊâßË°å React ‰∏ã‰∏Ä‰ª£Ë∞ÉÂíåÁÆóÊ≥ï Fiber ‰ºöÈÄöËøáÂºÄÂßãÊàñÂÅúÊ≠¢Ê∏≤ÊüìÁöÑÊñπÂºè‰ºòÂåñÂ∫îÁî®ÊÄßËÉΩÔºå‰ºöÂΩ±ÂìçÂà∞ componentWillMount ÁöÑËß¶ÂèëÊ¨°Êï∞Ôºå‰ºö‰ΩøÂæócomponentWillMount Ëøô‰∏™ÁîüÂëΩÂë®ÊúüÂáΩÊï∞ÁöÑË∞ÉÁî®Ê¨°Êï∞ÂèòÂæó‰∏çÁ°ÆÂÆö„ÄÇReact ÂèØËÉΩ‰ºöÂ§öÊ¨°È¢ëÁπÅË∞ÉÁî® componentWillMount„ÄÇÂ¶ÇÊûúÂ∞Ü AJAX ËØ∑Ê±ÇÊîæÂà∞ componentWillMount ÂáΩÊï∞‰∏≠ÔºåÈÇ£‰πà‰ºöË¢´Ëß¶ÂèëÂ§öÊ¨°Ôºå‰∏çÈááÁî®„ÄÇ Â¶ÇÊûúÊàë‰ª¨Â∞Ü AJAX ËØ∑Ê±ÇÊîæÁΩÆÂú®ÁîüÂëΩÂë®ÊúüÁöÑÂÖ∂‰ªñÂáΩÊï∞‰∏≠ÔºåÊàë‰ª¨Âπ∂‰∏çËÉΩ‰øùËØÅËØ∑Ê±Ç‰ªÖÂú®ÁªÑ‰ª∂ÊåÇËΩΩÂÆåÊØïÂêéÊâç‰ºöË¶ÅÊ±ÇÂìçÂ∫î„ÄÇÂ¶ÇÊûúÊàë‰ª¨ÁöÑÊï∞ÊçÆËØ∑Ê±ÇÂú®ÁªÑ‰ª∂ÊåÇËΩΩ‰πãÂâçÂ∞±ÂÆåÊàêÔºåÂπ∂‰∏îË∞ÉÁî®‰∫ÜsetStateÂáΩÊï∞Â∞ÜÊï∞ÊçÆÊ∑ªÂä†Âà∞ÁªÑ‰ª∂Áä∂ÊÄÅ‰∏≠ÔºåÂØπ‰∫éÊú™ÊåÇËΩΩÁöÑÁªÑ‰ª∂Âàô‰ºöÊä•Èîô„ÄÇËÄåÂú® componentDidMount ÂáΩÊï∞‰∏≠ËøõË°å AJAX ËØ∑Ê±ÇÂàôËÉΩÊúâÊïàÈÅøÂÖçËøô‰∏™ÈóÆÈ¢ò„ÄÇ React ‰∏≠ÁöÑ‰∫ã‰ª∂Â§ÑÁêÜÈÄªËæë ‰∏∫‰∫ÜËß£ÂÜ≥Ë∑®ÊµèËßàÂô®ÂÖºÂÆπÊÄßÈóÆÈ¢òÔºåReact Â∞ÜÊµèËßàÂô®ÂéüÁîü‰∫ã‰ª∂ÔºàBrowser Native EventÔºâÂ∞ÅË£Ö‰∏∫ÂêàÊàê‰∫ã‰ª∂ÔºàSyntheticEventÔºâ‰º†ÂÖ•ËÆæÁΩÆÁöÑ‰∫ã‰ª∂Â§ÑÁêÜÂô®‰∏≠„ÄÇÂêàÊàê‰∫ã‰ª∂Êèê‰æõ‰∫Ü‰∏éÂéüÁîü‰∫ã‰ª∂Áõ∏ÂêåÁöÑÊé•Âè£Ôºå‰∏çËøáÂÆÉ‰ª¨Â±èËîΩ‰∫ÜÂ∫ïÂ±ÇÊµèËßàÂô®ÁöÑÁªÜËäÇÂ∑ÆÂºÇÔºå‰øùËØÅ‰∫ÜË°å‰∏∫ÁöÑ‰∏ÄËá¥ÊÄßÔºõÂè¶Â§ñÔºåReact Âπ∂Ê≤°ÊúâÁõ¥Êé•Â∞Ü‰∫ã‰ª∂ÈôÑÁùÄÂà∞Â≠êÂÖÉÁ¥†‰∏äÔºåËÄåÊòØ‰ª•Âçï‰∏Ä‰∫ã‰ª∂ÁõëÂê¨Âô®ÁöÑÊñπÂºèÂ∞ÜÊâÄÊúâÁöÑ‰∫ã‰ª∂ÂèëÈÄÅÂà∞È°∂Â±ÇËøõË°åÂ§ÑÁêÜ„ÄÇËøôÊ†∑ React Âú®Êõ¥Êñ∞ DOM ÁöÑÊó∂ÂÄôÂ∞±‰∏çÈúÄË¶ÅËÄÉËôëÂ¶Ç‰ΩïÂéªÂ§ÑÁêÜÈôÑÁùÄÂú® DOM ‰∏äÁöÑ‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºåÊúÄÁªàËææÂà∞‰ºòÂåñÊÄßËÉΩÁöÑÁõÆÁöÑ„ÄÇ redux‰∏≠Èó¥‰ª∂ ‰∏≠Èó¥‰ª∂Êèê‰æõÁ¨¨‰∏âÊñπÊèí‰ª∂ÁöÑÊ®°ÂºèÔºåËá™ÂÆö‰πâÊã¶Êà™ action -&gt; reducer ÁöÑËøáÁ®ã„ÄÇÂèò‰∏∫ action -&gt; middlewares -&gt; reducer „ÄÇËøôÁßçÊú∫Âà∂ÂèØ‰ª•ÊîπÂèòÊï∞ÊçÆÊµÅÔºåÂÆûÁé∞Â¶ÇÂºÇÊ≠• action Ôºåaction ËøáÊª§ÔºåÊó•ÂøóËæìÂá∫ÔºåÂºÇÂ∏∏Êä•ÂëäÁ≠âÂäüËÉΩ„ÄÇ redux-loggerÔºöÊèê‰æõÊó•ÂøóËæìÂá∫ redux-thunkÔºöÂ§ÑÁêÜÂºÇÊ≠•Êìç‰Ωú redux-promiseÔºöÂ§ÑÁêÜÂºÇÊ≠•Êìç‰ΩúÔºåactionCreatorÁöÑËøîÂõûÂÄºÊòØpromise ‰∏∫‰ªÄ‰πàËôöÊãüdom‰ºöÊèêÈ´òÊÄßËÉΩ ËôöÊãüdomÁõ∏ÂΩì‰∫éÂú®jsÂíåÁúüÂÆûdom‰∏≠Èó¥Âä†‰∫Ü‰∏Ä‰∏™ÁºìÂ≠òÔºåÂà©Áî®dom diffÁÆóÊ≥ïÈÅøÂÖç‰∫ÜÊ≤°ÊúâÂøÖË¶ÅÁöÑdomÊìç‰ΩúÔºå‰ªéËÄåÊèêÈ´òÊÄßËÉΩ ÂÖ∑‰ΩìÂÆûÁé∞Ê≠•È™§Â¶Ç‰∏ã Áî® JavaScript ÂØπË±°ÁªìÊûÑË°®Á§∫ DOM Ê†ëÁöÑÁªìÊûÑÔºõÁÑ∂ÂêéÁî®Ëøô‰∏™Ê†ëÊûÑÂª∫‰∏Ä‰∏™ÁúüÊ≠£ÁöÑ DOM Ê†ëÔºåÊèíÂà∞ÊñáÊ°£ÂΩì‰∏≠„ÄÇ ÂΩìÁä∂ÊÄÅÂèòÊõ¥ÁöÑÊó∂ÂÄôÔºåÈáçÊñ∞ÊûÑÈÄ†‰∏ÄÊ£µÊñ∞ÁöÑÂØπË±°Ê†ë„ÄÇÁÑ∂ÂêéÁî®Êñ∞ÁöÑÊ†ëÂíåÊóßÁöÑÊ†ëËøõË°åÊØîËæÉÔºåËÆ∞ÂΩï‰∏§Ê£µÊ†ëÂ∑ÆÂºÇ„ÄÇ Êää2ÊâÄËÆ∞ÂΩïÁöÑÂ∑ÆÂºÇÂ∫îÁî®Âà∞Ê≠•È™§1ÊâÄÊûÑÂª∫ÁöÑÁúüÊ≠£ÁöÑDOMÊ†ë‰∏äÔºåËßÜÂõæÂ∞±Êõ¥Êñ∞„ÄÇ diffÁÆóÊ≥ï ÊääÊ†ëÂΩ¢ÁªìÊûÑÊåâÁÖßÂ±ÇÁ∫ßÂàÜËß£ÔºåÂè™ÊØîËæÉÂêåÁ∫ßÂÖÉÁ¥†„ÄÇ ÁªôÂàóË°®ÁªìÊûÑÁöÑÊØè‰∏™ÂçïÂÖÉÊ∑ªÂä†ÂîØ‰∏ÄÁöÑkeyÂ±ûÊÄßÔºåÊñπ‰æøÊØîËæÉ„ÄÇ React Âè™‰ºöÂåπÈÖçÁõ∏Âêå class ÁöÑ componentÔºàclassÊåáÁöÑÊòØÁªÑ‰ª∂ÁöÑÂêçÂ≠óÔºâ ÂêàÂπ∂Êìç‰ΩúÔºåË∞ÉÁî® component ÁöÑ setState ÊñπÊ≥ïÁöÑÊó∂ÂÄô, React Â∞ÜÂÖ∂Ê†áËÆ∞‰∏∫ - dirty„ÄÇÂà∞ÊØè‰∏Ä‰∏™‰∫ã‰ª∂Âæ™ÁéØÁªìÊùü, React ‰ºöÊ£ÄÊü•ÊâÄÊúâÊ†áËÆ∞ Ôºå‰ªÖÂ∞ÜÊ†áËÆ∞‰∏∫dirty ÁöÑ component ËøõË°åÈáçÊñ∞ÁªòÂà∂. ÈÄâÊã©ÊÄßÂú∞ËøõË°åÂ≠êÊ†ëÊ∏≤Êüì„ÄÇÂèØ‰ª•ÈáçÂÜôshouldComponentUpdate‰ªéËÄåÊèêÈ´òdiffÁöÑÊÄßËÉΩ","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 7 üí™","slug":"frontend-interview-07","date":"2020-06-26T12:05:35.000Z","updated":"2020-06-27T13:59:43.980Z","comments":true,"path":"2020/06/26/frontend-interview-07/","link":"","permalink":"WangHngLeee.github.io/2020/06/26/frontend-interview-07/","excerpt":"Ë∑®Âüü Âõ†‰∏∫ÊµèËßàÂô®Âá∫‰∫éÂÆâÂÖ®ËÄÉËôëÔºåÊúâÂêåÊ∫êÁ≠ñÁï•„ÄÇÂêåÊ∫êÁ≠ñÁï•Ë¶ÅÊ±ÇÂçèËÆÆÔºåÂüüÂêçÔºåÁ´ØÂè£ÂÖ®ÈÉ®Áõ∏ÂêåÔºåËã•Êúâ‰∏Ä‰∏™‰∏çÂêåÂ∞±ÊòØË∑®ÂüüÔºåÂàôAjax ËØ∑Ê±Ç‰ºöÂ§±Ë¥•„ÄÇ JSONP JSONP ÊòØÂà©Áî® &lt;script&gt; Ê†áÁ≠æÊ≤°ÊúâË∑®ÂüüÈôêÂà∂ÁöÑÊºèÊ¥ûÔºåÈÄöËøá &lt;script&gt; Ê†áÁ≠æÔºåÂΩìÈúÄË¶ÅÈÄöËÆØÊó∂ÔºåÊåáÂêë‰∏Ä‰∏™ÈúÄË¶ÅËÆøÈóÆÁöÑÂú∞ÂùÄÂπ∂Êèê‰æõ‰∏Ä‰∏™ÂõûË∞ÉÂáΩÊï∞Êù•Êé•Êî∂Êï∞ÊçÆ &lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt;","text":"Ë∑®Âüü Âõ†‰∏∫ÊµèËßàÂô®Âá∫‰∫éÂÆâÂÖ®ËÄÉËôëÔºåÊúâÂêåÊ∫êÁ≠ñÁï•„ÄÇÂêåÊ∫êÁ≠ñÁï•Ë¶ÅÊ±ÇÂçèËÆÆÔºåÂüüÂêçÔºåÁ´ØÂè£ÂÖ®ÈÉ®Áõ∏ÂêåÔºåËã•Êúâ‰∏Ä‰∏™‰∏çÂêåÂ∞±ÊòØË∑®ÂüüÔºåÂàôAjax ËØ∑Ê±Ç‰ºöÂ§±Ë¥•„ÄÇ JSONP JSONP ÊòØÂà©Áî® &lt;script&gt; Ê†áÁ≠æÊ≤°ÊúâË∑®ÂüüÈôêÂà∂ÁöÑÊºèÊ¥ûÔºåÈÄöËøá &lt;script&gt; Ê†áÁ≠æÔºåÂΩìÈúÄË¶ÅÈÄöËÆØÊó∂ÔºåÊåáÂêë‰∏Ä‰∏™ÈúÄË¶ÅËÆøÈóÆÁöÑÂú∞ÂùÄÂπ∂Êèê‰æõ‰∏Ä‰∏™ÂõûË∞ÉÂáΩÊï∞Êù•Êé•Êî∂Êï∞ÊçÆ &lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; JSONP ‰ΩøÁî®ÁÆÄÂçï‰∏îÂÖºÂÆπÊÄß‰∏çÈîôÔºå‰ΩÜÊòØÂè™Èôê‰∫é get ËØ∑Ê±Ç CORS CORSÈúÄË¶ÅÊµèËßàÂô®ÂíåÂêéÁ´ØÂêåÊó∂ÊîØÊåÅ ÊµèËßàÂô®‰ºöËá™Âä®ËøõË°å CORS ÈÄö‰ø°ÔºåÂÆûÁé∞CORSÈÄö‰ø°ÁöÑÂÖ≥ÈîÆÊòØÂêéÁ´Ø„ÄÇÂè™Ë¶ÅÂêéÁ´ØÂÆûÁé∞‰∫Ü CORSÔºåÂ∞±ÂÆûÁé∞‰∫ÜË∑®Âüü„ÄÇ ÊúçÂä°Á´ØËÆæÁΩÆ Access-Control-Allow-Origin Â∞±ÂèØ‰ª•ÂºÄÂêØ CORS„ÄÇ ËØ•Â±ûÊÄßË°®Á§∫Âì™‰∫õÂüüÂêçÂèØ‰ª•ËÆøÈóÆËµÑÊ∫êÔºåÂ¶ÇÊûúËÆæÁΩÆÈÄöÈÖçÁ¨¶ÂàôË°®Á§∫ÊâÄÊúâÁΩëÁ´ôÈÉΩÂèØ‰ª•ËÆøÈóÆËµÑÊ∫ê document.domain ËØ•ÊñπÂºèÂè™ËÉΩÁî®‰∫é‰∫åÁ∫ßÂüüÂêçÁõ∏ÂêåÁöÑÊÉÖÂÜµ‰∏ãÔºåÊØîÂ¶Ç a.test.com Âíå b.test.com ÈÄÇÁî®‰∫éËØ•ÊñπÂºè„ÄÇ Âè™ÈúÄË¶ÅÁªôÈ°µÈù¢Ê∑ªÂä† document.domain = 'test.com' Ë°®Á§∫‰∫åÁ∫ßÂüüÂêçÈÉΩÁõ∏ÂêåÂ∞±ÂèØ‰ª•ÂÆûÁé∞Ë∑®Âüü postMessage ËøôÁßçÊñπÂºèÈÄöÂ∏∏Áî®‰∫éËé∑ÂèñÂµåÂÖ•È°µÈù¢‰∏≠ÁöÑÁ¨¨‰∏âÊñπÈ°µÈù¢Êï∞ÊçÆ„ÄÇ‰∏Ä‰∏™È°µÈù¢ÂèëÈÄÅÊ∂àÊÅØÔºåÂè¶‰∏Ä‰∏™È°µÈù¢Âà§Êñ≠Êù•Ê∫êÂπ∂Êé•Êî∂Ê∂àÊÅØ // ÂèëÈÄÅÊ∂àÊÅØÁ´Øwindow.parent.postMessage('message', 'http://blog.poetries.com');// Êé•Êî∂Ê∂àÊÅØÁ´Øvar mc = new MessageChannel();mc.addEventListener('message', (event) =&gt; &#123; var origin = event.origin || event.originalEvent.origin; if (origin === 'http://blog.poetries.com') &#123; console.log('È™åËØÅÈÄöËøá') &#125;&#125;); Event loop JS‰∏≠ÁöÑevent loop JS ÊòØÈó®ÈùûÈòªÂ°ûÂçïÁ∫øÁ®ãËØ≠Ë®ÄÔºåÂõ†‰∏∫Âú®ÊúÄÂàù JS Â∞±ÊòØ‰∏∫‰∫ÜÂíåÊµèËßàÂô®‰∫§‰∫íËÄåËØûÁîüÁöÑ„ÄÇÂ¶ÇÊûú JS ÊòØÈó®Â§öÁ∫øÁ®ãÁöÑËØ≠Ë®ÄËØùÔºåÂú®Â§ö‰∏™Á∫øÁ®ã‰∏≠Â§ÑÁêÜ DOM Â∞±ÂèØËÉΩ‰ºöÂèëÁîüÈóÆÈ¢òÔºà‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Êñ∞Âä†ËäÇÁÇπÔºåÂè¶‰∏Ä‰∏™Á∫øÁ®ã‰∏≠Âà†Èô§ËäÇÁÇπÔºâ JS Âú®ÊâßË°åÁöÑËøáÁ®ã‰∏≠‰ºö‰∫ßÁîüÊâßË°åÁéØÂ¢ÉÔºåËøô‰∫õÊâßË°åÁéØÂ¢É‰ºöË¢´È°∫Â∫èÁöÑÂä†ÂÖ•Âà∞ÊâßË°åÊ†à‰∏≠„ÄÇÂ¶ÇÊûúÈÅáÂà∞ÂºÇÊ≠•ÁöÑ‰ª£Á†ÅÔºå‰ºöË¢´ÊåÇËµ∑Âπ∂Âä†ÂÖ•Âà∞ TaskÔºàÊúâÂ§öÁßç taskÔºâ ÈòüÂàó‰∏≠„ÄÇ‰∏ÄÊó¶ÊâßË°åÊ†à‰∏∫Á©∫ÔºåEvent Loop Â∞±‰ºö‰ªé Task ÈòüÂàó‰∏≠ÊãøÂá∫ÈúÄË¶ÅÊâßË°åÁöÑ‰ª£Á†ÅÂπ∂ÊîæÂÖ•ÊâßË°åÊ†à‰∏≠ÊâßË°åÔºåÊâÄ‰ª•Êú¨Ë¥®‰∏äÊù•ËØ¥ JS ‰∏≠ÁöÑÂºÇÊ≠•ËøòÊòØÂêåÊ≠•Ë°å‰∏∫ console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);console.log('script end'); ‰∏çÂêåÁöÑ‰ªªÂä°Ê∫ê‰ºöË¢´ÂàÜÈÖçÂà∞‰∏çÂêåÁöÑ Task ÈòüÂàó‰∏≠Ôºå‰ªªÂä°Ê∫êÂèØ‰ª•ÂàÜ‰∏∫ ÂæÆ‰ªªÂä°ÔºàmicrotaskÔºâ Âíå ÂÆè‰ªªÂä°ÔºàmacrotaskÔºâ„ÄÇÂú® ES6 ËßÑËåÉ‰∏≠Ôºåmicrotask Áß∞‰∏∫ jobsÔºåmacrotask Áß∞‰∏∫ task console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);new Promise((resolve) =&gt; &#123; console.log('Promise') resolve()&#125;).then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout ‰ª•‰∏ä‰ª£Á†ÅËôΩÁÑ∂ setTimeout ÂÜôÂú® Promise ‰πãÂâçÔºå‰ΩÜÊòØÂõ†‰∏∫ Promise Â±û‰∫éÂæÆ‰ªªÂä°ËÄå setTimeout Â±û‰∫éÂÆè‰ªªÂä° ÂæÆ‰ªªÂä° process.nextTick promise Object.observe MutationObserver ÂÆè‰ªªÂä° script setTimeout setInterval setImmediate I/O UI rendering ÂÆè‰ªªÂä°‰∏≠ÂåÖÊã¨‰∫Ü script ÔºåÊµèËßàÂô®‰ºöÂÖàÊâßË°å‰∏Ä‰∏™ÂÆè‰ªªÂä°ÔºåÊé•‰∏ãÊù•ÊúâÂºÇÊ≠•‰ª£Á†ÅÁöÑËØùÂ∞±ÂÖàÊâßË°åÂæÆ‰ªªÂä° Ê≠£Á°ÆÁöÑEvent loop È°∫Â∫è ÊâßË°åÂêåÊ≠•‰ª£Á†ÅÔºåËøôÂ±û‰∫éÂÆè‰ªªÂä° ÊâßË°åÊ†à‰∏∫Á©∫ÔºåÊü•ËØ¢ÊòØÂê¶ÊúâÂæÆ‰ªªÂä°ÈúÄË¶ÅÊâßË°å ÊâßË°åÊâÄÊúâÂæÆ‰ªªÂä° ÂøÖË¶ÅÁöÑËØùÊ∏≤Êüì UI ÁÑ∂ÂêéÂºÄÂßã‰∏ã‰∏ÄËΩÆ Event loopÔºåÊâßË°åÂÆè‰ªªÂä°‰∏≠ÁöÑÂºÇÊ≠•‰ª£Á†Å Â¶ÇÊûúÂÆè‰ªªÂä°‰∏≠ÁöÑÂºÇÊ≠•‰ª£Á†ÅÊúâÂ§ßÈáèÁöÑËÆ°ÁÆóÂπ∂‰∏îÈúÄË¶ÅÊìç‰Ωú DOM ÁöÑËØùÔºå‰∏∫‰∫ÜÊõ¥Âø´ÁöÑÂìçÂ∫îÁïåÈù¢ÂìçÂ∫îÔºåÂèØ‰ª•ÊääÊìç‰Ωú DOM ÊîæÂÖ•ÂæÆ‰ªªÂä°‰∏≠ Node ‰∏≠ÁöÑ Event loop Node ‰∏≠ÁöÑ Event loop ÂíåÊµèËßàÂô®‰∏≠ÁöÑ‰∏çÁõ∏Âêå„ÄÇ Node ÁöÑ Event loop ÂàÜ‰∏∫6‰∏™Èò∂ÊÆµÔºåÂÆÉ‰ª¨‰ºöÊåâÁÖßÈ°∫Â∫èÂèçÂ§çËøêË°å ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ&gt;‚îÇ timers ‚îÇ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ ‚îÇ I/O callbacks ‚îÇ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ ‚îÇ idle, prepare ‚îÇ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ incoming: ‚îÇ‚îÇ ‚îÇ poll ‚îÇ&lt;‚îÄ‚îÄconnections‚îÄ‚îÄ‚îÄ ‚îÇ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ data, etc. ‚îÇ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ ‚îÇ check ‚îÇ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îî‚îÄ‚îÄ‚î§ close callbacks ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò timer timers Èò∂ÊÆµ‰ºöÊâßË°å setTimeout Âíå setInterval ‰∏Ä‰∏™ timer ÊåáÂÆöÁöÑÊó∂Èó¥Âπ∂‰∏çÊòØÂáÜÁ°ÆÊó∂Èó¥ÔºåËÄåÊòØÂú®ËææÂà∞Ëøô‰∏™Êó∂Èó¥ÂêéÂ∞ΩÂø´ÊâßË°åÂõûË∞ÉÔºåÂèØËÉΩ‰ºöÂõ†‰∏∫Á≥ªÁªüÊ≠£Âú®ÊâßË°åÂà´ÁöÑ‰∫ãÂä°ËÄåÂª∂Ëøü I/O I/O Èò∂ÊÆµ‰ºöÊâßË°åÈô§‰∫Ü close ‰∫ã‰ª∂ÔºåÂÆöÊó∂Âô®Âíå setImmediate ÁöÑÂõûË∞É poll poll Èò∂ÊÆµÂæàÈáçË¶ÅÔºåËøô‰∏ÄÈò∂ÊÆµ‰∏≠ÔºåÁ≥ªÁªü‰ºöÂÅö‰∏§‰ª∂‰∫ãÊÉÖ ÊâßË°åÂà∞ÁÇπÁöÑÂÆöÊó∂Âô® ÊâßË°å poll ÈòüÂàó‰∏≠ÁöÑ‰∫ã‰ª∂ Âπ∂‰∏îÂΩì poll ‰∏≠Ê≤°ÊúâÂÆöÊó∂Âô®ÁöÑÊÉÖÂÜµ‰∏ãÔºå‰ºöÂèëÁé∞‰ª•‰∏ã‰∏§‰ª∂‰∫ãÊÉÖ Â¶ÇÊûú poll ÈòüÂàó‰∏ç‰∏∫Á©∫Ôºå‰ºöÈÅçÂéÜÂõûË∞ÉÈòüÂàóÂπ∂ÂêåÊ≠•ÊâßË°åÔºåÁõ¥Âà∞ÈòüÂàó‰∏∫Á©∫ÊàñËÄÖÁ≥ªÁªüÈôêÂà∂ Â¶ÇÊûú poll ÈòüÂàó‰∏∫Á©∫Ôºå‰ºöÊúâ‰∏§‰ª∂‰∫ãÂèëÁîü Â¶ÇÊûúÊúâ setImmediate ÈúÄË¶ÅÊâßË°åÔºåpoll Èò∂ÊÆµ‰ºöÂÅúÊ≠¢Âπ∂‰∏îËøõÂÖ•Âà∞ check Èò∂ÊÆµÊâßË°å setImmediate Â¶ÇÊûúÊ≤°Êúâ setImmediate ÈúÄË¶ÅÊâßË°åÔºå‰ºöÁ≠âÂæÖÂõûË∞ÉË¢´Âä†ÂÖ•Âà∞ÈòüÂàó‰∏≠Âπ∂Á´ãÂç≥ÊâßË°åÂõûË∞É Â¶ÇÊûúÊúâÂà´ÁöÑÂÆöÊó∂Âô®ÈúÄË¶ÅË¢´ÊâßË°åÔºå‰ºöÂõûÂà∞ timer Èò∂ÊÆµÊâßË°åÂõûË∞É„ÄÇ check check Èò∂ÊÆµÊâßË°å setImmediate close callbacks close callbacks Èò∂ÊÆµÊâßË°å close ‰∫ã‰ª∂ Âπ∂‰∏îÂú® Node ‰∏≠ÔºåÊúâ‰∫õÊÉÖÂÜµ‰∏ãÁöÑÂÆöÊó∂Âô®ÊâßË°åÈ°∫Â∫èÊòØÈöèÊú∫ÁöÑ setTimeout(() =&gt; &#123; console.log('setTimeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('setImmediate');&#125;)// ËøôÈáåÂèØËÉΩ‰ºöËæìÂá∫ setTimeoutÔºåsetImmediate// ÂèØËÉΩ‰πü‰ºöÁõ∏ÂèçÁöÑËæìÂá∫ÔºåËøôÂèñÂÜ≥‰∫éÊÄßËÉΩ// Âõ†‰∏∫ÂèØËÉΩËøõÂÖ• event loop Áî®‰∫Ü‰∏çÂà∞ 1 ÊØ´ÁßíÔºåËøôÊó∂ÂÄô‰ºöÊâßË°å setImmediate// Âê¶Âàô‰ºöÊâßË°å setTimeout ‰∏äÈù¢‰ªãÁªçÁöÑÈÉΩÊòØ macrotask ÁöÑÊâßË°åÊÉÖÂÜµÔºåmicrotask ‰ºöÂú®‰ª•‰∏äÊØè‰∏™Èò∂ÊÆµÂÆåÊàêÂêéÁ´ãÂç≥ÊâßË°å setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)// ‰ª•‰∏ä‰ª£Á†ÅÂú®ÊµèËßàÂô®Âíå node ‰∏≠ÊâìÂç∞ÊÉÖÂÜµÊòØ‰∏çÂêåÁöÑ// ÊµèËßàÂô®‰∏≠‰∏ÄÂÆöÊâìÂç∞ timer1, promise1, timer2, promise2// node ‰∏≠ÂèØËÉΩÊâìÂç∞ timer1, timer2, promise1, promise2// ‰πüÂèØËÉΩÊâìÂç∞ timer1, promise1, timer2, promise2 Node ‰∏≠ÁöÑ process.nextTick ‰ºöÂÖà‰∫éÂÖ∂‰ªñ microtask ÊâßË°å setTimeout(() =&gt; &#123; console.log(\"timer1\"); Promise.resolve().then(function() &#123; console.log(\"promise1\"); &#125;);&#125;, 0);process.nextTick(() =&gt; &#123; console.log(\"nextTick\");&#125;);// nextTick, timer1, promise1","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 6 üí™","slug":"frontend-interview-06","date":"2020-06-24T12:05:35.000Z","updated":"2020-06-26T18:23:52.348Z","comments":true,"path":"2020/06/24/frontend-interview-06/","link":"","permalink":"WangHngLeee.github.io/2020/06/24/frontend-interview-06/","excerpt":"JS ËøôÂá†Â§©Â§ç‰π†‰∫Ü‰∏Ä‰∏ãJSÁöÑÁü•ËØÜÔºåÂèëÁé∞Êúâ‰∫õÁü•ËØÜÁÇπÂèòÊ®°Á≥ä‰∫ÜÔºå‰∫éÊòØÊâìÁÆóÂÜô‰∏ÄÁØáJSÂ∏∏ËßÅÈóÆÈ¢òÁöÑÊÄªÁªìÂ∏ñÂ∑©Âõ∫‰∏Ä‰∏ã„ÄÇ JSÈáåÁöÑÊ∑±ÊµÖÊã∑Ë¥ù letet a a = &#123; age : 1&#125;let b = aa.age = 2console.log(b.age) // ËæìÂá∫‰∏∫2 ‰∏äËø∞‰æãÂ≠êÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁªô‰∏Ä‰∏™ÂèòÈáèËµãÂÄº‰∏Ä‰∏™ÂØπË±°ÔºåÈÇ£‰πà‰∏§ËÄÖÁöÑÂÄº‰ºöÊòØÂêå‰∏Ä‰∏™ÂºïÁî®ÔºåÂÖ∂‰∏≠‰∏ÄÊñπÊîπÂèòÔºåÂè¶‰∏ÄÊñπ‰πü‰ºöÁõ∏Â∫îÊîπÂèò„ÄÇ ÈÄöÂ∏∏Âú®ÂºÄÂèë‰∏≠Âπ∂‰∏çÂ∏åÊúõÂá∫Áé∞ËøôÊ†∑ÁöÑÈóÆÈ¢òÔºå‰∫éÊòØÊµÖÊã∑Ë¥ùÂ∞±ÂèØ‰ª•Êù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò ÊµÖÊã∑Ë¥ù È¶ñÂÖàÂèØ‰ª•ÈÄöËøá Object.assign Êù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) // 1 ‰πüÂèØ‰ª•ÈÄöËøáÂ±ïÂºÄËøêÁÆóÁ¨¶Ôºà‚Ä¶ÔºâÊù•Ëß£ÂÜ≥ let a = &#123; age: 1&#125;let b = &#123;...a&#125;a.age = 2console.log(b.age) // 1 ÈÄöÂ∏∏ÊµÖÊã∑Ë¥ùÂ∞±ËÉΩËß£ÂÜ≥Â§ßÈÉ®ÂàÜÈóÆÈ¢ò‰∫ÜÔºå‰ΩÜÊòØÂΩìÈÅáÂà∞Â¶Ç‰∏ãÊÉÖÂÜµÂ∞±ÈúÄË¶Å‰ΩøÁî®Âà∞Ê∑±Êã∑Ë¥ù‰∫Ü","text":"JS ËøôÂá†Â§©Â§ç‰π†‰∫Ü‰∏Ä‰∏ãJSÁöÑÁü•ËØÜÔºåÂèëÁé∞Êúâ‰∫õÁü•ËØÜÁÇπÂèòÊ®°Á≥ä‰∫ÜÔºå‰∫éÊòØÊâìÁÆóÂÜô‰∏ÄÁØáJSÂ∏∏ËßÅÈóÆÈ¢òÁöÑÊÄªÁªìÂ∏ñÂ∑©Âõ∫‰∏Ä‰∏ã„ÄÇ JSÈáåÁöÑÊ∑±ÊµÖÊã∑Ë¥ù letet a a = &#123; age : 1&#125;let b = aa.age = 2console.log(b.age) // ËæìÂá∫‰∏∫2 ‰∏äËø∞‰æãÂ≠êÂèØ‰ª•ÂèëÁé∞ÔºåÂ¶ÇÊûúÁªô‰∏Ä‰∏™ÂèòÈáèËµãÂÄº‰∏Ä‰∏™ÂØπË±°ÔºåÈÇ£‰πà‰∏§ËÄÖÁöÑÂÄº‰ºöÊòØÂêå‰∏Ä‰∏™ÂºïÁî®ÔºåÂÖ∂‰∏≠‰∏ÄÊñπÊîπÂèòÔºåÂè¶‰∏ÄÊñπ‰πü‰ºöÁõ∏Â∫îÊîπÂèò„ÄÇ ÈÄöÂ∏∏Âú®ÂºÄÂèë‰∏≠Âπ∂‰∏çÂ∏åÊúõÂá∫Áé∞ËøôÊ†∑ÁöÑÈóÆÈ¢òÔºå‰∫éÊòØÊµÖÊã∑Ë¥ùÂ∞±ÂèØ‰ª•Êù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò ÊµÖÊã∑Ë¥ù È¶ñÂÖàÂèØ‰ª•ÈÄöËøá Object.assign Êù•Ëß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) // 1 ‰πüÂèØ‰ª•ÈÄöËøáÂ±ïÂºÄËøêÁÆóÁ¨¶Ôºà‚Ä¶ÔºâÊù•Ëß£ÂÜ≥ let a = &#123; age: 1&#125;let b = &#123;...a&#125;a.age = 2console.log(b.age) // 1 ÈÄöÂ∏∏ÊµÖÊã∑Ë¥ùÂ∞±ËÉΩËß£ÂÜ≥Â§ßÈÉ®ÂàÜÈóÆÈ¢ò‰∫ÜÔºå‰ΩÜÊòØÂΩìÈÅáÂà∞Â¶Ç‰∏ãÊÉÖÂÜµÂ∞±ÈúÄË¶Å‰ΩøÁî®Âà∞Ê∑±Êã∑Ë¥ù‰∫Ü let a = &#123; age: 1, jobs: &#123; first: 'FE' &#125;&#125;let b = &#123;...a&#125;a.jobs.first = 'native'console.log(b.jobs.first) // native ÊµÖÊã∑Ë¥ùÂè™ËÉΩËß£ÂÜ≥‰∏ÄÂ±ÇÊï∞ÊçÆÁöÑÈóÆÈ¢òÔºåÂ¶ÇÊûúÊé•‰∏ãÂéªÁöÑÂÄº‰∏≠ËøòÊúâÂØπË±°ÁöÑËØùÔºåÈÇ£‰πàÂ∞±ÂèàÂõûÂà∞ÂéüÊù•ÁöÑÈóÆÈ¢ò‰∫ÜÔºå‰∏§ËÄÖ‰∫´ÊúâÁõ∏ÂêåÁöÑÂºïÁî®„ÄÇË¶ÅËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢òÔºåÈúÄË¶Å‰ΩøÁî®Ê∑±Êã∑Ë¥ù„ÄÇ Ê∑±Êã∑Ë¥ù Ëøô‰∏™ÈóÆÈ¢òÈÄöÂ∏∏ÂèØ‰ª•ÈÄöËøá JSON.parse(JSON.stringify(object)) Êù•Ëß£ÂÜ≥ let a = &#123; age: 1, jobs: &#123; first: 'FE' &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first) // FE Â∞ÜÂØπË±°ÊâÄÊúâÁöÑÂÜÖÂÆπÂèòÊàêJSONÊ†ºÂºèÔºåÂÜçËß£ÊûêJSONÂá∫Êù•Âç≥ÂèØ„ÄÇ‰ΩÜÊòØËØ•ÊñπÊ≥ï‰πüÊòØÊúâÂ±ÄÈôêÊÄßÁöÑÔºö ‰ºöÂøΩÁï• undefined ‰∏çËÉΩÂ∫èÂàóÂåñÂáΩÊï∞ ‰∏çËÉΩËß£ÂÜ≥Âæ™ÁéØÂºïÁî®ÁöÑÂØπË±° let obj = &#123; a: 1, b: &#123; c: 2, d: 3, &#125;,&#125;obj.c = obj.bobj.e = obj.aobj.b.c = obj.cobj.b.d = obj.bobj.b.e = obj.b.clet newObj = JSON.parse(JSON.stringify(obj))console.log(newObj) Â¶ÇÊûúÊúâ‰∏Ä‰∏™Âæ™ÁéØÂºïÁî®ÂØπË±°Ôºå‰ºöÂèëÁé∞Âπ∂‰∏çËÉΩÈÄöËøáËØ•ÊñπÊ≥ïÊ∑±Êã∑Ë¥ù Âú®ÈÅáÂà∞ÂáΩÊï∞ÊàñËÄÖ undefined ÁöÑÊó∂ÂÄôÔºåËØ•ÂØπË±°‰πü‰∏çËÉΩÊ≠£Â∏∏ÁöÑÂ∫èÂàóÂåñ let a = &#123; age: undefined, jobs: function() &#123;&#125;, name: 'poetries'&#125;let b = JSON.parse(JSON.stringify(a))console.log(b) // &#123;name: \"poetries\"&#125; Âú®‰∏äËø∞ÊÉÖÂÜµ‰∏≠ÔºåËØ•ÊñπÊ≥ï‰ºöÂøΩÁï•ÊéâÂáΩÊï∞Âíåundefined„ÄÇ ‰ΩÜÊòØÂú®ÈÄöÂ∏∏ÊÉÖÂÜµ‰∏ãÔºåÂ§çÊùÇÊï∞ÊçÆÈÉΩÊòØÂèØ‰ª•Â∫èÂàóÂåñÁöÑÔºåÊâÄ‰ª•JSON.parseÂíåJSON.stringifyÂáΩÊï∞ÂèØ‰ª•Ëß£ÂÜ≥Â§ßÈÉ®ÂàÜÈóÆÈ¢òÔºåÂπ∂‰∏îËØ•ÂáΩÊï∞ÊòØÂÜÖÁΩÆÂáΩÊï∞‰∏≠Â§ÑÁêÜÊ∑±Êã∑Ë¥ùÊÄßËÉΩÊúÄÂø´ÁöÑ„ÄÇÂ¶ÇÊûúÊï∞ÊçÆ‰∏≠Âê´Êúâ‰ª•‰∏ä‰∏âÁßçÊÉÖÂÜµ‰∏ãÔºåÂèØ‰ª•‰ΩøÁî® lodash ÁöÑÊ∑±Êã∑Ë¥ùÂáΩÊï∞„ÄÇ ÂéüÂûãÈóÆÈ¢ò ÊØè‰∏™ÂáΩÊï∞ÈÉΩÊúâ prototype Â±ûÊÄßÔºåÈô§‰∫Ü Function.prototype.bind()ÔºåËØ•Â±ûÊÄßÊåáÂêëÂéüÂûã„ÄÇ ÊØè‰∏™ÂØπË±°ÈÉΩÊúâ __proto__ Â±ûÊÄßÔºåÊåáÂêë‰∫ÜÂàõÂª∫ËØ•ÂØπË±°ÁöÑÊûÑÈÄ†ÂáΩÊï∞ÁöÑÂéüÂûã„ÄÇÂÖ∂ÂÆûËøô‰∏™Â±ûÊÄßÊåáÂêë‰∫Ü [[prototype]]Ôºå‰ΩÜÊòØ [[prototype]] ÊòØÂÜÖÈÉ®Â±ûÊÄßÔºåÊàë‰ª¨Âπ∂‰∏çËÉΩËÆøÈóÆÂà∞ÔºåÊâÄ‰ª•‰ΩøÁî® _proto_ Êù•ËÆøÈóÆ„ÄÇ ÂØπË±°ÂèØ‰ª•ÈÄöËøá __proto__ Êù•ÂØªÊâæ‰∏çÂ±û‰∫éËØ•ÂØπË±°ÁöÑÂ±ûÊÄßÔºå__proto__ Â∞ÜÂØπË±°ËøûÊé•Ëµ∑Êù•ÁªÑÊàê‰∫ÜÂéüÂûãÈìæ instanceof Âíå typeof ÁöÑÂå∫Âà´ typeof typeof ÂØπ‰∫éÂü∫Êú¨Á±ªÂûãÔºåÈô§‰∫Ü null ÈÉΩÂèØ‰ª•ÊòæÁ§∫Ê≠£Á°ÆÁöÑÁ±ªÂûã typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol'typeof b // b Ê≤°ÊúâÂ£∞ÊòéÔºå‰ΩÜÊòØËøò‰ºöÊòæÁ§∫ undefined typeof ÂØπ‰∫éÂØπË±°ÔºåÈô§‰∫ÜÂáΩÊï∞ÈÉΩ‰ºöÊòæÁ§∫ object typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console.log // 'function' ÂØπ‰∫é null Êù•ËØ¥ÔºåËôΩÁÑ∂ÂÆÉÊòØÂü∫Êú¨Á±ªÂûãÔºå‰ΩÜÊòØ‰ºöÊòæÁ§∫ objectÔºåËøôÊòØ‰∏Ä‰∏™Â≠òÂú®Âæà‰πÖ‰∫ÜÁöÑ bug typeof null // &apos;object&apos; ÂéüÂõ†ÔºöÂõ†‰∏∫Âú® JS ÁöÑÊúÄÂàùÁâàÊú¨‰∏≠Ôºå‰ΩøÁî®ÁöÑÊòØ 32 ‰ΩçÁ≥ªÁªüÔºå‰∏∫‰∫ÜÊÄßËÉΩËÄÉËôë‰ΩøÁî®‰Ωé‰ΩçÂ≠òÂÇ®‰∫ÜÂèòÈáèÁöÑÁ±ªÂûã‰ø°ÊÅØÔºå000 ÂºÄÂ§¥‰ª£Ë°®ÊòØÂØπË±°ÔºåÁÑ∂ËÄå null Ë°®Á§∫‰∏∫ÂÖ®Èõ∂ÔºåÊâÄ‰ª•Â∞ÜÂÆÉÈîôËØØÁöÑÂà§Êñ≠‰∏∫ object „ÄÇËôΩÁÑ∂Áé∞Âú®ÁöÑÂÜÖÈÉ®Á±ªÂûãÂà§Êñ≠‰ª£Á†ÅÂ∑≤ÁªèÊîπÂèò‰∫ÜÔºå‰ΩÜÊòØÂØπ‰∫éËøô‰∏™bugÂç¥ÊòØ‰∏ÄÁõ¥ÊµÅ‰º†‰∏ãÊù•„ÄÇ Â¶ÇÊûúÊÉ≥Ëé∑Âæó‰∏Ä‰∏™ÂèòÈáèÁöÑÊ≠£Á°ÆÁ±ªÂûãÔºåÂèØ‰ª•ÈÄöËøá Object.prototype.toString.call(xxxx)„ÄÇËøôÊ†∑Â∞±ÂèØ‰ª•Ëé∑ÂæóÁ±ª‰ºº [object Type] ÁöÑÂ≠óÁ¨¶‰∏≤ var a = \"hello world\";var b = [];var c = function()&#123;&#125;;console.log( object.prototype.toString.call( a ) );console.log( object.prototype.toString.call( b ) );console.log( object.prototype.toString.call( c ) );//ÁªìÊûú[object String];[object Array];[object Function];Âõ†Ê≠§,ÊÉ≥Ë¶ÅÂæóÂà∞ÂÖ∑‰ΩìÁöÑÁ±ªÂûãÂèØ‰ª•Â≠óÁ¨¶‰∏≤Êà™ÂèñÔºö console.log( object.prototype.toString.call( a ).slice( 8, -1) );ÁªìÊûú: String let a// ‰πüÂèØ‰ª•ËøôÊ†∑Âà§Êñ≠ undefineda === undefined// ‰ΩÜÊòØ undefined ‰∏çÊòØ‰øùÁïôÂ≠óÔºåËÉΩÂ§üÂú®‰ΩéÁâàÊú¨ÊµèËßàÂô®Ë¢´ËµãÂÄºlet undefined = 1// ËøôÊ†∑Âà§Êñ≠Â∞±‰ºöÂá∫Èîô// ÊâÄ‰ª•ÂèØ‰ª•Áî®‰∏ãÈù¢ÁöÑÊñπÂºèÊù•Âà§Êñ≠ÔºåÂπ∂‰∏î‰ª£Á†ÅÈáèÊõ¥Â∞ë// Âõ†‰∏∫ void ÂêéÈù¢Èöè‰æøË∑ü‰∏ä‰∏Ä‰∏™ÁªÑÊàêË°®ËææÂºè// ËøîÂõûÂ∞±ÊòØ undefineda === void 0 instanceof instanceof ÂèØ‰ª•Ê≠£Á°ÆÁöÑÂà§Êñ≠ÂØπË±°ÁöÑÁ±ªÂûãÔºåÂõ†‰∏∫ÂÜÖÈÉ®Êú∫Âà∂ÊòØÈÄöËøáÂà§Êñ≠ÂØπË±°ÁöÑÂéüÂûãÈìæ‰∏≠ÊòØ‰∏çÊòØËÉΩÊâæÂà∞Á±ªÂûãÁöÑ prototype function Foo() &#123;&#125;function Bar() &#123;&#125;Bar.prototype = new Foo();new Bar() instanceof Bar; // truenew Bar() instanceof Foo; // true// Â¶ÇÊûú‰ªÖ‰ªÖËÆæÁΩÆ Bar.prototype ‰∏∫ÂáΩÊï∞ Foo Êú¨Ë∫´ÔºåËÄå‰∏çÊòØ Foo ÊûÑÈÄ†ÂáΩÊï∞ÁöÑ‰∏Ä‰∏™ÂÆû‰æãBar.prototype = Foo;new Bar() instanceof Foo; // false Èó≠ÂåÖ Èó≠ÂåÖÁöÑÂÆö‰πâÂæàÁÆÄÂçïÔºöÂáΩÊï∞ A ËøîÂõû‰∫Ü‰∏Ä‰∏™ÂáΩÊï∞ BÔºåÂπ∂‰∏îÂáΩÊï∞ B ‰∏≠‰ΩøÁî®‰∫ÜÂáΩÊï∞ A ÁöÑÂèòÈáèÔºåÂáΩÊï∞ B Â∞±Ë¢´Áß∞‰∏∫Èó≠ÂåÖ„ÄÇ function A() &#123; let a = 1 function B() &#123; console.log(a) &#125; return B&#125; ‰∏∫‰ªÄ‰πàÂáΩÊï∞ A Â∑≤ÁªèÂºπÂá∫Ë∞ÉÁî®Ê†à‰∫ÜÔºå‰∏∫‰ªÄ‰πàÂáΩÊï∞ B ËøòËÉΩÂºïÁî®Âà∞ÂáΩÊï∞ A ‰∏≠ÁöÑÂèòÈáèÔºü Âõ†‰∏∫ÂáΩÊï∞ A ‰∏≠ÁöÑÂèòÈáèËøôÊó∂ÂÄôÊòØÂ≠òÂÇ®Âú®Â†Ü‰∏äÁöÑ„ÄÇÁé∞Âú®ÁöÑ JS ÂºïÊìéÂèØ‰ª•ÈÄöËøáÈÄÉÈÄ∏ÂàÜÊûêËæ®Âà´Âá∫Âì™‰∫õÂèòÈáèÈúÄË¶ÅÂ≠òÂÇ®Âú®Â†Ü‰∏äÔºåÂì™‰∫õÈúÄË¶ÅÂ≠òÂÇ®Âú®Ê†à‰∏ä„ÄÇ ÁªèÂÖ∏‰∏≠ÁöÑÁªèÂÖ∏Èù¢ËØïÈ¢òÔºåÂæ™ÁéØ‰∏≠‰ΩøÁî®Èó≠ÂåÖËß£ÂÜ≥ var ÂÆö‰πâÂáΩÊï∞ÁöÑÈóÆÈ¢ò for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125;// ËæìÂá∫‰ºöÊòØ‰∏ÄÂ†Ü6 È¶ñÂÖàÂõ†‰∏∫ setTimeout ÊòØ‰∏™ÂºÇÊ≠•ÂáΩÊï∞ÔºåÊâÄÊúâ‰ºöÂÖàÊääÂæ™ÁéØÂÖ®ÈÉ®ÊâßË°åÂÆåÊØïÔºåËøôÊó∂ÂÄô i Â∞±ÊòØ 6 ‰∫ÜÔºåÊâÄ‰ª•‰ºöËæìÂá∫‰∏ÄÂ†Ü 6„ÄÇ Ëß£ÂÜ≥ÂäûÊ≥ï‰∏§ÁßçÔºåÁ¨¨‰∏ÄÁßç‰ΩøÁî®Èó≠ÂåÖÂíåimmediately-invoked function expression (IIFE)ÊñπÊ≥ï for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; Á¨¨‰∫åÁßçÂ∞±ÊòØ‰ΩøÁî® setTimeout ÁöÑÁ¨¨‰∏â‰∏™ÂèÇÊï∞ for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer(j) &#123; console.log( j ); &#125;, i*1000, i);&#125; Á¨¨‰∏âÁßçÂ∞±ÊòØ‰ΩøÁî® let ÂÆö‰πâ i ‰∫Ü for ( let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; Âõ†‰∏∫ÂØπ‰∫é let Êù•ËØ¥Ôºå‰ªñ‰ºöÂàõÂª∫‰∏Ä‰∏™ÂùóÁ∫ß‰ΩúÁî®ÂüüÔºåÁõ∏ÂΩì‰∫é &#123; // ÂΩ¢ÊàêÂùóÁ∫ß‰ΩúÁî®Âüü let i = 0 &#123; let ii = i setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125; i++ &#123; let ii = i &#125; i++ &#123; let ii = i &#125; ...&#125;","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Leetcode EveryDay 102 / DFS(1) üí™","slug":"dfs01","date":"2020-06-14T17:53:35.000Z","updated":"2020-06-14T22:23:28.941Z","comments":true,"path":"2020/06/14/dfs01/","link":"","permalink":"WangHngLeee.github.io/2020/06/14/dfs01/","excerpt":"332. Reconstruct Itinerary üîó Question Link Example Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [‚ÄúJFK‚Äù, ‚ÄúLGA‚Äù] has a smaller lexical order than [‚ÄúJFK‚Äù, ‚ÄúLGB‚Äù]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. One must use all the tickets once and only once. Example 1:Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]Example 2:Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].But it is larger in lexical order. Solution class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;();; Map&lt;String,PriorityQueue&lt;String&gt;&gt; map=new HashMap&lt;&gt;(); public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; if(tickets == null || tickets.size() == 0)return res; for(List&lt;String&gt; ticket : tickets)&#123; map.putIfAbsent(ticket.get(0),new PriorityQueue&lt;&gt;()); map.get(ticket.get(0)).add(ticket.get(1)); &#125; dfs(\"JFK\");//Á±ª‰ººtreeÁöÑpostorderÈÅçÂéÜÔºå Collections.reverse(res);// return res; &#125; public void dfs(String start)&#123; PriorityQueue&lt;String&gt; ends = map.get(start); while(ends != null &amp;&amp; !ends.isEmpty())&#123; dfs(ends.poll());//‰∏çÊñ≠ÈÅçÂéÜchildrenÔºå‰πüÂ∞±ÊòØÂΩìÂâçmapÈáåstartÂØπÂ∫îÁöÑendsÈáålexiÊúÄÂ∞èÁöÑÈÇ£‰∏™„ÄÇ &#125; res.add(start); &#125;&#125; Using pq to make sure that every polled element is the smallest leximal one. DFS is just like tree postorder traversal, we need to find the minmum leximal city as start, which is same as traversing children treenode at first. Then we add the root value to the res in the last.","text":"332. Reconstruct Itinerary üîó Question Link Example Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [‚ÄúJFK‚Äù, ‚ÄúLGA‚Äù] has a smaller lexical order than [‚ÄúJFK‚Äù, ‚ÄúLGB‚Äù]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. One must use all the tickets once and only once. Example 1:Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]Example 2:Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].But it is larger in lexical order. Solution class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;();; Map&lt;String,PriorityQueue&lt;String&gt;&gt; map=new HashMap&lt;&gt;(); public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; if(tickets == null || tickets.size() == 0)return res; for(List&lt;String&gt; ticket : tickets)&#123; map.putIfAbsent(ticket.get(0),new PriorityQueue&lt;&gt;()); map.get(ticket.get(0)).add(ticket.get(1)); &#125; dfs(\"JFK\");//Á±ª‰ººtreeÁöÑpostorderÈÅçÂéÜÔºå Collections.reverse(res);// return res; &#125; public void dfs(String start)&#123; PriorityQueue&lt;String&gt; ends = map.get(start); while(ends != null &amp;&amp; !ends.isEmpty())&#123; dfs(ends.poll());//‰∏çÊñ≠ÈÅçÂéÜchildrenÔºå‰πüÂ∞±ÊòØÂΩìÂâçmapÈáåstartÂØπÂ∫îÁöÑendsÈáålexiÊúÄÂ∞èÁöÑÈÇ£‰∏™„ÄÇ &#125; res.add(start); &#125;&#125; Using pq to make sure that every polled element is the smallest leximal one. DFS is just like tree postorder traversal, we need to find the minmum leximal city as start, which is same as traversing children treenode at first. Then we add the root value to the res in the last. 339. Nested List Weight Sum üîóQuestion Link Example Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list ‚Äì whose elements may also be integers or other lists. Example 1:Input: [[1,1],2,[1,1]]Output: 10Explanation: Four 1&apos;s at depth 2, one 2 at depth 1.Example 2:Input: [1,[4,[6]]]Output: 27Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27. Solution In dfs we only recursively to call the function in NestedInteger. In bfs we can regard the nums like tree level traversal. The Integer one is root node, and nestedinteger is like the next levels‚Äôs nodes. DFS class Solution &#123; public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; return helper(nestedList, 1); &#125; public int helper(List&lt;NestedInteger&gt; nestedList, int depth) &#123; int sum = 0; for(NestedInteger nest : nestedList) &#123; if(nest.isInteger()) &#123; sum += depth * nest.getInteger(); &#125; else &#123; sum += helper(nest.getList(), depth+1); &#125; &#125; return sum; &#125;&#125; BFS class Solution &#123; public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null)return 0; int sum = 0; int level = 1; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i&lt;size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())sum+=temp.getInteger()*level; else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; level++; &#125; return sum; &#125;&#125; 364. Nested List Weight Sum II üîó Question Link Example Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list ‚Äì whose elements may also be integers or other lists. Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight. Example 1:Input: [[1,1],2,[1,1]]Output: 8 Explanation: Four 1&apos;s at depth 1, one 2 at depth 2.Example 2:Input: [1,[4,[6]]]Output: 17 Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17. Solution It is a little different from the 339. In this question the nestedinteger has the lower depth and single integer has higher depth. DFS: First we find the total depth of the nestedlist,then we loop each element in the nestedlist,if it is integer then we multiply it by the layer, else we recursevely call the getSum function. BFS: We use presum to store the temp sum of each layer. DFS class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null || nestedList.size() == 0) return 0; int h = helper(nestedList); int res = getSum(nestedList, h); return res; &#125; private int getSum(List&lt;NestedInteger&gt; l, int layer) &#123; int sum = 0; if(l == null || l.size() == 0) return sum; for(NestedInteger n : l) &#123; if(n.isInteger()) sum += n.getInteger() * layer; else sum += getSum(n.getList(), layer - 1); &#125; return sum; &#125; private int helper(List&lt;NestedInteger&gt; l) &#123; if(l == null || l.size() == 0) return 0; int max = 0; for(NestedInteger n : l) &#123; if(n.isInteger()) max = Math.max(max, 1); else max = Math.max(max, helper(n.getList()) + 1); &#125; return max; &#125;&#125; BFS class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null) return 0; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; int prevsum = 0; int total = 0; while(!queue.isEmpty())&#123; int size = queue.size(); int levelsum = 0; for(int i = 0 ; i&lt; size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())levelsum+=temp.getInteger(); else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; prevsum+=levelsum; total+=prevsum; &#125; return total; &#125;&#125; 472. Concatenated Words üîó Question Link Examples Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words. A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array. Example:Input: [&quot;cat&quot;,&quot;cats&quot;,&quot;catsdogcats&quot;,&quot;dog&quot;,&quot;dogcatsdog&quot;,&quot;hippopotamuses&quot;,&quot;rat&quot;,&quot;ratcatdogcat&quot;]Output: [&quot;catsdogcats&quot;,&quot;dogcatsdog&quot;,&quot;ratcatdogcat&quot;]Explanation: &quot;catsdogcats&quot; can be concatenated by &quot;cats&quot;, &quot;dog&quot; and &quot;cats&quot;; &quot;dogcatsdog&quot; can be concatenated by &quot;dog&quot;, &quot;cats&quot; and &quot;dog&quot;; &quot;ratcatdogcat&quot; can be concatenated by &quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot; and &quot;cat&quot;. Solution class Solution &#123; public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(words == null || words.length == 0)return res; Set&lt;String&gt; set = new HashSet&lt;&gt;(); Arrays.sort(words,(a,b)-&gt;a.length() - b.length());//sort the words with its length for(String str : words)&#123; if(str.length() &gt; 0 &amp;&amp; check(set,str))&#123; res.add(str); &#125; set.add(str); &#125; return res; &#125; public boolean check(Set&lt;String&gt; set, String str)&#123; if(set.contains(str))return true; int len = str.length(); for(int i=0; i&lt;len; i++)&#123; String temp = str.substring(0,i); if(set.contains(temp))&#123; if(check(set,str.substring(i)))&#123; set.add(str); return true; &#125; &#125; &#125; return false; &#125;&#125; We first sort the str array from min length to max length. Then we add each string to set. Before add it to the set, we check it with the current set to see whether current word can be made up by any words in the set. We loop each part of the string, if one part exist in the set, then we recursively call the check function to see the other part.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 101 / Graph(2) üí™","slug":"graph03","date":"2020-06-13T17:53:35.000Z","updated":"2020-06-14T16:16:48.935Z","comments":true,"path":"2020/06/13/graph03/","link":"","permalink":"WangHngLeee.github.io/2020/06/13/graph03/","excerpt":"37. Sudoku Solver üîó Question Link Examples Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‚Äò.‚Äô. Note:The given board contain only digits 1-9 and the character &apos;.&apos;.You may assume that the given Sudoku puzzle will have a single unique solution.The given board size is always 9x9. Solution class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0)return; //corner case solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0 ;i&lt;board.length;i++)&#123; for(int j=0 ;j&lt;board[0].length ;j++)&#123; if(board[i][j] =='.')&#123; for(char c = '1' ; c&lt;='9' ;c++)&#123; if(valid(board,i,j,c))&#123; board[i][j] = c; if(solve(board))return true; else&#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean valid(char[][] board, int row, int col, char c)&#123;//used to check every row and col; for(int i=0 ;i&lt;9 ;i++)&#123; if(board[i][col] != '.' &amp;&amp; board[i][col] == c)return false; // check each col; if(board[row][i] != '.' &amp;&amp; board[row][i] == c)return false; //check each row; if(board[3*(row /3)+i/3][3*(col/3)+i%3]!='.'&amp;&amp;board[3*(row/3)+i/3][3*(col/3)+i%3]==c)return false; &#125; return true; &#125;&#125; Recursively call the solve function to check the graph. We try to put number 1-9 in each empty cell and then check its col and row to find whether there exist duplicate numbers. If not then we return true. The tricky part is the last case in valid function. We check each 3x3 grid for a single part in each loop to make sure every number is unique in their 3x3 square area.","text":"37. Sudoku Solver üîó Question Link Examples Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character ‚Äò.‚Äô. Note:The given board contain only digits 1-9 and the character &apos;.&apos;.You may assume that the given Sudoku puzzle will have a single unique solution.The given board size is always 9x9. Solution class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0)return; //corner case solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0 ;i&lt;board.length;i++)&#123; for(int j=0 ;j&lt;board[0].length ;j++)&#123; if(board[i][j] =='.')&#123; for(char c = '1' ; c&lt;='9' ;c++)&#123; if(valid(board,i,j,c))&#123; board[i][j] = c; if(solve(board))return true; else&#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean valid(char[][] board, int row, int col, char c)&#123;//used to check every row and col; for(int i=0 ;i&lt;9 ;i++)&#123; if(board[i][col] != '.' &amp;&amp; board[i][col] == c)return false; // check each col; if(board[row][i] != '.' &amp;&amp; board[row][i] == c)return false; //check each row; if(board[3*(row /3)+i/3][3*(col/3)+i%3]!='.'&amp;&amp;board[3*(row/3)+i/3][3*(col/3)+i%3]==c)return false; &#125; return true; &#125;&#125; Recursively call the solve function to check the graph. We try to put number 1-9 in each empty cell and then check its col and row to find whether there exist duplicate numbers. If not then we return true. The tricky part is the last case in valid function. We check each 3x3 grid for a single part in each loop to make sure every number is unique in their 3x3 square area. 131. Palindrome Partitioning üîó Question Link Example Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example:Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] Solution class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;String&gt; temp = new ArrayList&lt;&gt;(); if(s == null || s.length() == 0)return res; help(res,temp,0,s); return res; &#125; public void help(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; temp, int start, String s)&#123; if(start == s.length())res.add(new ArrayList&lt;&gt;(temp)); for(int i=start; i&lt;s.length(); i++)&#123; if(valid(s,start,i))&#123; temp.add(s.substring(start,i+1)); help(res,temp,i+1,s); temp.remove(temp.size()-1); &#125; &#125; &#125; public boolean valid(String s, int left, int right)&#123; while(left&lt;=right)&#123; if(s.charAt(left) != s.charAt(right))return false; left++; right--; &#125; return true; &#125;&#125; Common backtracking solution. Only difference is that we use a common method ‚Äòvalid‚Äô to check whether a string is palindrome or not. 980. Unique Paths IIIr üîó Question Link Examples On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. Example 1:Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]Output: 2Explanation: We have the following two paths:1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) Solution class Solution &#123; int res = 0, empty = 1, startx, starty; public int uniquePathsIII(int[][] grid) &#123; int m = grid.length, n = grid[0].length; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (grid[i][j] == 0) empty++; else if (grid[i][j] == 1) &#123; startx = i; starty = j; &#125; &#125; &#125; dfs(grid, startx, starty); return res; &#125; public void dfs(int[][] grid, int x, int y) &#123; if (x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] &lt; 0) return; if (grid[x][y]==2) &#123; if (empty == 0) res++; return; &#125; grid[x][y] = -2; empty--; dfs(grid, x + 1, y); dfs(grid, x - 1, y); dfs(grid, x, y + 1); dfs(grid, x, y - 1); grid[x][y] = 0; empty++; &#125;&#125; First we find the start point, then using dfs and backtracking to find the unique path to the end point. Triky point is that the initial empty num is 1 because start point is caculated as empty too.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"}]},{"title":"Leetcode EveryDay 100 / Tree(2) üí™","slug":"tree02","date":"2020-06-11T17:53:35.000Z","updated":"2020-06-11T20:15:54.539Z","comments":true,"path":"2020/06/11/tree02/","link":"","permalink":"WangHngLeee.github.io/2020/06/11/tree02/","excerpt":"96. Unique Binary Search Trees üîó Question Link Example Given n, how many structurally unique BST‚Äôs (binary search trees) that store values 1 ‚Ä¶ n? Example:Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Solution DP + Math class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i &lt;=n;i++)&#123; for(int j = 1 ; j&lt;=i ; j ++)&#123; dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; T:O(n) S:O(n) Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST. Take 1,2,3 for example: G(3) / | \\ F(1,3) + F(2,3) + F(3,3) (1 as root) (2 as root) (3 as root) / \\ / \\ / \\ G(0) G(1) G(1) G(1) G(2) G(1)According to defination of BST, so different root have different subtrees.","text":"96. Unique Binary Search Trees üîó Question Link Example Given n, how many structurally unique BST‚Äôs (binary search trees) that store values 1 ‚Ä¶ n? Example:Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Solution DP + Math class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i &lt;=n;i++)&#123; for(int j = 1 ; j&lt;=i ; j ++)&#123; dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; T:O(n) S:O(n) Let say G(n) is the final res. In each subtree, we say F(i,n) is the number of unique BST. Take 1,2,3 for example: G(3) / | \\ F(1,3) + F(2,3) + F(3,3) (1 as root) (2 as root) (3 as root) / \\ / \\ / \\ G(0) G(1) G(1) G(1) G(2) G(1)According to defination of BST, so different root have different subtrees. 105. Construct Binary Tree from Preorder and Inorder Traversal üîó Question Link Example Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, givenpreorder = [3,9,20,15,7]inorder = [9,3,15,20,7]Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solution class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder == null || inorder == null || preorder.length == 0|| inorder.length == 0)&#123; return null; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0; i&lt;inorder.length; i++)&#123; map.put(inorder[i],i); &#125; return build(inorder,0,inorder.length-1,preorder,0,preorder.length-1,map); &#125; public TreeNode build(int[]inorder, int is, int ie, int[] preorder, int ps, int pe, Map&lt;Integer,Integer&gt; map)&#123; if(is &gt; ie || ps &gt; pe)return null; TreeNode node = new TreeNode(preorder[ps]); int inidx = map.get(preorder[ps]); // Âú®inorderÈáåÂæóÂà∞nodeÁöÑ‰ΩçÁΩÆ int remains = inidx - is; // ÂæóÂà∞Â∑¶ÂçäÈÉ®ÂàÜÁöÑÂâ©‰Ωô node.left = build(inorder,is,inidx-1,preorder,ps+1,ps+remains,map); node.right = build(inorder,inidx+1,ie,preorder,ps+remains+1,pe,map); return node; &#125;&#125; Recursively building a tree from preorder and inorder array. Root is the first element in preorder, and use that element to find the index in inorder to caculate the left and right part‚Äôs length. Using map to store the index and element in the map. T:O(n) S:O(n) 863. All Nodes Distance K in Binary Tree üîó Question Link Example We are given a binary tree (with root node root), a target node, and an integer value K. Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order. Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2Output: [7,4,1]Explanation:The nodes that are a distance 2 from the target node (with value 5)have values 7, 4, and 1. Solution class Solution &#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,target); dfs(root,0,K,res); return res; &#125; public int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; public void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)res.add(root.val); dfs(root.left,dist+1,K,res); dfs(root.right,dist+1,K,res); &#125;&#125; Using map to store different node‚Äôs distance to the target node.(Only sublayer node). Then using dfs to scan each node to caculate the distance. If it is not in the map, it means that node is uplayer of the target, so we using default 0 from root to scan, each step we add 1. If we meet a node that stored in the map, the we use the distance stored in the map to justify the distance. T:O(n) S:O(n) 366. Find Leaves of Binary Tree üîó Question Link Example Given a binary tree, collect a tree‚Äôs nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty. Example:Input: [1,2,3,4,5] 1 / \\ 2 3 / \\ 4 5 Output: [[4,5,3],[2],[1]]Explanation:1. Removing the leaves [4,5,3] would result in this tree: 1 / 2 2. Now removing the leaf [2] would result in this tree: 1 3. Now removing the leaf [1] would result in the empty tree: [] Solution Recursive class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,res); return res; &#125; public int find(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return -1; int left = find(root.left,res); int right = find(root.right,res); int level = Math.max(left,right)+1; if(res.size()&lt;level+1)&#123; res.add(new ArrayList&lt;&gt;()); &#125; res.get(level).add(root.val); return level; &#125;&#125; Using every node‚Äôs level to determine whether current node is leaf or not. Leaf node‚Äôs level return -1+1=0. Then we add the nodes to res by the order of it‚Äôs level. -&gt; 0: 4,5,3 -&gt; 1:2 -&gt; 2:1 T:O(n) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 99 / Graph(2) üí™","slug":"graph02","date":"2020-06-09T17:53:35.000Z","updated":"2020-06-09T22:11:49.718Z","comments":true,"path":"2020/06/09/graph02/","link":"","permalink":"WangHngLeee.github.io/2020/06/09/graph02/","excerpt":"1102. Path With Maximum Minimum Value üîó Question Link Example Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1]. The score of a path is the minimum value in that path. For example, the value of the path 8 ‚Üí 4 ‚Üí 5 ‚Üí 9 is 4. A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south). Example 1:Input: [[5,4,5],[1,2,6],[7,4,6]]Output: 4Explanation: The path with the maximum score is highlighted in yellow. Solution class Solution &#123; int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public int maximumMinimumPath(int[][] A) &#123; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;Integer.compare(b[0],a[0])); pq.add(new int[]&#123;A[0][0],0,0&#125;); int minval = Integer.MAX_VALUE; int m = A.length; int n = A[0].length; boolean[][] seen = new boolean[m][n]; seen[0][0] = true; while(!pq.isEmpty())&#123; int[] temp = pq.poll(); int i = temp[1], j= temp[2],val = temp[0]; minval = Math.min(minval,val); if(i==m-1 &amp;&amp; j==n-1)break; for(int[] dir : dirs)&#123; int newx = i+dir[0]; int newy = j+dir[1]; if(newx &gt;=0 &amp;&amp; newx&lt;m &amp;&amp; newy&gt;=0 &amp;&amp; newy&lt;n &amp;&amp; !seen[newx][newy])&#123; pq.add(new int[]&#123;A[newx][newy],newx,newy&#125;); seen[newx][newy] = true; &#125; &#125; &#125; return minval; &#125;&#125; Using BFS to keep searching the max value path. Using priorityqueue to keep the max one on the top. And keep the minval to find the minval in the max path. T:O(n) S:O(n)","text":"1102. Path With Maximum Minimum Value üîó Question Link Example Given a matrix of integers A with R rows and C columns, find the maximum score of a path starting at [0,0] and ending at [R-1,C-1]. The score of a path is the minimum value in that path. For example, the value of the path 8 ‚Üí 4 ‚Üí 5 ‚Üí 9 is 4. A path moves some number of times from one visited cell to any neighbouring unvisited cell in one of the 4 cardinal directions (north, east, west, south). Example 1:Input: [[5,4,5],[1,2,6],[7,4,6]]Output: 4Explanation: The path with the maximum score is highlighted in yellow. Solution class Solution &#123; int[][] dirs = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public int maximumMinimumPath(int[][] A) &#123; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;Integer.compare(b[0],a[0])); pq.add(new int[]&#123;A[0][0],0,0&#125;); int minval = Integer.MAX_VALUE; int m = A.length; int n = A[0].length; boolean[][] seen = new boolean[m][n]; seen[0][0] = true; while(!pq.isEmpty())&#123; int[] temp = pq.poll(); int i = temp[1], j= temp[2],val = temp[0]; minval = Math.min(minval,val); if(i==m-1 &amp;&amp; j==n-1)break; for(int[] dir : dirs)&#123; int newx = i+dir[0]; int newy = j+dir[1]; if(newx &gt;=0 &amp;&amp; newx&lt;m &amp;&amp; newy&gt;=0 &amp;&amp; newy&lt;n &amp;&amp; !seen[newx][newy])&#123; pq.add(new int[]&#123;A[newx][newy],newx,newy&#125;); seen[newx][newy] = true; &#125; &#125; &#125; return minval; &#125;&#125; Using BFS to keep searching the max value path. Using priorityqueue to keep the max one on the top. And keep the minval to find the minval in the max path. T:O(n) S:O(n) 765. Couples Holding Hands üîó Question Link Examples N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats. The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1). The couples‚Äô initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat. Example 1:Input: row = [0, 2, 1, 3]Output: 1Explanation: We only need to swap the second (row[1]) and third (row[2]) person. Solution class Solution &#123; class UF&#123; int[] parents; int count; public UF(int n)&#123; parents = new int[n]; for(int i=0 ;i&lt;n ;i++)&#123; parents[i] = i; &#125; count = 0; &#125; public int find ( int n)&#123; if(parents[n] == n)return n; return parents[n] = find(parents[n]); &#125; public void union(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 != root2)&#123; parents[root1] = root2; count++; &#125; &#125; &#125; public int minSwapsCouples(int[] row) &#123; int N = row.length /2; UF unionfind = new UF(N); for(int i=0 ;i&lt;N ;i++)&#123; int a = row[i*2]; int b = row[i*2+1]; unionfind.union(a/2,b/2); &#125; return unionfind.count; &#125;&#125; Using UF is more efficient. Just regard each couple is a vertex in the graph, what we need to do is to find the number of unconnected components, which is also the times we need to swap. T:O(n) S:O(n) 1267. Count Servers that Communicate üîó Question Link Example You are given a map of a server center, represented as a m * n integer matrix grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column. Return the number of servers that communicate with any other server. Example 1:Input: grid = [[1,0],[0,1]]Output: 0Explanation: No servers can communicate with others. Solution class Solution &#123; public int countServers(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int total = 0; int[] row = new int[m]; int[] col = new int[n]; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(grid[i][j] == 1)&#123; row[i]++; col[j]++; total++; &#125; &#125; &#125; for(int i=0; i&lt;m; i++)&#123; for(int j=0; j&lt;n; j++)&#123; if(grid[i][j] == 1)&#123; if(row[i]==1 &amp;&amp; col[j] == 1)&#123; total--; &#125; &#125; &#125; &#125; return total; &#125;&#125; First we loop each vertex in the graph, if it‚Äôs value is 1 we add 1 to total and update the row and col array to count the total computers that are on the same row or col. Then we loop the graph again to remove the single computer, which row and col is only 1. T:O(m*n) S:O(n) 802. Find Eventual Safe States üîó Question Link Example In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe? Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ‚Ä¶, N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example:Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]Output: [2,4,5,6]Here is a diagram of the above graph. Solution DFS - Tarjan‚Äôs Torpological class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(graph == null || graph.length == 0)return res; int[] state = new int[graph.length]; for(int i=0; i&lt;graph.length; i++)&#123; if(dfs(graph,i,state))&#123; res.add(i); &#125; &#125; return res; &#125; public boolean dfs(int[][] graph, int node, int[] state)&#123; if(state[node] == 1)return true; if(state[node] == 2)return false; state[node] = 2; for(int num : graph[node])&#123; if(!dfs(graph,num,state))&#123; return false; &#125; &#125; state[node] = 1; return true; &#125;&#125; T: O(V + E) S: O(V) Using Tarjan‚Äôs algo torpological to find SCC. If there is no SCC then we return true which means we can reach final safe state, then we add current node into res. Otherwise we return false. 684. Redundant Connection üîó Question Link Example The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ‚Ä¶, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v. Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v. Example 1:Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 / \\2 - 3 Solution Union-Find: class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int[] parents = new int[edges.length+1]; for(int i=1; i&lt;=edges.length; i++)&#123; parents[i] = i; &#125; for(int[] edge: edges)&#123; int root1 = find(parents,edge[0]); int root2 = find(parents,edge[1]); if(root1 == root2)&#123; return edge; &#125;else&#123; parents[root1] = root2; &#125; &#125; return new int[]&#123;&#125;; &#125; public int find(int[] parents, int i)&#123; if(i == parents[i])return i; parents[i] = find(parents,parents[i]); return parents[i]; &#125;&#125; It is clearly that we have to find the edge that cause a loop in the graph. So UF is the best way to do that. Once we find one vertex have the same root with other vertex then we return the edge that current vertex exist in. T:O(n) S:O(n) 841. Keys and Rooms üîó Question Link Example There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ‚Ä¶, N-1, and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ‚Ä¶, N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1:Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Solution BFS class Solution &#123; public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(rooms == null || rooms.size() == 0)return false; stack.push(0); set.add(0); while(!stack.isEmpty())&#123; int temp = stack.pop(); for(int key : rooms.get(temp))&#123; if(!set.contains(key))&#123; set.add(key); stack.push(key); if(set.size() == rooms.size())return true; &#125; &#125; &#125; return set.size() == rooms.size(); &#125;&#125; T:O(n) S:O(n) Straight forward solution. Using BFS to get each key and store them in set. Using stack to keep track of the rooms that we just opened. We only need to check whether the size of set and size of rooms are same.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Leetcode EveryDay 98 / Graph(1) üí™","slug":"graph01","date":"2020-06-08T17:53:35.000Z","updated":"2020-06-09T00:36:07.762Z","comments":true,"path":"2020/06/08/graph01/","link":"","permalink":"WangHngLeee.github.io/2020/06/08/graph01/","excerpt":"207. Course Schedule üîó Question Link Example There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1:Input: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: numCourses = 2, prerequisites = [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Solution DFS (Tarjan‚Äôs Algorithm) with two different state class Solution &#123; public boolean canFinish(int n, int[][] prerequisites) &#123; List&lt;Integer&gt;[] graph = new List[n]; for(int i=0; i&lt;n; i++)&#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int[] pre : prerequisites)&#123; int v = pre[1]; int w = pre[0]; graph[v].add(w); &#125; int[] state = new int[n]; for(int i=0; i&lt;n; i++)&#123; if(dfs(graph,state,i))&#123; return false; &#125; &#125; return true; &#125; public boolean dfs(List&lt;Integer&gt;[] graph, int[] state, int v)&#123; if(state[v] == 1)return true; // current node is being tracking in other dfs process if(state[v] == 2)return false;// current node have been tracked so no loop here. state[v] = 1; // change current node to be tracking for(int w: graph[v])&#123; if(dfs(graph,state,w))&#123; return true; &#125; &#125; state[v] = 2; // after searching and no loop here then we change state to be tracked return false; &#125;&#125; T:O(V+E) S:O(V)","text":"207. Course Schedule üîó Question Link Example There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1:Input: numCourses = 2, prerequisites = [[1,0]]Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: numCourses = 2, prerequisites = [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Solution DFS (Tarjan‚Äôs Algorithm) with two different state class Solution &#123; public boolean canFinish(int n, int[][] prerequisites) &#123; List&lt;Integer&gt;[] graph = new List[n]; for(int i=0; i&lt;n; i++)&#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int[] pre : prerequisites)&#123; int v = pre[1]; int w = pre[0]; graph[v].add(w); &#125; int[] state = new int[n]; for(int i=0; i&lt;n; i++)&#123; if(dfs(graph,state,i))&#123; return false; &#125; &#125; return true; &#125; public boolean dfs(List&lt;Integer&gt;[] graph, int[] state, int v)&#123; if(state[v] == 1)return true; // current node is being tracking in other dfs process if(state[v] == 2)return false;// current node have been tracked so no loop here. state[v] = 1; // change current node to be tracking for(int w: graph[v])&#123; if(dfs(graph,state,w))&#123; return true; &#125; &#125; state[v] = 2; // after searching and no loop here then we change state to be tracked return false; &#125;&#125; T:O(V+E) S:O(V) DFS (Tarjan‚Äôs Algorithm) with two boolean array class Solution &#123; public boolean canFinish(int n, int[][] prerequisites) &#123; List&lt;Integer&gt;[] graph = new List[n]; for(int i=0; i&lt;n; i++)&#123; graph[i] = new ArrayList&lt;&gt;(); &#125; for(int[] pre : prerequisites)&#123; int v = pre[1]; int w = pre[0]; graph[v].add(w); &#125; boolean[] marked = new boolean[n]; boolean[] tracking = new boolean[n]; for(int i=0; i&lt;n; i++)&#123; if(!marked[i])&#123; if(dfs(graph,marked,tracking,i))&#123; return false; &#125; &#125; &#125; return true; &#125; public boolean dfs(List&lt;Integer&gt;[] graph, boolean[] marked, boolean[]tracking, int v)&#123; marked[v] = true; tracking[v] = true; for(int w: graph[v])&#123; if(!marked[w])&#123; if(dfs(graph,marked,tracking,w))&#123; return true; &#125; &#125; if(tracking[w])&#123; return true; &#125; &#125; tracking[v] = false; return false; &#125;&#125; T:O(V+E) S:O(V) BFS class Solution &#123; public boolean canFinish(int n, int[][] prerequisites) &#123; List&lt;Integer&gt;[] graph = new List[n]; for (int i = 0; i &lt; n; i++) &#123; graph[i] = new ArrayList&lt;&gt;(); &#125; int[] indegrees = new int[n]; for (int[] prerequisite : prerequisites) &#123; int v = prerequisite[1]; int w = prerequisite[0]; graph[v].add(w); indegrees[w]++; &#125; Queue&lt;Integer&gt; start = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (indegrees[i] == 0) &#123; start.add(i); &#125; &#125; while (!start.isEmpty()) &#123; int v = start.poll(); for (int w : graph[v]) &#123; indegrees[w]--; if (indegrees[w] == 0) &#123; start.add(w); &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (indegrees[i] &gt; 0) &#123; return false; &#125; &#125; return true; &#125;&#125; T:O(V+E) S:O(V) DFS solution we use two states / two boolean array to check whether current node is being tracking or have been checked. Normal BFS Torpological solution. Using queue to check each course‚Äôs indegree. Finally if the total courses left is not 0 then we return false. 210. Course Schedule II üîó Question Link Example There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1:Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .Example 2:Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Solution BFS class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int index = 0; for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i = 0 ;i&lt;indegree.length ;i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); res[index] = i; index++; &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]] == 0)&#123; queue.add(pair[0]); res[index] = pair[0]; index++; &#125; &#125; &#125; &#125; return index == numCourses ? res : new int[]&#123;&#125;; &#125;&#125; DFS ( to be added) 133. Clone Graph üîó Question Link Example Example 1: Input: adjList = [[2,4],[1,3],[2,4],[1,3]]Output: [[2,4],[1,3],[2,4],[1,3]]Explanation: There are 4 nodes in the graph.1st node (val = 1)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).2nd node (val = 2)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3).3rd node (val = 3)&apos;s neighbors are 2nd node (val = 2) and 4th node (val = 4).4th node (val = 4)&apos;s neighbors are 1st node (val = 1) and 3rd node (val = 3). Solution class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); map.put(node,dummy); while(!queue.isEmpty())&#123; Node temp = queue.poll(); for(Node nb : temp.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb,new Node(nb.val)); queue.add(nb); &#125; map.get(temp).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; BFS thoughts. Clone each node to it‚Äôs new node and put them into hashmap. Then using dummy node to keep recode of the new map. T:O(n) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"}]},{"title":"Leetcode EveryDay 97 / Tree(1) üí™","slug":"tree01","date":"2020-06-07T17:53:35.000Z","updated":"2020-06-08T13:50:00.859Z","comments":true,"path":"2020/06/07/tree01/","link":"","permalink":"WangHngLeee.github.io/2020/06/07/tree01/","excerpt":"199. Binary Tree Right Side View üîó Question Link Example Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Solution DFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; dfs(root,res,0); return res; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; res, int depth)&#123; if(root == null)return; if(depth == res.size())&#123; res.add(root.val); &#125; dfs(root.right,res,depth+1); dfs(root.left,res,depth+1); &#125;&#125; We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res. T:O(n) S:O(n) BFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i == size-1)res.add(temp.val); // only add the last node in every level into res if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node. T:O(n) S:O(n)","text":"199. Binary Tree Right Side View üîó Question Link Example Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example:Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Solution DFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; dfs(root,res,0); return res; &#125; public void dfs(TreeNode root, List&lt;Integer&gt; res, int depth)&#123; if(root == null)return; if(depth == res.size())&#123; res.add(root.val); &#125; dfs(root.right,res,depth+1); dfs(root.left,res,depth+1); &#125;&#125; We dfs right node first so it can be the first node we meet in every level. If res.size == depth, it means we meet a new right most node, then we add it into res. T:O(n) S:O(n) BFS class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i == size-1)res.add(temp.val); // only add the last node in every level into res if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; Normal level traversal. In this time we only add the last node into res , which can be the rightside veiw node. T:O(n) S:O(n) 297. Serialize and Deserialize Binary Tree üîó Question Link Examples Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example:You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5as &quot;[1,2,3,null,null,4,5]&quot; Solution public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder res = new StringBuilder(); serial(root,res); return res.toString(); &#125; public void serial(TreeNode root, StringBuilder res)&#123; if(root == null)res.append(\"null\").append(\" \"); else&#123; res.append(root.val).append(\" \"); serial(root.left,res); serial(root.right,res); &#125; &#125; public TreeNode deserialize(String source)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = source.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return des(queue); &#125; public TreeNode des(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"null\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = des(queue); node.right = des(queue); return node; &#125;&#125; In serialize function, we use recursive preorder way to save the tree node‚Äôs value into a String. In deserialize function, we use the previous string as source data. Then we recursively to build a new tree using pre-order too. T:O(n) S:O(n) 124. Binary Tree Maximum Path Sum üîó Question Link Examples Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:Input: [1,2,3] 1 / \\ 2 3Output: 6Example 2:Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7Output: 42 Solutoin class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; Using revursive to find the max in right / left branch. Max is updated when current node is seen as the root node, so we sum the value of left+right+node.val . But in return line, we can only choose one branch in left/right branch. T:O(n) S:O(1) 236. Lowest Common Ancestor of a Binary Tree üîó Question Link Example Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: ‚ÄúThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).‚Äù Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.Example 2:Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Solution class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; else if(right == null)return left; else return root; &#125;&#125; There are three cases: when left and right both have return value, it means that two nodes are displayed in both left and right branch. The current root is their LCA, so we return root. when left has null, it means two nodes are both in right branch. So we just return right value. Right keep record the first target node we meet. when right has null, it means two nodes are both in left branch. So we just return left value. Left keep record the first target node we meet. T:O(n) S:O(1) 98. Validate Binary Search Tree üîó Question Link Example Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node‚Äôs key. The right subtree of a node contains only nodes with keys greater than the node‚Äôs key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3Input: [2,1,3]Output: trueExample 2: 5 / \\ 1 4 / \\ 3 6Input: [5,1,4,null,null,3,6]Output: falseExplanation: The root node&apos;s value is 5 but its right child&apos;s value is 4. Solution class Solution &#123; public boolean isValidBST(TreeNode root)&#123; if(root == null)return true; return help(root,Long.MIN_VALUE, Long.MAX_VALUE); &#125; public boolean help(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val &lt;= min || root.val &gt;= max)return false; return help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max); &#125;&#125; Using defination of BST:left &lt; root &lt; right. Then we can set up two max / min boundary to check each layer. Tricky: The test case contains large number which can only be included by Long type number. T:O(n) S:O(1) 987. Vertical Order Traversal of a Binary Tree üîó Question Link Example Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates). If two nodes have the same position, then the value of the node that is reported first is the value that is smaller. Return an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes. Example 1:Input: [1,2,3,4,5,6,7]Output: [[4],[2],[1,5,6],[3],[7]]Explanation: The node with value 5 and the node with value 6 have the same position according to the given scheme.However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6. Solution class Solution &#123; class pair&#123; TreeNode node; int x; int y; public pair(int x, int y, TreeNode n)&#123; this.x = x; this.y = y; node = n; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(0,0,root)); int min = 0; int max = 0; while(!queue.isEmpty())&#123; pair temp = queue.poll(); min = Math.min(min,temp.x); max = Math.max(max,temp.x); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(new pair(temp.x,temp.y,temp.node)); if(temp.node.left!=null)queue.add(new pair(temp.x-1,temp.y+1,temp.node.left)); if(temp.node.right!=null)queue.add(new pair(temp.x+1,temp.y+1,temp.node.right)); &#125; for(int i= min ;i&lt;= max; i++)&#123; Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : a.y - b.y); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j = 0; j&lt;map.get(i).size() ;j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; Using HashMap to store each x position‚Äôs nodes. And then sort each nodes wiht it‚Äôs y‚Äôs positon value. If two nodes have same y position, then sort them with node‚Äôs value. T:O(n^2logn) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 96 / Array(2) üí™","slug":"array02","date":"2020-06-06T17:53:35.000Z","updated":"2020-06-13T15:16:39.727Z","comments":true,"path":"2020/06/06/array02/","link":"","permalink":"WangHngLeee.github.io/2020/06/06/array02/","excerpt":"31. Next Permutation üîó Question Link Example Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 ‚Üí 1,3,23,2,1 ‚Üí 1,2,31,1,5 ‚Üí 1,5,1 Solution class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length -1; int pos = -1; int val = 0; for(int i = len-1 ;i&gt;=0 ;i--)&#123; if(nums[i] &lt; nums[i+1])&#123; pos = i; val = nums[i]; break; &#125; &#125; if(pos == -1)&#123; // already sort in descending order like 321 then we return 123 reverse(nums,0,len); return; &#125; for(int i = len ;i&gt;=0 ;i--)&#123; if(nums[i] &gt; val)&#123; swap(nums,pos,i); break; &#125; &#125; reverse(nums,pos+1,len);// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5 &#125; public void reverse(int[] nums, int start, int end)&#123; while(start &lt;= end)&#123; swap(nums,start,end); start++; end--; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125; T:O(n) S:O(1) From end to start we need to find the first num target which cause drop and keep record ot it‚Äôs pos and value. Then we start from end again to find the first num that is bigger than than target‚Äôs value. Then we swap this num with the target num , then reverse the array from pos+1 to len.","text":"31. Next Permutation üîó Question Link Example Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 ‚Üí 1,3,23,2,1 ‚Üí 1,2,31,1,5 ‚Üí 1,5,1 Solution class Solution &#123; public void nextPermutation(int[] nums) &#123; int len = nums.length -1; int pos = -1; int val = 0; for(int i = len-1 ;i&gt;=0 ;i--)&#123; if(nums[i] &lt; nums[i+1])&#123; pos = i; val = nums[i]; break; &#125; &#125; if(pos == -1)&#123; // already sort in descending order like 321 then we return 123 reverse(nums,0,len); return; &#125; for(int i = len ;i&gt;=0 ;i--)&#123; if(nums[i] &gt; val)&#123; swap(nums,pos,i); break; &#125; &#125; reverse(nums,pos+1,len);// 1 2 5 4 1 =&gt; 1 4 5 2 1 =&gt; 1 4 1 2 5 &#125; public void reverse(int[] nums, int start, int end)&#123; while(start &lt;= end)&#123; swap(nums,start,end); start++; end--; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125; T:O(n) S:O(1) From end to start we need to find the first num target which cause drop and keep record ot it‚Äôs pos and value. Then we start from end again to find the first num that is bigger than than target‚Äôs value. Then we swap this num with the target num , then reverse the array from pos+1 to len. 54. Spiral Matrix üîó Question Link Examples Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1:Input:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]Output: [1,2,3,6,9,8,7,4,5]Example 2:Input:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]Output: [1,2,3,4,8,12,11,10,9,5,6,7] Solution class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(matrix.length == 0 || matrix == null)return res; int m = matrix.length; int n = matrix[0].length; int left= 0; int right = n-1; int top = 0; int down = m-1; while(res.size() &lt; m*n)&#123; for(int i = left ;i &lt;= right &amp;&amp; res.size() &lt; n * m ;i++)&#123; res.add(matrix[top][i]); &#125; for(int i = top + 1 ; i&lt;= down-1 &amp;&amp; res.size() &lt; m * n ;i++)&#123; res.add(matrix[i][right]); &#125; for(int i = right ;i&gt;= left &amp;&amp; res.size() &lt; m*n;i--)&#123; res.add(matrix[down][i]); &#125; for(int i = down-1 ;i&gt;=top+1 &amp;&amp; res.size() &lt; m * n;i--)&#123; res.add(matrix[i][left]); &#125; left++; right--; top++; down--; &#125; return res; &#125;&#125; T:O(n) S:O(n) Simple idea. Just loop the matrix from left-&gt; right, top-&gt;down, right-&gt;left, down-&gt;top. Then minus each value by 1. 289. Game of Life üîó Question Link Examples Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population‚Ä¶ Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example:Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] Solution class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; T:O(mn) S:O(1) Tricky point is that we can use three state to keep record of the next generation. 1-&gt; live cell continue to live 2-&gt; live cell died due to lives &lt;2 or lives&gt;3 3-&gt; dead cell become live due to lives ==2 or lives ==3 After that we can use %2 to caculate whether it‚Äôs 0 or 1. 128. Longest Consecutive Sequence üîó Question Link Examples Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example:Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; //corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.getOrDefault(num-1,0); int right = map.getOrDefault(num+1,0); sum += left + right + 1; max = Math.max(max,sum); map.put(num,sum); map.put(num-left,sum); map.put(num+right,sum); &#125; &#125; return max; &#125;&#125; T:O(n) S:O(n) Everytime we just to find max continus length of num-1 and num+1, then we mix them up to form a new sum of current num. Then we update max , and also update the num-left, num+right with new sum value, it works because left and right is the length of continus length. 1054. Distant Barcodes üîó Question Link Examples n a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i]. Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. Example 1:Input: [1,1,1,2,2,2]Output: [2,1,2,1,2,1]Example 2:Input: [1,1,1,1,2,2,3,3]Output: [1,3,1,3,2,1,2,1] Solution class Solution &#123; public int[] rearrangeBarcodes(int[] barcodes) &#123; int[] res = new int[barcodes.length]; if(barcodes.length == 0 || barcodes == null)return res;//corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int b : barcodes)&#123; map.put(b,map.getOrDefault(b,0)+1); &#125; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;b[1] - a[1]); for(int key: map.keySet())&#123; pq.add(new int[]&#123;key,map.get(key)&#125;); &#125; int idx = 0; while(!pq.isEmpty())&#123; int[] temp = pq.poll(); while(temp[1]&gt;0)&#123; res[idx] = temp[0]; temp[1]--; idx+=2; if(idx&gt;=barcodes.length)idx=1; &#125; &#125; return res; &#125;&#125; T:O(nlogn) S:O(n)","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 95 / Array(1) √∞≈∏‚Äô¬™","slug":"array01","date":"2020-06-03T17:53:35.000Z","updated":"2020-06-07T14:02:34.368Z","comments":true,"path":"2020/06/03/array01/","link":"","permalink":"WangHngLeee.github.io/2020/06/03/array01/","excerpt":"42. Trapping Rain Water √∞≈∏‚Äù‚Äî Question Link Examples Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 Solution class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; //corner case int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1.","text":"42. Trapping Rain Water √∞≈∏‚Äù‚Äî Question Link Examples Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 Solution class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; //corner case int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; The main idea is first we find the leftmost and rightmost height. If leftmost is bigger, then we caculate from right side( shortest one decide the max water we can store). Otherwise we caculate from left side. After that, we move left or right to the middle center by 1. 238. Product of Array Except Self √∞≈∏‚Äù‚Äî Question Link Examples Given an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example:Input: [1,2,3,4]Output: [24,12,8,6]Constraint: It&apos;s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer. Solution class Solution &#123; public int[] productExceptSelf(int[] nums) &#123; int[] res = new int[nums.length]; int left = 1; int right = 1; if(nums == null || nums.length == 0)return res; for(int i = 0; i &lt; nums.length ;i++)&#123; if(i&gt;0)&#123; left = left * nums[i-1]; &#125; res[i] = left; &#125; for(int j = nums.length-1; j&gt;=0 ;j--)&#123; if(j&lt;nums.length-1)&#123; right = right * nums[j+1]; &#125; res[j] = res[j] * right; &#125; return res; &#125;&#125; First from left to get the left multiply num, then from right to left to get the final result. 152. Maximum Product Subarray √∞≈∏‚Äù‚Äî Question Link Examples Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1:Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6.Example 2:Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Solution class Solution &#123; public int maxProduct(int[] nums) &#123; int max = Integer.MIN_VALUE; if(nums == null || nums.length == 0)return 0; for(int i = 0 ;i&lt;nums.length ;i++)&#123; int sum = nums[i]; if(sum &gt; max)max = sum; for(int j = i+1; j&lt;nums.length ;j++)&#123; sum = sum * nums[j]; if(sum &gt; max)max = sum; &#125; &#125; return max; &#125;&#125; Simple two side for loops solution. 121. Best Time to Buy and Sell Stock √∞≈∏‚Äù‚Äî Question Link Examples Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1:Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Soluiton class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0)return 0; int max = 0; int min = prices[0]; for(int i = 0 ; i &lt; prices.length ;i++)&#123; if(prices[i] &gt; min)&#123; max = Math.max(prices[i]-min,max); &#125;else&#123; min = prices[i]; &#125; &#125; return max; &#125;&#125; Set first day‚Äôs value to be min which is like the price to buy in. Max is the value that to sell. 56. Merge Intervals √∞≈∏‚Äù‚Äî Question Link Examples Given a collection of intervals, merge all overlapping intervals. Example 1:Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].Example 2:Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Solution class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0 )return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0] - b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] item : intervals)&#123; if(end &gt;= item[0])&#123; // [0,4][1,3] end = Math.max(end,item[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = item[0]; end = item[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125; Classic merge intervals questions. Using start and end to decide whether merge a new interval or add current interval into answer. 560. Subarray Sum Equals K √∞≈∏‚Äù‚Äî Question Link Examples Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1:Input:nums = [1,1,1], k = 2Output: 2 Solution class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if(nums == null || nums.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int count = 0; int sum = 0; for(int num : nums)&#123; sum = sum + num; if(map.containsKey(sum - k))&#123; count+=map.get(sum-k); &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; Using presum to precaculate the sum with different length of nums in array. Eg: array : 1 1 1 1 1 0:1 1:1 map -&gt;2:1 3:1 4:1 5:1","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 94 / String(2) √∞≈∏‚Äô¬™","slug":"string02","date":"2020-06-02T17:53:35.000Z","updated":"2020-06-06T01:33:53.800Z","comments":true,"path":"2020/06/02/string02/","link":"","permalink":"WangHngLeee.github.io/2020/06/02/string02/","excerpt":"609. Find Duplicate File in System √∞≈∏‚Äù‚Äî Question Link Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. Example Input:[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]Output:[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]","text":"609. Find Duplicate File in System √∞≈∏‚Äù‚Äî Question Link Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths. Example Input:[&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]Output:[[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]] Solution class Solution &#123; public List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(String str : paths)&#123; String[] strs = str.split(\"\\\\s++\"); for(int i = 1 ;i&lt;strs.length ;i++)&#123; int idx = strs[i].indexOf('('); String msg = strs[i].substring(idx); String totalName = strs[0] + \"/\" + strs[i].substring(0,idx); Set&lt;String&gt; names = map.getOrDefault(msg,new HashSet&lt;&gt;()); names.add(totalName); map.put(msg,names); &#125; &#125; for(String key : map.keySet())&#123; if(map.get(key).size() &gt; 1)&#123; res.add(new ArrayList&lt;&gt;(map.get(key))); &#125; &#125; return res; &#125;&#125; T:O(n) S:O(n) First we split the string with &quot; &quot; to seprate the string with two parts : paths + file. Then we go to the file part, and find the message in it using ‚Äú(‚Äù, we split the file with two part: file name + file message. Using map and set to store the file like &quot; message -&gt; Set &quot;. Then we add the path in the set to final res list. 767. Reorganize String √∞≈∏‚Äù‚Äî Question Link Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Example Example 1:Input: S = &quot;aab&quot;Output: &quot;aba&quot;Example 2:Input: S = &quot;aaab&quot;Output: &quot;&quot; Solution class Solution &#123; public String reorganizeString(String S) &#123; int[] arr = new int[26]; for(int i = 0 ; i &lt; S.length() ;i++)&#123; arr[S.charAt(i)-'a']++; &#125; int max = 0, letter = 0; for(int i = 0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;max)&#123; max = arr[i]; letter = i; &#125; &#125; if(max &gt; (S.length() + 1)/2)return \"\"; char[] res = new char[S.length()]; int index = 0; while(arr[letter] &gt; 0)&#123; res[index] = (char)(letter +'a'); index+=2; arr[letter]--; &#125; for(int i = 0; i&lt;arr.length ;i++)&#123; while(arr[i]&gt;0)&#123; if(index &gt;= S.length())&#123; index = 1; &#125; res[index] = (char)(i + 'a'); index+=2; arr[i]--; &#125; &#125; return String.valueOf(res); &#125;&#125; T:O(n) S:O(1) Easy thoughts: We first find the char with max currency and put it on the even positin first like 0,2,4,6‚Ä¶ Then we keep to put all other chars in the remained position. If we get the end of the size of string, we turn back to the position of 1 and keep put char in it. It easy to understand with the following explain. a _ a _ a _ _ _ _ // fill in &quot;a&quot; at position 0, 2, 4a b a _ a _ b _ b // fill in &quot;b&quot; at position 6, 8, 1a b a c a _ b _ b // fill in &quot;c&quot; at position 3a b a c a d b d b // fill in &quot;d&quot; at position 5, 7 32. Longest Valid Parentheses √∞≈∏‚Äù‚Äî Question Link Given a string containing just the characters ‚Äò(‚Äô and ‚Äò)‚Äô, find the length of the longest valid (well-formed) parentheses substring. Example Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot;Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; Solution class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i = 0; i&lt;len ;i++)&#123; if(s.charAt(i) == '(')open++; else if(open &gt;0 &amp;&amp; s.charAt(i)==')')&#123; dp[i] = dp[i-1]+2; if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(dp[i],max); &#125; return max; &#125;&#125; DP problem. When we meet ‚Äò)‚Äô and open &gt;0 then we start dp operation. Tricky point is the line in the bellow: if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]];&#125; We are looking for the longest continuous parentheses, so we have to check the dp value before the current valid length. For example: ()()() // case 1((())) // case 2 In case 1, only we meet ) then we can make current dp to 2, but after that we will back to the value of 0. So we have to check whether there is valid length before the current length. In case 2 it is normal way what we think in the first time. 43. Multiply Strings √∞≈∏‚Äù‚Äî Question Link Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example Example 1:Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot;Example 2:Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Solution class Solution &#123; public String multiply(String num1, String num2) &#123; int m = num1.length(); int n = num2.length(); int[] arr = new int[m+n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; int mul = (num1.charAt(i)-'0') * (num2.charAt(j)-'0'); int pos1 = i+j,pos2 = i+j+1; int sum = arr[pos2] + mul; arr[pos1] += sum / 10; arr[pos2] = sum % 10; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int num : arr)&#123; if(!(sb.length() == 0 &amp;&amp; num == 0))&#123; sb.append(num); &#125; &#125; return sb.length() == 0 ? \"0\" : sb.toString(); &#125;&#125; T:O(n^2) S:O(1) We simulate the multiply process. Using pos1 and pos2 to store the carry. For example: 1 2 5 * 3 2 ------ 1 0 ( 5*2 ) step 1 0 4 ( 2*2 ) step 2 0 2 ( 1*2 ) .... 3 1 5 ( 3*5 ) .... 4 0 6 ...0 3 ...-------------- 4 0 0 0 Like above, cause every time we caculate the two number to get mul, then we have to use the last time‚Äôs pos1 value, which is the same as current pos2‚Äôs vlaue. Then after caculate that we add them together to get the final value string.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"New App Deployed üéâ","slug":"app1","date":"2020-05-31T16:13:54.000Z","updated":"2020-06-20T16:25:18.757Z","comments":true,"path":"2020/05/31/app1/","link":"","permalink":"WangHngLeee.github.io/2020/05/31/app1/","excerpt":"","text":"Covid-19 Tracker App now available online ! üíä üîó COVID-19 tracker Brief content of the application. Skill included: React, JavaScript, Chart.js, axios, MongoDB, ElementUI‚Ä¶","categories":[{"name":"Depolyed Web App","slug":"Depolyed-Web-App","permalink":"WangHngLeee.github.io/categories/Depolyed-Web-App/"}],"tags":[{"name":"Web Application","slug":"Web-Application","permalink":"WangHngLeee.github.io/tags/Web-Application/"},{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"}]},{"title":"Leetcode EveryDay 93 / String(1) üí™","slug":"string01","date":"2020-05-30T17:53:35.000Z","updated":"2020-06-02T21:14:03.882Z","comments":true,"path":"2020/05/30/string01/","link":"","permalink":"WangHngLeee.github.io/2020/05/30/string01/","excerpt":"14. Longest Common Prefix üîó Question Link Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string ‚Äú‚Äù. Example Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;","text":"14. Longest Common Prefix üîó Question Link Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string ‚Äú‚Äù. Example Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Solution class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs.length == 0 || strs == null) return \"\"; String pre = strs[0]; for(int i = 1 ; i &lt; strs.length ;i++)&#123; while(strs[i].indexOf(pre)!=0)&#123; pre = pre.substring(0,pre.length()-1); &#125; &#125; return pre; &#125;&#125; T: O(n) S: O(1) Using tricky of function of indexOf to get the first positoin of string. We take first string as comparator, then loop all the other strings to check if the first position of comparator in these strings is 0. If not 0, then we shrink the comparator string‚Äôs length - 1. 10. Regular Expression Matching üîó¬óQuestion Link Given an input string (s) and a pattern ¬ß, implement regular expression matching with support for ‚Äò.‚Äô and ‚Äò*‚Äô. ‚Äò.‚Äô Matches any single character. ‚Äò*‚Äô Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the preceding element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Solution class Solution&#123; public boolean isMatch(String s, String p) &#123; if(s == null || p == null) &#123; return false; &#125; boolean[][] state = new boolean[s.length() + 1][p.length() + 1]; state[0][0] = true; for (int j = 1; j &lt; state[0].length; j++) &#123; if (p.charAt(j - 1) == '*') &#123; if (state[0][j - 1] || (j &gt; 1 &amp;&amp; state[0][j - 2])) &#123; state[0][j] = true; &#125; &#125; &#125; for (int i = 1; i &lt; state.length; i++) &#123; for (int j = 1; j &lt; state[0].length; j++) &#123; if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') &#123; state[i][j] = state[i - 1][j - 1]; &#125; if (p.charAt(j - 1) == '*') &#123; if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != '.') &#123; state[i][j] = state[i][j - 2]; &#125; else &#123; state[i][j] = state[i - 1][j] || state[i][j - 1] || state[i][j - 2]; &#125; &#125; &#125; &#125; return state[s.length()][p.length()]; &#125;&#125; DP solution. 1, If p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];2, If p.charAt(j) == &apos;.&apos; : dp[i][j] = dp[i-1][j-1];3, If p.charAt(j) == &apos;*&apos;: here are two sub conditions: 1 if p.charAt(j-1) != s.charAt(i) dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty 2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == &apos;.&apos;: dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Leetcode EveryDay 92 üí™","slug":"code02","date":"2020-05-24T22:15:39.000Z","updated":"2020-05-24T22:26:31.171Z","comments":true,"path":"2020/05/24/code02/","link":"","permalink":"WangHngLeee.github.io/2020/05/24/code02/","excerpt":"130. Surrounded Regions √∞≈∏‚Äù‚ÄîQuestion Link BFS Solution : class Solution &#123; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; queue.add(new int[]&#123;i,j&#125;); board[i][j] = 'a'; &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] temp = queue.poll(); for(int[] dir : dirs)&#123; int x = temp[0]+dir[0]; int y = temp[1]+dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; board[x][y] == 'O') &#123; queue.add(new int[]&#123;x,y&#125;); board[x][y] = 'a'; &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125;&#125; DFS Solution : class Solution &#123; int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; helper(i,j,board); &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125; public void helper(int r, int c, char[][]board)&#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = 'a'; for(int[] dir : dirs)&#123; int x = r + dir[0]; int y = c + dir[1]; helper(x,y,board); &#125; &#125; &#125;&#125; In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into ‚Äòa‚Äô. After that, we make a loop of the whole board to change ‚Äòa‚Äô into O and all other Os into ‚ÄòX‚Äô.","text":"130. Surrounded Regions √∞≈∏‚Äù‚ÄîQuestion Link BFS Solution : class Solution &#123; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; queue.add(new int[]&#123;i,j&#125;); board[i][j] = 'a'; &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] temp = queue.poll(); for(int[] dir : dirs)&#123; int x = temp[0]+dir[0]; int y = temp[1]+dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; row &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; col &amp;&amp; board[x][y] == 'O') &#123; queue.add(new int[]&#123;x,y&#125;); board[x][y] = 'a'; &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125;&#125; DFS Solution : class Solution &#123; int[][] dirs = &#123;&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; public void solve(char[][] board) &#123; if(board.length &lt; 3 || board[0].length &lt; 3)return; int row = board.length; int col = board[0].length; for(int i = 0 ; i&lt;row;i++)&#123; for(int j = 0 ; j&lt;col;j++)&#123; if( (i==0 || i==row-1 || j==0 || j==col-1 ) &amp;&amp; board[i][j] == 'O')&#123; helper(i,j,board); &#125; &#125; &#125; for(int i = 0 ; i &lt; row ; i++)&#123; for(int j = 0 ; j&lt;col ; j++)&#123; if(board[i][j] == 'a')board[i][j] = 'O'; else if(board[i][j] == 'O')board[i][j] = 'X'; &#125; &#125; &#125; public void helper(int r, int c, char[][]board)&#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = 'a'; for(int[] dir : dirs)&#123; int x = r + dir[0]; int y = c + dir[1]; helper(x,y,board); &#125; &#125; &#125;&#125; In both solution, we just first check the boundary of the board and to check the continus Os, and we change every continus O in boundary into ‚Äòa‚Äô. After that, we make a loop of the whole board to change ‚Äòa‚Äô into O and all other Os into ‚ÄòX‚Äô.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"}]},{"title":"React Review üìì","slug":"react1","date":"2020-05-19T13:58:50.000Z","updated":"2020-05-19T19:39:10.747Z","comments":true,"path":"2020/05/19/react1/","link":"","permalink":"WangHngLeee.github.io/2020/05/19/react1/","excerpt":"React Â§ç‰π† ÁîüÂëΩÂë®Êúü ÁîüÂëΩÂë®ÊúüÂ∞±ÊòØÁªÑ‰ª∂‰ªéÂÆû‰æãÂåñÂà∞Ê∏≤ÊüìÂÜçÂà∞ÊúÄÁªà‰ªéÈ°µÈù¢‰∏≠ÈîÄÊØÅÔºåÊï¥‰∏™ËøáÁ®ãÂ∞±ÊòØÁîüÂëΩÂë®Êúü„ÄÇÂú®ÁîüÂëΩÂë®Êúü‰∏≠ÔºåÊúâÂæàÂ§öÂèØ‰ª•Ë∞ÉÁî®ÁöÑ‰∫ã‰ª∂Ôºå‰πüÁß∞‰∏∫hook/Èí©Â≠êÂáΩÊï∞„ÄÇ ÁîüÂëΩÂë®Êúü‰∏â‰∏™Áä∂ÊÄÅ Mounting : Â∞ÜÁªÑ‰ª∂ÊèíÂÖ•DOM‰∏≠ Updating : Â∞ÜÁªÑ‰ª∂Êõ¥Êñ∞Âà∞DOM‰∏≠ Unmounting : Â∞ÜÁªÑ‰ª∂ÁßªÂá∫DOM Èí©Â≠êÂáΩÊï∞ÔºàÊñπÊ≥ïÔºå‰∫ã‰ª∂Ôºâ componentWillMount(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊ∏≤Êüì,AJAX,Ê∑ªÂä†Âä®ÁîªÂâçÁöÑÁ±ª componentDidMount(): ÁªÑ‰ª∂Ê∏≤ÊüìÂÆåÊØïÔºåÊ∑ªÂä†Âä®Áîª componentWillReceiveProps(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊé•ÂèópropsÊï∞ÊçÆ shouldComponentUpdate(): ÁªÑ‰ª∂Êé•Êî∂Âà∞Êñ∞ÁöÑprops/stateÊó∂Âà§Êñ≠ÊòØÂê¶Êõ¥Êñ∞ÔºåËøîÂõûbooleanÂÄº componentWillUpdate(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊõ¥Êñ∞ componentDidUpdate(): ÁªÑ‰ª∂Êõ¥Êñ∞ÂÆåÊØï compnentWillUnmount(): ÁªÑ‰ª∂Â∞ÜË¶ÅÂç∏ËΩΩ","text":"React Â§ç‰π† ÁîüÂëΩÂë®Êúü ÁîüÂëΩÂë®ÊúüÂ∞±ÊòØÁªÑ‰ª∂‰ªéÂÆû‰æãÂåñÂà∞Ê∏≤ÊüìÂÜçÂà∞ÊúÄÁªà‰ªéÈ°µÈù¢‰∏≠ÈîÄÊØÅÔºåÊï¥‰∏™ËøáÁ®ãÂ∞±ÊòØÁîüÂëΩÂë®Êúü„ÄÇÂú®ÁîüÂëΩÂë®Êúü‰∏≠ÔºåÊúâÂæàÂ§öÂèØ‰ª•Ë∞ÉÁî®ÁöÑ‰∫ã‰ª∂Ôºå‰πüÁß∞‰∏∫hook/Èí©Â≠êÂáΩÊï∞„ÄÇ ÁîüÂëΩÂë®Êúü‰∏â‰∏™Áä∂ÊÄÅ Mounting : Â∞ÜÁªÑ‰ª∂ÊèíÂÖ•DOM‰∏≠ Updating : Â∞ÜÁªÑ‰ª∂Êõ¥Êñ∞Âà∞DOM‰∏≠ Unmounting : Â∞ÜÁªÑ‰ª∂ÁßªÂá∫DOM Èí©Â≠êÂáΩÊï∞ÔºàÊñπÊ≥ïÔºå‰∫ã‰ª∂Ôºâ componentWillMount(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊ∏≤Êüì,AJAX,Ê∑ªÂä†Âä®ÁîªÂâçÁöÑÁ±ª componentDidMount(): ÁªÑ‰ª∂Ê∏≤ÊüìÂÆåÊØïÔºåÊ∑ªÂä†Âä®Áîª componentWillReceiveProps(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊé•ÂèópropsÊï∞ÊçÆ shouldComponentUpdate(): ÁªÑ‰ª∂Êé•Êî∂Âà∞Êñ∞ÁöÑprops/stateÊó∂Âà§Êñ≠ÊòØÂê¶Êõ¥Êñ∞ÔºåËøîÂõûbooleanÂÄº componentWillUpdate(): ÁªÑ‰ª∂Â∞ÜË¶ÅÊõ¥Êñ∞ componentDidUpdate(): ÁªÑ‰ª∂Êõ¥Êñ∞ÂÆåÊØï compnentWillUnmount(): ÁªÑ‰ª∂Â∞ÜË¶ÅÂç∏ËΩΩ Â∞ùËØï‰ª•‰∏ã‰ª£Á†ÅËæìÂá∫ÊÉÖÂÜµÔºö import React,&#123;Component&#125; from 'react';import ReactDOM from 'react-dom';class Complife extends React.Component()&#123; constructor(props)&#123; super(props); this.state=&#123; msg:'test msg' &#125; console.log('ÊûÑÈÄ†ÂáΩÊï∞') &#125; componentWillMount()&#123; console.log('ÊåÇËΩΩÂÆåÊØïÔºåÂáÜÂ§áÊ∏≤Êüì') &#125; componentDidMount()&#123; console.log('Ê∏≤ÊüìÂÆåÊØï') &#125; componentWillReceiveProps()&#123; console.log('ÁªÑ‰ª∂Â∞ÜË¶ÅÊé•Âèóprops') &#125; shouldComponentUpdate()&#123; //Â¶ÇÊûúÂ∏åÊúõÊõ¥Êñ∞ËøîÂõûtrueÔºå‰∏çÂ∏åÊúõÂàôËøîÂõûfalseÔºå‰∏çÊõ¥Êñ∞Â∞±ÊòØundefined if(this.state.msg == 'test msg')&#123; return true; console.log(true); &#125; else&#123; return false; console.log(false); &#125; &#125; componentWillUpdate()&#123; console.log('ÁªÑ‰ª∂Â∞ÜË¶ÅÊõ¥Êñ∞') &#125; componentDidUpdate()&#123; console.log('ÁªÑ‰ª∂Êõ¥Êñ∞ÂÆåÊØï') &#125; componentWillUnmount()&#123; console.log('ÁªÑ‰ª∂Âç∏ËΩΩ') &#125; render()&#123; console.logÔºà'Ê∏≤ÊüìÂáΩÊï∞') return( &lt;div&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Complife /&gt;, document.querySelector('#app')) consoleÁªìÊûú ÊûÑÈÄ†ÂáΩÊï∞ÁªÑ‰ª∂Â∞ÜË¶ÅÊ∏≤ÊüìÊ∏≤ÊüìÂáΩÊï∞ÁªÑ‰ª∂Ê∏≤ÊüìÂÆåÊØï Ê≤°ÊúâÂÖ∂‰ªñeventÊó∂ÊûÑÈÄ†ÁöÑÈ°∫Â∫èÂ¶Ç‰∏äÈù¢ÁªìÊûúÊâÄÁ§∫„ÄÇ ‰ΩÜÂ¶ÇÊûúÊúâclickeventÊõ¥Êñ∞Áä∂ÊÄÅÊó∂ÔºåÁªÑ‰ª∂ÁöÑÁä∂ÊÄÅÈ°∫Â∫èÂèàÊòØÊÄéÊ†∑ÁöÑÂë¢Ôºü ÂÖ∂‰ªñ‰∏çÂèòÔºåÂú®renderÂáΩÊï∞‰∏≠Â¢ûÂä†‰∏Ä‰∏™ondlick‰∫ã‰ª∂ ............ render()&#123; console.logÔºà'Ê∏≤ÊüìÂáΩÊï∞') return( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.changeMsg&#125;&gt;Êõ¥Êñ∞&lt;/button&gt; &lt;/div&gt; ) &#125; changeMsg=()=&gt;&#123; this.setState(&#123; msg:\"changing msg\" &#125;) &#125; &#125;............ ÁÇπÂáªÊõ¥Êñ∞ÂêéÊ≠§Êó∂consoleÂ∞Ü‰ºöÂ§öÂá∫‰ª•‰∏ãÂÜÖÂÆπ ÁªÑ‰ª∂Â∞ÜË¶ÅÊõ¥Êñ∞Ê∏≤ÊüìÂáΩÊï∞ÁªÑ‰ª∂Êõ¥Êñ∞ÂÆåÊØï Âú®complife‰πãÂêéÂ¢ûÂä†parent classÂ∞ùËØïUnmountÂáΩÊï∞ ......class Parent extends React.Component()&#123; constructor(props)&#123; super(props); this.state=&#123; isshow:true; &#125; &#125; render()&#123; return( &lt;div&gt; &lt;button onClick=&#123;this.remove&#125;&gt; remove complifÁªÑ‰ª∂ &lt;/button&gt; &lt;complife /&gt; &lt;/div&gt; ) &#125; remove=()=&gt;&#123; this.setState(&#123; isshow:false; &#125;) &#125;&#125;ReactDOM.render( &lt;Parent /&gt;, document.querySelector('#app')) Ê≠§Êó∂ÁÇπÂáªbuttonÂêé‰ºöÂ¢ûÂä†‰∏ÄÊù°console ÁªÑ‰ª∂Âç∏ËΩΩ","categories":[{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"React","slug":"ÂâçÁ´ØÊ°ÜÊû∂/React","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/React/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"}]},{"title":"Leetcode EveryDay 91 üí™","slug":"code01","date":"2020-05-16T15:16:38.000Z","updated":"2020-05-16T23:15:14.451Z","comments":true,"path":"2020/05/16/code01/","link":"","permalink":"WangHngLeee.github.io/2020/05/16/code01/","excerpt":"289. Game of Life üîóQuestion Link class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state: 1 means keep living 2 means live to dead* 3 means dead to live. Finally we just use the number to %2 to get the final result.","text":"289. Game of Life üîóQuestion Link class Solution &#123; int[][] dir =&#123;&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;&#125;; public void gameOfLife(int[][] board) &#123; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; int live=0; for(int[] d:dir)&#123; if(d[0]+i&lt;0 || d[0]+i&gt;=board.length || d[1]+j&lt;0 || d[1]+j&gt;=board[0].length) continue; if(board[d[0]+i][d[1]+j]==1 || board[d[0]+i][d[1]+j]==2) live++; &#125; if(board[i][j]==0 &amp;&amp; live==3) board[i][j]=3;// dead to live if(board[i][j]==1 &amp;&amp; (live&lt;2 || live&gt;3)) board[i][j]=2; // live to dead if(board[i][j]==1 &amp;&amp; (live ==2 || live ==3))board[i][j]=1; // continue live; &#125; &#125; for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; board[i][j]%=2; &#125; &#125; &#125;&#125; First we loop the whole board , find total lives for each cell in 8 directions. Then we check different situation according to the question descriptoin. I use three different state to save the state: 1 means keep living 2 means live to dead* 3 means dead to live. Finally we just use the number to %2 to get the final result. 1249. Minimum Remove to Make Valid Parentheses üîóQuestion Link class Solution &#123; public String minRemoveToMakeValid(String s) &#123; if(s == null || s.length() == 0)return \"\"; boolean[] check = new boolean[s.length()]; StringBuilder res = new StringBuilder(\"\"); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0 ;i&lt;s.length() ;i++)&#123; if(s.charAt(i) == '(')stack.push(i); // add idnex of ( to stack else if(s.charAt(i) == ')')&#123; if(!stack.isEmpty())&#123; // stack not empty then add index of ) to stack check[i] = true; check[stack.pop()] = true; &#125; &#125;else&#123; check[i] = true; // any character in s should be true &#125; &#125; for(int i = 0 ; i &lt; check.length ;i++)&#123; if(check[i])&#123; res.append(s.charAt(i)); &#125; &#125; return res.toString(); &#125;&#125; First we add index of open / close parenthes to stack. Then we check for pair. If there is a pair of them we change the index of these in check to be true. All other chars should be true in check array except for ( and ). Finally we loop the check array to form the final res string. 415. Add Strings üîóQuestion Link class Solution &#123; public String addStrings(String num1, String num2) &#123; int len1 = num1.length()-1; int len2 = num2.length()-1; int carry = 0; StringBuilder sb = new StringBuilder(); while(len1 &gt;=0 || len2 &gt;=0)&#123; int n1 = 0; int n2 = 0; if(len1 &gt;=0)&#123; n1 = num1.charAt(len1)-'0'; &#125; if(len2&gt;=0)&#123; n2 = num2.charAt(len2)-'0'; &#125; int sum = n1 + n2 + carry; carry = sum/10; sb.append(sum%10); len1--; len2--; &#125; if(carry!=0)&#123; sb.append(carry); &#125; return sb.reverse().toString(); &#125;&#125; Normal solution. Using carry and sum/10 and sum%10. Remeber to reverse the ans in the final. 953. Verifying an Alien Dictionary üîóQuestion Link class Solution &#123; int[] dict = new int[26]; public boolean isAlienSorted(String[] words, String order) &#123; for(int i = 0 ; i&lt;order.length() ;i++)&#123; dict[order.charAt(i)-'a'] = i; &#125; for(int j = 1 ;j&lt;words.length;j++)&#123; if(checkbig(words[j-1],words[j]))&#123; return false; &#125; &#125; return true; &#125; public boolean checkbig(String word1, String word2)&#123; int a = word1.length(); int b = word2.length(); for(int i = 0 ; i&lt;a &amp;&amp; i&lt;b;i++)&#123; if(word1.charAt(i) != word2.charAt(i))&#123; if(dict[word1.charAt(i)-'a'] &lt; dict[word2.charAt(i)-'a'])return false; if(dict[word1.charAt(i)-'a'] &gt; dict[word2.charAt(i)-'a'])return true; &#125; &#125; return word1.length() &gt; word2.length(); &#125;&#125; First we use int[26] to store the new order of letters. Then we use it as a new dictionary to compare. After we make it, we loop the given string array, then check them one by one. Make a new function checkbig to check whether the later word is bigger than the former. If yes then return false. Otherwise we continue. In the checkbig function, we check the value of each char in the dictionary. If word1‚Äôs char is little than the word2 then we return true. So back to the main function it will return false. In final we also need check the length of them. eg ( ‚Äòword‚Äô, ‚Äòwordl‚Äô). 339. Nested List Weight Sum üîóQuestion Link * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public int depthSum(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null)return 0; int sum = 0; int level = 1; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i&lt;size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())sum+=temp.getInteger()*level; else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; level++; &#125; return sum; &#125;&#125; Using BFS to loop the whole array like a binary tree. In the queue loop, we only need to check whether current is an integer or a nestedarray. If is an integer, we add its value * level to the sum. After each level loop, we increase level by 1. Input: [1,[4,[6]]]Output: 27Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27. 364. Nested List Weight Sum II üîóQuestion Link * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * // Constructor initializes an empty nested list. * public NestedInteger(); * * // Constructor initializes a single integer. * public NestedInteger(int value); * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // Set this NestedInteger to hold a single integer. * public void setInteger(int value); * * // Set this NestedInteger to hold a nested list and adds a nested integer to it. * public void add(NestedInteger ni); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */class Solution &#123; public int depthSumInverse(List&lt;NestedInteger&gt; nestedList) &#123; if(nestedList == null) return 0; Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;&gt;(); for(NestedInteger ni : nestedList)&#123; queue.add(ni); &#125; int prevsum = 0; int total = 0; while(!queue.isEmpty())&#123; int size = queue.size(); int levelsum = 0; for(int i = 0 ; i&lt; size ;i++)&#123; NestedInteger temp = queue.poll(); if(temp.isInteger())levelsum+=temp.getInteger(); else&#123; for(NestedInteger n : temp.getList())&#123; queue.add(n); &#125; &#125; &#125; prevsum+=levelsum; total+=prevsum; &#125; return total; &#125;&#125; Different to the former question, in this question we have to loop from the leaf. So we have to keep a prevsum to keep track of. Input: [1,[4,[6]]]Output: 17Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1*3 + 4*2 + 6*1 = 17.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"}]},{"title":"Front-end Interview Questions 1 üí™","slug":"Font-end Interview","date":"2020-05-12T18:28:27.000Z","updated":"2020-06-20T16:26:34.645Z","comments":true,"path":"2020/05/12/Font-end Interview/","link":"","permalink":"WangHngLeee.github.io/2020/05/12/Font-end Interview/","excerpt":"HTML ÁØá HTML5ËØ≠‰πâÂåñ Â∞±ÊòØÁî®ÂêàÁêÜ„ÄÅÊ≠£Á°ÆÁöÑÊ†áÁ≠æÊù•Â±ïÁ§∫ÂÜÖÂÆπÔºåÂ¶Çh1h2h3 p Ëøô‰∫õ„ÄÇ prosÔºö1.Êòì‰∫éÈòÖËØªÔºåÂΩìÊ†∑ÂºèË°®Áé∞‰∏¢Â§±Êó∂ÔºåÁªìÊûÑÊñπ‰æøËØªËÄÖÈòÖËØª„ÄÇ 2.Âà©‰∫éÂºÄÂèëÁª¥Êä§ÔºåÁ±ªÂà´Ê∏ÖÊô∞„ÄÇ","text":"HTML ÁØá HTML5ËØ≠‰πâÂåñ Â∞±ÊòØÁî®ÂêàÁêÜ„ÄÅÊ≠£Á°ÆÁöÑÊ†áÁ≠æÊù•Â±ïÁ§∫ÂÜÖÂÆπÔºåÂ¶Çh1h2h3 p Ëøô‰∫õ„ÄÇ prosÔºö1.Êòì‰∫éÈòÖËØªÔºåÂΩìÊ†∑ÂºèË°®Áé∞‰∏¢Â§±Êó∂ÔºåÁªìÊûÑÊñπ‰æøËØªËÄÖÈòÖËØª„ÄÇ 2.Âà©‰∫éÂºÄÂèëÁª¥Êä§ÔºåÁ±ªÂà´Ê∏ÖÊô∞„ÄÇ ÁªìÊûÑ 1.header ÂÆö‰πâÊñáÊ°£ÊàñËÄÖÊñáÊ°£ÁöÑÈÉ®ÂàÜÂå∫ÂüüÁöÑÈ°µÁúâÔºåÂ∫î‰Ωú‰∏∫‰ªãÁªçÂÜÖÂÆπÊàñËÄÖÂØºËà™ÈìæÊé•Ê†èÁöÑÂÆπÂô®„ÄÇ 2.nav ÂåÖÂê´Â§ö‰∏™Ë∂ÖÈìæÊé•ÁöÑÂå∫ÂüüÔºåÂåÖÂê´ÂèØ‰ª•Ë∑≥ËΩ¨Âà∞ÂÖ∂‰ªñÈ°µÈù¢ÊàñËÄÖËØ•È°µÈù¢ÂÖ∂‰ªñÈÉ®ÂàÜÁöÑÈìæÊé•ÂàóË°®„ÄÇ 3.main ÂÆö‰πâÊñáÊ°£ÁöÑ‰∏ªË¶ÅÈÉ®ÂàÜÔºåÂè™ËÉΩÊúâ‰∏Ä‰∏™Ôºå ‰∏∫‰ªÄ‰πàÊúÄÂ•ΩÊää CSS ÁöÑlinkÊ†áÁ≠æÊîæÂú®head‰πãÈó¥Ôºü‰∏∫‰ªÄ‰πàÊúÄÂ•ΩÊääJSÁöÑscriptÊ†áÁ≠æÊÅ∞Â•ΩÊîæÂú®body‰πãÂâçÔºåÊúâ‰æãÂ§ñÊÉÖÂÜµÂêóÔºü 1.ÊäälinkÊîæÂú®head‰∏≠ È¶ñÂÖàÔºåËøôÊòØËßÑËåÉÊñáÊ°£ÁöÑË¶ÅÊ±Ç„ÄÇÂÖ∂Ê¨°ÔºåÊòØ‰∏∫‰∫ÜËÆ©È°µÈù¢ÈÄêÊ≠•ÂëàÁé∞ÔºåÊèêÈ´òÁî®Êà∑‰ΩìÈ™å„ÄÇËã•ÊîæÂú®Â∫ïÈÉ®ÔºåÈÉ®ÂàÜÊµèËßàÂô®‰∏çËÉΩÈÄêÊ≠•ÂëàÁé∞ÁîöËá≥Âä†ËΩΩÂ§±Ë¥•„ÄÇ ËøôÊ†∑ÂÅöÂèØ‰ª•Èò≤Ê≠¢ÂëàÁé∞Á©∫ÁôΩÈ°µÊàñËÄÖÊó†Ê†∑ÂºèÈ°µÈù¢„ÄÇ 2.ÊääscriptÊîæÂú®/body‰πãÂâç ËÑöÊú¨Âú®‰∏ãËΩΩÊó∂ÂíåÊâßË°åÊúüÂâçÔºå‰ºöÈòªÊ≠¢HTMLËß£ÊûêÔºåÊîæÂú®Â∫ïÈÉ®ÊòØ‰∏∫‰∫Ü‰øùËØÅhtmlËÉΩÂ§üÈ°∫Âà©Âä†ËΩΩÔºåÂ∞ÜÈ°µÈù¢Â∞ΩÂø´ÂëàÁé∞„ÄÇ ‰æãÂ§ñÁöÑÊÉÖÂÜµÊòØËÑöÊú¨ÈáåÂåÖÂê´document.write()Êó∂„ÄÇÊàñËÄÖÊòØscript‰ΩøÁî®deferÂ±ûÊÄßÔºåÊîæÂú®head‰∏≠„ÄÇ ‰ªÄ‰πàÊòØÊ∏êËøõÂºèÊ∏≤ÊüìÔºàprogressive renderingÔºâÔºü ÊòØÁî®‰∫éÊèêÈ´òÁΩëÈ°µÊÄßËÉΩÔºå‰ª•Â∞ΩÂø´ÂëàÁé∞ÁΩëÈ°µÁöÑÊäÄÊúØÔºåÁé∞Â§öÁî®‰∫éÁßªÂä®Á´Ø(ÁßªÂä®Á´ØÁΩëÈÄü‰∏çÁ®≥ÂÆö) 1.ÂõæÁâáÊáíÂä†ËΩΩ‚Äî‚ÄîÈ°µÈù¢‰∏äÁöÑÂõæÁâá‰∏ç‰ºö‰∏ÄÊ¨°ÊÄßÂÖ®ÈÉ®Âä†ËΩΩ„ÄÇÂΩìÁî®Êà∑ÊªöÂä®È°µÈù¢Âà∞ÂõæÁâáÈÉ®ÂàÜÊó∂ÔºåJavaScript Â∞ÜÂä†ËΩΩÂπ∂ÊòæÁ§∫ÂõæÂÉè„ÄÇ 2.ÂàÜÂ±ÇÊ¨°Ê∏≤Êüì„ÄÇÈ°µÈù¢Âè™ÂåÖÂê´Âü∫Êú¨ÁöÑÊúÄÂ∞ëÈáèÁöÑ CSS„ÄÅËÑöÊú¨ÂíåÂÜÖÂÆπÔºåÁÑ∂ÂêéÂèØ‰ª•‰ΩøÁî®Âª∂ËøüÂä†ËΩΩËÑöÊú¨ÊàñÁõëÂê¨DOMContentLoaded/load‰∫ã‰ª∂Âä†ËΩΩÂÖ∂‰ªñËµÑÊ∫êÂíåÂÜÖÂÆπ„ÄÇ 3.ÂºÇÊ≠•Âä†ËΩΩ HTML ÁâáÊÆµ‚Äî‚ÄîÂΩìÈ°µÈù¢ÈÄöËøáÂêéÂè∞Ê∏≤ÊüìÊó∂ÔºåÊääHTMLÊãÜÂàÜÔºåÈÄöËøáÂºÇÊ≠•ËØ∑Ê±ÇÔºåÂàÜÂùóÂèëÈÄÅÁªôÊµèËßàÂô®„ÄÇ viewport ËßÜÂõæÁ™óÂè£ÔºåÂú®ÁßªÂä®webÂºÄÂèë‰∏≠‰ΩøÁî®„ÄÇË°®Á§∫Â∞ÜËÆæÂ§áÊµèËßàÂô®ÂÆΩÂ∫¶ËôöÊãüÊàê‰∏Ä‰∏™ÁâπÂÆöÁöÑÂÄºÔºàÊàñËÆ°ÁÆóÂæóÂá∫ÔºâÔºåËøôÊ†∑Âà©‰∫éÁßªÂä®webÁ´ôÁÇπË∑®ËÆæÂ§áÊòæÁ§∫ÊïàÊûúÂü∫Êú¨‰∏ÄËá¥. ReflowÂíåRepaint Reflow ÂΩìÊ∂âÂèäÂà∞DOMËäÇÁÇπÁöÑÂ∏ÉÂ±ÄÂ±ûÊÄßÂèëÁîüÊîπÂèòÊó∂Ôºå‰ºöÈáçÊñ∞ËÆ°ÁÆóËØ•Â±ûÊÄßÔºåÂπ∂ÈáçÊñ∞ÊèèÁªòÁõ∏Â∫îÁöÑÂÖÉÁ¥†ÔºåÁß∞‰∏∫ÂõûÊµÅ„ÄÇ Repaint ÂΩìÂΩ±ÂìçDOMÂÖÉÁ¥†ÂèØËßÅÊÄßÁöÑÂ±ûÊÄßÂèëÁîüÂèòÂåñÊó∂ÔºåÊµèËßàÂô®‰ºöÈáçÊñ∞ÊèèËø∞ËØ•ÂÖÉÁ¥†ÔºåÁß∞‰∏∫ÈáçÁªò„ÄÇ ‰ΩÜRepaintÂíåReflowÊòØ‰∏çÂèØÈÅøÂÖçÁöÑÔºåÂè™ËÉΩËØ¥ÂØπÊÄßËÉΩÁöÑÂΩ±ÂìçÂáèÂà∞ÊúÄÂ∞è„ÄÇ img‰∏≠ÁöÑaltÂíåÂÖÉÁ¥†ÁöÑtitleÂ±ûÊÄß‰ΩúÁî® alt Â¶ÇÊûúÊó†Ê≥ïÊòæÁ§∫ÂõæÂÉèÔºåÊµèËßàÂô®‰ºöÊòæÁ§∫altÊåáÂÆöÁöÑÂÖÉÁ¥†„ÄÇ img Èº†Ê†áÊÇ¨ÊµÆÊó∂ÊòæÁ§∫titleÂÜÖÂÆπ„ÄÇ hrefÂíåsrcÂå∫Âà´ hrefË∂ÖÊñáÊú¨ÂºïÁî®ÔºåÁî®‰∫éaÂíålinkÂÖÉÁ¥†‰∏ä srcÊòØÂºïÁî®ËµÑÊ∫êÔºåÊõøÊç¢ÂΩìÂâçÂÖÉÁ¥†„ÄÇÊµèËßàÂô®Ëß£ÊûêÂà∞srcÊó∂‰ºöÊöÇÂÅúÂÖ∂‰ªñ‰ªªÂä°Ôºå‰πüÊòØ‰∏∫‰ªÄ‰πàjsÂ∫îËØ•ÊîæÂú®Â∫ïÈÉ®ÁöÑÂéüÂõ†„ÄÇ ÊµèËßàÂô®Ê∏≤ÊüìËøáÁ®ã 1.Ëß£ÊûêhtmlÁîüÊàêDOMÊ†ë 2.Ëß£ÊûêcssÁîüÊàêcssomÊ†ë 3.Â∞ÜdomÂíåcssomÂêàÂπ∂ÊàêÊ∏≤ÊüìÊ†ë 4.ÈÅçÂéÜÊ∏≤ÊüìÊ†ëÂºÄÂßãÂ∏ÉÂ±ÄÔºåËÆ°ÁÆóÊØè‰∏™‰ΩçÁΩÆÁöÑÂ§ßÂ∞è 5.Â∞ÜÊ∏≤ÊüìÊ†ëÊØè‰∏™ËäÇÁÇπÁªòÂà∂Âà∞Â±èÂπï‰∏ä","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 5 üí™","slug":"front-end-interview2","date":"2020-04-26T18:28:27.000Z","updated":"2020-05-19T15:45:43.592Z","comments":true,"path":"2020/04/26/front-end-interview2/","link":"","permalink":"WangHngLeee.github.io/2020/04/26/front-end-interview2/","excerpt":"","text":"HTML &lt;!DOCTYPE&gt;‰ΩúÁî® ‰∏ÄËà¨Âú®htmlÊñáÊ°£Á¨¨‰∏ÄË°åÂ£∞Êòé„ÄÇÁî®Êù•ÂëäÁü•ÊµèËßàÂô®Áî®‰ªÄ‰πàÊñáÊ°£Ëß£ÊûêÊ†áÂáÜÊù•Ëß£ÊûêÂΩìÂâçÊñáÊ°£„ÄÇËß£ÊûêÊ®°ÂºèÂàÜ‰∏∫Ê†áÂáÜÊ®°ÂºèÂíåÂÖºÂÆπÊ®°Âºè„ÄÇ Ê†áÂáÜÊ®°Âºè &amp;&amp; ÂÖºÂÆπÊ®°Âºè Ê†áÂáÜÊ®°ÂºèÔºöÊ†áÂáÜÊ®°ÂºèÁöÑÊ∏≤ÊüìÊñπÂºèÂíå JS ÂºïÊìéÁöÑËß£ÊûêÊñπÂºèÈÉΩÊòØ‰ª•ËØ•ÊµèËßàÂô®ÊîØÊåÅÁöÑÊúÄÈ´òÊ†áÂáÜËøêË°å„ÄÇ ÂÖºÂÆπÊ®°ÂºèÔºöÈ°µÈù¢‰ª•ÂÆΩÊùæÁöÑÂêëÂêéÂÖºÂÆπÁöÑÊñπÂºèÊòæÁ§∫ÔºåÊ®°ÊãüËÄÅÂºèÊµèËßàÂô®ÁöÑË°å‰∏∫‰ª•Èò≤Ê≠¢Á´ôÁÇπÊó†Ê≥ïÂ∑•‰Ωú„ÄÇ link Âíå @importÂå∫Âà´ ‰ªéÂ±ûÂÖ≥Á≥ªÔºölinkÊòØÂü∫‰∫éhtmlÁöÑËØ≠Ê≥ïÔºåËÄå@importÊòØÂü∫‰∫écssÁöÑÔºåcss2.1‰πãÂêéÊâçÂá∫Áé∞„ÄÇ Âä†ËΩΩÈ°∫Â∫èÔºölink‰∏≠ÁöÑÂÜÖÂÆπÂèØ‰ª•ÈöèÈ°µÈù¢ÂÖ∂‰ªñÂÜÖÂÆπ‰∏ÄËµ∑Âä†ËΩΩÔºåËÄå@import‰∏≠ÂºïÂÖ•ÁöÑcssÂøÖÈ°ªÁ≠âÂÖ∂‰ªñÂÖ®ÈÉ®Âä†ËΩΩÂÆåÊàêÂêéÂÜçÂºÄÂßãÂä†ËΩΩ„ÄÇ ÂÖºÂÆπÊÄßÂå∫Âà´ÔºölinkÊòØÂü∫‰∫éhtmlÁöÑÔºå‰∏çÂ≠òÂú®ÂÖºÂÆπÊÄßÈóÆÈ¢ò„ÄÇ@importÊòØcss2.1‰πãÂêéÊâçÂá∫Áé∞ÁöÑÔºå‰ºöÂ≠òÂú®ÈÉ®ÂàÜIE5+‰πãÂâçÁöÑÊµèËßàÂô®Âú®‰∏çÂÖºÂÆπÁöÑÈóÆÈ¢ò„ÄÇ DOMÂèØÊìç‰ΩúÊÄßÔºö ÂèØ‰ª•ÈÄöËøáJSÊìç‰ΩúDOMÊîπÂèòlink‰∏≠ÁöÑÂÜÖÂÆπÊù•ÊîπÂèòÊ†∑ÂºèÔºõËÄåDOMÊòØÂü∫‰∫éÊñáÊ°£ÁöÑÔºåÊó†Ê≥ï‰ΩøÁî®@importÊù•ÊîπÂèò„ÄÇ ÊµèËßàÂô®Ê∏≤ÊüìÂéüÁêÜ È¶ñÂÖàËß£ÊûêÊî∂Âà∞HTMLÁöÑÊñá‰ª∂ÔºåÊûÑÈÄ†DOMÊ†ë„ÄÇ ÂØπCSSÊñá‰ª∂ËøõË°åËß£ÊûêÔºåÊûÑÈÄ†CSSOMËßÑÂàôÊ†ë„ÄÇ Ê†πÊçÆDOMÂíåCSSOMËßÑÂàôÊ†ëÊûÑÈÄ†Ê∏≤ÊüìÊ†ë„ÄÇ ÂΩìÊ∏≤ÊüìÂØπË±°Ë¢´ÂàõÂª∫Âπ∂Ê∑ªÂä†Âà∞Ê†ë‰∏≠ÔºåÂÆÉ‰ª¨Âπ∂Ê≤°Êúâ‰ΩçÁΩÆÂíåÂ§ßÂ∞èÔºåÊâÄ‰ª•ÂΩìÊµèËßàÂô®ÁîüÊàêÊ∏≤ÊüìÊ†ë‰ª•ÂêéÔºåÂ∞±‰ºöÊ†πÊçÆÊ∏≤ÊüìÊ†ëÊù•ËøõË°åÂ∏ÉÂ±ÄÔºà‰πüÂè´ÂÅöÂõûÊµÅ/ÈáçÊéíÔºâ. Â∏ÉÂ±ÄÈò∂ÊÆµÁªìÊùüÂêéÊòØÁªòÂà∂Èò∂ÊÆµÔºàÈáçÁªòÔºâÔºåÈÅçÂéÜÊ∏≤ÊüìÊ†ëÂπ∂Ë∞ÉÁî®Ê∏≤ÊüìÂØπË±°ÁöÑ paint ÊñπÊ≥ïÂ∞ÜÂÆÉ‰ª¨ÁöÑÂÜÖÂÆπÊòæÁ§∫Âú®Â±èÂπï‰∏äÔºåÁªòÂà∂‰ΩøÁî® UI Âü∫Á°ÄÁªÑ‰ª∂„ÄÇ async Âíå defer ÁöÑ‰ΩúÁî®ÂíåÂå∫Âà´ Â¶ÇÊûúscript‰∏≠Ê≤°ÊúâasyncÂíådeferÔºåÂàôÊµèËßàÂô®‰ºöËá™Âä®Âä†ËΩΩÂíåÊâßË°åÊåáÂÆöÂØπËÑöÊú¨Êñá‰ª∂ÔºåÂπ∂ÊöÇÂÅúÂÖ∂‰ªñËµÑÊ∫êÁöÑÂä†ËΩΩÂíåÊâßË°åÔºåÁü•ÈÅìscript‰∏≠ÁöÑËµÑÊ∫êÂä†ËΩΩÊâßË°åÂÆåÊØï„ÄÇ deferÔºöË°®Á§∫Âª∂ËøüÊâßË°åÂºïÂÖ•ÁöÑJS„ÄÇJSÂä†ËΩΩÊó∂ HTML Âπ∂Êú™ÂÅúÊ≠¢Ëß£ÊûêÔºåËøô‰∏§‰∏™ËøáÁ®ãÊòØÂπ∂Ë°åÁöÑ„ÄÇÂΩìÊï¥‰∏™ document Ëß£ÊûêÂÆåÊØïÂêéÂÜçÊâßË°åËÑöÊú¨Êñá‰ª∂ÔºåÂú® DOMContentLoaded ‰∫ã‰ª∂Ëß¶Âèë‰πãÂâçÂÆåÊàê„ÄÇÂ§ö‰∏™ËÑöÊú¨ÊåâÈ°∫Â∫èÊâßË°å„ÄÇ asyncÔºöË°®Á§∫ÂºÇÊ≠•ÊâßË°åÂºïÂÖ•JavaScriptÔºå‰∏é defer ÁöÑÂå∫Âà´Âú®‰∫éÔºåÂ¶ÇÊûúÂ∑≤ÁªèÂä†ËΩΩÂ•ΩÔºåÂ∞±‰ºöÂºÄÂßãÊâßË°åÔºå‰πüÂ∞±ÊòØËØ¥ÂÆÉÁöÑÊâßË°å‰ªçÁÑ∂‰ºöÈòªÂ°ûÊñáÊ°£ÁöÑËß£ÊûêÔºåÂè™ÊòØÂÆÉÁöÑÂä†ËΩΩËøáÁ®ã‰∏ç‰ºöÈòªÂ°û„ÄÇÂ§ö‰∏™ËÑöÊú¨ÁöÑÊâßË°åÈ°∫Â∫èÊó†Ê≥ï‰øùËØÅ„ÄÇ DOMContentLoaded ‰∫ã‰ª∂Âíå Load ‰∫ã‰ª∂ÁöÑÂå∫Âà´ DOMContentLoadedÂú®HTMLÊñá‰ª∂ÂÖ®ÈÉ®Âä†ËΩΩÂÆåÊàêÂêéËß¶ÂèëÔºåÂπ∂‰∏çÈúÄË¶ÅÁ≠âÂæÖcssÊ†∑Âºè„ÄÅÂõæÁâáÂõæË°®Á≠âÊñá‰ª∂ÁöÑÂä†ËΩΩ„ÄÇ LoadÂøÖÈ°ªÁ≠âÂà∞ÊâÄÊúâÊñá‰ª∂ÂÖ®ÈÉ®Âä†ËΩΩÂÆåÊàêÂêéÊâç‰ºöËß¶Âèë„ÄÇ HTMLÁ¶ªÁ∫øÁºìÂ≠ò ÂéüÁêÜÔºöHTML5 ÁöÑÁ¶ªÁ∫øÂ≠òÂÇ®ÊòØÂü∫‰∫é‰∏Ä‰∏™Êñ∞Âª∫ÁöÑ .appcache Êñá‰ª∂ÁöÑÁºìÂ≠òÊú∫Âà∂Ôºà‰∏çÊòØÂ≠òÂÇ®ÊäÄÊúØÔºâÔºåÈÄöËøáËøô‰∏™Êñá‰ª∂‰∏äÁöÑËß£ÊûêÊ∏ÖÂçïÁ¶ªÁ∫øÂ≠òÂÇ®ËµÑÊ∫êÔºåËøô‰∫õËµÑÊ∫êÂ∞±‰ºöÂÉè cookie ‰∏ÄÊ†∑Ë¢´Â≠òÂÇ®‰∫Ü‰∏ãÊù•„ÄÇ‰πãÂêéÂΩìÁΩëÁªúÂú®Â§Ñ‰∫éÁ¶ªÁ∫øÁä∂ÊÄÅ‰∏ãÊó∂ÔºåÊµèËßàÂô®‰ºöÈÄöËøáË¢´Á¶ªÁ∫øÂ≠òÂÇ®ÁöÑÊï∞ÊçÆËøõË°åÈ°µÈù¢Â±ïÁ§∫„ÄÇ Âú®Á∫øÁöÑÊÉÖÂÜµ‰∏ãÔºåÊµèËßàÂô®ÂèëÁé∞ html Â§¥ÈÉ®Êúâ manifest Â±ûÊÄßÔºåÂÆÉ‰ºöËØ∑Ê±Ç manifest Êñá‰ª∂ÔºåÂ¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¨°ËÆøÈóÆ app ÔºåÈÇ£‰πàÊµèËßàÂô®Â∞±‰ºöÊ†πÊçÆ manifest Êñá‰ª∂ÁöÑÂÜÖÂÆπ‰∏ãËΩΩÁõ∏Â∫îÁöÑËµÑÊ∫êÂπ∂‰∏îËøõË°åÁ¶ªÁ∫øÂ≠òÂÇ®„ÄÇÂ¶ÇÊûúÂ∑≤ÁªèËÆøÈóÆËøá app Âπ∂‰∏îËµÑÊ∫êÂ∑≤ÁªèÁ¶ªÁ∫øÂ≠òÂÇ®‰∫ÜÔºåÈÇ£‰πàÊµèËßàÂô®Â∞±‰ºö‰ΩøÁî®Á¶ªÁ∫øÁöÑËµÑÊ∫êÂä†ËΩΩÈ°µÈù¢ÔºåÁÑ∂ÂêéÊµèËßàÂô®‰ºöÂØπÊØîÊñ∞ÁöÑ manifest Êñá‰ª∂‰∏éÊóßÁöÑ manifest Êñá‰ª∂ÔºåÂ¶ÇÊûúÊñá‰ª∂Ê≤°ÊúâÂèëÁîüÊîπÂèòÔºåÂ∞±‰∏çÂÅö‰ªª‰ΩïÊìç‰ΩúÔºåÂ¶ÇÊûúÊñá‰ª∂ÊîπÂèò‰∫ÜÔºåÈÇ£‰πàÂ∞±‰ºöÈáçÊñ∞‰∏ãËΩΩÊñá‰ª∂‰∏≠ÁöÑËµÑÊ∫êÂπ∂ËøõË°åÁ¶ªÁ∫øÂ≠òÂÇ®„ÄÇ Á¶ªÁ∫øÁöÑÊÉÖÂÜµ‰∏ãÔºåÊµèËßàÂô®Â∞±Áõ¥Êé•‰ΩøÁî®Á¶ªÁ∫øÂ≠òÂÇ®ÁöÑËµÑÊ∫ê„ÄÇ attibuteÂíåpropertyÂå∫Âà´ attribute ÊòØ dom ÂÖÉÁ¥†Âú®ÊñáÊ°£‰∏≠‰Ωú‰∏∫ html Ê†áÁ≠æÊã•ÊúâÁöÑÂ±ûÊÄßÔºõ property Â∞±ÊòØ dom ÂÖÉÁ¥†Âú® js ‰∏≠‰Ωú‰∏∫ÂØπË±°Êã•ÊúâÁöÑÂ±ûÊÄß„ÄÇ ÂØπ‰∫é html ÁöÑÊ†áÂáÜÂ±ûÊÄßÊù•ËØ¥Ôºåattribute Âíå property ÊòØÂêåÊ≠•ÁöÑÔºåÊòØ‰ºöËá™Âä®Êõ¥Êñ∞ÁöÑÔºå‰ΩÜÊòØÂØπ‰∫éËá™ÂÆö‰πâÁöÑÂ±ûÊÄßÊù•ËØ¥Ôºå‰ªñ‰ª¨ÊòØ‰∏çÂêåÊ≠•ÁöÑ„ÄÇ CSS","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 4 üí™","slug":"frontend-interview-note","date":"2020-04-26T18:28:27.000Z","updated":"2020-05-19T15:45:59.415Z","comments":true,"path":"2020/04/26/frontend-interview-note/","link":"","permalink":"WangHngLeee.github.io/2020/04/26/frontend-interview-note/","excerpt":"CSS ::before Âíå:after‰∏≠ÂçïÂºïÂè∑ÂíåÂèåÂºïÂè∑ÁöÑÂå∫Âà´ ÂçïÂÜíÂè∑(:)Áî®‰∫écss‰º™Á±ªÔºåÂèåÂÜíÂè∑(::)Áî®‰∫écss‰º™ÂÖÉÁ¥†„ÄÇÊúâ‰∫õÊµèËßàÂô®ËÄÉËôëÂà∞ÂÖºÂÆπÈóÆÈ¢òÔºåÈÉ®ÂàÜÊÉÖÂÜµ‰∏ã‰πüÂèØ‰ª•Áî®ÂçïÂºïÂè∑(:)Ë°®Á§∫‰º™ÂÖÉÁ¥†„ÄÇ ‰º™Á±ª(üòÉÔºö‰∏ÄËà¨ÂåπÈÖçÁöÑÊòØÂÖÉÁ¥†ÁöÑÊüê‰∫õÁâπÂÆöÁä∂ÊÄÅÔºå‰æãÂ¶Ç:hover, :link ‰º™Á±ªÁî®‰∫éÂΩìÂ∑≤ÊúâÁöÑÂÖÉÁ¥†Â§Ñ‰∫éÊüê‰∏™Áä∂ÊÄÅÊó∂Ôºå‰∏∫ÂÖ∂Ê∑ªÂä†ÂØπÂ∫îÁöÑÊ†∑ÂºèÔºåËøô‰∏™Áä∂ÊÄÅÊòØÊ†πÊçÆÁî®Êà∑Ë°å‰∏∫ËÄåÂä®ÊÄÅÂèòÂåñÁöÑ„ÄÇÊØîÂ¶ÇËØ¥ÔºåÂΩìÁî®Êà∑ÊÇ¨ÂÅúÂú®ÊåáÂÆöÁöÑ ÂÖÉÁ¥†Êó∂ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá :hover Êù•ÊèèËø∞Ëøô‰∏™ÂÖÉÁ¥†ÁöÑÁä∂ÊÄÅ„ÄÇ ‰º™ÂÖÉÁ¥†(:üòÉÔºö‰∏ÄËà¨ÂåπÈÖçÁöÑÊòØÁâπÊÆä‰ΩçÁΩÆÔºåÊØîÂ¶Ç::before ::afterÁ≠â„ÄÇ ‰º™ÂÖÉÁ¥†Áî®‰∫éÂàõÂª∫‰∏Ä‰∫õ‰∏çÂú®ÊñáÊ°£Ê†ë‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂπ∂‰∏∫ÂÖ∂Ê∑ªÂä†Ê†∑Âºè„ÄÇÂÆÉ‰ª¨ÂÖÅËÆ∏Êàë‰ª¨‰∏∫ÂÖÉÁ¥†ÁöÑÊüê‰∫õÈÉ®ÂàÜËÆæÁΩÆÊ†∑Âºè„ÄÇÊØîÂ¶ÇËØ¥ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá ::be fore Êù•Âú®‰∏Ä‰∏™ÂÖÉÁ¥†ÂâçÂ¢ûÂä†‰∏Ä‰∫õÊñáÊú¨ÔºåÂπ∂‰∏∫Ëøô‰∫õÊñáÊú¨Ê∑ªÂä†Ê†∑Âºè„ÄÇËôΩÁÑ∂Áî®Êà∑ÂèØ‰ª•ÁúãÂà∞Ëøô‰∫õÊñáÊú¨Ôºå‰ΩÜÊòØËøô‰∫õÊñáÊú¨ÂÆûÈôÖ‰∏ä‰∏çÂú®ÊñáÊ°£Ê†ë‰∏≠„ÄÇ","text":"CSS ::before Âíå:after‰∏≠ÂçïÂºïÂè∑ÂíåÂèåÂºïÂè∑ÁöÑÂå∫Âà´ ÂçïÂÜíÂè∑(:)Áî®‰∫écss‰º™Á±ªÔºåÂèåÂÜíÂè∑(::)Áî®‰∫écss‰º™ÂÖÉÁ¥†„ÄÇÊúâ‰∫õÊµèËßàÂô®ËÄÉËôëÂà∞ÂÖºÂÆπÈóÆÈ¢òÔºåÈÉ®ÂàÜÊÉÖÂÜµ‰∏ã‰πüÂèØ‰ª•Áî®ÂçïÂºïÂè∑(:)Ë°®Á§∫‰º™ÂÖÉÁ¥†„ÄÇ ‰º™Á±ª(üòÉÔºö‰∏ÄËà¨ÂåπÈÖçÁöÑÊòØÂÖÉÁ¥†ÁöÑÊüê‰∫õÁâπÂÆöÁä∂ÊÄÅÔºå‰æãÂ¶Ç:hover, :link ‰º™Á±ªÁî®‰∫éÂΩìÂ∑≤ÊúâÁöÑÂÖÉÁ¥†Â§Ñ‰∫éÊüê‰∏™Áä∂ÊÄÅÊó∂Ôºå‰∏∫ÂÖ∂Ê∑ªÂä†ÂØπÂ∫îÁöÑÊ†∑ÂºèÔºåËøô‰∏™Áä∂ÊÄÅÊòØÊ†πÊçÆÁî®Êà∑Ë°å‰∏∫ËÄåÂä®ÊÄÅÂèòÂåñÁöÑ„ÄÇÊØîÂ¶ÇËØ¥ÔºåÂΩìÁî®Êà∑ÊÇ¨ÂÅúÂú®ÊåáÂÆöÁöÑ ÂÖÉÁ¥†Êó∂ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá :hover Êù•ÊèèËø∞Ëøô‰∏™ÂÖÉÁ¥†ÁöÑÁä∂ÊÄÅ„ÄÇ ‰º™ÂÖÉÁ¥†(:üòÉÔºö‰∏ÄËà¨ÂåπÈÖçÁöÑÊòØÁâπÊÆä‰ΩçÁΩÆÔºåÊØîÂ¶Ç::before ::afterÁ≠â„ÄÇ ‰º™ÂÖÉÁ¥†Áî®‰∫éÂàõÂª∫‰∏Ä‰∫õ‰∏çÂú®ÊñáÊ°£Ê†ë‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂπ∂‰∏∫ÂÖ∂Ê∑ªÂä†Ê†∑Âºè„ÄÇÂÆÉ‰ª¨ÂÖÅËÆ∏Êàë‰ª¨‰∏∫ÂÖÉÁ¥†ÁöÑÊüê‰∫õÈÉ®ÂàÜËÆæÁΩÆÊ†∑Âºè„ÄÇÊØîÂ¶ÇËØ¥ÔºåÊàë‰ª¨ÂèØ‰ª•ÈÄöËøá ::be fore Êù•Âú®‰∏Ä‰∏™ÂÖÉÁ¥†ÂâçÂ¢ûÂä†‰∏Ä‰∫õÊñáÊú¨ÔºåÂπ∂‰∏∫Ëøô‰∫õÊñáÊú¨Ê∑ªÂä†Ê†∑Âºè„ÄÇËôΩÁÑ∂Áî®Êà∑ÂèØ‰ª•ÁúãÂà∞Ëøô‰∫õÊñáÊú¨Ôºå‰ΩÜÊòØËøô‰∫õÊñáÊú¨ÂÆûÈôÖ‰∏ä‰∏çÂú®ÊñáÊ°£Ê†ë‰∏≠„ÄÇ Â±Ö‰∏≠ÈóÆÈ¢ò 1.Ê∞¥Âπ≥Â±Ö‰∏≠ ‰∏∫divËÆæÁΩÆÂÆΩÂ∫¶ÔºåËÆ©margin‰∏∫0 auto„ÄÇ .div&#123; width:100px; margin: 0 auto;&#125; ‰ΩøÁî®text-alignÂÆûÁé∞ .container&#123; background-color:black; text-align: center;&#125;.box&#123; display:inline-block; width:100px; height:100px; background-color:pink;/*ÂíåblackÂå∫ÂàÜÂºÄÊõ¥Ê∏ÖÊ•ö*/&#125; 2.Ê∞¥Âπ≥ÂûÇÁõ¥Â±Ö‰∏≠ ÂÆπÂô®È´òÂÆΩÂÄºÁªôÂÆöÊó∂,marginËÆæ‰∏∫Ëá™Ë∫´ÂÆΩÈ´ò‰∏ÄÂçä .div&#123; width:200; height:200; top:50%; left:50%; margin: -100px 0 0 -100px;&#125; ÂÖàÂ∞ÜdivÂ∑¶‰∏äËßíÁßªÂà∞Â±èÂπï‰∏≠ÂøÉÔºåÂÜçËÆæÁΩÆmargin‰∏∫Ëá™Ë∫´sizeÁöÑ‰∏ÄÂçä„ÄÇ ÂÆπÂô®ÂÆΩÈ´òÊú™Áü•Êó∂Ôºå‰ΩøÁî®transformÊñπÊ≥ï„ÄÇ .div&#123; position: absolute;/* Áõ∏ÂØπÂÆö‰ΩçÊàñÁªùÂØπÂÆö‰ΩçÂùáÂèØ */ top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink;&#125; ‰ΩøÁî®flexÂ∏ÉÂ±Ä .center&#123; display:flex; align-items: center; justify-content: center;&#125;.center div&#123; width:100px; height:100px; background-color:red;/*ÁúãÊïàÊûú*/&#125; position‰∏≠Ôºå‰∏çÂêåÁöÑÂÄºÂÖ∂ÂÆö‰ΩçÂéüÁÇπÂêÑÊòØ‰ªÄ‰πàÔºü(relative,absolute,static,fixed,inherit) absolute: ÁîüÊàêÁªùÂØπÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÔºåÁõ∏ÂØπ‰∫éÂÄº‰∏ç‰∏∫ static ÁöÑÁ¨¨‰∏Ä‰∏™Áà∂ÂÖÉÁ¥†ÁöÑ padding box ËøõË°åÂÆö‰ΩçÔºå‰πüÂèØ‰ª•ÁêÜËß£‰∏∫Á¶ªËá™Â∑±Ëøô‰∏ÄÁ∫ßÂÖÉÁ¥†ÊúÄËøëÁöÑ ‰∏ÄÁ∫ß position ËÆæÁΩÆ‰∏∫ absolute ÊàñËÄÖ relative ÁöÑÁà∂ÂÖÉÁ¥†ÁöÑ padding box ÁöÑÂ∑¶‰∏äËßí‰∏∫ÂéüÁÇπÁöÑ„ÄÇ fixed :ÁîüÊàêÁªùÂØπÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÔºåÁõ∏ÂØπ‰∫éÊµèËßàÂô®Á™óÂè£ËøõË°åÂÆö‰Ωç„ÄÇ relative: ÁîüÊàêÁõ∏ÂØπÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÔºåÁõ∏ÂØπ‰∫éÂÖ∂ÂÖÉÁ¥†Êú¨Ë∫´ÊâÄÂú®Ê≠£Â∏∏‰ΩçÁΩÆËøõË°åÂÆö‰Ωç„ÄÇ static: ÈªòËÆ§ÂÄº„ÄÇÊ≤°ÊúâÂÆö‰ΩçÔºåÂÖÉÁ¥†Âá∫Áé∞Âú®Ê≠£Â∏∏ÁöÑÊµÅ‰∏≠ÔºàÂøΩÁï• top, bottom, left, right, z-index Â£∞ÊòéÔºâ„ÄÇ inherit: ËßÑÂÆö‰ªéÁà∂ÂÖÉÁ¥†ÁªßÊâø position Â±ûÊÄßÁöÑÂÄº„ÄÇ li ‰∏é li ‰πãÈó¥ÊúâÁúã‰∏çËßÅÁöÑÁ©∫ÁôΩÈó¥ÈöîÈóÆÈ¢ò &amp;&amp; Ëß£ÂÜ≥ÊñπÊ≥ï ÊµèËßàÂô®Âú®Ê∏≤ÊüìinlineË°åÂÜÖÂÖÉÁ¥†ÁöÑÊó∂ÂÄôÔºå‰∏∫‰∫ÜÁæéËßÇ‰ºöÂ∞ÜÂÖÉÁ¥†Èó¥ÁöÑÁ©∫ÁôΩÂ≠óÁ¨¶Ê∏≤ÊüìÊàêÊç¢Á©∫Ê†º„ÄÇËÄåÊàë‰ª¨Âú®ÂÜôliÁöÑÊó∂ÂÄô‰∏∫‰∫ÜÁæéËßÇ‰ºöÂ∞ÜliÊîæÂú®ÂçïÁã¨‰∏ÄË°åÔºåÊâÄ‰ª•liÊç¢Ë°åÂêé‰ºö‰∫ßÁîüÊç¢Ë°åÁ¨¶„ÄÇ ‰∏∫liËÆæÁΩÆ float: left„ÄÇ Â∞ÜÊâÄÊúâ li ÂÜôÂú®Âêå‰∏ÄË°å„ÄÇ Â∞Ü ul ÂÜÖÁöÑfont-sizeËÆæ‰∏∫0„ÄÇ Ê∂àÈô§ ul ÁöÑÂ≠óÁ¨¶Èó¥Èöî ÔºåËÆæÁΩÆletter-spacing: -8pxÔºå","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"üìñ VueÂ≠¶‰π†Á¨îËÆ∞(3)","slug":"vue3","date":"2020-04-13T17:15:41.000Z","updated":"2020-04-27T00:06:07.125Z","comments":true,"path":"2020/04/13/vue3/","link":"","permalink":"WangHngLeee.github.io/2020/04/13/vue3/","excerpt":"","text":"vue v-model Âíå Êï∞ÊçÆÂèåÂêëÁªëÂÆö v-model ...&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h4&gt; &#123;&#123; msg &#125;&#125; &lt;/h4&gt; &lt;input type='text' v-bind:value = \"msg\"&gt; &lt;input type='text' v-model = \"msg\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data:&#123; msg: 'This is new data ' &#125; &#125;)&lt;/script&gt; ‰∏äÈù¢ÁöÑ‰ª£Á†ÅÂæàÊ∏ÖÊ•öÁöÑÂ±ïÁ§∫‰∫Üv-bind ÂçïÂêëÊï∞ÊçÆÁªëÂÆöÂíå v-model ÂèåÂêëÊï∞ÊçÆÁªëÂÆöÁöÑÂå∫Âà´„ÄÇ Á¨¨‰∏Ä‰∏™inputÊ°ÜÂÜÖÁöÑÊñáÂ≠óÂè™‰ºöÂíåh4ÂÜÖÂêåÊ≠•‰∏ÄÊ¨°ÔºåÂΩìÂØπinputÂÅöÂá∫ÊîπÂèòÊó∂Ôºåh4ÂÜÖÂÆπ‰∏ç‰ºöÈöè‰πãÊîπÂèò„ÄÇ Áõ∏ÂèçÔºå‰ΩøÁî®‰∫Üv-modelÁöÑinputÂèëÁîüÊîπÂèòÊó∂Ôºåh4ÊòæÁ§∫ÁöÑÂÜÖÂÆπ‰ºöÈöè‰πã‰∏ÄËµ∑ÊîπÂèò„ÄÇ ÂæÖÊõ¥Êñ∞","categories":[{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"Vue","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"üìñ ÂâçÁ´ØÈóÆÈ¢òÊùÇÁÉ©-VueÁØá(1)","slug":"front-end-interview-vue","date":"2020-04-08T18:15:41.000Z","updated":"2020-05-19T15:45:47.471Z","comments":true,"path":"2020/04/08/front-end-interview-vue/","link":"","permalink":"WangHngLeee.github.io/2020/04/08/front-end-interview-vue/","excerpt":"ËÆ≤‰∏ÄËÆ≤MVVMÔºüÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ MVVMÊòØModel-View-ViewModelÁöÑÁº©ÂÜôÔºå‰πüÂ∞±ÊòØÊääÂêéÁ´ØÊ¶ÇÂøµÈáåMVCÁöÑcontrollerÊç¢Êàê‰∫Üviewmodel„ÄÇ ModelÂ±Ç‰ª£Ë°®Êï∞ÊçÆÊ®°ÂûãÔºåView‰ª£Ë°®UIÁªÑ‰ª∂ÔºåViewModelÊòØViewÂíåModelÂ±ÇÁöÑÊ°•Ê¢ÅÔºåÊï∞ÊçÆ‰ºöÁªëÂÆöÂà∞viewModelÂ±ÇÂπ∂Ëá™Âä®Â∞ÜÊï∞ÊçÆÊ∏≤ÊüìÂà∞È°µÈù¢‰∏≠ÔºåËßÜÂõæÂèòÂåñÁöÑÊó∂ÂÄô‰ºöÈÄöÁü•viewModelÂ±ÇÊõ¥Êñ∞Êï∞ÊçÆ„ÄÇ ËÆ≤‰∏Ä‰∏ãVue2.xÂìçÂ∫îÂºèÊï∞ÊçÆÁöÑÂéüÁêÜÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ VueÂú®ÂàùÂßãÂåñÊï∞ÊçÆÊó∂Ôºå‰ºö‰ΩøÁî®Object.definePropertyÈáçÊñ∞ÂÆö‰πâdata‰∏≠ÁöÑÊâÄÊúâÂ±ûÊÄß„ÄÇÂΩìÈ°µÈù¢‰ΩøÁî®ÂØπÂ∫îÂ±ûÊÄßÊó∂ÔºåÈ¶ñÂÖà‰ºöËøõË°å‰æùËµñÊî∂ÈõÜ(Êî∂ÈõÜÂΩìÂâçÁªÑ‰ª∂ÁöÑwatcher)ÔºåÂ¶ÇÊûúÂ±ûÊÄßÂèëÁîüÂèòÂåñ‰ºöÈÄöÁü•Áõ∏ÂÖ≥‰æùËµñËøõË°åÊõ¥Êñ∞Êìç‰Ωú(ÂèëÂ∏ÉËÆ¢ÈòÖ)„ÄÇ","text":"ËÆ≤‰∏ÄËÆ≤MVVMÔºüÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ MVVMÊòØModel-View-ViewModelÁöÑÁº©ÂÜôÔºå‰πüÂ∞±ÊòØÊääÂêéÁ´ØÊ¶ÇÂøµÈáåMVCÁöÑcontrollerÊç¢Êàê‰∫Üviewmodel„ÄÇ ModelÂ±Ç‰ª£Ë°®Êï∞ÊçÆÊ®°ÂûãÔºåView‰ª£Ë°®UIÁªÑ‰ª∂ÔºåViewModelÊòØViewÂíåModelÂ±ÇÁöÑÊ°•Ê¢ÅÔºåÊï∞ÊçÆ‰ºöÁªëÂÆöÂà∞viewModelÂ±ÇÂπ∂Ëá™Âä®Â∞ÜÊï∞ÊçÆÊ∏≤ÊüìÂà∞È°µÈù¢‰∏≠ÔºåËßÜÂõæÂèòÂåñÁöÑÊó∂ÂÄô‰ºöÈÄöÁü•viewModelÂ±ÇÊõ¥Êñ∞Êï∞ÊçÆ„ÄÇ ËÆ≤‰∏Ä‰∏ãVue2.xÂìçÂ∫îÂºèÊï∞ÊçÆÁöÑÂéüÁêÜÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ VueÂú®ÂàùÂßãÂåñÊï∞ÊçÆÊó∂Ôºå‰ºö‰ΩøÁî®Object.definePropertyÈáçÊñ∞ÂÆö‰πâdata‰∏≠ÁöÑÊâÄÊúâÂ±ûÊÄß„ÄÇÂΩìÈ°µÈù¢‰ΩøÁî®ÂØπÂ∫îÂ±ûÊÄßÊó∂ÔºåÈ¶ñÂÖà‰ºöËøõË°å‰æùËµñÊî∂ÈõÜ(Êî∂ÈõÜÂΩìÂâçÁªÑ‰ª∂ÁöÑwatcher)ÔºåÂ¶ÇÊûúÂ±ûÊÄßÂèëÁîüÂèòÂåñ‰ºöÈÄöÁü•Áõ∏ÂÖ≥‰æùËµñËøõË°åÊõ¥Êñ∞Êìç‰Ωú(ÂèëÂ∏ÉËÆ¢ÈòÖ)„ÄÇ ËÆ≤‰∏Ä‰∏ãVue3.xÂìçÂ∫îÂºèÊï∞ÊçÆÂéüÁêÜÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ Vue3.xÊîπÁî®ProxyÊõø‰ª£Object.defineProperty„ÄÇÂõ†‰∏∫ProxyÂèØ‰ª•Áõ¥Êé•ÁõëÂê¨ÂØπË±°ÂíåÊï∞ÁªÑÁöÑÂèòÂåñÔºåÂπ∂‰∏îÊúâÂ§öËææ13ÁßçÊã¶Êà™ÊñπÊ≥ï„ÄÇÂπ∂‰∏î‰Ωú‰∏∫Êñ∞Ê†áÂáÜÂ∞ÜÂèóÂà∞ÊµèËßàÂô®ÂéÇÂïÜÈáçÁÇπÊåÅÁª≠ÁöÑÊÄßËÉΩ‰ºòÂåñ„ÄÇ ProxyÂè™‰ºö‰ª£ÁêÜÂØπË±°ÁöÑÁ¨¨‰∏ÄÂ±ÇÔºåÈÇ£‰πàVue3ÂèàÊòØÊÄéÊ†∑Â§ÑÁêÜËøô‰∏™ÈóÆÈ¢òÁöÑÂë¢ÔºüÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ Âà§Êñ≠ÂΩìÂâçReflect.getÁöÑËøîÂõûÂÄºÊòØÂê¶‰∏∫Object„ÄÇÂ¶ÇÊûúÊòØÂàôÂÜçÈÄöËøáreactiveÊñπÊ≥ïÂÅö‰ª£ÁêÜÔºåËøôÊ†∑Â∞±ÂÆûÁé∞‰∫ÜÊ∑±Â∫¶ËßÇÊµã„ÄÇ ÁõëÊµãÊï∞ÁªÑÁöÑÊó∂ÂÄôÂèØËÉΩËß¶ÂèëÂ§öÊ¨°get/setÔºåÂ¶Ç‰ΩïÈò≤Ê≠¢Ëß¶ÂèëÂ§öÊ¨°Âë¢ÔºüÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ ÂèØ‰ª•ÈÄöËøáÂà§Êñ≠keyÊòØÂê¶‰∏∫ÂΩìÂâçË¢´‰ª£ÁêÜÂØπË±°targetËá™Ë∫´Â±ûÊÄßÔºå‰πüÂèØ‰ª•Âà§Êñ≠ÊóßÂÄº‰∏éÊñ∞ÂÄºÊòØÂê¶Áõ∏Á≠âÔºåÂè™ÊúâÊª°Ë∂≥‰ª•‰∏ä‰∏§‰∏™Êù°‰ª∂‰πã‰∏ÄÊó∂ÔºåÊâçÊúâÂèØËÉΩÊâßË°åtrigger„ÄÇ vue2.x‰∏≠Â¶Ç‰ΩïÁõëÊµãÊï∞ÁªÑÂèòÂåñÔºà‚≠êÔ∏è‚≠êÔ∏èÔºâ ‰ΩøÁî®‰∫ÜÂáΩÊï∞Âä´ÊåÅÁöÑÊñπÂºèÔºåÈáçÂÜô‰∫ÜÊï∞ÁªÑÁöÑÊñπÊ≥ïÔºåVueÂ∞Üdata‰∏≠ÁöÑÊï∞ÁªÑËøõË°å‰∫ÜÂéüÂûãÈìæÈáçÂÜôÔºåÊåáÂêë‰∫ÜËá™Â∑±ÂÆö‰πâÁöÑÊï∞ÁªÑÂéüÂûãÊñπÊ≥ï„ÄÇËøôÊ†∑ÂΩìË∞ÉÁî®Êï∞ÁªÑapiÊó∂ÔºåÂèØ‰ª•ÈÄöÁü•‰æùËµñÊõ¥Êñ∞„ÄÇÂ¶ÇÊûúÊï∞ÁªÑ‰∏≠ÂåÖÂê´ÁùÄÂºïÁî®Á±ªÂûãÔºå‰ºöÂØπÊï∞ÁªÑ‰∏≠ÁöÑÂºïÁî®Á±ªÂûãÂÜçÊ¨°ÈÄíÂΩíÈÅçÂéÜËøõË°åÁõëÊéß„ÄÇËøôÊ†∑Â∞±ÂÆûÁé∞‰∫ÜÁõëÊµãÊï∞ÁªÑÂèòÂåñ„ÄÇ ÔºàËøôÈáåË¶ÅÂ§öÁúãvueÊ∫êÁ†ÅÂíåjsÂéüÂûãÈìæÁöÑÊ¶ÇÂøµ„ÄÇ) nextTickÊòØ‰ªÄ‰πàÔºüÂÆÉÁöÑÂÆûÁé∞ÂéüÁêÜÔºüÔºà‚≠êÔ∏è‚≠êÔ∏èÔºâ Âú®‰∏ãÊ¨° DOM Êõ¥Êñ∞Âæ™ÁéØÁªìÊùü‰πãÂêéÊâßË°åÂª∂ËøüÂõûË∞É„ÄÇnextTick‰∏ªË¶Å‰ΩøÁî®‰∫ÜÂÆè‰ªªÂä°ÂíåÂæÆ‰ªªÂä°„ÄÇÊ†πÊçÆÊâßË°åÁéØÂ¢ÉÂàÜÂà´Â∞ùËØïÈááÁî® Promise MutationObserver setImmediate Â¶ÇÊûú‰ª•‰∏äÈÉΩ‰∏çË°åÂàôÈááÁî®setTimeout ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™ÂºÇÊ≠•ÊñπÊ≥ïÔºåÂ§öÊ¨°Ë∞ÉÁî®nextTick‰ºöÂ∞ÜÊñπÊ≥ïÂ≠òÂÖ•ÈòüÂàó‰∏≠ÔºåÈÄöËøáËøô‰∏™ÂºÇÊ≠•ÊñπÊ≥ïÊ∏ÖÁ©∫ÂΩìÂâçÈòüÂàó„ÄÇ (ÂÖ∂ÂÆûÈóÆÊ°ÜÊû∂ÊúÄÁªàËøòÊòØËÄÉÈ™åÂéüÁîüJavaScriptÁöÑÂäüÂ∫ï) VueÁöÑÁîüÂëΩÂë®ÊúüÔºà‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏èÔºâ VueÂÆû‰æãÊúâ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁîüÂëΩÂë®ÊúüÔºå‰πüÂ∞±ÊòØ‰ªéÂºÄÂßãÂàõÂª∫„ÄÅÂàùÂßãÂåñÊï∞ÊçÆ„ÄÅÁºñËØëÊ®°Áâà„ÄÅÊåÇËΩΩDOM„ÄÅÊ∏≤Êüì‚û°Ô∏èÊõ¥Êñ∞‚û°Ô∏èÊ∏≤Êüì„ÄÅÈîÄÊØÅÁ≠â‰∏ÄÁ≥ªÂàóËøáÁ®ãÔºåËøôÂ∞±ÊòØVueÁîüÂëΩÂë®ÊúüÁöÑÂÆö‰πâ„ÄÇÈÄö‰øóËÆ≤Â∞±ÊòØVueÂÆû‰æã‰ªéÂàõÂª∫Âà∞ÈîÄÊØÅÂà∞ÂÖ®ËøáÁ®ã„ÄÇ beforeCreateÔºöÊòØnew Vue()‰πãÂêéËß¶ÂèëÁöÑÁ¨¨‰∏Ä‰∏™Èí©Â≠êÔºåÂú®ÂΩìÂâçÈò∂ÊÆµdata„ÄÅmethods„ÄÅcomputed‰ª•Âèäwatch‰∏äÁöÑÊï∞ÊçÆÂíåÊñπÊ≥ïÈÉΩ‰∏çËÉΩË¢´ËÆøÈóÆ„ÄÇ createdÔºöÂú®ÂÆû‰æãÂàõÂª∫ÂÆåÊàêÂêéÂèëÁîüÔºåÂΩìÂâçÈò∂ÊÆµÂ∑≤ÁªèÂÆåÊàê‰∫ÜÊï∞ÊçÆËßÇÊµãÔºå‰πüÂ∞±ÊòØÂèØ‰ª•‰ΩøÁî®Êï∞ÊçÆÔºåÊõ¥ÊîπÊï∞ÊçÆÔºåÂú®ËøôÈáåÊõ¥ÊîπÊï∞ÊçÆ‰∏ç‰ºöËß¶ÂèëupdatedÂáΩÊï∞„ÄÇÂèØ‰ª•ÂÅö‰∏Ä‰∫õÂàùÂßãÊï∞ÊçÆÁöÑËé∑ÂèñÔºåÂú®ÂΩìÂâçÈò∂ÊÆµÊó†Ê≥ï‰∏éDomËøõË°å‰∫§‰∫íÔºåÂ¶ÇÊûúÈùûË¶ÅÊÉ≥ÔºåÂèØ‰ª•ÈÄöËøávm.$nextTickÊù•ËÆøÈóÆDom„ÄÇ beforeMountÔºö ÂèëÁîüÂú®ÊåÇËΩΩ‰πãÂâçÔºåÂú®Ëøô‰πãÂâçtemplateÊ®°ÊùøÂ∑≤ÂØºÂÖ•Ê∏≤ÊüìÂáΩÊï∞ÁºñËØë„ÄÇËÄåÂΩìÂâçÈò∂ÊÆµËôöÊãüDomÂ∑≤ÁªèÂàõÂª∫ÂÆåÊàêÔºåÂç≥Â∞ÜÂºÄÂßãÊ∏≤Êüì„ÄÇÂú®Ê≠§Êó∂‰πüÂèØ‰ª•ÂØπÊï∞ÊçÆËøõË°åÊõ¥ÊîπÔºå‰∏ç‰ºöËß¶Âèëupdated„ÄÇ mountedÔºö Âú®ÊåÇËΩΩÂÆåÊàêÂêéÂèëÁîüÔºåÂú®ÂΩìÂâçÈò∂ÊÆµÔºåÁúüÂÆûÁöÑDomÊåÇËΩΩÂÆåÊØïÔºåÊï∞ÊçÆÂÆåÊàêÂèåÂêëÁªëÂÆöÔºåÂèØ‰ª•ËÆøÈóÆÂà∞DomËäÇÁÇπÔºå‰ΩøÁî®$refsÂ±ûÊÄßÂØπDomËøõË°åÊìç‰Ωú„ÄÇ beforeUpdateÔºö ÂèëÁîüÂú®Êõ¥Êñ∞‰πãÂâçÔºå‰πüÂ∞±ÊòØÂìçÂ∫îÂºèÊï∞ÊçÆÂèëÁîüÊõ¥Êñ∞ÔºåËôöÊãüdomÈáçÊñ∞Ê∏≤Êüì‰πãÂâçË¢´Ëß¶ÂèëÔºå‰Ω†ÂèØ‰ª•Âú®ÂΩìÂâçÈò∂ÊÆµËøõË°åÊõ¥ÊîπÊï∞ÊçÆÔºå‰∏ç‰ºöÈÄ†ÊàêÈáçÊ∏≤Êüì„ÄÇ updatedÔºö ÂèëÁîüÂú®Êõ¥Êñ∞ÂÆåÊàê‰πãÂêéÔºåÂΩìÂâçÈò∂ÊÆµÁªÑ‰ª∂DomÂ∑≤ÂÆåÊàêÊõ¥Êñ∞„ÄÇË¶ÅÊ≥®ÊÑèÁöÑÊòØÈÅøÂÖçÂú®Ê≠§ÊúüÈó¥Êõ¥ÊîπÊï∞ÊçÆÔºåÂõ†‰∏∫ËøôÂèØËÉΩ‰ºöÂØºËá¥Êó†ÈôêÂæ™ÁéØÁöÑÊõ¥Êñ∞„ÄÇ beforeDestroyÔºö ÂèëÁîüÂú®ÂÆû‰æãÈîÄÊØÅ‰πãÂâçÔºåÂú®ÂΩìÂâçÈò∂ÊÆµÂÆû‰æãÂÆåÂÖ®ÂèØ‰ª•Ë¢´‰ΩøÁî®ÔºåÊàë‰ª¨ÂèØ‰ª•Âú®ËøôÊó∂ËøõË°åÂñÑÂêéÊî∂Â∞æÂ∑•‰ΩúÔºåÊØîÂ¶ÇÊ∏ÖÈô§ËÆ°Êó∂Âô®„ÄÇ destroyedÔºö ÂèëÁîüÂú®ÂÆû‰æãÈîÄÊØÅ‰πãÂêéÔºåËøô‰∏™Êó∂ÂÄôÂè™Ââ©‰∏ã‰∫ÜdomÁ©∫Â£≥„ÄÇÁªÑ‰ª∂Â∑≤Ë¢´ÊãÜËß£ÔºåÊï∞ÊçÆÁªëÂÆöË¢´Âç∏Èô§ÔºåÁõëÂê¨Ë¢´ÁßªÂá∫ÔºåÂ≠êÂÆû‰æã‰πüÁªüÁªüË¢´ÈîÄÊØÅ„ÄÇ","categories":[{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"Vue","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/"},{"name":"Interview","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue/Interview","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/Interview/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"},{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"üìñ VueÂ≠¶‰π†Á¨îËÆ∞(2)","slug":"vue2","date":"2020-04-05T13:15:41.000Z","updated":"2020-04-05T14:29:12.774Z","comments":true,"path":"2020/04/05/vue2/","link":"","permalink":"WangHngLeee.github.io/2020/04/05/vue2/","excerpt":"vueÊåá‰ª§‚Äì‰∫ã‰ª∂‰øÆÈ•∞Á¨¶ .stopÈòªÊ≠¢ÂÜíÊ≥° &lt;body&gt; &lt;div id='app'&gt; &lt;div @click = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click.stop =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ËæìÂá∫ÁªìÊûúÔºö btn clicked stopËÆ©ÂÜíÊ≥°ÂÅúÂú®‰∫ÜbtnËøô‰∏™Âú∞ÊñπÔºå‰∏ç‰ºöÁªßÁª≠Âêë‰∏äÂª∂‰º∏Âà∞divÁà∂Á±ª„ÄÇ Â¶ÇÊûúÊ≤°ÊúâstopÈòªÊ≠¢ÂÜíÊ≥°ÁöÑËØùÔºåÊ≠£Â∏∏ÂÜíÊ≥°Ë°å‰∏∫ËæìÂá∫Â∫îËØ•‰∏∫Ôºö btn clickeddiv clicked xxx.stop: Ëá™Ë∫´‰øÆÈ•∞Á¨¶,ÂèØ‰ª•ÈòªÊ≠¢ÂÜíÊ≥°Ë°å‰∏∫„ÄÇ","text":"vueÊåá‰ª§‚Äì‰∫ã‰ª∂‰øÆÈ•∞Á¨¶ .stopÈòªÊ≠¢ÂÜíÊ≥° &lt;body&gt; &lt;div id='app'&gt; &lt;div @click = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click.stop =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ËæìÂá∫ÁªìÊûúÔºö btn clicked stopËÆ©ÂÜíÊ≥°ÂÅúÂú®‰∫ÜbtnËøô‰∏™Âú∞ÊñπÔºå‰∏ç‰ºöÁªßÁª≠Âêë‰∏äÂª∂‰º∏Âà∞divÁà∂Á±ª„ÄÇ Â¶ÇÊûúÊ≤°ÊúâstopÈòªÊ≠¢ÂÜíÊ≥°ÁöÑËØùÔºåÊ≠£Â∏∏ÂÜíÊ≥°Ë°å‰∏∫ËæìÂá∫Â∫îËØ•‰∏∫Ôºö btn clickeddiv clicked xxx.stop: Ëá™Ë∫´‰øÆÈ•∞Á¨¶,ÂèØ‰ª•ÈòªÊ≠¢ÂÜíÊ≥°Ë°å‰∏∫„ÄÇ .prevent ÈòªÊ≠¢ÈªòËÆ§‰∫ã‰ª∂ &lt;body&gt; &lt;div id='app'&gt; &lt;a href=\"https://google.com\" @click.prevent=\"linkclicked\"&gt;Google&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; linkclicked()&#123; console.log('link clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ‰∏äËø∞‰ª£Á†ÅÊúÄÁªàÂ∞Ü‰ºöconsoleÂá∫‚Äòlink clicked‚ÄôÁöÑÁªìÊûú‰ΩÜÊòØÂπ∂‰∏ç‰ºöË∑≥ËΩ¨ÔºåÂõ†‰∏∫preventÈòªÊ≠¢‰∫ÜË∑≥ËΩ¨ÁöÑÈªòËÆ§Ë°å‰∏∫„ÄÇ .prevent: ÂèØ‰ª•ÈòªÊ≠¢ÈªòËÆ§ÁöÑjsË°å‰∏∫„ÄÇ .capture ÊçïËé∑Ë°å‰∏∫ Âà©Áî®‰πãÂâç.stop‰∏≠ÁöÑ‰ª£Á†ÅÊù•ÁúãÔºö &lt;body&gt; &lt;div id='app'&gt; &lt;div @click.capture = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; Ê≠§Êó∂ÊéßÂà∂Âè∞ËæìÂá∫ÁöÑÈ°∫Â∫èÂàôÂ∞Ü‰ºöÊòØ div clickedbtn clicked captureÊîπÂèò‰∫ÜwebÁöÑÈªòËÆ§ÂÜíÊ≥°Ë°å‰∏∫ÔºåÂèòÊàê‰∫ÜÊçïËé∑Ë°å‰∏∫„ÄÇ ÂÜíÊ≥°ÔºöÊ∏≤Êüì‰πãÂêéÔºåÂΩìÁî®Êà∑‰∫ßÁîü‰∫§‰∫íÊó∂ÔºåÂÖà‰ªéÁà∂ËäÇÁÇπÂêë‰∏ãÂØªÊâæËß¶ÂèëË°å‰∏∫ÁöÑcomponentÔºåÁÑ∂ÂêéÁî±‰∏ãËá≥‰∏äÂÜíÊ≥°Âú∞‰æùÊ¨°Ëß¶ÂèësubÁà∂Á±ª„ÄÇ ÊçïËé∑Ôºö‰∏éÂÜíÊ≥°Áõ∏ÂèçÔºåÁõ¥Êé•Áî±‰∏äÂà∞‰∏ãËß¶Âèë„ÄÇ .self Ëá™Ë∫´Ëß¶Âèë &lt;body&gt; &lt;div id='app'&gt; &lt;div @click.self = \"divclicker\"&gt; &lt;input type='button' value='clickme' @click =\"btnclicker\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; divclicker()&#123; console.log('div clicked') &#125;, btnclicker()&#123; console.log('btn clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; Ê≠§Êó∂Âè™ÁÇπÂáªbuttonÊó∂ÊéßÂà∂Âè∞Âè™‰ºöËæìÂá∫Ôºö btn clicked Âπ∂Ê≤°ÊúâdivÁöÑÊ∂àÊÅØÂá∫Áé∞ÔºåËøôÊòØÂõ†‰∏∫selfÂÆö‰πâ‰∫ÜÂè™ÊúâÁÇπÂáªËØ•ÂÖÉÁ¥†Êú¨Ë∫´ÁöÑÊó∂ÂÄôÊâç‰ºöËß¶ÂèëË°å‰∏∫„ÄÇÊâÄ‰ª•ÂΩìÁÇπÂáªdivËåÉÂõ¥ÂÜÖÁöÑÁ©∫ÁôΩÂ§ÑÊó∂‰ºöËæìÂá∫‚Äòdiv clicked‚Äô. .once Âè™ÊâßË°å‰∏ÄÊ¨° &lt;body&gt; &lt;div id='app'&gt; &lt;a href=\"https://google.com\" @click.prevent.self =\"linkclicked\"&gt;Google&lt;/a&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123; linkclicked()&#123; console.log('link clicked') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt; ‰∏äËø∞‰ª£Á†ÅÂè™‰ºöÈòªÊ≠¢ËØ•aÊ†áÁ≠æË∑≥ËΩ¨‰∏ÄÊ¨°ÔºåÁÇπÂáªÁ¨¨‰∫åÊ¨°Âàô‰ºöÊ≠£Â∏∏Ë∑≥ËΩ¨ÔºåÂõ†‰∏∫selfÈôêÂà∂‰∫ÜpreventÂè™Ëµ∑‰ΩúÁî®‰∏ÄÊ¨°„ÄÇ ‰∫ã‰ª∂‰øÆÈ•∞Á¨¶ÂèØ‰ª•‰∏≤ËÅî„ÄÇ onceÂè™Ëß¶Âèë‰∏ÄÊ¨°Ôºå‰∏îÂè™Êúâ‰∏ÄÊ¨°ÊúâÊïà„ÄÇ .stop Âíå .self ÈòªÊ≠¢ÂÜíÊ≥°ÁöÑÂéüÁêÜÂå∫Âà´ .stop Âíå .self ÈÉΩÂèØ‰ª•‰∫ßÁîüÈòªÊ≠¢ÂÜíÊ≥°ÁöÑË°å‰∏∫ÂèëÁîüÔºå‰ΩÜÊòØ‰∫åËÄÖÂéüÁêÜ‰∏çÂêå„ÄÇ .stop ÈòªÊ≠¢‰∫ÜËØ•ÂÖÉÁ¥†‰πã‰∏äÁöÑÊâÄÊúâÁà∂ÂÖÉÁ¥†ÁöÑÂÜíÊ≥°Ë°å‰∏∫ .self Âè™ÈòªÊ≠¢‰∫ÜËá™Ë∫´ÁöÑÂÜíÊ≥°Ë°å‰∏∫„ÄÇ // selfÊú∫Âà∂div1 div2 div3 @click.self btn @click ÁÇπÂáªbtnÂêéÔºåÈô§‰∫Üdiv3‰∏ç‰ºöÂÜíÊ≥°ÔºåbtnÔºådiv1Âíådiv2Âùá‰ºöÊ≠£Â∏∏ÂÜíÊ≥°„ÄÇ // stopÊú∫Âà∂div1 div2 div3 @click.stop btn @click Ê≠§Êó∂ÁÇπÂáªbtnÔºåÂè™ÊúâbtnÂíådiv3‰ºöÂÜíÊ≥°ÔºåËÄådiv1Âíådiv2Âùá‰∏ç‰ºöÂÜíÊ≥°„ÄÇ","categories":[{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"Vue","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"üìñ VueÂ≠¶‰π†Á¨îËÆ∞(1)","slug":"vue1","date":"2020-04-04T17:23:41.000Z","updated":"2020-04-05T14:29:14.739Z","comments":true,"path":"2020/04/04/vue1/","link":"","permalink":"WangHngLeee.github.io/2020/04/04/vue1/","excerpt":"MVC &amp; MVVM MVC MVCÊòØÂêéÁ´Ø‰∏≠ÁöÑÂàÜÂ±ÇÊ¶ÇÂøµ„ÄÇM-ModelÔºåV-ViewÔºåC-Controller„ÄÇ MVVM MVVCÂè™ÊòØÈíàÂØπÂâçÁ´ØÂàÜÂ±Ç„ÄÇM-ModelÔºåV-ViewÔºåVM-View Model„ÄÇÂÖ∂‰∏≠MÂíåVË¶ÅÈÄöËøáVMÊù•ËøõË°åÊï∞ÊçÆÈìæÊé•„ÄÇ VueÂü∫Êú¨‰ª£Á†Å ÂàÜ‰∏§Â§ßÈÉ®ÂàÜ„ÄÇhtmlÂíåjs„ÄÇ htmlÈÉ®ÂàÜ ...&lt;body&gt;//js‰∏≠newÁöÑvueÂÆû‰æãÂ∞Ü‰ºöÊéßÂà∂ËØ•div‰∏≠ÁöÑÊâÄÊúâÂÖÉÁ¥†„ÄÇ &lt;div id='app'&gt; &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;p&gt; &lt;/div&gt;&lt;/body&gt;... jsÈÉ®ÂàÜ // ÂàõÂª∫Êñ∞ÁöÑvueÂÆû‰æãvar vm = new Vue(&#123; el:'#app', // ÈÄâÊã©ÊéßÂà∂Êüê‰∏™div data:&#123; title:'test'//Â≠òÊîædata &#125;, method:&#123; func1()&#123; // ÂÆûÁé∞ÂáΩÊï∞ÂÜÖÂÆπ &#125;, func2()&#123; //ÂÆûÁé∞ÂáΩÊï∞ÂÜÖÂÆπ &#125; &#125;&#125;) ‰∏çÈöæÁúãÂá∫Ôºåhtml‰∏≠ÁöÑÈÉ®ÂàÜÊòØV-viewÔºåjs‰∏≠ÁöÑÈÉ®ÂàÜÊòØVM-ViewModelÔºåË¥üË¥£Êï∞ÊçÆÈìæÊé•ÔºåÂè¶Â§ñmodelÈÉ®ÂàÜ‰πüÂú®js‰∏≠ÔºåÂÖ∑‰ΩìÊòØdata‰ΩìÁé∞‰∫ÜmodelÁöÑÂäüËÉΩ„ÄÇ vue‰∏≠‰∏çÈúÄË¶ÅÁî®data.titleÊù•ÂºïÁî®ÔºåÁõ¥Êé•Áî®Âç≥ÂèØ„ÄÇ","text":"MVC &amp; MVVM MVC MVCÊòØÂêéÁ´Ø‰∏≠ÁöÑÂàÜÂ±ÇÊ¶ÇÂøµ„ÄÇM-ModelÔºåV-ViewÔºåC-Controller„ÄÇ MVVM MVVCÂè™ÊòØÈíàÂØπÂâçÁ´ØÂàÜÂ±Ç„ÄÇM-ModelÔºåV-ViewÔºåVM-View Model„ÄÇÂÖ∂‰∏≠MÂíåVË¶ÅÈÄöËøáVMÊù•ËøõË°åÊï∞ÊçÆÈìæÊé•„ÄÇ VueÂü∫Êú¨‰ª£Á†Å ÂàÜ‰∏§Â§ßÈÉ®ÂàÜ„ÄÇhtmlÂíåjs„ÄÇ htmlÈÉ®ÂàÜ ...&lt;body&gt;//js‰∏≠newÁöÑvueÂÆû‰æãÂ∞Ü‰ºöÊéßÂà∂ËØ•div‰∏≠ÁöÑÊâÄÊúâÂÖÉÁ¥†„ÄÇ &lt;div id='app'&gt; &lt;p&gt;&#123;&#123; title &#125;&#125;&lt;p&gt; &lt;/div&gt;&lt;/body&gt;... jsÈÉ®ÂàÜ // ÂàõÂª∫Êñ∞ÁöÑvueÂÆû‰æãvar vm = new Vue(&#123; el:'#app', // ÈÄâÊã©ÊéßÂà∂Êüê‰∏™div data:&#123; title:'test'//Â≠òÊîædata &#125;, method:&#123; func1()&#123; // ÂÆûÁé∞ÂáΩÊï∞ÂÜÖÂÆπ &#125;, func2()&#123; //ÂÆûÁé∞ÂáΩÊï∞ÂÜÖÂÆπ &#125; &#125;&#125;) ‰∏çÈöæÁúãÂá∫Ôºåhtml‰∏≠ÁöÑÈÉ®ÂàÜÊòØV-viewÔºåjs‰∏≠ÁöÑÈÉ®ÂàÜÊòØVM-ViewModelÔºåË¥üË¥£Êï∞ÊçÆÈìæÊé•ÔºåÂè¶Â§ñmodelÈÉ®ÂàÜ‰πüÂú®js‰∏≠ÔºåÂÖ∑‰ΩìÊòØdata‰ΩìÁé∞‰∫ÜmodelÁöÑÂäüËÉΩ„ÄÇ vue‰∏≠‰∏çÈúÄË¶ÅÁî®data.titleÊù•ÂºïÁî®ÔºåÁõ¥Êé•Áî®Âç≥ÂèØ„ÄÇ v-cloak / v-text / v-html &lt;div id='app'&gt; &lt;p v-cloak&gt;aaa &#123;&#123; msg &#125;&#125; aaa&lt;/p&gt; &lt;h1 v-text=\"msg1\"&gt;aaa&lt;/h1&gt; &lt;h1 v-html=\"msg2\"&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg1:'test'Ôºå msg2:'&lt;h1&gt;This is h1 text&lt;/h1&gt;' &#125; &#125;)&lt;/script&gt; ‰ΩøÁî®v-cloakËÉΩÂ§üËß£ÂÜ≥ÊèíÂÄºË°®ËææÂºèÂú®ÁΩëÈÄü‰∏çÁ®≥ÂÆö‰∏ãÊñáÊú¨ÁöÑÈó™ÁÉÅÈóÆÈ¢ò„ÄÇ v-textËÉΩÂ§üË¶ÜÁõñÂéüÊú¨ÁöÑÊñáÊú¨ÔºåËÄåv-cloakÂè™‰ºöÊõø‰ª£Êú¨Ë∫´ÁöÑÂç†Â≠óÁ¨¶„ÄÇ v-htmlÂèØ‰ª•Ëá™Âä®ËØÜÂà´htmlÊñáÊú¨ËØ≠Âè•Âπ∂ËΩ¨ÊàêhtmlÊ∏≤Êüì„ÄÇ v-bind Â±ûÊÄßÁªëÂÆö &lt;div id='app'&gt; &lt;input type=\"button\" value=\"btn\" v-bind:title=\"title\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; title:'this is title' &#125; &#125;)&lt;/script&gt; v-bind‰ºöÂ∞ÜÁõÆÊ†átargetÁªëÂÆöÂà∞ËØ•ÂÖÉÁ¥†‰∏äÔºåÂ¶ÇÊûú‰∏çÁî®v-bindÂàô‰ºöÊòæÁ§∫titleÂ≠óÊ†∑ËÄå‰∏çÊòØdata‰∏≠Ëá™ÂÆö‰πâÁöÑtitleÂÄº„ÄÇ Âè¶Â§ñÁî±‰∫év-bind:ÊòØjsËØ≠Ê≥ïÔºåÊâÄ‰ª•ÂêéÈù¢ÂèØ‰ª•Ë∑üËá™ÂÆö‰πâÁöÑlambdaÔºå‰æãÂ¶Çv-bind:title=‚Äútitle + ‚Äò123‚Äô‚Äù. v-bind:‰πüÂèØ‰ª•Áõ¥Êé•ÁÆÄÂÜô‰∏∫: v-on ‰∫ã‰ª∂ÁªëÂÆö &lt;div id='app'&gt; &lt;input type=\"button\" value=\"btn\" v-on:click=\"alert\"&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; title:'this is title' &#125;, methods:&#123; alert:function()&#123; alert('test') &#125; &#125; &#125;)&lt;/script&gt; v-onÁî®‰∫é‰∫ã‰ª∂ÁªëÂÆö„ÄÇÂêéÈù¢‰∏ÄËà¨Ë∑üËá™Â∑±ÂÆö‰πâÁöÑÂáΩÊï∞„ÄÇÁ±ª‰ººjs‰∏≠ÁöÑonclick. ÂèØ‰ª•ÁÆÄÂÜô‰∏∫@clickÔºå@mouseover„ÄÇ„ÄÇ„ÄÇ js‰∏≠ÂÆö‰πâmethodsÊó∂ÔºåÊúâ‰∏§ÁßçÂÜôÊ≥ïÔºå‰∏ÄÁßçÊòØfunctionÔºå‰∏ÄÁßçÊòØÂáΩÊï∞ÂêçÁõ¥Êé•Ë∑ü(). methods&#123; alert()&#123; alert('test'); &#125;, alert1:function()&#123; alert('test1'); &#125;&#125; demo1 : Ë∑ëÈ©¨ÁÅØÊñáÂ≠óÂæ™ÁéØ &lt;body&gt; &lt;div id='app'&gt; &lt;input type='button' value='ÂºÄÂßã' @click=\"begin\"&gt; &lt;input type='button' value='ÂÅúÊ≠¢' @click=\"stop\"&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data:&#123; msg:'ÊµãËØïË∑ëÈ©¨ÁÅØÊñáÂ≠óÊµÅÔºÅÊµãËØïÔºÅ'Ôºå intervalId:null &#125;, methods: begin()&#123; if(intervalId != null)return; this.intervalId = setInterval( ()=&gt;&#123; // ‰øùËØÅËÉΩÂ§üËá™Âä®Âà∑Êñ∞Âä†ÂÖ•interval var start = msg.substring(0,1); var end = msg.substring(1); this.msg = start + end;//ÈáçÊñ∞ÊãºÊé•string &#125;,400); &#125;, stop()&#123; clearInterval(this.intervalId); intervalId = null; &#125; &#125; &#125;) ÊØèÊ¨°ÊääÁ¨¨‰∏Ä‰ΩçcharÁßªÂà∞ÊúÄÂêé ‰∏∫‰∫Ü‰øùËØÅËøûÁª≠ÊªöÂä®ÔºåËÆæÂÆöinterval Âà©Áî®intervalIdÊù•‰øùËØÅÂºÄÂßãÂíåÂÅúÊ≠¢ÊåâÈíÆÊ≠£Â∏∏Â∑•‰Ωú„ÄÇÂà©Áî®intervalIdÊòØÂê¶‰∏∫nullÊù•Âà§Êñ≠‰πãÂâçÊòØÂê¶ÁßªÂä®Ëøá„ÄÇ","categories":[{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"Vue","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"}]},{"title":"Leetcode EveryDay 90 üí™","slug":"chin-up-28","date":"2020-03-15T18:13:23.000Z","updated":"2020-03-16T01:03:27.806Z","comments":true,"path":"2020/03/15/chin-up-28/","link":"","permalink":"WangHngLeee.github.io/2020/03/15/chin-up-28/","excerpt":"","text":"567. Permutation in String üîóQuestion Link class Solution &#123; public boolean checkInclusion(String s1, String s2) &#123; if(s1 == null || s2 == null)return false; int len1 = s1.length(); int len2 = s2.length(); if(len1 &gt; len2)return false; int[] arr = new int[26]; for(int i = 0 ; i&lt;len1 ;i++)&#123; arr[s1.charAt(i) - 'a']++; arr[s2.charAt(i) - 'a']--; &#125; if(allzero(arr))return true; for(int j = len1; j&lt;len2 ;j++)&#123; arr[s2.charAt(j)-'a']--; arr[s2.charAt(j-len1)-'a']++; if(allzero(arr))return true; &#125; return false; &#125; public boolean allzero(int[] arr)&#123; for(int i = 0 ; i &lt; 26;i++)&#123; if(arr[i]!=0)return false; &#125; return true; &#125;&#125; ÁªèÂÖ∏26Â§ßÂ∞èarrÊñπÊ≥ï„ÄÇÊ£ÄÊü•ÂêÑ‰∏™Â≠óÊØçÂá∫Áé∞ÁöÑÊ¨°Êï∞„ÄÇÁª¥Êä§‰∏Ä‰∏™len1Â§ßÂ∞èÁöÑÁ™óÂè£","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"SilidingWindow","slug":"SilidingWindow","permalink":"WangHngLeee.github.io/tags/SilidingWindow/"}]},{"title":"Weekly Contest 180 üèÜ","slug":"contest06","date":"2020-03-15T13:02:09.000Z","updated":"2020-03-16T00:11:01.441Z","comments":true,"path":"2020/03/15/contest06/","link":"","permalink":"WangHngLeee.github.io/2020/03/15/contest06/","excerpt":"Áî±‰∫éÊØîËµõÊó∂Èó¥Âª∂ÂêéÊ≤°Ëµ∂‰∏äÔºåÊâÄ‰ª•ËøôÊ¨°ËµõÂêéÂÅöÁöÑÔºåÊú¨Ê¨°‰∏âÈ¢ò„ÄÇ 1380. Lucky Numbers in a Matrix üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; minvalues = new HashSet&lt;&gt;(); for(int i = 0 ; i&lt;matrix.length ;i++)&#123; int min = matrix[i][0]; for(int j = 1 ; j&lt; matrix[0].length ;j++)&#123; if(matrix[i][j] &lt; min)&#123; min = matrix[i][j]; &#125; &#125; minvalues.add(min); &#125; for(int j=0 ; j&lt; matrix[0].length ;j++)&#123; int max = matrix[0][j]; for(int i =1 ; i&lt;matrix.length ;i++)&#123; if(matrix[i][j] &gt; max)&#123; max = matrix[i][j]; &#125; &#125; if(minvalues.contains(max))&#123; res.add(max); &#125; &#125; return res; &#125;&#125; ÂæàÁõ¥ËßÇ„ÄÇË°åÁöÑminÂêåÊó∂‰πüÊòØcolÁöÑmaxÊâçÊòØlucky number„ÄÇ ÊâÄ‰ª•‰∏Ä‰∏™setÂÖàÂ≠òÂá∫Áé∞ËøáÁöÑminÂÄºÔºåÂÜçÊâ´ÊèècolÊâæÂà∞ÊâÄÊúâÁöÑmaxÔºåÂ¶ÇÊûúmaxÂú®setÈáåÂá∫Áé∞ËøáÔºåÂàôÂä†ÂÖ•res„ÄÇ","text":"Áî±‰∫éÊØîËµõÊó∂Èó¥Âª∂ÂêéÊ≤°Ëµ∂‰∏äÔºåÊâÄ‰ª•ËøôÊ¨°ËµõÂêéÂÅöÁöÑÔºåÊú¨Ê¨°‰∏âÈ¢ò„ÄÇ 1380. Lucky Numbers in a Matrix üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; luckyNumbers (int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); HashSet&lt;Integer&gt; minvalues = new HashSet&lt;&gt;(); for(int i = 0 ; i&lt;matrix.length ;i++)&#123; int min = matrix[i][0]; for(int j = 1 ; j&lt; matrix[0].length ;j++)&#123; if(matrix[i][j] &lt; min)&#123; min = matrix[i][j]; &#125; &#125; minvalues.add(min); &#125; for(int j=0 ; j&lt; matrix[0].length ;j++)&#123; int max = matrix[0][j]; for(int i =1 ; i&lt;matrix.length ;i++)&#123; if(matrix[i][j] &gt; max)&#123; max = matrix[i][j]; &#125; &#125; if(minvalues.contains(max))&#123; res.add(max); &#125; &#125; return res; &#125;&#125; ÂæàÁõ¥ËßÇ„ÄÇË°åÁöÑminÂêåÊó∂‰πüÊòØcolÁöÑmaxÊâçÊòØlucky number„ÄÇ ÊâÄ‰ª•‰∏Ä‰∏™setÂÖàÂ≠òÂá∫Áé∞ËøáÁöÑminÂÄºÔºåÂÜçÊâ´ÊèècolÊâæÂà∞ÊâÄÊúâÁöÑmaxÔºåÂ¶ÇÊûúmaxÂú®setÈáåÂá∫Áé∞ËøáÔºåÂàôÂä†ÂÖ•res„ÄÇ 1381. Design a Stack With Increment Operation üîóQuestion Link First Soluiton class CustomStack &#123; Stack&lt;Integer&gt; stack; int max; public CustomStack(int maxSize) &#123; stack = new Stack&lt;&gt;(); max = maxSize; &#125; public void push(int x) &#123; if(stack.size() &lt; max)&#123; stack.push(x); &#125; &#125; public int pop() &#123; return stack.size() == 0 ? -1 : stack.pop(); &#125; public void increment(int k, int val) &#123; Stack&lt;Integer&gt; temp = new Stack&lt;&gt;(); while(!stack.isEmpty()) temp.push(stack.pop()); while(k!=0 &amp;&amp; !temp.isEmpty()) &#123; int cur = temp.pop() + val; stack.push(cur); k--; &#125; while(!temp.isEmpty()) stack.push(temp.pop()); &#125;&#125; Simply using extra stack to reverse the original stack, and to add some operations on it. Optimized Soluiton class CustomStack &#123; List&lt;Integer&gt; arr; int size; public CustomStack(int maxSize) &#123; arr = new ArrayList&lt;&gt;(); size = maxSize; &#125; public void push(int x) &#123; if(arr.size() &lt; size)&#123; arr.add(x); &#125; &#125; public int pop() &#123; return arr.size() == 0 ? -1 : arr.remove(arr.size()-1); &#125; public void increment(int k, int val) &#123; for(int i = 0; i &lt; k &amp;&amp; i&lt;arr.size() ; i++)&#123; arr.set(i,arr.get(i)+val); &#125; &#125;&#125; Using extra arr to simulate a stack. Pay attention to the ‚Äòremove‚Äô, it can remove the specified index num and return it‚Äôs value. 1382. Balance a Binary Search Tree üîóQuestion Link class Solution &#123; List&lt;Integer&gt; sortedarr = new ArrayList&lt;&gt;(); public TreeNode balanceBST(TreeNode root) &#123; inorder(root); return buildtree(0,sortedarr.size()-1); &#125; public void inorder(TreeNode root)&#123; if(root == null)return; inorder(root.left); sortedarr.add(root.val); inorder(root.right); &#125; public TreeNode buildtree(int start, int end)&#123; if(start &gt; end)return null; int mid = start + ( end - start)/2; TreeNode root = new TreeNode(sortedarr.get(mid)); root.left = buildtree(start,mid-1); root.right = buildtree(mid+1,end); return root; &#125;&#125; Classic template : inorder traverse + preorder buildtree.","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 89 üí™","slug":"chin-up-27","date":"2020-03-12T15:13:23.000Z","updated":"2020-05-16T22:28:46.645Z","comments":true,"path":"2020/03/12/chin-up-27/","link":"","permalink":"WangHngLeee.github.io/2020/03/12/chin-up-27/","excerpt":"734. Sentence Similarity ƒë¬ü¬î¬óQuestion Link class Solution &#123; public boolean areSentencesSimilar(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123; map.putIfAbsent(str.get(0),new HashSet&lt;&gt;()); map.putIfAbsent(str.get(1),new HashSet&lt;&gt;()); map.get(str.get(0)).add(str.get(1)); map.get(str.get(1)).add(str.get(0)); &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; if(words1[i].equals(words2[i]))continue; if(!map.containsKey(words1[i]))return false; if(!map.get(words1[i]).contains(words2[i]))return false; &#125; return true; &#125;&#125; Using map to store the key-value of each string in the pairs. Then we loop the word1 and words2, only when two stirng is equal or map contains each other then we can continue to loop. Other wise we return fasle.","text":"734. Sentence Similarity ƒë¬ü¬î¬óQuestion Link class Solution &#123; public boolean areSentencesSimilar(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; Map&lt;String,Set&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123; map.putIfAbsent(str.get(0),new HashSet&lt;&gt;()); map.putIfAbsent(str.get(1),new HashSet&lt;&gt;()); map.get(str.get(0)).add(str.get(1)); map.get(str.get(1)).add(str.get(0)); &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; if(words1[i].equals(words2[i]))continue; if(!map.containsKey(words1[i]))return false; if(!map.get(words1[i]).contains(words2[i]))return false; &#125; return true; &#125;&#125; Using map to store the key-value of each string in the pairs. Then we loop the word1 and words2, only when two stirng is equal or map contains each other then we can continue to loop. Other wise we return fasle. 737. Sentence Similarity II ƒë¬ü¬î¬óQuestion Link class Solution &#123; public boolean areSentencesSimilarTwo(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs) &#123; if(words1.length != words2.length)return false; // corner case Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); for(List&lt;String&gt; str : pairs)&#123;// initialize union find hashmap String parent1 = find(map,str.get(0)); String parent2 = find(map,str.get(1)); if(!parent1.equals(parent2))map.put(parent1,parent2); // &#125; for(int i = 0 ; i &lt; words1.length ;i++)&#123; // return false if two string are not equal and both of them are not from the same root string if(!words1[i].equals(words2[i]) &amp;&amp; !find(map,words1[i]).equals(find(map,words2[i])))return false; &#125; return true; &#125; public String find(Map&lt;String,String&gt; map, String s)&#123; if(!map.containsKey(s))map.put(s,s); return s.equals(map.get(s)) ? s : find(map,map.get(s)); &#125;&#125; Using Union-Find. Using map to create unionfind graph. First we initialize each string with the root of itself. Then we update the root with parent2 if they are not the same. Then loop the word1, if we meet two string are not equal and are not from the same root string , we return false. Otherwise we continue until we return true in the final. 277. Find the Celebrity ƒë¬ü¬î¬óQuestion Link /* The knows API is defined in the parent class Relation. boolean knows(int a, int b); */public class Solution extends Relation &#123; public int findCelebrity(int n) &#123; int person = 0 ; for(int i = 0 ; i&lt; n;i++)&#123; if(knows(person,i))&#123; person = i; &#125; &#125; for(int i = 0 ;i&lt;n ;i++)&#123; if(i != person &amp;&amp; (!knows(i,person) || knows(person,i)))return -1; &#125; return person; &#125;&#125; we first loop the perosn and change the candidate if the first know the second one. Because we have to make sure that candidate know nobody. Then we for loop again, only when the person is not candidate and he don‚Äôt know the candidate or the candidate know the person, we return -1. Other wise we just return the candidate that we found. 139. Word Break ƒë¬ü¬î¬óQuestion Link class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] dp = new boolean[s.length()+1]; Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String str : wordDict)&#123; set.add(str); &#125; dp[0] = true; for(int i = 1 ; i &lt;= s.length(); i++)&#123; for(int j = 0 ; j&lt;i ;j++)&#123; if(dp[j] &amp;&amp; set.contains(s.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; dpƒá¬õ¬¥ƒá¬ñ¬∞0-ƒ∫Àù¬ìƒ∫¬â¬çindexƒá¬â¬Äƒá¬ú¬âsubstringƒá¬ò≈ªƒ∫¬ê≈öƒ∫¬á≈ü√ß¬é¬∞ƒç≈º¬áƒÉ¬Ä¬Ç 399. Evaluate Division ƒë¬ü¬î¬óQuestion Link class Solution &#123; public double[] calcEquation(List&lt;List&lt;String&gt;&gt; eq, double[] vals, List&lt;List&lt;String&gt;&gt; q) &#123; Map&lt;String, Map&lt;String, Double&gt;&gt; m = new HashMap&lt;&gt;(); for (int i = 0; i &lt; vals.length; i++) &#123; m.putIfAbsent(eq.get(i).get(0), new HashMap&lt;&gt;()); m.putIfAbsent(eq.get(i).get(1), new HashMap&lt;&gt;()); m.get(eq.get(i).get(0)).put(eq.get(i).get(1), vals[i]); m.get(eq.get(i).get(1)).put(eq.get(i).get(0), 1 / vals[i]); &#125; double[] r = new double[q.size()]; for (int i = 0; i &lt; q.size(); i++) r[i] = dfs(q.get(i).get(0), q.get(i).get(1), 1, m, new HashSet&lt;&gt;()); return r; &#125; double dfs(String s, String t, double r, Map&lt;String, Map&lt;String, Double&gt;&gt; m, Set&lt;String&gt; seen) &#123; if (!m.containsKey(s) || !seen.add(s)) return -1; if (s.equals(t)) return r; Map&lt;String, Double&gt; next = m.get(s); for (String c : next.keySet()) &#123; double result = dfs(c, t, r * next.get(c), m, seen); if (result != -1) return result; &#125; return -1; &#125;&#125; √ß¬é¬∞ƒá¬ä¬äƒá≈ª¬è√§¬∏≈ûƒ∫¬≠¬óƒá≈ª¬çƒ∫≈ª≈°ƒ∫≈ü¬î√ß¬ö¬Ñƒ∫¬Ö≈Ç√ß≈Ç≈•ƒ∫¬≠¬òƒç≈º¬õmƒÉ¬Ä¬Çƒ∫¬Ü¬çDFSƒá¬â≈æquery√©¬á¬å√ß¬õ¬∏ƒ∫≈ª≈°ƒ∫≈ü¬î√ß¬ö¬Ñ√§¬∏¬§√§¬∏≈û√§≈°¬ã√©¬ó¬¥√ß¬ö¬Ñƒ∫¬Ä≈∫ƒÉ¬Ä¬Ç 990. Satisfiability of Equality Equations ƒë¬ü¬î¬óQuestion Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26;i++)&#123; UF[i] = i;//initialize UF array. &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a');// link the two == chars &#125; &#125; for(String str : equations)&#123; if(str.charAt(1) == '!')&#123; //check whether two chars in != case have the same root if(UF[find(str.charAt(0)-'a')] == find(str.charAt(3)-'a'))return false; &#125; &#125; return true; &#125; public int find(int a)&#123; // create find function. if(a != UF[a])UF[a] = find(UF[a]); return UF[a]; &#125;&#125; UnionFindƒÉ¬Ä¬ÇCreate a UF graph to store the first and second char in equations. In ‚Äò==‚Äô case, we update the UF of first char. In ‚Äò!=‚Äô case, if we find that the two char has the same root, then return false.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 88 üí™","slug":"chin-up-26","date":"2020-03-10T15:13:23.000Z","updated":"2020-03-13T23:02:39.026Z","comments":true,"path":"2020/03/10/chin-up-26/","link":"","permalink":"WangHngLeee.github.io/2020/03/10/chin-up-26/","excerpt":"304. Range Sum Query 2D - Immutable üîóQuestion Link class NumMatrix &#123; int[][] dp; public NumMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return; int m = matrix.length; int n = matrix[0].length; dp = new int[m+1][n+1]; for(int i= 1; i&lt;=m;i++)&#123; for(int j = 1 ;j&lt;=n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int iMin = Math.min(row1, row2); int iMax = Math.max(row1, row2); int jMin = Math.min(col1, col2); int jMax = Math.max(col1, col2); return dp[iMax + 1][jMax + 1] - dp[iMax + 1][jMin] - dp[iMin][jMax + 1] + dp[iMin][jMin]; &#125;&#125; dpÂ≠òÂΩìÂâç‰ΩçÁΩÆÊûÑÊàêÁöÑÊñπÂΩ¢ÂÜÖÊâÄÊúâÁöÑÂíåÔºåÂú®ËÆ°ÁÆóÊó∂Áî±‰∫édp[i-1][j-1]Âä†‰∫Ü‰∏§Ê¨°ÔºåË¶ÅÂáèÂéª‰∏ÄÊ¨°ÔºåÁÑ∂ÂêéÂä†‰∏äÂΩìÂâçÁöÑÂÄºmatrix[i][j]„ÄÇ Âú®ËÆ°ÁÆósumÁöÑÊó∂ÂÄôÔºåÊúÄÂè≥‰∏ã‰ΩçÁΩÆÁöÑÂíåÂáèÂéªÊúÄÂ∞èË°å„ÄÅÊúÄÂ∞èÂàóÂØπÂ∫îÁöÑÂíåÂÄºÔºåÁî±‰∫éÂ∑¶‰∏äÁöÑÂÄºË¢´Âáè‰∫Ü‰∏§Ê¨°ÔºåË¶ÅÂä†ÂõûÊù•‰∏ÄÊ¨°„ÄÇ","text":"304. Range Sum Query 2D - Immutable üîóQuestion Link class NumMatrix &#123; int[][] dp; public NumMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return; int m = matrix.length; int n = matrix[0].length; dp = new int[m+1][n+1]; for(int i= 1; i&lt;=m;i++)&#123; for(int j = 1 ;j&lt;=n ;j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + matrix[i-1][j-1]; &#125; &#125; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; int iMin = Math.min(row1, row2); int iMax = Math.max(row1, row2); int jMin = Math.min(col1, col2); int jMax = Math.max(col1, col2); return dp[iMax + 1][jMax + 1] - dp[iMax + 1][jMin] - dp[iMin][jMax + 1] + dp[iMin][jMin]; &#125;&#125; dpÂ≠òÂΩìÂâç‰ΩçÁΩÆÊûÑÊàêÁöÑÊñπÂΩ¢ÂÜÖÊâÄÊúâÁöÑÂíåÔºåÂú®ËÆ°ÁÆóÊó∂Áî±‰∫édp[i-1][j-1]Âä†‰∫Ü‰∏§Ê¨°ÔºåË¶ÅÂáèÂéª‰∏ÄÊ¨°ÔºåÁÑ∂ÂêéÂä†‰∏äÂΩìÂâçÁöÑÂÄºmatrix[i][j]„ÄÇ Âú®ËÆ°ÁÆósumÁöÑÊó∂ÂÄôÔºåÊúÄÂè≥‰∏ã‰ΩçÁΩÆÁöÑÂíåÂáèÂéªÊúÄÂ∞èË°å„ÄÅÊúÄÂ∞èÂàóÂØπÂ∫îÁöÑÂíåÂÄºÔºåÁî±‰∫éÂ∑¶‰∏äÁöÑÂÄºË¢´Âáè‰∫Ü‰∏§Ê¨°ÔºåË¶ÅÂä†ÂõûÊù•‰∏ÄÊ¨°„ÄÇ 221. Maximal Square üîóQuestion Link class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m+1][n+1]; int max = 0; for(int i = 1;i&lt;=m;i++)&#123; for(int j = 1; j&lt;=n;j++)&#123; if(matrix[i-1][j-1] == '1')&#123; dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j]))+1; max = Math.max(max,dp[i][j]); &#125; &#125; &#125; return max*max; &#125;&#125; dp[i][j]Ë°®Á§∫‰Ωç‰∫éÂè≥‰∏ãËßí(i, j)ÁöÑÊ≠£ÊñπÂΩ¢ÁöÑËæπÈïøÈïøÂ∫¶„ÄÇ Â¶ÇÊûúÊ≠§ÂçïÂÖÉÊ†ºÁöÑÂÄº‰πüÊòØ1ÔºåÂàôÊ≠£ÊñπÂΩ¢ÊúÄÂ∞èÈïøÂ∫¶ÂÖ∂‰∏äÊñπÁöÑÂÄºÔºåÂ∑¶‰æßÂíåÂØπËßíÁ∫øÂ∑¶‰∏äÂÄº‰∏≠ÁöÑÊúÄÂ∞èÂÄº+1„ÄÇÂõ†‰∏∫Â¶ÇÊûú‰∏Ä‰æßÁü≠ÊàñÁº∫Â§±ÔºåÂàô‰∏ç‰ºöÂΩ¢ÊàêÊ≠£ÊñπÂΩ¢„ÄÇ 1277. Count Square Submatrices with All One üîóQuestion Link class Solution &#123; public int countSquares(int[][] matrix) &#123; int res = 0; int m = matrix.length; int n = matrix[0].length; for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0; j&lt;n ;j++)&#123; if(matrix[i][j] == 1)&#123; if(i&gt;0 &amp;&amp; j &gt;0)&#123; matrix[i][j] = Math.min(matrix[i-1][j-1], Math.min(matrix[i][j-1],matrix[i-1][j]))+1; &#125; res+=matrix[i][j]; &#125;else&#123; continue; &#125; &#125; &#125; return res; &#125;&#125; matrix‰øùÂ≠òÊØè‰∏™‰ΩçÁΩÆËÉΩÂ§üÁªÑÊàêÊ≠£ÊñπÂΩ¢ÁöÑÊúÄÂ∞èËæπÈïøÔºåÂÖ∂ÂÆûÊääÊâÄÊúâÊÉÖÂÜµÁöÑÊúÄÂ∞èËæπÈïøÂä†Ëµ∑Êù•Â∞±ÊòØÊ≠£ÊñπÂΩ¢ÁöÑ‰∏™Êï∞„ÄÇ 309. Best Time to Buy and Sell Stock with Cooldown üîóQuestion Link class Solution &#123; public int maxProfit(int[] prices) &#123; int sell = 0; int prevsell = 0; int buy = Integer.MIN_VALUE; int prevbuy; for(int price : prices)&#123; prevbuy = buy; buy = Math.max(prevsell - price, prevbuy); prevsell = sell; sell = Math.max(prevbuy + price, prevsell); &#125; return sell; &#125;&#125; buy‚ÄìÁõÆÂâç‰π∞ÂÆå‰πãÂêéÊúÄÂ§ßÂâ©‰ΩôÂÄºÔºåsell‚ÄìÁõÆÂâçÂçñÂÆåÊúÄÂ§ßÂâ©‰ΩôÂÄºÔºåprevbuy‚Äì‰∏äÊ¨°Êìç‰Ωú‰πãÂêéÂâ©‰ΩôÂÄºÔºåprevsell‚Äì‰∏äÊ¨°Êìç‰Ωú‰πãÂêéÂâ©‰ΩôÂÄº„ÄÇ Êõ¥Êñ∞buyÔºåË¶ÅÊ±ÇÊúÄÂ§ßÂâ©‰ΩôÂÄºÔºåÊâÄ‰ª•Ë¶ÅÂíåprevsell-priceÊØîËæÉ„ÄÇÊõ¥Êñ∞sellÔºåË¶ÅÊ±ÇÊúÄÂ§ßÂçñÂá∫ÂÄºÔºåÊâÄ‰ª• prevbuy + priceÊØîËæÉ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Weekly Contest 179 üèÜ","slug":"contest05","date":"2020-03-08T04:02:09.000Z","updated":"2020-03-09T01:31:22.991Z","comments":true,"path":"2020/03/07/contest05/","link":"","permalink":"WangHngLeee.github.io/2020/03/07/contest05/","excerpt":"Êú¨Ê¨°‰∏âÈ¢ò„ÄÇ 1374. Generate a String With Characters That Have Odd Counts üîóQuestion Link class Solution &#123; public String generateTheString(int n) &#123; if(n == 0 )return \"\"; StringBuilder sb = new StringBuilder(); if(n%2==0)&#123; int k = n-1; for(int i = 0 ; i &lt; k ;i++)&#123; sb.append(\"a\"); &#125; sb.append(\"b\"); return sb.toString(); &#125;else&#123; for(int i = 0 ; i&lt;n ;i++)&#123; sb.append(\"a\"); &#125; return sb.toString(); &#125; &#125;&#125; Â∞±ÊòØÂà§Êñ≠nÁöÑÂ•áÂÅ∂ÊÄßÔºåÂ¶ÇÊûúÂ•áÊï∞ÂÖ®ÈÉ®Âä†aÔºåÂ¶ÇÊûúÂÅ∂Êï∞ÂàôÂú®ÊúÄÂêé‰∏Ä‰ΩçÂä†bÂ∞±Ë°å‰∫Ü„ÄÇÈ¢òÁõÆÊèèËø∞‰∏çÊ∏Ö„ÄÇ","text":"Êú¨Ê¨°‰∏âÈ¢ò„ÄÇ 1374. Generate a String With Characters That Have Odd Counts üîóQuestion Link class Solution &#123; public String generateTheString(int n) &#123; if(n == 0 )return \"\"; StringBuilder sb = new StringBuilder(); if(n%2==0)&#123; int k = n-1; for(int i = 0 ; i &lt; k ;i++)&#123; sb.append(\"a\"); &#125; sb.append(\"b\"); return sb.toString(); &#125;else&#123; for(int i = 0 ; i&lt;n ;i++)&#123; sb.append(\"a\"); &#125; return sb.toString(); &#125; &#125;&#125; Â∞±ÊòØÂà§Êñ≠nÁöÑÂ•áÂÅ∂ÊÄßÔºåÂ¶ÇÊûúÂ•áÊï∞ÂÖ®ÈÉ®Âä†aÔºåÂ¶ÇÊûúÂÅ∂Êï∞ÂàôÂú®ÊúÄÂêé‰∏Ä‰ΩçÂä†bÂ∞±Ë°å‰∫Ü„ÄÇÈ¢òÁõÆÊèèËø∞‰∏çÊ∏Ö„ÄÇ 1375. Bulb Switcher III üîóQuestion Link class Solution &#123; public int numTimesAllBlue(int[] light) &#123; int right = 0; int len = light.length; int res = 0; for(int i = 0 ; i &lt; len; i++)&#123; right = Math.max(right,light[i]); if(right == i+1)res++; &#125; return res; &#125;&#125; Áª¥Êä§ÊúÄÂè≥ÁöÑÁÅØÊ≥°ÁºñÂè∑ÔºåÂ¶ÇÊûúÂΩìÂâçindex+1Á≠â‰∫éÊúÄÂè≥ÁöÑÁÅØÊ≥°ÁºñÂè∑ÔºåÂàôËØ¥ÊòéÂ∑¶ËæπÂÖ®ÈÉ®ÁÇπ‰∫ÆÔºåres++„ÄÇÂõ†‰∏∫indexÂèçÊò†‰∫ÜÁÇπ‰∫Æ‰∫ÜÂ§öÂ∞ëÁÅØÊ≥°ÔºåËÄåÁÅØÊ≥°‰∏çÂèØËÉΩÈáçÂ§çÔºåÊâÄ‰ª•Âú®ÊúÄÂè≥ÁºñÂè∑‰∏çÂèòÁöÑÊÉÖÂÜµ‰∏ãÔºåÂ¶ÇÊûúindex+1Á≠â‰∫éÊúÄÂè≥ÁºñÂè∑(ÁºñÂè∑‰ªé1ÂºÄÂßãÊâÄ‰ª•Ë¶Å+1)ÔºåËØ¥ÊòéÂ∑¶ËæπÂÖ®ÈÉ®ÁÇπËøáÔºåres++„ÄÇ 1376. Time Needed to Inform All Employees üîóQuestion Link class Solution &#123; public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) &#123; Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int i = 0 ; i&lt;manager.length ;i++)&#123; if(manager[i]!=-1)&#123; if(!map.containsKey(manager[i]))&#123; map.put(manager[i],new ArrayList&lt;&gt;()); &#125; map.get(manager[i]).add(i); &#125; &#125; int max = 0; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(headID); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i&lt;size ; i++)&#123; int temp = queue.poll(); if(manager[temp]!=-1)&#123; // ÈÅøÂºÄheadÁöÑ‰ΩçÁΩÆÔºå‰ªé‰∏çÊòØheadÁöÑtimeÂºÄÂßãÁ¥ØÂä†„ÄÇ informTime[temp]+=informTime[manager[temp]]; &#125; max = Math.max(max,informTime[temp]); if(map.get(temp)!=null)&#123; for(int num : map.get(temp))&#123; queue.add(num); &#125; &#125; &#125; &#125; return max; &#125;&#125; Áõ¥Êé•Ë£∏BFS„ÄÇÊõ¥Êñ∞informTimeÁöÑÂÄºÔºå‰ΩøÂÖ∂Êàê‰∏∫Á¥ØËÆ°Âíå„ÄÇÊúÄÂêéËøîÂõûÂÖ∂‰∏≠ÁöÑmax„ÄÇ","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 87 üí™","slug":"chin-up-25","date":"2020-03-06T16:13:23.000Z","updated":"2020-03-13T20:43:12.937Z","comments":true,"path":"2020/03/06/chin-up-25/","link":"","permalink":"WangHngLeee.github.io/2020/03/06/chin-up-25/","excerpt":"992. Subarrays with K Different Integers üîóQuestion Link class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return help(A,K) - help(A,K-1); &#125; public int help(int[] A, int K)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; int ans = 0; for(int j = 0 ; j &lt; A.length ;j++)&#123; if (map.getOrDefault(A[j], 0) == 0) K--; map.put(A[j],map.getOrDefault(A[j],0)+1); while(K&lt;0)&#123; map.put(A[i],map.get(A[i])-1); if(map.get(A[i]) == 0)K++; i++; &#125; ans += j-i+1; &#125; return ans; &#125;&#125; Ê≠£Â•ΩÊúâK‰∏™ = ÊúÄÂ§öK‰∏™ÁöÑÊÉÖÂÜµÂáèÂéªÊúÄÂ§öK-1ÁöÑÊÉÖÂÜµ„ÄÇ","text":"992. Subarrays with K Different Integers üîóQuestion Link class Solution &#123; public int subarraysWithKDistinct(int[] A, int K) &#123; return help(A,K) - help(A,K-1); &#125; public int help(int[] A, int K)&#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0; int ans = 0; for(int j = 0 ; j &lt; A.length ;j++)&#123; if (map.getOrDefault(A[j], 0) == 0) K--; map.put(A[j],map.getOrDefault(A[j],0)+1); while(K&lt;0)&#123; map.put(A[i],map.get(A[i])-1); if(map.get(A[i]) == 0)K++; i++; &#125; ans += j-i+1; &#125; return ans; &#125;&#125; Ê≠£Â•ΩÊúâK‰∏™ = ÊúÄÂ§öK‰∏™ÁöÑÊÉÖÂÜµÂáèÂéªÊúÄÂ§öK-1ÁöÑÊÉÖÂÜµ„ÄÇ 15. 3Sum üîóQuestion Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; nums.length ;i++)&#123; if(i == 0 || i&gt;0 &amp;&amp; nums[i] != nums[i-1])&#123; int low = i+1; int high = nums.length -1; int target = 0 - nums[i]; while(low &lt; high)&#123; if(nums[low] + nums[high] == target)&#123; res.add(Arrays.asList(nums[low],nums[high],nums[i])); while(low &lt; high &amp;&amp; nums[low]==nums[low + 1])low++; while(low &lt; high &amp;&amp; nums[high ] == nums[high-1])high--; low++; high--; &#125;else if(nums[low] + nums[high] &lt; target)&#123; while(low &lt; high &amp;&amp; nums[low] == nums[low]+1)low++; low++; &#125;else&#123; while(low &lt; high &amp;&amp; nums[high] == nums[high-1])high--; high--; &#125; &#125; &#125; &#125; return res; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇtwo pointersÂü∫Êú¨ÊÄùË∑Ø„ÄÇÊ≥®ÊÑèÂà§Êñ≠ÊúâÈáçÂ§çÊï∞Â≠óÁöÑÊÉÖÂÜµ„ÄÇ 167. Two Sum II - Input array is sorted üîóQuestion Link class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; int[] res = new int[2]; if(numbers == null || numbers.length&lt;2)return res; int left = 0; int right = numbers.length-1; while(left &lt;= right)&#123; int temp = numbers[left] + numbers[right]; if(temp == target)&#123; res[0] = left+1; res[1] = right+1; return res; &#125; if(temp&lt;target)&#123; left++; &#125;else&#123; right--; &#125; &#125; return res; &#125;&#125; two pointers„ÄÇÊ≥®ÊÑèÊúÄÂêéËøîÂõûindexË¶Å+1. 16. 3Sum Closest üîóQuestion Link class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int sum = nums[0] + nums[1] + nums[nums.length-1]; int closetsum = sum; for(int i = 0 ; i &lt;nums.length-2 ; i++)&#123; if(i == 0 || i&gt;0 &amp;&amp; nums[i] != nums[i-1])&#123; int left = i+1; int right = nums.length -1; while(left&lt;right)&#123; sum = nums[i] + nums[left] + nums[right]; if(sum &lt; target)&#123; while(left &lt; right &amp;&amp; nums[left] == nums[left+1])left++; left++; &#125;else if(sum &gt; target)&#123; while(left &lt; right &amp;&amp; nums[right] == nums[right-1])right--; right--; &#125;else&#123; return sum; &#125; if(Math.abs(target - closetsum) &gt; Math.abs(target-sum))&#123; closetsum = sum; &#125; &#125; &#125; &#125; return closetsum; &#125;&#125; 3 sumÂèòÁßç„ÄÇÂè™ÈúÄË¶ÅÂ§öÁª¥Êä§‰∏Ä‰∏™‰∏¥Êó∂ÁöÑsumÂÄºÔºåÂíåclosetsumÊØîËæÉÊõ¥Êñ∞Â∞±ÂèØ‰ª•‰∫Ü„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"}]},{"title":"Leetcode EveryDay 86 üí™","slug":"chin-up-24","date":"2020-03-05T16:13:23.000Z","updated":"2020-03-13T23:02:39.027Z","comments":true,"path":"2020/03/05/chin-up-24/","link":"","permalink":"WangHngLeee.github.io/2020/03/05/chin-up-24/","excerpt":"4. Median of Two Sorted Arrays üîóQuestion Link class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] arr = new int[m+n]; for(int i = 0 ;i&lt;m ;i++)&#123; arr[i] = nums1[i]; &#125; for(int j = 0 ;j&lt;n;j++)&#123; arr[m+j] = nums2[j]; &#125; Arrays.sort(arr); int k = arr.length; if(k%2 != 0)return (double)arr[k/2]; else return ((double)(arr[(k/2) - 1] + arr[(k/2)])/2); &#125;&#125; two array Âä†Âà∞‰∏ÄËµ∑sort„ÄÇ","text":"4. Median of Two Sorted Arrays üîóQuestion Link class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = nums1.length; int n = nums2.length; int[] arr = new int[m+n]; for(int i = 0 ;i&lt;m ;i++)&#123; arr[i] = nums1[i]; &#125; for(int j = 0 ;j&lt;n;j++)&#123; arr[m+j] = nums2[j]; &#125; Arrays.sort(arr); int k = arr.length; if(k%2 != 0)return (double)arr[k/2]; else return ((double)(arr[(k/2) - 1] + arr[(k/2)])/2); &#125;&#125; two array Âä†Âà∞‰∏ÄËµ∑sort„ÄÇ 378. Kth Smallest Element in a Sorted Matrix üîóQuestion Link class Solution &#123; public int kthSmallest(int[][] matrix, int k) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a); for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0;j&lt;n ;j++)&#123; pq.add(matrix[i][j]); if(pq.size() &gt; k)pq.poll(); &#125; &#125; return pq.poll(); &#125;&#125; ÁªèÂÖ∏kthÈóÆÈ¢ò„ÄÇÁª¥Êä§Â§ßÂ∞è‰∏∫kÁöÑmax/min heapÂç≥ÂèØ„ÄÇ 668. Kth Smallest Number in Multiplication Table üîóQuestion Link class Solution &#123; public int findKthNumber(int m, int n, int k) &#123; int lo=1, hi=m*n; while(lo&lt;hi)&#123; int mid= (lo+hi)/2, cnt=0; for (int i=1,j=n; i&lt;=m; i++)&#123; while(j&gt;=1 &amp;&amp; i*j&gt;mid) j--; cnt+=j; &#125; if (cnt&gt;=k) hi=mid; else lo=mid+1; &#125; return lo; &#125;&#125; binary searchÊäänumÂàÜÊàê‰∏§ÈÉ®ÂàÜÊù•Êâæ„ÄÇ 917. Reverse Only Letters üîóQuestion Link class Solution &#123; public String reverseOnlyLetters(String S) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); if(S == null || S.length() == 0)return \"\"; for(int i = 0 ; i&lt;S.length() ;i++)&#123; if(Character.isLetter(S.charAt(i)))&#123; stack.push(S.charAt(i)); &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i = 0 ; i &lt; S.length() ;i++)&#123; if(!Character.isLetter(S.charAt(i)))&#123; sb.append(S.charAt(i)); &#125;else&#123; sb.append(stack.pop()); &#125; &#125; return sb.toString(); &#125;&#125; stackÈÄÜÂ∫èËæìÂá∫„ÄÇÊ≥®ÊÑèÊ†áÁÇπÁ¨¶Âè∑‰∏çÂè™Êúâ‚Äò-‚Äô„ÄÇ 925. Long Pressed Name üîóQuestion Link class Solution &#123; public boolean isLongPressedName(String name, String typed) &#123; int m = name.length(); int n = typed.length(); int i = 0 ; for(int j = 0 ; j &lt; n ; j++)&#123; if(i&lt;m &amp;&amp; name.charAt(i) == typed.charAt(j))&#123; i++; &#125;else if(j == 0 || typed.charAt(j) != typed.charAt(j-1))&#123; return false; &#125; &#125; return i == m; &#125;&#125; two pointer.Âè™ÈúÄË¶ÅÂØπtypedËá™Ë∫´Ê£ÄÊü•ÊúâÊó†Áõ∏ÂêåÈáçÂ§çÂç≥ÂèØ„ÄÇÂ¶ÇÊûú‰∏§‰∏™‰ΩçÁΩÆÂÖÉÁ¥†Áõ∏ÂêåÔºåÂàôname ÁöÑindex++ÔºåÂ¶ÇÊûú‰∏çÂêåÂπ∂‰∏îtypedÁöÑÂâç‰∏Ä‰∏™ÂíåËØ•ÂÖÉÁ¥†‰∏ç‰∏ÄÊ†∑ÔºåÂàôÁõ¥Êé•ËøîÂõûfalse„ÄÇ abc-aabc-true abc-adbc-false 986. Interval List Intersections üîóQuestion Link class Solution &#123; public int[][] intervalIntersection(int[][] A, int[][] B) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int a = 0; int b = 0; while(a&lt;A.length &amp; b&lt;B.length)&#123; int start = Math.max(A[a][0],B[b][0]); int end = Math.min(A[a][1],B[b][1]); if(start &lt;= end)&#123; res.add(new int[]&#123;start,end&#125;); &#125; if(A[a][1] &gt; B[b][1])b++; else a++; &#125; int[][] ans = new int[res.size()][2]; int i = 0; for(int[] num : res)&#123; ans[i] = num; i++; &#125; return ans; &#125;&#125; intervalÁöÑÈ¢ò„ÄÇstartÂèñÊúÄÂ§ßÔºåendÂèñÊúÄÂ∞èÔºåÂ¶ÇÊûústart&lt;end ËØ¥ÊòéÊúâÊúâ‰∫§ÈõÜÔºåÂä†ÂÖ•res„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÔºåAÁöÑÁªìÂ∞æÊØîBÁöÑÂ§ßÔºåÂàôbÂæÄÂêéÈÅçÂéÜ‰∏Ä‰∏™ÔºåÁõ∏ÂèçÔºåAÂæÄÂêéÂæ™ÁéØ‰∏Ä‰∏™„ÄÇ 855. Exam Room üîóQuestion Link class ExamRoom &#123; int n; List&lt;Integer&gt; L; public ExamRoom(int N) &#123; L = new ArrayList&lt;&gt;(); n = N; &#125; public int seat() &#123; if (L.size() == 0) &#123; L.add(0); return 0; // empty we set seat at 0; &#125; int d = Math.max(L.get(0), n - 1 - L.get(L.size() - 1)); for (int i = 0; i &lt; L.size() - 1; ++i) d = Math.max(d, (L.get(i + 1) - L.get(i)) / 2); if (L.get(0) == d) &#123;//d == 0 we also set seat at 0 L.add(0, 0); return 0; &#125; for (int i = 0; i &lt; L.size() - 1; ++i)//try to find the minimum index that match d. if ((L.get(i + 1) - L.get(i)) / 2 == d) &#123; L.add(i + 1, (L.get(i + 1) + L.get(i)) / 2); return L.get(i + 1); &#125; L.add(n- 1); // no match we add at last position return n - 1; &#125; public void leave(int p) &#123; // find the p and remove it for (int i = 0; i &lt; L.size(); ++i) if (L.get(i) == p) L.remove(i); &#125;&#125; ÊúâÊÑèÊÄùÁöÑdesignÈ¢ò„ÄÇÁî®listÂ≠òseatÁöÑ‰ΩçÁΩÆÔºåÁÑ∂ÂêéÊØèÊ¨°ÈÅçÂéÜÊâæÊúÄÂ§ßÁöÑdistÔºåÁÑ∂ÂêéÂÜçÈáçÂ§¥ÂºÄÂßãÊâæÊúÄÂ∞èËÉΩÂ§üÂåπÈÖçdistÁöÑindexÔºåÊääseatÊèíÂÖ•ËØ•index„ÄÇ Âê¶ÂàôÁõ¥Êé•ÂÆâÊéíÂú®ÊúÄÂêéÈù¢„ÄÇleaveÁöÑÊó∂ÂÄôÂè™ÈúÄË¶Åremove pÊâÄÂú®ÁöÑlist indexÂç≥ÂèØ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"}]},{"title":"Front-end Interview Note 3 üí™","slug":"frontend-interview-js","date":"2020-03-05T13:05:35.000Z","updated":"2020-05-19T15:45:40.502Z","comments":true,"path":"2020/03/05/frontend-interview-js/","link":"","permalink":"WangHngLeee.github.io/2020/03/05/frontend-interview-js/","excerpt":"JS Èó≠ÂåÖ Èó≠ÂåÖÂ∞±ÊòØËÉΩÂ§üËØªÂèñÂÖ∂‰ªñÂáΩÊï∞ÂÜÖÈÉ®ÂèòÈáèÁöÑÂáΩÊï∞ÔºåÊàñËÄÖÂ≠êÂáΩÊï∞Âú®Â§ñË∞ÉÁî®ÔºåÂ≠êÂáΩÊï∞ÊâÄÂú®ÁöÑÁà∂ÂáΩÊï∞ÁöÑ‰ΩúÁî®Âüü‰∏ç‰ºöË¢´ÈáäÊîæ„ÄÇ Â∫îÁî®Âú∫ÊôØÔºüÂáΩÊï∞Èò≤ÊäñÔºå‰ΩøÁî®Èó≠ÂåÖËÆæËÆ°Âçï‰æãÊ®°ÂºèÔºå‰∏∫Â§ö‰∏™ÁªÑ‰ª∂Áã¨Á´ãÂ±ûÊÄßÔºåËÆæÁΩÆÁßÅÊúâÂèòÈáèÔºåÂèñÂà∞Ê≠£Á°ÆÂÄº„ÄÇ Á±ªÁöÑÂàõÂª∫ÂíåÁªßÊâø ÂàõÂª∫Ôºönew‰∏Ä‰∏™functionÔºåÂú®Ëøô‰∏™functionÁöÑprototypeÈáåÈù¢Â¢ûÂä†Â±ûÊÄßÂíåÊñπÊ≥ï„ÄÇ 1„ÄÅÂéüÂûãÈìæÁªßÊâøÔºåÂ∞ÜÁà∂Á±ªÁöÑÂÆû‰æã‰Ωú‰∏∫Â≠êÁ±ªÁöÑÂéüÂûãÔºå‰ªñÁöÑÁâπÁÇπÊòØÂÆû‰æãÊòØÂ≠êÁ±ªÁöÑÂÆû‰æã‰πüÊòØÁà∂Á±ªÁöÑÂÆû‰æãÔºåÁà∂Á±ªÊñ∞Â¢ûÁöÑÂéüÂûãÊñπÊ≥ï/Â±ûÊÄßÔºåÂ≠êÁ±ªÈÉΩËÉΩÂ§üËÆøÈóÆÔºåÂπ∂‰∏îÂéüÂûãÈìæÁªßÊâøÁÆÄÂçïÊòì‰∫éÂÆûÁé∞ÔºåÁº∫ÁÇπÊòØÊù•Ëá™ÂéüÂûãÂØπË±°ÁöÑÊâÄÊúâÂ±ûÊÄßË¢´ÊâÄÊúâÂÆû‰æãÂÖ±‰∫´ÔºåÊó†Ê≥ïÂÆûÁé∞Â§öÁªßÊâøÔºåÊó†Ê≥ïÂêëÁà∂Á±ªÊûÑÈÄ†ÂáΩÊï∞‰º†ÂèÇ„ÄÇ 2„ÄÅÊûÑÈÄ†ÁªßÊâøÔºå‰ΩøÁî®Áà∂Á±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞Êù•Â¢ûÂº∫Â≠êÁ±ªÂÆû‰æãÔºåÂç≥Â§çÂà∂Áà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÁªôÂ≠êÁ±ªÔºå ÊûÑÈÄ†ÁªßÊâøÂèØ‰ª•ÂêëÁà∂Á±ª‰º†ÈÄíÂèÇÊï∞ÔºåÂèØ‰ª•ÂÆûÁé∞Â§öÁªßÊâøÔºåÈÄöËøácallÂ§ö‰∏™Áà∂Á±ªÂØπË±°„ÄÇ‰ΩÜÊòØÊûÑÈÄ†ÁªßÊâøÂè™ËÉΩÁªßÊâøÁà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÂíåÊñπÊ≥ïÔºå‰∏çËÉΩÁªßÊâøÂéüÂûãÂ±ûÊÄßÂíåÊñπÊ≥ïÔºåÊó†Ê≥ïÂÆûÁé∞ÂáΩÊï∞ÊúçÁî®ÔºåÊØè‰∏™Â≠êÁ±ªÈÉΩÊúâÁà∂Á±ªÂÆû‰æãÂáΩÊï∞ÁöÑÂâØÊú¨ÔºåÂΩ±ÂìçÊÄßËÉΩ 3„ÄÅÂÆû‰æãÁªßÊâøÔºå‰∏∫Áà∂Á±ªÂÆû‰æãÊ∑ªÂä†Êñ∞ÁâπÊÄßÔºå‰Ωú‰∏∫Â≠êÁ±ªÂÆû‰æãËøîÂõûÔºåÂÆû‰æãÁªßÊâøÁöÑÁâπÁÇπÊòØ‰∏çÈôêÂà∂Ë∞ÉÁî®ÊñπÊ≥ïÔºå‰∏çÁÆ°ÊòØnew Â≠êÁ±ªÔºàÔºâËøòÊòØÂ≠êÁ±ªÔºàÔºâËøîÂõûÁöÑÂØπË±°ÂÖ∑ÊúâÁõ∏ÂêåÁöÑÊïàÊûúÔºåÁº∫ÁÇπÊòØÂÆû‰æãÊòØÁà∂Á±ªÁöÑÂÆû‰æãÔºå‰∏çÊòØÂ≠êÁ±ªÁöÑÂÆû‰æãÔºå‰∏çÊîØÊåÅÂ§öÁªßÊâø 4„ÄÅÊã∑Ë¥ùÁªßÊâøÔºöÁâπÁÇπÔºöÊîØÊåÅÂ§öÁªßÊâøÔºåÁº∫ÁÇπÔºöÊïàÁéáËæÉ‰ΩéÔºåÂÜÖÂ≠òÂç†Áî®È´òÔºàÂõ†‰∏∫Ë¶ÅÊã∑Ë¥ùÁà∂Á±ªÁöÑÂ±ûÊÄßÔºâÊó†Ê≥ïËé∑ÂèñÁà∂Á±ª‰∏çÂèØÊûö‰∏æÁöÑÊñπÊ≥ïÔºà‰∏çÂèØÊûö‰∏æÊñπÊ≥ïÔºå‰∏çËÉΩ‰ΩøÁî®for in ËÆøÈóÆÂà∞Ôºâ 5„ÄÅÁªÑÂêàÁªßÊâøÔºöÈÄöËøáË∞ÉÁî®Áà∂Á±ªÊûÑÈÄ†ÔºåÁªßÊâøÁà∂Á±ªÁöÑÂ±ûÊÄßÂπ∂‰øùÁïô‰º†ÂèÇÁöÑ‰ºòÁÇπÔºåÁÑ∂ÂêéÈÄöËøáÂ∞ÜÁà∂Á±ªÂÆû‰æã‰Ωú‰∏∫Â≠êÁ±ªÂéüÂûãÔºåÂÆûÁé∞ÂáΩÊï∞Â§çÁî® 6„ÄÅÂØÑÁîüÁªÑÂêàÁªßÊâøÔºöÈÄöËøáÂØÑÁîüÊñπÂºèÔºåÁ†çÊéâÁà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÔºåËøôÊ†∑ÔºåÂú®Ë∞ÉÁî®‰∏§Ê¨°Áà∂Á±ªÁöÑÊûÑÈÄ†ÁöÑÊó∂ÂÄôÔºåÂ∞±‰∏ç‰ºöÂàùÂßãÂåñ‰∏§Ê¨°ÂÆû‰æãÊñπÊ≥ï/Â±ûÊÄßÔºåÈÅøÂÖçÁöÑÁªÑÂêàÁªßÊâøÁöÑÁº∫ÁÇπ Javascript ÁöÑ‰ΩúÁî®ÂüüÈìæÔºü ‰ΩúÁî®ÂüüÈìæÁöÑ‰ΩúÁî®ÊòØ‰øùËØÅÂØπÊâßË°åÁéØÂ¢ÉÊúâÊùÉËÆøÈóÆÁöÑÊâÄÊúâÂèòÈáèÂíåÂáΩÊï∞ÁöÑÊúâÂ∫èËÆøÈóÆÔºåÈÄöËøá‰ΩúÁî®ÂüüÈìæÔºåÊàë‰ª¨ÂèØ‰ª•ËÆøÈóÆÂà∞Â§ñÂ±ÇÁéØÂ¢ÉÁöÑÂèòÈáèÂíå ÂáΩÊï∞„ÄÇ‰ΩúÁî®ÂüüÈìæÁöÑÊú¨Ë¥®‰∏äÊòØ‰∏Ä‰∏™ÊåáÂêëÂèòÈáèÂØπË±°ÁöÑÊåáÈíàÂàóË°®„ÄÇÂèòÈáèÂØπË±°ÊòØ‰∏Ä‰∏™ÂåÖÂê´‰∫ÜÊâßË°åÁéØÂ¢É‰∏≠ÊâÄÊúâÂèòÈáèÂíåÂáΩÊï∞ÁöÑÂØπË±°„ÄÇ‰ΩúÁî®ÂüüÈìæÁöÑÂâç Á´ØÂßãÁªàÈÉΩÊòØÂΩìÂâçÊâßË°å‰∏ä‰∏ãÊñáÁöÑÂèòÈáèÂØπË±°„ÄÇÂÖ®Â±ÄÊâßË°å‰∏ä‰∏ãÊñáÁöÑÂèòÈáèÂØπË±°Ôºà‰πüÂ∞±ÊòØÂÖ®Â±ÄÂØπË±°ÔºâÂßãÁªàÊòØ‰ΩúÁî®ÂüüÈìæÁöÑÊúÄÂêé‰∏Ä‰∏™ÂØπË±°„ÄÇ ÂΩìÊàë‰ª¨Êü•Êâæ‰∏Ä‰∏™ÂèòÈáèÊó∂ÔºåÂ¶ÇÊûúÂΩìÂâçÊâßË°åÁéØÂ¢É‰∏≠Ê≤°ÊúâÊâæÂà∞ÔºåÊàë‰ª¨ÂèØ‰ª•Ê≤øÁùÄ‰ΩúÁî®ÂüüÈìæÂêëÂêéÊü•Êâæ„ÄÇ","text":"JS Èó≠ÂåÖ Èó≠ÂåÖÂ∞±ÊòØËÉΩÂ§üËØªÂèñÂÖ∂‰ªñÂáΩÊï∞ÂÜÖÈÉ®ÂèòÈáèÁöÑÂáΩÊï∞ÔºåÊàñËÄÖÂ≠êÂáΩÊï∞Âú®Â§ñË∞ÉÁî®ÔºåÂ≠êÂáΩÊï∞ÊâÄÂú®ÁöÑÁà∂ÂáΩÊï∞ÁöÑ‰ΩúÁî®Âüü‰∏ç‰ºöË¢´ÈáäÊîæ„ÄÇ Â∫îÁî®Âú∫ÊôØÔºüÂáΩÊï∞Èò≤ÊäñÔºå‰ΩøÁî®Èó≠ÂåÖËÆæËÆ°Âçï‰æãÊ®°ÂºèÔºå‰∏∫Â§ö‰∏™ÁªÑ‰ª∂Áã¨Á´ãÂ±ûÊÄßÔºåËÆæÁΩÆÁßÅÊúâÂèòÈáèÔºåÂèñÂà∞Ê≠£Á°ÆÂÄº„ÄÇ Á±ªÁöÑÂàõÂª∫ÂíåÁªßÊâø ÂàõÂª∫Ôºönew‰∏Ä‰∏™functionÔºåÂú®Ëøô‰∏™functionÁöÑprototypeÈáåÈù¢Â¢ûÂä†Â±ûÊÄßÂíåÊñπÊ≥ï„ÄÇ 1„ÄÅÂéüÂûãÈìæÁªßÊâøÔºåÂ∞ÜÁà∂Á±ªÁöÑÂÆû‰æã‰Ωú‰∏∫Â≠êÁ±ªÁöÑÂéüÂûãÔºå‰ªñÁöÑÁâπÁÇπÊòØÂÆû‰æãÊòØÂ≠êÁ±ªÁöÑÂÆû‰æã‰πüÊòØÁà∂Á±ªÁöÑÂÆû‰æãÔºåÁà∂Á±ªÊñ∞Â¢ûÁöÑÂéüÂûãÊñπÊ≥ï/Â±ûÊÄßÔºåÂ≠êÁ±ªÈÉΩËÉΩÂ§üËÆøÈóÆÔºåÂπ∂‰∏îÂéüÂûãÈìæÁªßÊâøÁÆÄÂçïÊòì‰∫éÂÆûÁé∞ÔºåÁº∫ÁÇπÊòØÊù•Ëá™ÂéüÂûãÂØπË±°ÁöÑÊâÄÊúâÂ±ûÊÄßË¢´ÊâÄÊúâÂÆû‰æãÂÖ±‰∫´ÔºåÊó†Ê≥ïÂÆûÁé∞Â§öÁªßÊâøÔºåÊó†Ê≥ïÂêëÁà∂Á±ªÊûÑÈÄ†ÂáΩÊï∞‰º†ÂèÇ„ÄÇ 2„ÄÅÊûÑÈÄ†ÁªßÊâøÔºå‰ΩøÁî®Áà∂Á±ªÁöÑÊûÑÈÄ†ÂáΩÊï∞Êù•Â¢ûÂº∫Â≠êÁ±ªÂÆû‰æãÔºåÂç≥Â§çÂà∂Áà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÁªôÂ≠êÁ±ªÔºå ÊûÑÈÄ†ÁªßÊâøÂèØ‰ª•ÂêëÁà∂Á±ª‰º†ÈÄíÂèÇÊï∞ÔºåÂèØ‰ª•ÂÆûÁé∞Â§öÁªßÊâøÔºåÈÄöËøácallÂ§ö‰∏™Áà∂Á±ªÂØπË±°„ÄÇ‰ΩÜÊòØÊûÑÈÄ†ÁªßÊâøÂè™ËÉΩÁªßÊâøÁà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÂíåÊñπÊ≥ïÔºå‰∏çËÉΩÁªßÊâøÂéüÂûãÂ±ûÊÄßÂíåÊñπÊ≥ïÔºåÊó†Ê≥ïÂÆûÁé∞ÂáΩÊï∞ÊúçÁî®ÔºåÊØè‰∏™Â≠êÁ±ªÈÉΩÊúâÁà∂Á±ªÂÆû‰æãÂáΩÊï∞ÁöÑÂâØÊú¨ÔºåÂΩ±ÂìçÊÄßËÉΩ 3„ÄÅÂÆû‰æãÁªßÊâøÔºå‰∏∫Áà∂Á±ªÂÆû‰æãÊ∑ªÂä†Êñ∞ÁâπÊÄßÔºå‰Ωú‰∏∫Â≠êÁ±ªÂÆû‰æãËøîÂõûÔºåÂÆû‰æãÁªßÊâøÁöÑÁâπÁÇπÊòØ‰∏çÈôêÂà∂Ë∞ÉÁî®ÊñπÊ≥ïÔºå‰∏çÁÆ°ÊòØnew Â≠êÁ±ªÔºàÔºâËøòÊòØÂ≠êÁ±ªÔºàÔºâËøîÂõûÁöÑÂØπË±°ÂÖ∑ÊúâÁõ∏ÂêåÁöÑÊïàÊûúÔºåÁº∫ÁÇπÊòØÂÆû‰æãÊòØÁà∂Á±ªÁöÑÂÆû‰æãÔºå‰∏çÊòØÂ≠êÁ±ªÁöÑÂÆû‰æãÔºå‰∏çÊîØÊåÅÂ§öÁªßÊâø 4„ÄÅÊã∑Ë¥ùÁªßÊâøÔºöÁâπÁÇπÔºöÊîØÊåÅÂ§öÁªßÊâøÔºåÁº∫ÁÇπÔºöÊïàÁéáËæÉ‰ΩéÔºåÂÜÖÂ≠òÂç†Áî®È´òÔºàÂõ†‰∏∫Ë¶ÅÊã∑Ë¥ùÁà∂Á±ªÁöÑÂ±ûÊÄßÔºâÊó†Ê≥ïËé∑ÂèñÁà∂Á±ª‰∏çÂèØÊûö‰∏æÁöÑÊñπÊ≥ïÔºà‰∏çÂèØÊûö‰∏æÊñπÊ≥ïÔºå‰∏çËÉΩ‰ΩøÁî®for in ËÆøÈóÆÂà∞Ôºâ 5„ÄÅÁªÑÂêàÁªßÊâøÔºöÈÄöËøáË∞ÉÁî®Áà∂Á±ªÊûÑÈÄ†ÔºåÁªßÊâøÁà∂Á±ªÁöÑÂ±ûÊÄßÂπ∂‰øùÁïô‰º†ÂèÇÁöÑ‰ºòÁÇπÔºåÁÑ∂ÂêéÈÄöËøáÂ∞ÜÁà∂Á±ªÂÆû‰æã‰Ωú‰∏∫Â≠êÁ±ªÂéüÂûãÔºåÂÆûÁé∞ÂáΩÊï∞Â§çÁî® 6„ÄÅÂØÑÁîüÁªÑÂêàÁªßÊâøÔºöÈÄöËøáÂØÑÁîüÊñπÂºèÔºåÁ†çÊéâÁà∂Á±ªÁöÑÂÆû‰æãÂ±ûÊÄßÔºåËøôÊ†∑ÔºåÂú®Ë∞ÉÁî®‰∏§Ê¨°Áà∂Á±ªÁöÑÊûÑÈÄ†ÁöÑÊó∂ÂÄôÔºåÂ∞±‰∏ç‰ºöÂàùÂßãÂåñ‰∏§Ê¨°ÂÆû‰æãÊñπÊ≥ï/Â±ûÊÄßÔºåÈÅøÂÖçÁöÑÁªÑÂêàÁªßÊâøÁöÑÁº∫ÁÇπ Javascript ÁöÑ‰ΩúÁî®ÂüüÈìæÔºü ‰ΩúÁî®ÂüüÈìæÁöÑ‰ΩúÁî®ÊòØ‰øùËØÅÂØπÊâßË°åÁéØÂ¢ÉÊúâÊùÉËÆøÈóÆÁöÑÊâÄÊúâÂèòÈáèÂíåÂáΩÊï∞ÁöÑÊúâÂ∫èËÆøÈóÆÔºåÈÄöËøá‰ΩúÁî®ÂüüÈìæÔºåÊàë‰ª¨ÂèØ‰ª•ËÆøÈóÆÂà∞Â§ñÂ±ÇÁéØÂ¢ÉÁöÑÂèòÈáèÂíå ÂáΩÊï∞„ÄÇ‰ΩúÁî®ÂüüÈìæÁöÑÊú¨Ë¥®‰∏äÊòØ‰∏Ä‰∏™ÊåáÂêëÂèòÈáèÂØπË±°ÁöÑÊåáÈíàÂàóË°®„ÄÇÂèòÈáèÂØπË±°ÊòØ‰∏Ä‰∏™ÂåÖÂê´‰∫ÜÊâßË°åÁéØÂ¢É‰∏≠ÊâÄÊúâÂèòÈáèÂíåÂáΩÊï∞ÁöÑÂØπË±°„ÄÇ‰ΩúÁî®ÂüüÈìæÁöÑÂâç Á´ØÂßãÁªàÈÉΩÊòØÂΩìÂâçÊâßË°å‰∏ä‰∏ãÊñáÁöÑÂèòÈáèÂØπË±°„ÄÇÂÖ®Â±ÄÊâßË°å‰∏ä‰∏ãÊñáÁöÑÂèòÈáèÂØπË±°Ôºà‰πüÂ∞±ÊòØÂÖ®Â±ÄÂØπË±°ÔºâÂßãÁªàÊòØ‰ΩúÁî®ÂüüÈìæÁöÑÊúÄÂêé‰∏Ä‰∏™ÂØπË±°„ÄÇ ÂΩìÊàë‰ª¨Êü•Êâæ‰∏Ä‰∏™ÂèòÈáèÊó∂ÔºåÂ¶ÇÊûúÂΩìÂâçÊâßË°åÁéØÂ¢É‰∏≠Ê≤°ÊúâÊâæÂà∞ÔºåÊàë‰ª¨ÂèØ‰ª•Ê≤øÁùÄ‰ΩúÁî®ÂüüÈìæÂêëÂêéÊü•Êâæ„ÄÇ ‰∫ã‰ª∂ÊµÅÂíå‰∫ã‰ª∂Ê®°Âûã ‰∫ã‰ª∂ÊòØÁî®Êà∑Êìç‰ΩúÁΩëÈ°µÊó∂ÂèëÁîüÁöÑ‰∫§‰∫íÂä®‰ΩúÊàñËÄÖÁΩëÈ°µÊú¨Ë∫´ÁöÑ‰∏Ä‰∫õÊìç‰ΩúÔºåÁé∞‰ª£ÊµèËßàÂô®‰∏ÄÂÖ±Êúâ‰∏âÁßç‰∫ã‰ª∂Ê®°Âûã„ÄÇ 1.DOM0 Á∫ßÊ®°ÂûãÔºåËøôÁßçÊ®°Âûã‰∏ç‰ºö‰º†Êí≠ÔºåÊâÄ‰ª•Ê≤°Êúâ‰∫ã‰ª∂ÊµÅÁöÑÊ¶ÇÂøµÔºå‰ΩÜÊòØÁé∞Âú®ÊúâÁöÑÊµèËßàÂô®ÊîØÊåÅ‰ª•ÂÜíÊ≥°ÁöÑÊñπÂºèÂÆû Áé∞ÔºåÂÆÉÂèØ‰ª•Âú®ÁΩëÈ°µ‰∏≠Áõ¥Êé•ÂÆö‰πâÁõëÂê¨ÂáΩÊï∞Ôºå‰πüÂèØ‰ª•ÈÄöËøá js Â±ûÊÄßÊù•ÊåáÂÆöÁõëÂê¨ÂáΩÊï∞„ÄÇËøôÁßçÊñπÂºèÊòØÊâÄÊúâÊµèËßàÂô®ÈÉΩÂÖºÂÆπÁöÑ„ÄÇ 2.IE ‰∫ã‰ª∂Ê®°ÂûãÔºåÂú®ËØ•‰∫ã‰ª∂Ê®°Âûã‰∏≠Ôºå‰∏ÄÊ¨°‰∫ã‰ª∂ÂÖ±Êúâ‰∏§‰∏™ËøáÁ®ãÔºå‰∫ã‰ª∂Â§ÑÁêÜÈò∂ÊÆµÔºåÂíå‰∫ã‰ª∂ÂÜíÊ≥°Èò∂ÊÆµ„ÄÇ‰∫ã‰ª∂Â§ÑÁêÜÈò∂ÊÆµ‰ºö È¶ñÂÖàÊâßË°åÁõÆÊ†áÂÖÉÁ¥†ÁªëÂÆöÁöÑÁõëÂê¨‰∫ã‰ª∂„ÄÇÁÑ∂ÂêéÊòØ‰∫ã‰ª∂ÂÜíÊ≥°Èò∂ÊÆµÔºåÂÜíÊ≥°ÊåáÁöÑÊòØ‰∫ã‰ª∂‰ªéÁõÆÊ†áÂÖÉÁ¥†ÂÜíÊ≥°Âà∞ documentÔºå‰æùÊ¨°Ê£ÄÊü•ÁªèËøáÁöÑËäÇÁÇπ ÊòØÂê¶ÁªëÂÆö‰∫Ü‰∫ã‰ª∂ÁõëÂê¨ÂáΩÊï∞ÔºåÂ¶ÇÊûúÊúâÂàôÊâßË°å„ÄÇËøôÁßçÊ®°ÂûãÈÄöËøá attachEvent Êù•Ê∑ªÂä†ÁõëÂê¨ÂáΩÊï∞ÔºåÂèØ‰ª•Ê∑ªÂä†Â§ö‰∏™ÁõëÂê¨ÂáΩÊï∞Ôºå‰ºöÊåâÈ°∫Â∫è‰æù Ê¨°ÊâßË°å„ÄÇ 3.DOM2 Á∫ß‰∫ã‰ª∂Ê®°ÂûãÔºåÂú®ËØ•‰∫ã‰ª∂Ê®°Âûã‰∏≠Ôºå‰∏ÄÊ¨°‰∫ã‰ª∂ÂÖ±Êúâ‰∏â‰∏™ËøáÁ®ãÔºå‰∫ã‰ª∂ÊçïËé∑Èò∂ÊÆµ„ÄÇÊçïËé∑ÊåáÁöÑÊòØ‰∫ã‰ª∂‰ªé docu ment ‰∏ÄÁõ¥Âêë‰∏ã‰º†Êí≠Âà∞ÁõÆÊ†áÂÖÉÁ¥†Ôºå‰æùÊ¨°Ê£ÄÊü•ÁªèËøáÁöÑËäÇÁÇπÊòØÂê¶ÁªëÂÆö‰∫Ü‰∫ã‰ª∂ÁõëÂê¨ÂáΩÊï∞ÔºåÂ¶ÇÊûúÊúâÂàôÊâßË°å„ÄÇÂêéÈù¢‰∏§‰∏™Èò∂ÊÆµÂíå IE ‰∫ã‰ª∂Ê®°Âûã ÁöÑ‰∏§‰∏™Èò∂ÊÆµÁõ∏Âêå„ÄÇËøôÁßç‰∫ã‰ª∂Ê®°ÂûãÔºå‰∫ã‰ª∂ÁªëÂÆöÁöÑÂáΩÊï∞ÊòØ addEventListenerÔºåÂÖ∂‰∏≠Á¨¨‰∏â‰∏™ÂèÇÊï∞ÂèØ‰ª•ÊåáÂÆö‰∫ã‰ª∂ÊòØÂê¶Âú®ÊçïËé∑Èò∂ÊÆµÊâßË°å„ÄÇ ‰∫ã‰ª∂ÊµÅÔºö‰∫ã‰ª∂ÊµÅÊèèËø∞ÁöÑÊòØ‰ªéÈ°µÈù¢‰∏≠Êé•Êî∂‰∫ã‰ª∂ÁöÑÈ°∫Â∫è,DOM2Á∫ß‰∫ã‰ª∂ÊµÅÂåÖÊã¨‰∏ãÈù¢Âá†‰∏™Èò∂ÊÆµ„ÄÇ‰∫ã‰ª∂ÊçïËé∑Èò∂ÊÆµÔºåÂ§Ñ‰∫éÁõÆÊ†áÈò∂ÊÆµÔºå‰∫ã‰ª∂ÂÜíÊ≥°Èò∂ÊÆµ Â¶Ç‰ΩïËÆ©‰∫ã‰ª∂ÂÖàÂÜíÊ≥°ÂêéÊçïËé∑ Âú®DOMÊ†áÂáÜ‰∫ã‰ª∂Ê®°Âûã‰∏≠ÔºåÊòØÂÖàÊçïËé∑ÂêéÂÜíÊ≥°„ÄÇ‰ΩÜÊòØÂ¶ÇÊûúË¶ÅÂÆûÁé∞ÂÖàÂÜíÊ≥°ÂêéÊçïËé∑ÁöÑÊïàÊûúÔºåÂØπ‰∫éÂêå‰∏Ä‰∏™‰∫ã‰ª∂ÔºåÁõëÂê¨ÊçïËé∑ÂíåÂÜíÊ≥°ÔºåÂàÜÂà´ÂØπÂ∫îÁõ∏Â∫îÁöÑÂ§ÑÁêÜÂáΩÊï∞ÔºåÁõëÂê¨Âà∞ÊçïËé∑‰∫ã‰ª∂ÔºåÂÖàÊöÇÁºìÊâßË°åÔºåÁõ¥Âà∞ÂÜíÊ≥°‰∫ã‰ª∂Ë¢´ÊçïËé∑ÂêéÂÜçÊâßË°åÊçïËé∑‰πãÈó¥„ÄÇ Ê†πÊçÆw3cÊ†áÂáÜÔºåÂ∫îÂÖàÊçïËé∑ÂÜçÂÜíÊ≥°„ÄÇËã•Ë¶ÅÂÆûÁé∞ÂÖàÂÜíÊ≥°ÂêéÊçïËé∑ÔºåÁªô‰∏Ä‰∏™ÂÖÉÁ¥†ÁªëÂÆö‰∏§‰∏™addEventListenerÔºåÂÖ∂‰∏≠‰∏Ä‰∏™Á¨¨‰∏â‰∏™ÂèÇÊï∞ËÆæÁΩÆ‰∏∫falseÔºàÂç≥ÂÜíÊ≥°ÔºâÔºåÂè¶‰∏Ä‰∏™Á¨¨‰∏â‰∏™ÂèÇÊï∞ËÆæÁΩÆ‰∏∫trueÔºàÂç≥ÊçïËé∑ÔºâÔºåË∞ÉÊï¥ÂÆÉ‰ª¨ÁöÑ‰ª£Á†ÅÈ°∫Â∫èÔºåÂ∞ÜËÆæÁΩÆ‰∏∫falseÁöÑÁõëÂê¨‰∫ã‰ª∂ÊîæÂú®ËÆæÁΩÆ‰∏∫trueÁöÑÁõëÂê¨‰∫ã‰ª∂ÂâçÈù¢Âç≥ÂèØ„ÄÇ ‰∫ã‰ª∂ÂßîÊâò‰∏éÂÜíÊ≥°ÂéüÁêÜ ‰∫ã‰ª∂ÂßîÊâòÊåáÁöÑÊòØÔºå‰∏çÂú®‰∫ã‰ª∂ÁöÑÂèëÁîüÂú∞ÔºàÁõ¥Êé•domÔºâ‰∏äËÆæÁΩÆÁõëÂê¨ÂáΩÊï∞ÔºåËÄåÊòØÂú®ÂÖ∂Áà∂ÂÖÉÁ¥†‰∏äËÆæÁΩÆÁõëÂê¨ÂáΩÊï∞ÔºåÈÄöËøá‰∫ã‰ª∂ÂÜíÊ≥°ÔºåÁà∂ÂÖÉÁ¥†ÂèØ‰ª•ÁõëÂê¨Âà∞Â≠êÂÖÉÁ¥†‰∏ä‰∫ã‰ª∂ÁöÑËß¶ÂèëÔºåÈÄöËøáÂà§Êñ≠‰∫ã‰ª∂ÂèëÁîüÂÖÉÁ¥†DOMÁöÑÁ±ªÂûãÔºåÊù•ÂÅöÂá∫‰∏çÂêåÁöÑÂìçÂ∫î„ÄÇ ‰∫ã‰ª∂ÂÜíÊ≥°ÔºåÂ∞±ÊòØÂÖÉÁ¥†Ëá™Ë∫´ÁöÑ‰∫ã‰ª∂Ë¢´Ëß¶ÂèëÂêéÔºåÂ¶ÇÊûúÁà∂ÂÖÉÁ¥†ÊúâÁõ∏ÂêåÁöÑ‰∫ã‰ª∂ÔºåÂ¶Çonclick‰∫ã‰ª∂ÔºåÈÇ£‰πàÂÖÉÁ¥†Êú¨Ë∫´ÁöÑËß¶ÂèëÁä∂ÊÄÅÂ∞±‰ºö‰º†ÈÄíÔºå‰πüÂ∞±ÊòØÂÜíÂà∞Áà∂ÂÖÉÁ¥†ÔºåÁà∂ÂÖÉÁ¥†ÁöÑÁõ∏Âêå‰∫ã‰ª∂‰πü‰ºö‰∏ÄÁ∫ß‰∏ÄÁ∫ßÊ†πÊçÆÂµåÂ•óÂÖ≥Á≥ªÂêëÂ§ñËß¶ÂèëÔºåÁõ¥Âà∞document/windowÔºåÂÜíÊ≥°ËøáÁ®ãÁªìÊùü„ÄÇ ‰∏æ‰æãÔºöÊúÄÁªèÂÖ∏ÁöÑÂ∞±ÊòØulÂíåliÊ†áÁ≠æÁöÑ‰∫ã‰ª∂ÁõëÂê¨ÔºåÊØîÂ¶ÇÊàë‰ª¨Âú®Ê∑ªÂä†‰∫ã‰ª∂Êó∂ÂÄôÔºåÈááÁî®‰∫ã‰ª∂ÂßîÊâòÊú∫Âà∂Ôºå‰∏ç‰ºöÂú®liÊ†áÁ≠æ‰∏äÁõ¥Êé•Ê∑ªÂä†ÔºåËÄåÊòØÂú®ulÁà∂ÂÖÉÁ¥†‰∏äÊ∑ªÂä†„ÄÇÂ•ΩÂ§ÑÔºöÊØîËæÉÂêàÈÄÇÂä®ÊÄÅÂÖÉÁ¥†ÁöÑÁªëÂÆöÔºåÊñ∞Ê∑ªÂä†ÁöÑÂ≠êÂÖÉÁ¥†‰πü‰ºöÊúâÁõëÂê¨ÂáΩÊï∞Ôºå‰πüÂèØ‰ª•Êúâ‰∫ã‰ª∂Ëß¶ÂèëÊú∫Âà∂„ÄÇ Â¶Ç‰ΩïÈòªÊ≠¢ÂÜíÊ≥°Ôºü w3cÁöÑÊñπÊ≥ïÊòØe.stopPropagation()ÔºåIEÂàôÊòØ‰ΩøÁî®e.cancelBubble = true Ê∑±Êã∑Ë¥ù ÊµÖÊã∑Ë¥ù ÊµÖÊã∑Ë¥ùÊåáÁöÑÊòØÂ∞Ü‰∏Ä‰∏™ÂØπË±°ÁöÑÂ±ûÊÄßÂÄºÂ§çÂà∂Âà∞Âè¶‰∏Ä‰∏™ÂØπË±°ÔºåÂ¶ÇÊûúÊúâÁöÑÂ±ûÊÄßÁöÑÂÄº‰∏∫ÂºïÁî®Á±ªÂûãÁöÑËØùÔºåÈÇ£‰πà‰ºöÂ∞ÜËøô‰∏™ÂºïÁî®ÁöÑÂú∞ÂùÄÂ§çÂà∂ÁªôÂØπË±°ÔºåÂõ†Ê≠§ ‰∏§‰∏™ÂØπË±°‰ºöÊúâÂêå‰∏Ä‰∏™ÂºïÁî®Á±ªÂûãÁöÑÂºïÁî®„ÄÇÊµÖÊã∑Ë¥ùÂèØ‰ª•‰ΩøÁî® Object.assign ÂíåÂ±ïÂºÄËøêÁÆóÁ¨¶Êù•ÂÆûÁé∞„ÄÇ Ê∑±Êã∑Ë¥ùÁõ∏ÂØπÊµÖÊã∑Ë¥ùËÄåË®ÄÔºåÂ¶ÇÊûúÈÅáÂà∞Â±ûÊÄßÂÄº‰∏∫ÂºïÁî®Á±ªÂûãÁöÑÊó∂ÂÄôÔºåÂÆÉÊñ∞Âª∫‰∏Ä‰∏™ÂºïÁî®Á±ªÂûãÂπ∂Â∞ÜÂØπÂ∫îÁöÑÂÄºÂ§çÂà∂ÁªôÂÆÉÔºåÂõ†Ê≠§ÂØπË±°Ëé∑ÂæóÁöÑ‰∏Ä‰∏™Êñ∞ÁöÑÂºï Áî®Á±ªÂûãËÄå‰∏çÊòØ‰∏Ä‰∏™ÂéüÊúâÁ±ªÂûãÁöÑÂºïÁî®„ÄÇÊ∑±Êã∑Ë¥ùÂØπ‰∫é‰∏Ä‰∫õÂØπË±°ÂèØ‰ª•‰ΩøÁî® JSON ÁöÑ‰∏§‰∏™ÂáΩÊï∞Êù•ÂÆûÁé∞Ôºå‰ΩÜÊòØÁî±‰∫é JSON ÁöÑÂØπË±°Ê†ºÂºèÊØî js ÁöÑÂØπ Ë±°Ê†ºÂºèÊõ¥Âä†‰∏•Ê†ºÔºåÊâÄ‰ª•Â¶ÇÊûúÂ±ûÊÄßÂÄºÈáåËæπÂá∫Áé∞ÂáΩÊï∞ÊàñËÄÖ Symbol Á±ªÂûãÁöÑÂÄºÊó∂Ôºå‰ºöËΩ¨Êç¢Â§±Ë¥•„ÄÇ ÊáíÂä†ËΩΩÂíåÈ¢ÑÂä†ËΩΩ È¢ÑÂä†ËΩΩÔºöÊèêÂâçÂä†ËΩΩÂõæÁâáÔºåÂΩìÁî®Êà∑ÈúÄË¶ÅÊü•ÁúãÊó∂ÂèØÁõ¥Êé•‰ªéÊú¨Âú∞ÁºìÂ≠ò‰∏≠Ê∏≤Êüì„ÄÇ ÊáíÂä†ËΩΩÔºöÊáíÂä†ËΩΩÁöÑ‰∏ªË¶ÅÁõÆÁöÑÊòØ‰Ωú‰∏∫ÊúçÂä°Âô®ÂâçÁ´ØÁöÑ‰ºòÂåñÔºåÂáèÂ∞ëËØ∑Ê±ÇÊï∞ÊàñÂª∂ËøüËØ∑Ê±ÇÊï∞„ÄÇ ‰∏§ÁßçÊäÄÊúØÁöÑÊú¨Ë¥®Ôºö‰∏§ËÄÖÁöÑË°å‰∏∫ÊòØÁõ∏ÂèçÁöÑÔºå‰∏Ä‰∏™ÊòØÊèêÂâçÂä†ËΩΩÔºå‰∏Ä‰∏™ÊòØËøüÁºìÁîöËá≥‰∏çÂä†ËΩΩ„ÄÇ ÊáíÂä†ËΩΩÂØπÊúçÂä°Âô®ÂâçÁ´ØÊúâ‰∏ÄÂÆöÁöÑÁºìËß£ÂéãÂäõ‰ΩúÁî®ÔºåÈ¢ÑÂä†ËΩΩÂàô‰ºöÂ¢ûÂä†ÊúçÂä°Âô®ÂâçÁ´ØÂéãÂäõ„ÄÇ ÊîπÂèòÂáΩÊï∞ÂÜÖÈÉ®thisÊåáÈíàÁöÑÊåáÂêëÂáΩÊï∞ÔºàbindÔºåapplyÔºåcallÁöÑÂå∫Âà´Ôºâ CallÔºåapplyÂÆÉ‰ª¨ÁöÑÂÖ±ÂêåÁÇπÊòØÔºåÈÉΩËÉΩÂ§üÊîπÂèòÂáΩÊï∞ÊâßË°åÊó∂ÁöÑ‰∏ä‰∏ãÊñáÔºåÂ∞Ü‰∏Ä‰∏™ÂØπË±°ÁöÑÊñπÊ≥ï‰∫§ÁªôÂè¶‰∏Ä‰∏™ÂØπË±°Êù•ÊâßË°åÔºåÂπ∂‰∏îÊòØÁ´ãÂç≥ÊâßË°åÁöÑ„ÄÇ bind ÊñπÊ≥ï ‰∏é apply Âíå call ÊØîËæÉÁ±ª‰ººÔºå‰πüËÉΩÊîπÂèòÂáΩÊï∞‰ΩìÂÜÖÁöÑ this ÊåáÂêë„ÄÇ‰∏çÂêåÁöÑÊòØÔºåbind ÊñπÊ≥ïÁöÑËøîÂõûÂÄºÊòØÂáΩÊï∞ÔºåÂπ∂‰∏îÈúÄË¶ÅÁ®çÂêéË∞ÉÁî®ÔºåÊâç‰ºöÊâßË°å„ÄÇËÄå apply Âíå call ÂàôÊòØÁ´ãÂç≥Ë∞ÉÁî® JSËäÇÊµÅ‰∏éÈò≤Êäñ ÂáΩÊï∞ËäÇÊµÅ: ÊåáÂÆöÊó∂Èó¥Èó¥ÈöîÂÜÖÂè™‰ºöÊâßË°å‰∏ÄÊ¨°‰ªªÂä°Ôºõ ÂáΩÊï∞Èò≤Êäñ: ‰ªªÂä°È¢ëÁπÅËß¶ÂèëÁöÑÊÉÖÂÜµ‰∏ãÔºåÂè™Êúâ‰ªªÂä°Ëß¶ÂèëÁöÑÈó¥ÈöîË∂ÖËøáÊåáÂÆöÈó¥ÈöîÁöÑÊó∂ÂÄôÔºå‰ªªÂä°Êâç‰ºöÊâßË°å„ÄÇ iframe &amp;&amp; iframeÁöÑÁº∫ÁÇπ ÂÆö‰πâÔºöiframeÂÖÉÁ¥†‰ºöÂàõÂª∫ÂåÖÂê´Âè¶‰∏Ä‰∏™ÊñáÊ°£ÁöÑÂÜÖËÅîÊ°ÜÊû∂ ÊèêÁ§∫ÔºöÂèØ‰ª•Â∞ÜÊèêÁ§∫ÊñáÂ≠óÊîæÂú®‰πãÈó¥ÔºåÊù•ÊèêÁ§∫Êüê‰∫õ‰∏çÊîØÊåÅiframeÁöÑÊµèËßàÂô® Áº∫ÁÇπÔºöiframe ‰ºöÈòªÂ°û‰∏ªÈ°µÈù¢ÁöÑ onload ‰∫ã‰ª∂„ÄÇwindow ÁöÑ onload ‰∫ã‰ª∂ÈúÄË¶ÅÂú®ÊâÄÊúâ iframe Âä†ËΩΩÂÆåÊØïÂêéÔºàÂåÖÂê´ÈáåÈù¢ÁöÑÂÖÉÁ¥†ÔºâÊâç ‰ºöËß¶Âèë„ÄÇÂú® Safari Âíå Chrome ÈáåÔºåÈÄöËøá JavaScript Âä®ÊÄÅËÆæÁΩÆ iframe ÁöÑ src ÂèØ‰ª•ÈÅøÂÖçËøôÁßçÈòªÂ°ûÊÉÖÂÜµ„ÄÇ Ôºà2Ôºâ ÊêúÁ¥¢ÂºïÊìéÁöÑÊ£ÄÁ¥¢Á®ãÂ∫èÊó†Ê≥ïËß£ËØªËøôÁßçÈ°µÈù¢Ôºå‰∏çÂà©‰∫éÁΩëÈ°µÁöÑ SEO „ÄÇ Ôºà3Ôºâ iframe Âíå‰∏ªÈ°µÈù¢ÂÖ±‰∫´ËøûÊé•Ê±†ÔºåËÄåÊµèËßàÂô®ÂØπÁõ∏ÂêåÂüüÁöÑËøûÊé•ÊúâÈôêÂà∂ÔºåÊâÄ‰ª•‰ºöÂΩ±ÂìçÈ°µÈù¢ÁöÑÂπ∂Ë°åÂä†ËΩΩ„ÄÇ Ôºà4Ôºâ ÊµèËßàÂô®ÁöÑÂêéÈÄÄÊåâÈíÆÂ§±Êïà„ÄÇ Ôºà5Ôºâ Â∞èÂûãÁöÑÁßªÂä®ËÆæÂ§áÊó†Ê≥ïÂÆåÂÖ®ÊòæÁ§∫Ê°ÜÊû∂„ÄÇ JS‰∏≠ÁöÑÂûÉÂúæÂõûÊî∂Êú∫Âà∂ ÂûÉÂúæÂõûÊî∂Êúâ‰∏§ÁßçÂÆûÁé∞ÊñπÂºèÔºåÂàÜÂà´ÊòØÊ†áËÆ∞Ê∏ÖÈô§ÂíåÂºïÁî®ËÆ°Êï∞ Ê†áËÆ∞Ê∏ÖÈô§ÔºöÂΩìÂèòÈáèËøõÂÖ•ÊâßË°åÁéØÂ¢ÉÊó∂Ê†áËÆ∞‰∏∫‚ÄúËøõÂÖ•ÁéØÂ¢É‚ÄùÔºåÂΩìÂèòÈáèÁ¶ªÂºÄÊâßË°åÁéØÂ¢ÉÊó∂ÂàôÊ†áËÆ∞‰∏∫‚ÄúÁ¶ªÂºÄÁéØÂ¢É‚ÄùÔºåË¢´Ê†áËÆ∞‰∏∫‚ÄúËøõÂÖ•ÁéØÂ¢É‚ÄùÁöÑÂèòÈáèÊòØ‰∏çËÉΩË¢´ÂõûÊî∂ÁöÑÔºåÂõ†‰∏∫ÂÆÉ‰ª¨Ê≠£Âú®Ë¢´‰ΩøÁî®ÔºåËÄåÊ†áËÆ∞‰∏∫‚ÄúÁ¶ªÂºÄÁéØÂ¢É‚ÄùÁöÑÂèòÈáèÂàôÂèØ‰ª•Ë¢´ÂõûÊî∂„ÄÇ ÂºïÁî®ËÆ°Êï∞ÔºöÁªüËÆ°ÂºïÁî®Á±ªÂûãÂèòÈáèÂ£∞ÊòéÂêéË¢´ÂºïÁî®ÁöÑÊ¨°Êï∞ÔºåÂΩìÊ¨°Êï∞‰∏∫ 0 Êó∂ÔºåËØ•ÂèòÈáèÂ∞ÜË¢´ÂõûÊî∂„ÄÇ common.js CommonjsÔºöÂºÄÂßã‰∫éÊúçÂä°Âô®Á´ØÁöÑÊ®°ÂùóÂåñÔºåÂêåÊ≠•ÂÆö‰πâÁöÑÊ®°ÂùóÂåñÔºåÊØè‰∏™Ê®°ÂùóÈÉΩÊòØ‰∏Ä‰∏™ÂçïÁã¨ÁöÑ‰ΩúÁî®ÂüüÔºåÊ®°ÂùóËæìÂá∫Ôºåmodules.exportsÔºåÊ®°ÂùóÂä†ËΩΩrequire()ÂºïÂÖ•Ê®°Âùó„ÄÇ Êï∞ÁªÑÂéªÈáç Ê≥ï‰∏ÄÔºöindexOfÂæ™ÁéØÂéªÈáç Ê≥ï‰∫åÔºöES6 SetÂéªÈáçÔºõArray.from(new Set(array)) Ê≥ï‰∏âÔºöObject ÈîÆÂÄºÂØπÂéªÈáçÔºõÊääÊï∞ÁªÑÁöÑÂÄºÂ≠òÊàê Object ÁöÑ key ÂÄºÔºåÊØîÂ¶Ç Object[value1] = trueÔºåÂú®Âà§Êñ≠Âè¶‰∏Ä‰∏™ÂÄºÁöÑÊó∂ÂÄôÔºåÂ¶ÇÊûú Object[value2]Â≠òÂú®ÁöÑËØùÔºåÂ∞±ËØ¥ÊòéËØ•ÂÄºÊòØÈáçÂ§çÁöÑ„ÄÇ Âà§Êñ≠Êï∞ÊçÆÁ±ªÂûãÔºàÊòØÊï∞ÁªÑÔºâÔºü Object.prototype.call.toString() Instanceof Ë∑®ÂüüÔºüÂÆûÁé∞ÊñπÊ≥ï Ë∑®ÂüüÔºåÊòØÊåáÊµèËßàÂô®‰∏çËÉΩÊâßË°åÂÖ∂‰ªñÁΩëÁ´ôÁöÑËÑöÊú¨„ÄÇÂÆÉÊòØÁî±ÊµèËßàÂô®ÁöÑÂêåÊ∫êÁ≠ñÁï•ÈÄ†ÊàêÁöÑÔºåÊòØÊµèËßàÂô®ÂØπJavaScriptÂÆûÊñΩÁöÑÂÆâÂÖ®ÈôêÂà∂ÔºåÈÇ£‰πàÂè™Ë¶ÅÂçèËÆÆ„ÄÅÂüüÂêç„ÄÅÁ´ØÂè£Êúâ‰ªª‰Ωï‰∏Ä‰∏™‰∏çÂêåÔºåÈÉΩË¢´ÂΩì‰ΩúÊòØ‰∏çÂêåÁöÑÂüü„ÄÇË∑®ÂüüÂéüÁêÜÔºåÂç≥ÊòØÈÄöËøáÂêÑÁßçÊñπÂºèÔºåÈÅøÂºÄÊµèËßàÂô®ÁöÑÂÆâÂÖ®ÈôêÂà∂„ÄÇ JSONPÔºöÈÄöËøáÂä®ÊÄÅÂàõÂª∫scriptÔºåÂÜçËØ∑Ê±Ç‰∏Ä‰∏™Â∏¶ÂèÇÁΩëÂùÄÂÆûÁé∞Ë∑®ÂüüÈÄö‰ø°„ÄÇdocument.domain + iframeË∑®ÂüüÔºö‰∏§‰∏™È°µÈù¢ÈÉΩÈÄöËøájsÂº∫Âà∂ËÆæÁΩÆdocument.domain‰∏∫Âü∫Á°Ä‰∏ªÂüüÔºåÂ∞±ÂÆûÁé∞‰∫ÜÂêåÂüü„ÄÇ location.hash + iframeË∑®ÂüüÔºöaÊ¨≤‰∏ébË∑®ÂüüÁõ∏‰∫íÈÄö‰ø°ÔºåÈÄöËøá‰∏≠Èó¥È°µcÊù•ÂÆûÁé∞„ÄÇ ‰∏â‰∏™È°µÈù¢Ôºå‰∏çÂêåÂüü‰πãÈó¥Âà©Áî®iframeÁöÑlocation.hash‰º†ÂÄºÔºåÁõ∏ÂêåÂüü‰πãÈó¥Áõ¥Êé•jsËÆøÈóÆÊù•ÈÄö‰ø°„ÄÇ window.name + iframeË∑®ÂüüÔºöÈÄöËøáiframeÁöÑsrcÂ±ûÊÄßÁî±Â§ñÂüüËΩ¨ÂêëÊú¨Âú∞ÂüüÔºåË∑®ÂüüÊï∞ÊçÆÂç≥Áî±iframeÁöÑwindow.name‰ªéÂ§ñÂüü‰º†ÈÄíÂà∞Êú¨Âú∞Âüü„ÄÇ postMessageË∑®ÂüüÔºöÂèØ‰ª•Ë∑®ÂüüÊìç‰ΩúÁöÑwindowÂ±ûÊÄß‰πã‰∏Ä„ÄÇ CORSÔºöÊúçÂä°Á´ØËÆæÁΩÆAccess-Control-Allow-OriginÂç≥ÂèØÔºåÂâçÁ´ØÊó†È°ªËÆæÁΩÆÔºåËã•Ë¶ÅÂ∏¶cookieËØ∑Ê±ÇÔºåÂâçÂêéÁ´ØÈÉΩÈúÄË¶ÅËÆæÁΩÆ„ÄÇ ‰ª£ÁêÜË∑®ÂüüÔºöËµ∑‰∏Ä‰∏™‰ª£ÁêÜÊúçÂä°Âô®ÔºåÂÆûÁé∞Êï∞ÊçÆÁöÑËΩ¨Âèë ÈáçÊéíÂíåÈáçÁªò ÈáçÁªòÔºöÂΩìÁõíÂ≠êÁöÑ‰ΩçÁΩÆ„ÄÅÂ§ßÂ∞è‰ª•ÂèäÂÖ∂‰ªñÂ±ûÊÄßÔºåÈ¢úËâ≤„ÄÅÂ≠ó‰ΩìÂ§ßÂ∞èÁ≠âÈÉΩÁ°ÆÂÆö‰∏ãÊù•‰πãÂêéÔºåÊµèËßàÂô®‰æøÊääËøô‰∫õÂéüËâ≤ÈÉΩÊåâÁÖßÂêÑËá™ÁöÑÁâπÊÄßÁªòÂà∂‰∏ÄÈÅçÔºåÂ∞ÜÂÜÖÂÆπÂëàÁé∞Âú®È°µÈù¢‰∏ä„ÄÇÈáçÁªòÊòØÊåá‰∏Ä‰∏™ÂÖÉÁ¥†Â§ñËßÇÁöÑÊîπÂèòÊâÄËß¶ÂèëÁöÑÊµèËßàÂô®Ë°å‰∏∫ÔºåÊµèËßàÂô®‰ºöÊ†πÊçÆÂÖÉÁ¥†ÁöÑÊñ∞Â±ûÊÄßÈáçÊñ∞ÁªòÂà∂Ôºå‰ΩøÂÖÉÁ¥†ÂëàÁé∞Êñ∞ÁöÑÂ§ñËßÇ„ÄÇ ÈáçÊéíÔºöÂΩìÊ∏≤ÊüìÊ†ë‰∏≠ÁöÑ‰∏ÄÈÉ®ÂàÜ(ÊàñÂÖ®ÈÉ®)Âõ†‰∏∫ÂÖÉÁ¥†ÁöÑËßÑÊ®°Â∞∫ÂØ∏ÔºåÂ∏ÉÂ±ÄÔºåÈöêËóèÁ≠âÊîπÂèòËÄåÈúÄË¶ÅÈáçÊñ∞ÊûÑÂª∫, ËøôÂ∞±Áß∞‰∏∫ÂõûÊµÅ(reflow)„ÄÇÊØè‰∏™È°µÈù¢Ëá≥Â∞ëÈúÄË¶Å‰∏ÄÊ¨°ÂõûÊµÅÔºåÂ∞±ÊòØÂú®È°µÈù¢Á¨¨‰∏ÄÊ¨°Âä†ËΩΩÁöÑÊó∂ÂÄô„ÄÇ ÈáçÁªòÂíåÈáçÊéíÁöÑÂÖ≥Á≥ªÔºöÂú®ÂõûÊµÅÁöÑÊó∂ÂÄôÔºåÊµèËßàÂô®‰ºö‰ΩøÊ∏≤ÊüìÊ†ë‰∏≠ÂèóÂà∞ÂΩ±ÂìçÁöÑÈÉ®ÂàÜÂ§±ÊïàÔºåÂπ∂ÈáçÊñ∞ÊûÑÈÄ†ËøôÈÉ®ÂàÜÊ∏≤ÊüìÊ†ëÔºåÂÆåÊàêÂõûÊµÅÂêéÔºåÊµèËßàÂô®‰ºöÈáçÊñ∞ÁªòÂà∂ÂèóÂΩ±ÂìçÁöÑÈÉ®ÂàÜÂà∞Â±èÂπï‰∏≠ÔºåËØ•ËøáÁ®ãÁß∞‰∏∫ÈáçÁªò„ÄÇÊâÄ‰ª•ÔºåÈáçÊéíÂøÖÂÆö‰ºöÂºïÂèëÈáçÁªòÔºå‰ΩÜÈáçÁªò‰∏ç‰∏ÄÂÆö‰ºöÂºïÂèëÈáçÊéí„ÄÇ ËôöÊãüvirtual dom Áî®JavaScript ÂØπË±°ÁªìÊûÑË°®Á§∫ DOM Ê†ëÁöÑÁªìÊûÑÔºõÁÑ∂ÂêéÁî®Ëøô‰∏™Ê†ëÊûÑÂª∫‰∏Ä‰∏™ÁúüÊ≠£ÁöÑ DOM Ê†ëÔºåÊèíÂà∞ÊñáÊ°£ÂΩì‰∏≠ ÂΩìÁä∂ÊÄÅÂèòÊõ¥ÁöÑÊó∂ÂÄôÔºåÈáçÊñ∞ÊûÑÈÄ†‰∏ÄÊ£µÊñ∞ÁöÑÂØπË±°Ê†ë„ÄÇÁÑ∂ÂêéÁî®Êñ∞ÁöÑÊ†ëÂíåÊóßÁöÑÊ†ëËøõË°åÊØîËæÉÔºåËÆ∞ÂΩï‰∏§Ê£µÊ†ëÂ∑ÆÂºÇ ÊääÊâÄËÆ∞ÂΩïÁöÑÂ∑ÆÂºÇÂ∫îÁî®Âà∞ÊâÄÊûÑÂª∫ÁöÑÁúüÊ≠£ÁöÑDOMÊ†ë‰∏äÔºåËßÜÂõæÂ∞±Êõ¥Êñ∞‰∫Ü„ÄÇVirtual DOM Êú¨Ë¥®‰∏äÂ∞±ÊòØÂú® JS Âíå DOM ‰πãÈó¥ÂÅö‰∫Ü‰∏Ä‰∏™ÁºìÂ≠ò„ÄÇ webpackÔºü cssÊñá‰ª∂ webpack ÊòØ‰∏Ä‰∏™Áé∞‰ª£ JavaScript Â∫îÁî®Á®ãÂ∫èÁöÑÈùôÊÄÅÊ®°ÂùóÊâìÂåÖÂô®(module bundler)„ÄÇÂΩì webpack Â§ÑÁêÜÂ∫îÁî®Á®ãÂ∫èÊó∂ÔºåÂÆÉ‰ºöÈÄíÂΩíÂú∞ÊûÑÂª∫‰∏Ä‰∏™‰æùËµñÂÖ≥Á≥ªÂõæ(dependency graph)ÔºåÂÖ∂‰∏≠ÂåÖÂê´Â∫îÁî®Á®ãÂ∫èÈúÄË¶ÅÁöÑÊØè‰∏™Ê®°ÂùóÔºåÁÑ∂ÂêéÂ∞ÜÊâÄÊúâËøô‰∫õÊ®°ÂùóÊâìÂåÖÊàê‰∏Ä‰∏™ÊàñÂ§ö‰∏™bundle„ÄÇ promise ES6Êñ∞ËØ≠Ê≥ïÔºåPromiseÊòØ‰∏Ä‰∏™ÂØπË±°Ôºå‰øùÂ≠òÁùÄÊú™Êù•Â∞ÜË¶ÅÁªìÊùüÁöÑ‰∫ã‰ª∂ÔºåÂ•πÊúâ‰∏§‰∏™ÁâπÂæÅ: 1„ÄÅÂØπË±°ÁöÑÁä∂ÊÄÅ‰∏çÂèóÂ§ñÈÉ®ÂΩ±ÂìçÔºåPromiseÂØπË±°‰ª£Ë°®‰∏Ä‰∏™ÂºÇÊ≠•Êìç‰ΩúÔºåÊúâ‰∏âÁßçÁä∂ÊÄÅÔºåpendingËøõË°å‰∏≠ÔºåfulfilledÂ∑≤ÊàêÂäüÔºårejectedÂ∑≤Â§±Ë¥•ÔºåÂè™ÊúâÂºÇÊ≠•Êìç‰ΩúÁöÑÁªìÊûúÔºåÊâçÂèØ‰ª•ÂÜ≥ÂÆöÂΩìÂâçÊòØÂì™‰∏ÄÁßçÁä∂ÊÄÅÔºå‰ªª‰ΩïÂÖ∂‰ªñÊìç‰ΩúÈÉΩÊó†Ê≥ïÊîπÂèòËøô‰∏™Áä∂ÊÄÅÔºåËøô‰πüÂ∞±ÊòØpromiseÂêçÂ≠óÁöÑÁî±Êù• 2„ÄÅ‰∏ÄÊó¶Áä∂ÊÄÅÊîπÂèòÔºåÂ∞±‰∏ç‰ºöÂÜçÂèòÔºåpromiseÂØπË±°Áä∂ÊÄÅÊîπÂèòÂè™Êúâ‰∏§ÁßçÂèØËÉΩÔºå‰ªépendingÊîπÂà∞fulfilledÊàñËÄÖ‰ªépendingÊîπÂà∞rejectedÔºåÂè™Ë¶ÅËøô‰∏§ÁßçÊÉÖÂÜµÂèëÁîüÔºåÁä∂ÊÄÅÂ∞±ÂáùÂõ∫‰∫ÜÔºå‰∏ç‰ºöÂÜçÊîπÂèòÔºåËøô‰∏™Êó∂ÂÄôÂ∞±Áß∞‰∏∫ÂÆöÂûãresolved, vueÁîüÂëΩÂë®Êúü VueÂÆû‰æãÊúâ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁîüÂëΩÂë®ÊúüÔºå‰πüÂ∞±ÊòØ‰ªéÂºÄÂßãÂàõÂª∫„ÄÅÂàùÂßãÂåñÊï∞ÊçÆ„ÄÅÁºñËØëÊ®°Êùø„ÄÅÊåÇËΩΩDom„ÄÅÊ∏≤Êüì‚ÜíÊõ¥Êñ∞‚ÜíÊ∏≤Êüì„ÄÅÈîÄÊØÅÁ≠â‰∏ÄÁ≥ªÂàóËøáÁ®ãÔºåÊàë‰ª¨Áß∞ËøôÊòØVueÁöÑÁîüÂëΩÂë®Êúü„ÄÇÈÄö‰øóËØ¥Â∞±ÊòØVueÂÆû‰æã‰ªéÂàõÂª∫Âà∞ÈîÄÊØÅÁöÑËøáÁ®ãÔºåÂ∞±ÊòØÁîüÂëΩÂë®Êúü„ÄÇ es6ÁÆ≠Â§¥ÂáΩÊï∞ÁâπÊÄß 1„ÄÅÁÆ≠Â§¥ÂáΩÊï∞Ê≤°ÊúâthisÔºåÊâÄ‰ª•ÈúÄË¶ÅÈÄöËøáÊü•Êâæ‰ΩúÁî®ÂüüÈìæÊù•Á°ÆÂÆöthisÁöÑÂÄºÔºåËøôÂ∞±ÊÑèÂë≥ÁùÄÂ¶ÇÊûúÁÆ≠Â§¥ÂáΩÊï∞Ë¢´ÈùûÁÆ≠Â§¥ÂáΩÊï∞ÂåÖÂê´ÔºåthisÁªëÂÆöÁöÑÂ∞±ÊòØÊúÄËøë‰∏ÄÂ±ÇÈùûÁÆ≠Â§¥ÂáΩÊï∞ÁöÑthisÔºå 2„ÄÅÁÆ≠Â§¥ÂáΩÊï∞Ê≤°ÊúâËá™Â∑±ÁöÑargumentsÂØπË±°Ôºå‰ΩÜÊòØÂèØ‰ª•ËÆøÈóÆÂ§ñÂõ¥ÂáΩÊï∞ÁöÑargumentsÂØπË±° 3„ÄÅ‰∏çËÉΩÈÄöËøánewÂÖ≥ÈîÆÂ≠óË∞ÉÁî®ÔºåÂêåÊ†∑‰πüÊ≤°Êúânew.targetÂÄºÂíåÂéüÂûã es6Êñ∞ÁâπÊÄß ÂùóÁ∫ß‰ΩúÁî®ÂüüÔºöES5Âè™ÊúâÂÖ®Â±Ä‰ΩúÁî®ÂüüÂíåÂáΩÊï∞‰ΩúÁî®ÂüüÔºåÂùóÁ∫ß‰ΩúÁî®ÂüüÁöÑÂ•ΩÂ§ÑÊòØ‰∏çÂÜçÈúÄË¶ÅÁ´ãÂç≥ÊâßË°åÁöÑÂáΩÊï∞Ë°®ËææÂºèÔºåÂæ™ÁéØ‰Ωì‰∏≠ÁöÑÈó≠ÂåÖ‰∏çÂÜçÊúâÈóÆÈ¢ò restÂèÇÊï∞ÔºöÁî®‰∫éËé∑ÂèñÂáΩÊï∞ÁöÑÂ§ö‰ΩôÂèÇÊï∞ÔºåËøôÊ†∑Â∞±‰∏çÈúÄË¶Å‰ΩøÁî®argumentsÂØπË±°‰∫ÜÔºå promise:‰∏ÄÁßçÂºÇÊ≠•ÁºñÁ®ãÁöÑËß£ÂÜ≥ÊñπÊ°àÔºåÊØî‰º†ÁªüÁöÑËß£ÂÜ≥ÊñπÊ°àÂõûË∞ÉÂáΩÊï∞Âíå‰∫ã‰ª∂Êõ¥ÂêàÁêÜÂº∫Â§ß Ê®°ÂùóÂåñÔºöÂÖ∂Ê®°ÂùóÂäüËÉΩ‰∏ªË¶ÅÊúâ‰∏§‰∏™ÂëΩ‰ª§ÊûÑÊàêÔºåexportÂíåimportÔºåexportÂëΩ‰ª§Áî®‰∫éËßÑÂÆöÊ®°ÂùóÁöÑÂØπÂ§ñÊé•Âè£ÔºåimportÂëΩ‰ª§Áî®‰∫éËæìÂÖ•ÂÖ∂‰ªñÊ®°ÂùóÊèê‰æõÁöÑÂäüËÉΩ ÂêåÊ∫êÁ≠ñÁï• Â¶ÇÊûúÊ≤°ÊúâÂêåÊ∫êÁ≠ñÁï•Ôºå‰∏çÂêåÊ∫êÁöÑÊï∞ÊçÆÂíåËµÑÊ∫êÔºàÂ¶ÇHTTPÂ§¥„ÄÅCookie„ÄÅDOM„ÄÅlocalStorageÁ≠âÔºâÂ∞±ËÉΩÁõ∏‰∫íÈöèÊÑèËÆøÈóÆÔºåÊ†πÊú¨Ê≤°ÊúâÈöêÁßÅÂíåÂÆâÂÖ®ÂèØË®Ä„ÄÇ‰∏∫‰∫ÜÂÆâÂÖ®Ëµ∑ËßÅÂíåËµÑÊ∫êÁöÑÊúâÊïàÁÆ°ÁêÜÔºåÊµèËßàÂô®ÂΩìÁÑ∂Ë¶ÅÈááÁî®ËøôÁßçÁ≠ñÁï•„ÄÇ PWA PWAÂÖ®Áß∞Progressive Web AppÔºåÂç≥Ê∏êËøõÂºèWEBÂ∫îÁî®„ÄÇ‰∏Ä‰∏™ PWA Â∫îÁî®È¶ñÂÖàÊòØ‰∏Ä‰∏™ÁΩëÈ°µ, ÂèØ‰ª•ÈÄöËøá Web ÊäÄÊúØÁºñÂÜôÂá∫‰∏Ä‰∏™ÁΩëÈ°µÂ∫îÁî®. ÈöèÂêéÊ∑ªÂä†‰∏ä App Manifest Âíå Service Worker Êù•ÂÆûÁé∞ PWA ÁöÑÂÆâË£ÖÂíåÁ¶ªÁ∫øÁ≠âÂäüËÉΩ Redux Âú®ÁªÑ‰ª∂ÂåñÁöÑÂ∫îÁî®‰∏≠Ôºå‰ºöÊúâÁùÄÂ§ßÈáèÁöÑÁªÑ‰ª∂Â±ÇÁ∫ßÂÖ≥Á≥ªÔºåÊ∑±ÂµåÂ•óÁöÑÁªÑ‰ª∂‰∏éÊµÖÂ±ÇÁà∂ÁªÑ‰ª∂ËøõË°åÊï∞ÊçÆ‰∫§‰∫íÔºåÂèòÂæóÂçÅÂàÜÁπÅÁêêÂõ∞Èöæ„ÄÇËÄåreduxÔºåÁ´ôÂú®‰∏Ä‰∏™ÊúçÂä°Á∫ßÂà´ÁöÑËßíÂ∫¶ÔºåÂèØ‰ª•ÊØ´Êó†ÈòªÁ¢çÂú∞Â∞ÜÂ∫îÁî®ÁöÑÁä∂ÊÄÅ‰º†ÈÄíÂà∞ÊØè‰∏Ä‰∏™Â±ÇÁ∫ßÁöÑÁªÑ‰ª∂‰∏≠„ÄÇreduxÂ∞±Áõ∏ÂΩì‰∫éÊï¥‰∏™Â∫îÁî®ÁöÑÁÆ°ÂÆ∂„ÄÇ reduxÈáåÂ∏∏Áî®ÊñπÊ≥ï Êèê‰æõ getState() ÊñπÊ≥ïËé∑Âèñ stateÔºõ Êèê‰æõ dispatch(action) ÊñπÊ≥ïÊõ¥Êñ∞ stateÔºõ ÈÄöËøá subscribe(listener) Ê≥®ÂÜåÁõëÂê¨Âô®; vueÂèåÂêëÁªëÂÆöÂéüÁêÜÔºö vueÊï∞ÊçÆÂèåÂêëÁªëÂÆöÊòØÈÄöËøáÊï∞ÊçÆÂä´ÊåÅÁªìÂêàÂèëÂ∏ÉËÄÖ-ËÆ¢ÈòÖËÄÖÊ®°ÂºèÁöÑÊñπÂºèÊù•ÂÆûÁé∞ÁöÑ„ÄÇÂà©Áî®‰∫Ü Object.defineProperty() Ëøô‰∏™ÊñπÊ≥ïÈáçÊñ∞ÂÆö‰πâ‰∫ÜÂØπË±°Ëé∑ÂèñÂ±ûÊÄßÂÄº(get)ÂíåËÆæÁΩÆÂ±ûÊÄßÂÄº(set)„ÄÇ ‰ªÄ‰πàÊòØ DOM Âíå BOMÔºü DOM ÊåáÁöÑÊòØÊñáÊ°£ÂØπË±°Ê®°ÂûãÔºåÂÆÉÊåáÁöÑÊòØÊääÊñáÊ°£ÂΩìÂÅö‰∏Ä‰∏™ÂØπË±°Êù•ÂØπÂæÖÔºåËøô‰∏™ÂØπË±°‰∏ªË¶ÅÂÆö‰πâ‰∫ÜÂ§ÑÁêÜÁΩëÈ°µÂÜÖÂÆπÁöÑÊñπÊ≥ïÂíåÊé•Âè£„ÄÇ BOM ÊåáÁöÑÊòØÊµèËßàÂô®ÂØπË±°Ê®°ÂûãÔºåÂÆÉÊåáÁöÑÊòØÊääÊµèËßàÂô®ÂΩìÂÅö‰∏Ä‰∏™ÂØπË±°Êù•ÂØπÂæÖÔºåËøô‰∏™ÂØπË±°‰∏ªË¶ÅÂÆö‰πâ‰∫Ü‰∏éÊµèËßàÂô®ËøõË°å‰∫§‰∫íÁöÑÊ≥ïÂíåÊé•Âè£„ÄÇBOM ÁöÑÊ†∏ÂøÉÊòØ windowÔºåËÄå window ÂØπË±°ÂÖ∑ÊúâÂèåÈáçËßíËâ≤ÔºåÂÆÉÊó¢ÊòØÈÄöËøá js ËÆøÈóÆÊµèËßàÂô®Á™óÂè£ÁöÑ‰∏Ä‰∏™Êé•Âè£ÔºåÂèàÊòØ‰∏Ä‰∏™ GlobalÔºàÂÖ®Â±ÄÔºâÂØπË±°„ÄÇ Ajax ÊàëÂØπ ajax ÁöÑÁêÜËß£ÊòØÔºåÂÆÉÊòØ‰∏ÄÁßçÂºÇÊ≠•ÈÄö‰ø°ÁöÑÊñπÊ≥ïÔºåÈÄöËøáÁõ¥Êé•Áî± js ËÑöÊú¨ÂêëÊúçÂä°Âô®ÂèëËµ∑ http ÈÄö‰ø°ÔºåÁÑ∂ÂêéÊ†πÊçÆÊúçÂä°Âô®ËøîÂõûÁöÑÊï∞ÊçÆÔºå Êõ¥Êñ∞ÁΩëÈ°µÁöÑÁõ∏Â∫îÈÉ®ÂàÜÔºåËÄå‰∏çÁî®Âà∑Êñ∞Êï¥‰∏™È°µÈù¢ÁöÑ‰∏ÄÁßçÊñπÊ≥ï„ÄÇ","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"JS","slug":"Interview/JS","permalink":"WangHngLeee.github.io/categories/Interview/JS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 2 üí™","slug":"front-end-interview-css","date":"2020-03-04T13:05:35.000Z","updated":"2020-05-19T15:45:51.561Z","comments":true,"path":"2020/03/04/front-end-interview-css/","link":"","permalink":"WangHngLeee.github.io/2020/03/04/front-end-interview-css/","excerpt":"CSS ÁØá ÁõíÊ®°Âûã CSS‰∏≠ÁöÑÁõíÂ≠êÊ®°ÂûãÂåÖÊã¨IEÁõíÂ≠êÊ®°ÂûãÂíåÊ†áÂáÜÁöÑW3CÁõíÂ≠êÊ®°Âûã„ÄÇ box-sizing(Êúâ3‰∏™ÂÄºÂì¶)Ôºöborder-box,padding-box,content-box. Ê†áÂáÜÁöÑÁõíÂ≠êÊ®°ÂûãÔºöwidthÊåácontentÈÉ®ÂàÜÁöÑÂÆΩÂ∫¶ Âú®IEÁõíÂ≠êÊ®°Âûã‰∏≠ÔºöwidthË°®Á§∫content+padding+border Ê†áÂáÜÁõíÂ≠êÊ®°ÂûãÁöÑÁõíÂ≠êÂÆΩÂ∫¶ÔºöÂ∑¶Âè≥border+Â∑¶Âè≥padding+width IEÁõíÂ≠êÊ®°ÂûãÁöÑÁõíÂ≠êÂÆΩÂ∫¶Ôºöwidth flex FlexÊòØFlexible BoxÁöÑÁº©ÂÜôÔºåÊÑè‰∏∫&quot;ÂºπÊÄßÂ∏ÉÂ±Ä&quot;ÔºåÁî®Êù•‰∏∫ÁõíÁä∂Ê®°ÂûãÊèê‰æõÊúÄÂ§ßÁöÑÁÅµÊ¥ªÊÄß„ÄÇ Â∏ÉÂ±ÄÁöÑ‰º†ÁªüËß£ÂÜ≥ÊñπÊ°àÔºåÂü∫‰∫éÁõíÁä∂Ê®°ÂûãÔºå‰æùËµñdisplayÂ±ûÊÄß + positionÂ±ûÊÄß + floatÂ±ûÊÄß„ÄÇ ÂÆπÂô®ÈªòËÆ§Â≠òÂú®‰∏§Ê†πËΩ¥ÔºöÊ∞¥Âπ≥ÁöÑ‰∏ªËΩ¥Ôºàmain axisÔºâÂíåÂûÇÁõ¥ÁöÑ‰∫§ÂèâËΩ¥Ôºàcross axisÔºâ„ÄÇ‰∏ªËΩ¥ÁöÑÂºÄÂßã‰ΩçÁΩÆÔºà‰∏éËæπÊ°ÜÁöÑ‰∫§ÂèâÁÇπÔºâÂè´ÂÅömain startÔºåÁªìÊùü‰ΩçÁΩÆÂè´ÂÅömain endÔºõ‰∫§ÂèâËΩ¥ÁöÑÂºÄÂßã‰ΩçÁΩÆÂè´ÂÅöcross startÔºåÁªìÊùü‰ΩçÁΩÆÂè´ÂÅöcross end„ÄÇÈ°πÁõÆÈªòËÆ§Ê≤ø‰∏ªËΩ¥ÊéíÂàó„ÄÇÂçï‰∏™È°πÁõÆÂç†ÊçÆÁöÑ‰∏ªËΩ¥Á©∫Èó¥Âè´ÂÅömain sizeÔºåÂç†ÊçÆÁöÑ‰∫§ÂèâËΩ¥Á©∫Èó¥Âè´ÂÅöcross size„ÄÇ cssÈÄâÊã©Âô® id ÈÄâÊã©Âô®Ôºåclass ÈÄâÊã©Âô®ÔºåÊ†áÁ≠æÈÄâÊã©Âô®Ôºå‰º™ÂÖÉÁ¥†ÈÄâÊã©Âô®Ôºå‰º™Á±ªÈÄâÊã©Âô®Á≠â Âêå‰∏ÄÂÖÉÁ¥†ÂºïÁî®‰∫ÜÂ§ö‰∏™Ê†∑ÂºèÊó∂ÔºåÊéíÂú®ÂêéÈù¢ÁöÑÊ†∑ÂºèÂ±ûÊÄßÁöÑ‰ºòÂÖàÁ∫ßÈ´òÔºõ Ê†∑ÂºèÈÄâÊã©Âô®ÁöÑÁ±ªÂûã‰∏çÂêåÊó∂Ôºå‰ºòÂÖàÁ∫ßÈ°∫Â∫è‰∏∫Ôºöid ÈÄâÊã©Âô® &gt; class ÈÄâÊã©Âô® &gt; Ê†áÁ≠æÈÄâÊã©Âô®Ôºõ Ê†áÁ≠æ‰πãÈó¥Â≠òÂú®Â±ÇÁ∫ßÂåÖÂê´ÂÖ≥Á≥ªÊó∂ÔºåÂêé‰ª£ÂÖÉÁ¥†‰ºöÁªßÊâøÁ•ñÂÖàÂÖÉÁ¥†ÁöÑÊ†∑Âºè„ÄÇÂ¶ÇÊûúÂêé‰ª£ÂÖÉÁ¥†ÂÆö‰πâ‰∫Ü‰∏éÁ•ñÂÖàÂÖÉÁ¥†Áõ∏ÂêåÁöÑÊ†∑ÂºèÔºåÂàôÁ•ñÂÖàÂÖÉÁ¥†ÁöÑÁõ∏ÂêåÁöÑÊ†∑ÂºèÂ±ûÊÄß‰ºöË¢´Ë¶ÜÁõñ„ÄÇÁªßÊâøÁöÑÊ†∑ÂºèÁöÑ‰ºòÂÖàÁ∫ßÊØîËæÉ‰ΩéÔºåËá≥Â∞ëÊØîÊ†áÁ≠æÈÄâÊã©Âô®ÁöÑ‰ºòÂÖàÁ∫ß‰ΩéÔºõ Â∏¶Êúâ!important Ê†áËÆ∞ÁöÑÊ†∑ÂºèÂ±ûÊÄßÁöÑ‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºõ Ê†∑ÂºèË°®ÁöÑÊù•Ê∫ê‰∏çÂêåÊó∂Ôºå‰ºòÂÖàÁ∫ßÈ°∫Â∫è‰∏∫ÔºöÂÜÖËÅîÊ†∑Âºè&gt; ÂÜÖÈÉ®Ê†∑Âºè &gt; Â§ñÈÉ®Ê†∑Âºè &gt; ÊµèËßàÂô®Áî®Êà∑Ëá™ÂÆö‰πâÊ†∑Âºè &gt; ÊµèËßàÂô®ÈªòËÆ§Ê†∑Âºè","text":"CSS ÁØá ÁõíÊ®°Âûã CSS‰∏≠ÁöÑÁõíÂ≠êÊ®°ÂûãÂåÖÊã¨IEÁõíÂ≠êÊ®°ÂûãÂíåÊ†áÂáÜÁöÑW3CÁõíÂ≠êÊ®°Âûã„ÄÇ box-sizing(Êúâ3‰∏™ÂÄºÂì¶)Ôºöborder-box,padding-box,content-box. Ê†áÂáÜÁöÑÁõíÂ≠êÊ®°ÂûãÔºöwidthÊåácontentÈÉ®ÂàÜÁöÑÂÆΩÂ∫¶ Âú®IEÁõíÂ≠êÊ®°Âûã‰∏≠ÔºöwidthË°®Á§∫content+padding+border Ê†áÂáÜÁõíÂ≠êÊ®°ÂûãÁöÑÁõíÂ≠êÂÆΩÂ∫¶ÔºöÂ∑¶Âè≥border+Â∑¶Âè≥padding+width IEÁõíÂ≠êÊ®°ÂûãÁöÑÁõíÂ≠êÂÆΩÂ∫¶Ôºöwidth flex FlexÊòØFlexible BoxÁöÑÁº©ÂÜôÔºåÊÑè‰∏∫&quot;ÂºπÊÄßÂ∏ÉÂ±Ä&quot;ÔºåÁî®Êù•‰∏∫ÁõíÁä∂Ê®°ÂûãÊèê‰æõÊúÄÂ§ßÁöÑÁÅµÊ¥ªÊÄß„ÄÇ Â∏ÉÂ±ÄÁöÑ‰º†ÁªüËß£ÂÜ≥ÊñπÊ°àÔºåÂü∫‰∫éÁõíÁä∂Ê®°ÂûãÔºå‰æùËµñdisplayÂ±ûÊÄß + positionÂ±ûÊÄß + floatÂ±ûÊÄß„ÄÇ ÂÆπÂô®ÈªòËÆ§Â≠òÂú®‰∏§Ê†πËΩ¥ÔºöÊ∞¥Âπ≥ÁöÑ‰∏ªËΩ¥Ôºàmain axisÔºâÂíåÂûÇÁõ¥ÁöÑ‰∫§ÂèâËΩ¥Ôºàcross axisÔºâ„ÄÇ‰∏ªËΩ¥ÁöÑÂºÄÂßã‰ΩçÁΩÆÔºà‰∏éËæπÊ°ÜÁöÑ‰∫§ÂèâÁÇπÔºâÂè´ÂÅömain startÔºåÁªìÊùü‰ΩçÁΩÆÂè´ÂÅömain endÔºõ‰∫§ÂèâËΩ¥ÁöÑÂºÄÂßã‰ΩçÁΩÆÂè´ÂÅöcross startÔºåÁªìÊùü‰ΩçÁΩÆÂè´ÂÅöcross end„ÄÇÈ°πÁõÆÈªòËÆ§Ê≤ø‰∏ªËΩ¥ÊéíÂàó„ÄÇÂçï‰∏™È°πÁõÆÂç†ÊçÆÁöÑ‰∏ªËΩ¥Á©∫Èó¥Âè´ÂÅömain sizeÔºåÂç†ÊçÆÁöÑ‰∫§ÂèâËΩ¥Á©∫Èó¥Âè´ÂÅöcross size„ÄÇ cssÈÄâÊã©Âô® id ÈÄâÊã©Âô®Ôºåclass ÈÄâÊã©Âô®ÔºåÊ†áÁ≠æÈÄâÊã©Âô®Ôºå‰º™ÂÖÉÁ¥†ÈÄâÊã©Âô®Ôºå‰º™Á±ªÈÄâÊã©Âô®Á≠â Âêå‰∏ÄÂÖÉÁ¥†ÂºïÁî®‰∫ÜÂ§ö‰∏™Ê†∑ÂºèÊó∂ÔºåÊéíÂú®ÂêéÈù¢ÁöÑÊ†∑ÂºèÂ±ûÊÄßÁöÑ‰ºòÂÖàÁ∫ßÈ´òÔºõ Ê†∑ÂºèÈÄâÊã©Âô®ÁöÑÁ±ªÂûã‰∏çÂêåÊó∂Ôºå‰ºòÂÖàÁ∫ßÈ°∫Â∫è‰∏∫Ôºöid ÈÄâÊã©Âô® &gt; class ÈÄâÊã©Âô® &gt; Ê†áÁ≠æÈÄâÊã©Âô®Ôºõ Ê†áÁ≠æ‰πãÈó¥Â≠òÂú®Â±ÇÁ∫ßÂåÖÂê´ÂÖ≥Á≥ªÊó∂ÔºåÂêé‰ª£ÂÖÉÁ¥†‰ºöÁªßÊâøÁ•ñÂÖàÂÖÉÁ¥†ÁöÑÊ†∑Âºè„ÄÇÂ¶ÇÊûúÂêé‰ª£ÂÖÉÁ¥†ÂÆö‰πâ‰∫Ü‰∏éÁ•ñÂÖàÂÖÉÁ¥†Áõ∏ÂêåÁöÑÊ†∑ÂºèÔºåÂàôÁ•ñÂÖàÂÖÉÁ¥†ÁöÑÁõ∏ÂêåÁöÑÊ†∑ÂºèÂ±ûÊÄß‰ºöË¢´Ë¶ÜÁõñ„ÄÇÁªßÊâøÁöÑÊ†∑ÂºèÁöÑ‰ºòÂÖàÁ∫ßÊØîËæÉ‰ΩéÔºåËá≥Â∞ëÊØîÊ†áÁ≠æÈÄâÊã©Âô®ÁöÑ‰ºòÂÖàÁ∫ß‰ΩéÔºõ Â∏¶Êúâ!important Ê†áËÆ∞ÁöÑÊ†∑ÂºèÂ±ûÊÄßÁöÑ‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºõ Ê†∑ÂºèË°®ÁöÑÊù•Ê∫ê‰∏çÂêåÊó∂Ôºå‰ºòÂÖàÁ∫ßÈ°∫Â∫è‰∏∫ÔºöÂÜÖËÅîÊ†∑Âºè&gt; ÂÜÖÈÉ®Ê†∑Âºè &gt; Â§ñÈÉ®Ê†∑Âºè &gt; ÊµèËßàÂô®Áî®Êà∑Ëá™ÂÆö‰πâÊ†∑Âºè &gt; ÊµèËßàÂô®ÈªòËÆ§Ê†∑Âºè BFC BFCÔºåÂùóÁ∫ßÊ†ºÂºèÂåñ‰∏ä‰∏ãÊñáÔºåÁî®‰∫éÊ∏ÖÊ•öÊµÆÂä®ÔºåÈò≤Ê≠¢marginÈáçÂè†Á≠â„ÄÇËøôÊòØ‰∏Ä‰∏™Áã¨Á´ãÁöÑÊ∏≤ÊüìÂå∫ÂüüÔºåËßÑÂÆö‰∫ÜÂÜÖÈÉ®Â¶Ç‰ΩïÂ∏ÉÂ±ÄÔºåÂπ∂‰∏îËøô‰∏™Âå∫ÂüüÁöÑÂ≠êÂÖÉÁ¥†‰∏ç‰ºöÂΩ±ÂìçÂà∞Â§ñÈù¢ÁöÑÂÖÉÁ¥†ÔºåÂÖ∂‰∏≠ÊØîËæÉÈáçË¶ÅÁöÑÂ∏ÉÂ±ÄËßÑÂàôÊúâÂÜÖÈÉ®boxÂûÇÁõ¥ÊîæÁΩÆÔºåËÆ°ÁÆóBFCÁöÑÈ´òÂ∫¶ÁöÑÊó∂ÂÄôÔºåÊµÆÂä®ÂÖÉÁ¥†‰πüÂèÇ‰∏éËÆ°ÁÆóÔºåËß¶ÂèëBFCÁöÑËßÑÂàôÊúâÊ†πÂÖÉÁ¥†ÔºåÊµÆÂä®ÂÖÉÁ¥†Ôºåposition‰∏∫absoluteÊàñfixedÁöÑÂÖÉÁ¥†Ôºådisplay‰∏∫inline-blockÔºåtable-cellÔºåtable-captionÔºåflexÔºåinline-flexÔºåoverflow‰∏ç‰∏∫visibleÁöÑÂÖÉÁ¥† Ê∏ÖÈô§ÊµÆÂä®Ôºö bfcÊ∏ÖÈô§ÊµÆÂä® ÁªôË¶ÅÊ∏ÖÈô§ÊµÆÂä®ÁöÑÂÖÉÁ¥†Ê∑ªÂä†Ê†∑Âºèclear Ôºà clearÁöÑÂéüÁêÜÊòØ‰ΩøÊµÆÂä®ÂÖÉÁ¥†‰∏çÂΩ±ÂìçÂà´ÁöÑÂÖÉÁ¥†ÔºåËÄå‰∏çÊòØÊ∂àÁÅ≠ÊµÆÂä®Ôºâ Áà∂ÂÖÉÁ¥†ÁªìÊùüÊ†áÁ≠æÈí±ÊèíÂÖ•Ê∏ÖÈô§ÊµÆÂä®ÁöÑÂùóÁ∫ßÂÖÉÁ¥†ÔºåÁªôËØ•ÂÖÉÁ¥†Ê∑ªÂä†Ê†∑Âºèclear Ê∑ªÂä†‰º™ÂÖÉÁ¥†ÔºåÂú®Áà∂Á∫ßÂÖÉÁ¥†ÁöÑÊúÄÂêéÔºåÊ∑ªÂä†‰∏Ä‰∏™‰º™ÂÖÉÁ¥†ÔºåÈÄöËøáÊ∏ÖÈô§‰º™ÂÖÉÁ¥†ÁöÑÊµÆÂä®ÔºåÊ≥®ÊÑèËØ•‰º™ÂÖÉÁ¥†ÁöÑdisplay‰∏∫blockÔºå Áà∂ÂÖÉÁ¥†Ê∑ªÂä†Ê†∑ÂºèoverflowÊ∏ÖÈô§ÊµÆÂä®ÔºåoverflowËÆæÁΩÆÈô§visible‰ª•Â§ñÁöÑ‰ªª‰Ωï‰ΩçÁΩÆ Â±ÇÂè†‰∏ä‰∏ãÊñá Â±ÇÂè†‰∏ä‰∏ãÊñáÔºåstacking contextÔºå ÊòØHTML‰∏≠ÁöÑ‰∏Ä‰∏™‰∏âÁª¥ÁöÑÊ¶ÇÂøµ„ÄÇz-index È°∫Â∫èÊ†πÊçÆz-index‰ªéÂ§ßÂà∞Â∞èÊòæÁ§∫ÔºåÈ¶ñÂÖàÁúãÁà∂Á±ªÂÆπÂô®ÁöÑz-index„ÄÇdivÁöÑz-indexÂÜ≥ÂÆö‰∫ÜÂ≠êÂÖÉÁ¥†ÁöÑÊòæÁ§∫È°∫Â∫è„ÄÇ CSS ‰∏≠Âì™‰∫õÂ±ûÊÄßÂèØ‰ª•ÁªßÊâøÔºü ÊØè‰∏Ä‰∏™Â±ûÊÄßÂú®ÂÆö‰πâ‰∏≠ÈÉΩÁªôÂá∫‰∫ÜËøô‰∏™Â±ûÊÄßÊòØÂê¶ÂÖ∑ÊúâÁªßÊâøÊÄßÔºå‰∏Ä‰∏™ÂÖ∑ÊúâÁªßÊâøÊÄßÁöÑÂ±ûÊÄß‰ºöÂú®Ê≤°ÊúâÊåáÂÆöÂÄºÁöÑÊó∂ÂÄôÔºå‰ºö‰ΩøÁî®Áà∂ÂÖÉÁ¥†ÁöÑÂêåÂ±ûÊÄßÁöÑÂÄº Êù•‰Ωú‰∏∫Ëá™Â∑±ÁöÑÂÄº„ÄÇ ‰∏ÄËà¨ÂÖ∑ÊúâÁªßÊâøÊÄßÁöÑÂ±ûÊÄßÊúâÔºåÂ≠ó‰ΩìÁõ∏ÂÖ≥ÁöÑÂ±ûÊÄßÔºåfont-size Âíå font-weight Á≠â„ÄÇÊñáÊú¨Áõ∏ÂÖ≥ÁöÑÂ±ûÊÄßÔºåcolor Âíå text-align Á≠â„ÄÇ Ë°®Ê†ºÁöÑ‰∏Ä‰∫õÂ∏ÉÂ±ÄÂ±ûÊÄß„ÄÅÂàóË°®Â±ûÊÄßÂ¶Ç list-style Á≠â„ÄÇ ËøòÊúâÂÖâÊ†áÂ±ûÊÄß cursor„ÄÅÂÖÉÁ¥†ÂèØËßÅÊÄß visibility „ÄÇ ÂΩì‰∏Ä‰∏™Â±ûÊÄß‰∏çÊòØÁªßÊâøÂ±ûÊÄßÁöÑÊó∂ÂÄôÔºåÊàë‰ª¨‰πüÂèØ‰ª•ÈÄöËøáÂ∞ÜÂÆÉÁöÑÂÄºËÆæÁΩÆ‰∏∫ inherit Êù•‰ΩøÂÆÉ‰ªéÁà∂ÂÖÉÁ¥†ÈÇ£Ëé∑ÂèñÂêåÂêçÁöÑÂ±ûÊÄßÂÄºÊù•ÁªßÊâø„ÄÇ ÂûÇÁõ¥Â±Ö‰∏≠ÈóÆÈ¢òÔºö ÂØπ‰∫éÂÆΩÈ´òÂõ∫ÂÆöÁöÑÂÖÉÁ¥† Ôºà1ÔºâÊàë‰ª¨ÂèØ‰ª•Âà©Áî® margin:0 auto Êù•ÂÆûÁé∞ÂÖÉÁ¥†ÁöÑÊ∞¥Âπ≥Â±Ö‰∏≠„ÄÇ Ôºà2ÔºâÂà©Áî®ÁªùÂØπÂÆö‰ΩçÔºåËÆæÁΩÆÂõõ‰∏™ÊñπÂêëÁöÑÂÄºÈÉΩ‰∏∫0ÔºåÂπ∂Â∞Ü margin ËÆæÁΩÆ‰∏∫ auto ÔºåÁî±‰∫éÂÆΩÈ´òÂõ∫ÂÆöÔºåÂõ†Ê≠§ÂØπÂ∫îÊñπÂêëÂÆûÁé∞Âπ≥ÂàÜÔºåÂèØ‰ª•ÂÆûÁé∞Ê∞¥ Âπ≥ÂíåÂûÇÁõ¥ÊñπÂêë‰∏äÁöÑÂ±Ö‰∏≠„ÄÇ Ôºà3ÔºâÂà©Áî®ÁªùÂØπÂÆö‰ΩçÔºåÂÖàÂ∞ÜÂÖÉÁ¥†ÁöÑÂ∑¶‰∏äËßíÈÄöËøá top: 50% Âíå left: 50% ÂÆö‰ΩçÂà∞È°µÈù¢ÁöÑ‰∏≠ÂøÉÔºåÁÑ∂ÂêéÂÜçÈÄöËøá margin Ë¥üÂÄºÊù•Ë∞ÉÊï¥ÂÖÉÁ¥† ÁöÑ‰∏≠ÂøÉÁÇπÂà∞È°µÈù¢ÁöÑ‰∏≠ÂøÉ„ÄÇ Ôºà4ÔºâÂà©Áî®ÁªùÂØπÂÆö‰ΩçÔºåÂÖàÂ∞ÜÂÖÉÁ¥†ÁöÑÂ∑¶‰∏äËßíÈÄöËøá top: 50% Âíå left: 50% ÂÆö‰ΩçÂà∞È°µÈù¢ÁöÑ‰∏≠ÂøÉÔºåÁÑ∂ÂêéÂÜçÈÄöËøá translate Êù•Ë∞ÉÊï¥ÂÖÉÁ¥† ÁöÑ‰∏≠ÂøÉÁÇπÂà∞È°µÈù¢ÁöÑ‰∏≠ÂøÉ„ÄÇ Ôºà5Ôºâ‰ΩøÁî® flex Â∏ÉÂ±ÄÔºåÈÄöËøá align-items: center Âíå justify-content: center ËÆæÁΩÆÂÆπÂô®ÁöÑÂûÇÁõ¥ÂíåÊ∞¥Âπ≥ÊñπÂêë‰∏ä‰∏∫Â±Ö‰∏≠ÂØπ ÈΩêÔºåÁÑ∂ÂêéÂÆÉÁöÑÂ≠êÂÖÉÁ¥†‰πüÂèØ‰ª•ÂÆûÁé∞ÂûÇÁõ¥ÂíåÊ∞¥Âπ≥ÁöÑÂ±Ö‰∏≠„ÄÇ ÂØπ‰∫éÂÆΩÈ´ò‰∏çÂÆöÁöÑÂÖÉÁ¥†Ôºå‰∏äÈù¢ÁöÑÂêéÈù¢‰∏§ÁßçÊñπÊ≥ïÔºåÂèØ‰ª•ÂÆûÁé∞ÂÖÉÁ¥†ÁöÑÂûÇÁõ¥ÂíåÊ∞¥Âπ≥ÁöÑÂ±Ö‰∏≠„ÄÇ CSS positionÁßçÁ±ª&amp;Â±ûÊÄßÔºü Âõ∫ÂÆöÂÆö‰ΩçfixedÔºöÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆÁõ∏ÂØπ‰∫éÊµèËßàÂô®Á™óÂè£ÊòØÂõ∫ÂÆö‰ΩçÁΩÆÔºåÂç≥‰ΩøÁ™óÂè£ÊòØÊªöÂä®ÁöÑÂÆÉ‰πü‰∏ç‰ºöÁßªÂä®„ÄÇFixedÂÆö‰Ωç‰ΩøÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆ‰∏éÊñáÊ°£ÊµÅÊó†ÂÖ≥ÔºåÂõ†Ê≠§‰∏çÂç†ÊçÆÁ©∫Èó¥„ÄÇ FixedÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÂíåÂÖ∂‰ªñÂÖÉÁ¥†ÈáçÂè†„ÄÇ Áõ∏ÂØπÂÆö‰ΩçrelativeÔºöÂ¶ÇÊûúÂØπ‰∏Ä‰∏™ÂÖÉÁ¥†ËøõË°åÁõ∏ÂØπÂÆö‰ΩçÔºåÂÆÉÂ∞ÜÂá∫Áé∞Âú®ÂÆÉÊâÄÂú®ÁöÑ‰ΩçÁΩÆ‰∏ä„ÄÇÁÑ∂ÂêéÔºåÂèØ‰ª•ÈÄöËøáËÆæÁΩÆÂûÇÁõ¥ÊàñÊ∞¥Âπ≥‰ΩçÁΩÆÔºåËÆ©Ëøô‰∏™ÂÖÉÁ¥†‚ÄúÁõ∏ÂØπ‰∫é‚ÄùÂÆÉÁöÑËµ∑ÁÇπËøõË°åÁßªÂä®„ÄÇ Âú®‰ΩøÁî®Áõ∏ÂØπÂÆö‰ΩçÊó∂ÔºåÊó†ËÆ∫ÊòØÂê¶ËøõË°åÁßªÂä®ÔºåÂÖÉÁ¥†‰ªçÁÑ∂Âç†ÊçÆÂéüÊù•ÁöÑÁ©∫Èó¥„ÄÇÂõ†Ê≠§ÔºåÁßªÂä®ÂÖÉÁ¥†‰ºöÂØºËá¥ÂÆÉË¶ÜÁõñÂÖ∂ÂÆÉÊ°Ü„ÄÇ ÁªùÂØπÂÆö‰ΩçabsoluteÔºöÁªùÂØπÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆÁõ∏ÂØπ‰∫éÊúÄËøëÁöÑÂ∑≤ÂÆö‰ΩçÁà∂ÂÖÉÁ¥†ÔºåÂ¶ÇÊûúÂÖÉÁ¥†Ê≤°ÊúâÂ∑≤ÂÆö‰ΩçÁöÑÁà∂ÂÖÉÁ¥†ÔºåÈÇ£‰πàÂÆÉÁöÑ‰ΩçÁΩÆÁõ∏ÂØπ‰∫é„ÄÇ absolute ÂÆö‰Ωç‰ΩøÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆ‰∏éÊñáÊ°£ÊµÅÊó†ÂÖ≥ÔºåÂõ†Ê≠§‰∏çÂç†ÊçÆÁ©∫Èó¥„ÄÇ absolute ÂÆö‰ΩçÁöÑÂÖÉÁ¥†ÂíåÂÖ∂‰ªñÂÖÉÁ¥†ÈáçÂè†„ÄÇ Á≤òÊÄßÂÆö‰ΩçstickyÔºöÂÖÉÁ¥†ÂÖàÊåâÁÖßÊôÆÈÄöÊñáÊ°£ÊµÅÂÆö‰ΩçÔºåÁÑ∂ÂêéÁõ∏ÂØπ‰∫éËØ•ÂÖÉÁ¥†Âú®ÊµÅ‰∏≠ÁöÑflow rootÔºàBFCÔºâÂíå containing blockÔºàÊúÄËøëÁöÑÂùóÁ∫ßÁ•ñÂÖàÂÖÉÁ¥†ÔºâÂÆö‰Ωç„ÄÇËÄåÂêéÔºåÂÖÉÁ¥†ÂÆö‰ΩçË°®Áé∞‰∏∫Âú®Ë∑®Ë∂äÁâπÂÆöÈòàÂÄºÂâç‰∏∫Áõ∏ÂØπÂÆö‰ΩçÔºå‰πãÂêé‰∏∫Âõ∫ÂÆöÂÆö‰Ωç„ÄÇ ÈªòËÆ§ÂÆö‰ΩçStaticÔºöÈªòËÆ§ÂÄº„ÄÇÊ≤°ÊúâÂÆö‰ΩçÔºåÂÖÉÁ¥†Âá∫Áé∞Âú®Ê≠£Â∏∏ÁöÑÊµÅ‰∏≠ÔºàÂøΩÁï•top, bottom, left, right ÊàñËÄÖ z-index Â£∞ÊòéÔºâ„ÄÇ inherit:ËßÑÂÆöÂ∫îËØ•‰ªéÁà∂ÂÖÉÁ¥†ÁªßÊâøposition Â±ûÊÄßÁöÑÂÄº„ÄÇ Â∏∏ËßÅÈ°µÈù¢Â∏ÉÂ±Ä ‰º†ÁªüÁõíÊ®°ÂûãÂ∏ÉÂ±ÄÔºöÊñáÊ°£ÊµÅÂ∏ÉÂ±ÄÔºåÊµÆÂä®Â∏ÉÂ±ÄÔºåÂÆö‰ΩçÂ∏ÉÂ±Ä ÂºπÊÄßÁõíÂ≠êflexÂ∏ÉÂ±ÄÔºö GridÁΩëÊ†ºÂ∏ÉÂ±Ä Âú£ÊùØÔºàÂ§öÂàóÔºâÂ∏ÉÂ±Ä ÂèåÈ£ûÁøºÂ∏ÉÂ±Ä ÂìçÂ∫îÂºèÂ∏ÉÂ±Ä 1.Â™í‰ΩìÊü•ËØ¢ÔºöCSS3Â™í‰ΩìÊü•ËØ¢ÂèØ‰ª•ËÆ©Êàë‰ª¨ÈíàÂØπ‰∏çÂêåÁöÑÂ™í‰ΩìÁ±ªÂûãÂÆö‰πâ‰∏çÂêåÁöÑÊ†∑ÂºèÔºåÂΩìÈáçÁΩÆÊµèËßàÂô®Á™óÂè£Â§ßÂ∞èÁöÑËøáÁ®ã‰∏≠ÔºåÈ°µÈù¢‰πü‰ºöÊ†πÊçÆÊµèËßàÂô®ÁöÑÂÆΩÂ∫¶ÂíåÈ´òÂ∫¶ÈáçÊñ∞Ê∏≤ÊüìÈ°µÈù¢„ÄÇ 2.ÁôæÂàÜÊØîÂ∏ÉÂ±ÄÔºöÈÄöËøáÁôæÂàÜÊØîÂçï‰ΩçÔºåÂèØ‰ª•‰ΩøÂæóÊµèËßàÂô®‰∏≠ÁªÑ‰ª∂ÁöÑÂÆΩÂíåÈ´òÈöèÁùÄÊµèËßàÂô®ÁöÑÈ´òÂ∫¶ÁöÑÂèòÂåñËÄåÂèòÂåñÔºå‰ªéËÄåÂÆûÁé∞ÂìçÂ∫îÂºèÁöÑÊïàÊûú 3.remÂ∏ÉÂ±ÄÔºöremÂçï‰ΩçÈÉΩÊòØÁõ∏ÂØπ‰∫éÊ†πÂÖÉÁ¥†htmlÁöÑfont-sizeÊù•ÂÜ≥ÂÆöÂ§ßÂ∞èÁöÑ„ÄÇÈÄöËøáremÊù•ÂÆûÁé∞ÂìçÂ∫îÂºèÁöÑÂ∏ÉÂ±ÄÔºåÂè™ÈúÄË¶ÅÊ†πÊçÆËßÜÂõæÂÆπÂô®ÁöÑÂ§ßÂ∞èÔºåÂä®ÊÄÅÁöÑÊîπÂèòfont-sizeÂç≥ÂèØ 4.ËßÜÂè£Âçï‰Ωç 5.ÂõæÁâáÂìçÂ∫îÂºèÔºö Â§ßÂ∞èËá™ÈÄÇÂ∫î ÔΩúÔΩú Ê†πÊçÆÂàÜËæ®ÁéáÂ∞ΩÂèØËÉΩÈÄâÊã©ÂàÜËæ®ÁéáÈ´òÁöÑÂõæÁâá„ÄÇ cssÈ¢ÑÂ§ÑÁêÜÔºåÂêéÂ§ÑÁêÜ È¢ÑÂ§ÑÁêÜÔºöÂπø‰πâ‰∏äËØ¥ÔºåÁõÆÊ†áÊ†ºÂºè‰∏∫ CSS ÁöÑ È¢ÑÂ§ÑÁêÜÂô® ÊòØ CSS È¢ÑÂ§ÑÁêÜÂô®Ôºå‰ΩÜÊú¨Êñá ÁâπÊåá ‰ª•ÊúÄÁªàÁîüÊàê CSS ‰∏∫ÁõÆÁöÑÁöÑ È¢ÜÂüüÁâπÂÆöËØ≠Ë®Ä„ÄÇSass„ÄÅLESS„ÄÅStylus ÊòØÁõÆÂâçÊúÄ‰∏ªÊµÅÁöÑ CSS È¢ÑÂ§ÑÁêÜÂô®„ÄÇ ÂÆûÁé∞ÂéüÁêÜÔºöÂèñÂà∞ DSL Ê∫ê‰ª£Á†Å ÁöÑ ÂàÜÊûêÊ†ëÔºåÂ∞ÜÂê´Êúâ Âä®ÊÄÅÁîüÊàê Áõ∏ÂÖ≥ËäÇÁÇπÁöÑ ÂàÜÊûêÊ†ë ËΩ¨Êç¢‰∏∫ ÈùôÊÄÅÂàÜÊûêÊ†ëÔºåÂ∞Ü ÈùôÊÄÅÂàÜÊûêÊ†ë ËΩ¨Êç¢‰∏∫ CSS ÁöÑ ÈùôÊÄÅÂàÜÊûêÊ†ëÔºåÂ∞Ü CSS ÁöÑ ÈùôÊÄÅÂàÜÊûêÊ†ë ËΩ¨Êç¢‰∏∫ CSS ‰ª£Á†Å ÂêéÂ§ÑÁêÜÔºöÂØπ CSS ËøõË°åÂ§ÑÁêÜÔºåÂπ∂ÊúÄÁªàÁîüÊàê CSS ÁöÑ È¢ÑÂ§ÑÁêÜÂô®ÔºåÂÆÉÂ±û‰∫éÂπø‰πâ‰∏äÁöÑ CSS È¢ÑÂ§ÑÁêÜÂô®„ÄÇ CSS ÂéãÁº©Â∑•ÂÖ∑ÔºàÂ¶Ç clean-cssÔºâ ÂÆûÁé∞ÂéüÁêÜÔºöÂ∞Ü Ê∫ê‰ª£Á†Å ÂÅö‰∏∫ CSS Ëß£ÊûêÔºåËé∑ÂæóÂàÜÊûêÊ†ëÔºåÂØπCSSÁöÑÂàÜÊûêÊ†ëËøõË°åÂêéÂ§ÑÁêÜÔºå css3Êñ∞ÁâπÊÄß Transition:ÂèØ‰ª•Âú®ÂΩìÂÖÉÁ¥†‰ªé‰∏ÄÁßçÊ†∑ÂºèÂèòÊç¢‰∏∫Âè¶‰∏ÄÁßçÊ†∑ÂºèÊó∂‰∏∫ÂÖÉÁ¥†Ê∑ªÂä†ÊïàÊûúÔºåËÄå‰∏çÁî®‰ΩøÁî®FlashÂä®ÁîªÊàñJavaScript TransformÔºöTransformÁî®Êù•ÂêëÂÖÉÁ¥†Â∫îÁî®ÂêÑÁßç2DÂíå3DËΩ¨Êç¢ÔºåËØ•Â±ûÊÄßÂÖÅËÆ∏Êàë‰ª¨ÂØπÂÖÉÁ¥†ËøõË°åÊóãËΩ¨„ÄÅÁº©Êîæ„ÄÅÁßªÂä®ÊàñÂÄæÊñúÁ≠â AnimationÔºöAnimationËÆ©CSSÊã•Êúâ‰∫ÜÂèØ‰ª•Âà∂‰ΩúÂä®ÁîªÁöÑÂäüËÉΩ„ÄÇ‰ΩøÁî®AnimationÂà∂‰ΩúÂä®ÁîªÂèØ‰ª•ÁúÅÂéªÂ§çÊùÇÁöÑjs‰ª£Á†Å displayÂì™‰∫õÂèñÂÄº noneÔºöÈöêËóèÔºå‰∏ç‰ºöÂç†Áî®ÊñáÊ°£ÊµÅ‰ΩçÁΩÆÔºàÂÖ∂‰ªñÂÖÉÁ¥†‰ºöÂç†Áî®‰ªñÁöÑ‰ΩçÁΩÆÔºâ inlineÔºöË°åÂÜÖÂÖÉÁ¥† inline-blockÔºöË°åÂÜÖÂùóÂÖÉÁ¥†Ôºå‰πüÂç≥ÊúâÂùóÂÖÉÁ¥†ÁöÑ‰∏Ä‰∫õÁâπÊÄßÔºåÂèØ‰ª•ËÆæÁΩÆÂÆΩÈ´òÂ∫¶ËæπË∑ùÁ≠âÁ≠â„ÄÇ blockÔºöÂùóÂÖÉÁ¥†ÔºåÁã¨Âç†‰∏ÄË°åÔºåÂèØ‰ª•ËÆæÁΩÆÂÆΩÈ´òËæπË∑ùÁ≠âÁ≠â„ÄÇ tableÔºöÁõ∏ÂÖ≥Ôºå‰ºóÊâÄÂë®Áü•tableÂüüÊúâ‰∏Ä‰∫õÁâπÂÆöÁöÑÊ†áÁ≠æÔºötable„ÄÅtr„ÄÅth„ÄÅtd„ÄÅtfootÁ≠âÁ≠â„ÄÇÈÇ£‰πàÂèØ‰ª•Áî®divÁ≠âÂÖÉÁ¥†ÁöÑÊù•ÂÆûÁé∞ÂêóÔºüÂèØ‰ª•ÔºåÂ∞ÜËøô‰∫õÂÖÉÁ¥†ÁöÑdisplayËÆæÁΩÆÊàêtable-*Â∞±Ë°å„ÄÇ inheritÔºöÂç≥ÁªßÊâø„ÄÇ Áõ∏ÈÇªÁöÑ‰∏§‰∏™inline-blockËäÇÁÇπ‰∏∫‰ªÄ‰πà‰ºöÂá∫Áé∞Èó¥ÈöîÔºåËØ•Â¶Ç‰ΩïËß£ÂÜ≥ ‰∏§‰∏™In line block ËäÇÁÇπ‰πãÈó¥ÊúâÁ©∫ÈöôÂéüÂõ†ÔºöËã±ÊñáÊúâÁ©∫Ê†º‰Ωú‰∏∫ËØçÂàÜÁïåÔºåËÄå‰∏≠ÊñáÂàôÊ≤°Êúâ„ÄÇÔºàËøôËÉåÂêéÂª∂‰º∏Âá∫‰∏Ä‰∏™‰∏≠ÊñáÂàÜËØçÁöÑÈóÆÈ¢òÔºâËøô‰∏™ÈóÆÈ¢òÁöÑÂéüÂõ†ÂèØ‰ª•‰∏äËø∞Âà∞SGML(Ê†áÂáÜÈÄöÁî®Ê†áËÆ∞ËØ≠Ë®Ä)ÂíåTeX(ÊéíÁâàÂ∑•ÂÖ∑)ÔºåÂÆÉÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™Ë°åÂÜÖÔºàinlineÔºâÁöÑÈóÆÈ¢òÔºåÂÆÉÁî±Á©∫Ê†º„ÄÅÊç¢Ë°åÊàñÂõûËΩ¶ÊâÄ‰∫ßÁîüÁ©∫ÁôΩÁ¨¶ÊâÄËá¥ ÊñπÊ≥ï1. ÊîπÂèò‰π¶ÂÜôÊñπÂºè ÂéªÊéâhtml‰∏≠ÁöÑÁ©∫Ê†ºÔºåÊàñËÄÖÊéíÂàóÂú®‰∏ÄË°åÔºå‰ΩÜÊòØÂèØËØªÊÄßÂ∑Æ ÊñπÊ≥ï2Ôºöfont-size ÊñπÊ≥ï3Ôºö‰ΩøÁî®marginË¥üÂÄº ÊñπÊ≥ï4Ôºö‰ΩøÁî®word-spacingÊàñletter-spacing meta viewport ÁßªÂä®Á´ØÈÄÇÈÖç ÊâÄÂÅöÁöÑÈÄÇÈÖçÔºåÂ∞±ÊòØË¶ÅË∞ÉÊï¥layout viewportÁöÑÂ§ßÂ∞èÔºåËÄåÁî®metaÊ†áÁ≠æÂ∞±ÂèØ‰ª•Ë∞ÉÊï¥layout viewportÁöÑÂ§ßÂ∞è„ÄÇ remÂ∏ÉÂ±ÄÁöÑ‰ºòÁº∫ÁÇπ remÂèØ‰ª•ËÆ©Êàë‰ª¨ÁöÑÈ°µÈù¢Êõ¥ÁÅµÊ¥ªÔºåÊõ¥ÂÅ•Â£ÆÔºåÊØîËµ∑Âà∞Â§ÑÂÜôÊ≠ªÁöÑpxÂÄºÔºåem‰ºº‰πéÊõ¥ÊúâÂº†ÂäõÔºåÊîπÂä®Áà∂ÂÖÉÁ¥†ÁöÑÂ≠ó‰ΩìÂ§ßÂ∞èÔºåÂ≠êÂÖÉÁ¥†‰ºöÁ≠âÊØî‰æãÂèòÂåñÔºåËøô‰∏ÄÂèòÂåñ‰ºº‰πéÈ¢ÑÁ§∫‰∫ÜÊó†ÈôêÂèØËÉΩ remÊòØÂºπÊÄßÂ∏ÉÂ±ÄÁöÑ‰∏ÄÁßçÔºåÂºπÊÄßÂ∏ÉÂ±ÄÊòØÂìçÂ∫îÂºèÂ∏ÉÂ±ÄÁöÑ‰∏ÄÁßçÔºå‰ΩÜÊòØÂìçÂ∫îÂºèÂ∏ÉÂ±Ä‰∏çÊòØÂºπÊÄßÂ∏ÉÂ±Ä„ÄÇÂºπÊÄßÂ∏ÉÂ±ÄÂº∫Ë∞ÉÁ≠âÊØîÁº©ÊîæÔºåÂº∫Ë∞ÉÁôæÂàÜÁôæËøòÂéüÔºåÂìçÂ∫îÂºèÂ∏ÉÂ±ÄÂº∫Ë∞É‰∏çÂêåËÆæÂ§áÊúâ‰∏çÂêåÁöÑÂ±ïÁé∞„ÄÇ RemËøá‰∫éÊ≠ªÊùøÔºåÂìçÂ∫îÂºèÂ∏ÉÂ±ÄÂèØ‰ª•Â§öËÆæÂ§áËá™ÈÄÇÂ∫îÔºå linkÊ†áÁ≠æÂíåimportÊ†áÁ≠æÁöÑÂå∫Âà´Ôºö linkÂ±û‰∫éhtmlÊ†áÁ≠æÔºåËÄå@importÊòØcssÊèê‰æõÁöÑ È°µÈù¢Ë¢´Âä†ËΩΩÊó∂Ôºålink‰ºöÂêåÊó∂Ë¢´Âä†ËΩΩÔºåËÄå@importÂºïÁî®ÁöÑcss‰ºöÁ≠âÂà∞È°µÈù¢Âä†ËΩΩÁªìÊùüÂêéÂä†ËΩΩ„ÄÇ linkÊòØhtmlÊ†áÁ≠æÔºåÂõ†Ê≠§Ê≤°ÊúâÂÖºÂÆπÊÄßÔºåËÄå@importÂè™ÊúâIE5‰ª•‰∏äÊâçËÉΩËØÜÂà´„ÄÇ linkÊñπÂºèÊ†∑ÂºèÁöÑÊùÉÈáçÈ´ò‰∫é@importÁöÑ„ÄÇ 1ÂÉèÁ¥†ËæπÊ°ÜÈóÆÈ¢òÔºö 1Ôºâborder-image ÂõæÁâá ÂÆûÁé∞ Áº∫ÁÇπÊòØÂà∂‰ΩúÂõæÁâáÁöÑÂúÜËßíÊó∂ÂÄô‰ºöÂá∫Áé∞Ê®°Á≥ä„ÄÇ .border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(\"image_url\") 2 0 stretch;&#125; background-image Ê∏êÂèòÂÆûÁé∞ Èô§Âï¶Áî®ÂõæÁâáÔºåÈöæÈÅìÁ∫ØÁ≤πÁöÑcssÂ∞±‰∏çËÉΩÂÆûÁé∞ÂêóÔºüÊàëÁöÑÁ°Æ‰∏çÊÉ≥‰ΩøÁî®ÂõæÁâáÔºåÊÑüËßâÂà∂‰ΩúËµ∑Êù•ÂæàÈ∫ªÁÉ¶ÔºåÂÖ∂ÂÆûÁôæÂ∫¶Á≥ØÁ±≥Âõ¢È¶ñÈ°µÂ∞±ÊòØËøô‰πàÂÅöÁöÑ‰ΩÜÊòØËøôÁßçÊñπÊ≥ïÊúâ‰∏™Áº∫ÁÇπÔºåÂ∞±ÊòØ‰∏çËÉΩÂÆûÁé∞ÂúÜËßí .border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; &#125; viewport+remÂÆûÁé∞ box-shadow ÂÆûÁé∞ Âà©Áî®Èò¥ÂΩ±Êàë‰ª¨‰πüÂèØ‰ª•ÂÆûÁé∞ÔºåÈÇ£‰πàÊàë‰ª¨Êù•ÁúãÁúãÈò¥ÂΩ±Ôºå‰ºòÁÇπÊòØÂúÜËßí‰∏çÊòØÈóÆÈ¢òÔºåÁº∫ÁÇπÊòØÈ¢úËâ≤‰∏çÂ•ΩÊéßÂà∂„ÄÇ div&#123; -webkit-box-shadow:0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; transform: scale(0.5) ÂÆûÁé∞ Êé®ËçêÁõ∏ÂΩìÁÅµÊ¥ª ÂÖ∂ÂÆûÊàë‰ª¨ÂàöÊâçÂàó‰∏æ‰∫ÜÈÇ£‰πàÂ§ö‰æãÂ≠êÔºåÊó†ÈùûÂ∞±ÊòØÊää1pxÁº©ÊîæÈÉΩ0.5pxÁöÑÁä∂ÊÄÅ‰∏ãÔºåËÄå0.5pxÂπ∂‰∏çÊòØÊâÄÊúâÈÉΩÊîØÊåÅÔºåÂÜçÊ†πÊçÆÂ™í‰ΩìÊü•ËØ¢ËÆæÁΩÆ‰∏çÂêåÁöÑÁº©ÊîæÊØî‰æãÂ∞±ÂèØ‰ª•‰∫ÜÔºåÈÇ£‰πàÊàë‰ª¨Â∞±ÂºÄÂßãÁé©ÂÑøÁº©ÊîæÂêß„ÄÇ 1.Áî®heightÔºö1pxÁöÑdivÔºåÁÑ∂ÂêéÊ†πÊçÆÂ™í‰ΩìÊü•ËØ¢ËÆæÁΩÆtransform: scaleY(0.5);Ôºå div&#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; 2.Áî®::afterÂíå::befor,ËÆæÁΩÆborder-bottomÔºö1px solid #000,ÁÑ∂ÂêéÂú®Áº©Êîæ-webkit-transform: scaleY(0.5);ÂèØ‰ª•ÂÆûÁé∞‰∏§Ê†πËæπÁ∫øÁöÑÈúÄÊ±Ç div::after&#123; content:'';width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125; 3.Áî®::afterËÆæÁΩÆborderÔºö1px solid #000; width:200%; height:200%,ÁÑ∂ÂêéÂÜçÁº©ÊîæscaleY(0.5); ‰ºòÁÇπÂèØ‰ª•ÂÆûÁé∞ÂúÜËßíÔºå‰∫¨‰∏úÂ∞±ÊòØËøô‰πàÂÆûÁé∞ÁöÑÔºåÁº∫ÁÇπÊòØÊåâÈíÆÊ∑ªÂä†activeÊØîËæÉÈ∫ªÁÉ¶„ÄÇ .div::after &#123; content: ''; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125;","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Front-end Interview Note 1 üí™","slug":"frontent-interview-html","date":"2020-03-04T13:05:35.000Z","updated":"2020-05-19T15:46:03.506Z","comments":true,"path":"2020/03/04/frontent-interview-html/","link":"","permalink":"WangHngLeee.github.io/2020/03/04/frontent-interview-html/","excerpt":"HTMLÁØá ËØ≠‰πâÂåñ HTML5ËØ≠‰πâÂåñÊ†áÁ≠æÊòØÊåáÊ≠£Á°ÆÁöÑÊ†áÁ≠æÂåÖÂê´‰∫ÜÊ≠£Á°ÆÁöÑÂÜÖÂÆπÔºåÁªìÊûÑËâØÂ•ΩÔºå‰æø‰∫éÈòÖËØªÔºåÊØîÂ¶ÇnavË°®Á§∫ÂØºËà™Êù°ÔºåÁ±ª‰ººÁöÑËøòÊúâarticle„ÄÅheader„ÄÅfooterÁ≠âÁ≠âÊ†áÁ≠æ„ÄÇ ÁßªÂä®ËÆæÂ§áÂøΩÁï•Â∞ÜÈ°µÈù¢‰∏≠ÁöÑÊï∞Â≠óËØÜÂà´‰∏∫ÁîµËØùÂè∑Á†ÅÁöÑÊñπÊ≥ï Â¶ÇÊûúÂøΩÁï•È°µÈù¢‰∏≠ÁöÑÊï∞Â≠óËØÜÂà´‰∏∫ÁîµËØùÂè∑Á†Å, Âè™Ë¶ÅÊääËøô‰∏™ÈªòËÆ§Ë°å‰∏∫ÂÖ≥Èó≠Â∞±Ë°åÔºåÂè™Ë¶Å‰∏ÄË°å‰ª£Á†Å: &lt;meta name = \"format-detection\" content = \"telephone=no\"&gt; http vs https : ÂÆö‰πâÔºö http: Ë∂ÖÊñáÊú¨‰º†ËæìÂçèËÆÆÔºåÊòØ‰∫íËÅîÁΩë‰∏äÂ∫îÁî®ÊúÄ‰∏∫ÂπøÊ≥õÁöÑ‰∏ÄÁßçÁΩëÁªúÂçèËÆÆÔºåÊòØ‰∏Ä‰∏™ÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Âô®Á´ØËØ∑Ê±ÇÂíåÂ∫îÁ≠îÁöÑÊ†áÂáÜÔºàTCPÔºâÔºåÁî®‰∫é‰ªéWWWÊúçÂä°Âô®‰º†ËæìË∂ÖÊñáÊú¨Âà∞Êú¨Âú∞ÊµèËßàÂô®ÁöÑ‰º†ËæìÂçèËÆÆÔºåÂÆÉÂèØ‰ª•‰ΩøÊµèËßàÂô®Êõ¥Âä†È´òÊïàÔºå‰ΩøÁΩëÁªú‰º†ËæìÂáèÂ∞ë„ÄÇ https: ÊòØ‰ª•ÂÆâÂÖ®‰∏∫ÁõÆÊ†áÁöÑHTTPÈÄöÈÅìÔºåÁÆÄÂçïËÆ≤ÊòØHTTPÁöÑÂÆâÂÖ®ÁâàÔºåÂç≥HTTP‰∏ãÂä†ÂÖ•SSLÂ±ÇÔºåHTTPSÁöÑÂÆâÂÖ®Âü∫Á°ÄÊòØSSLÔºåÂõ†Ê≠§Âä†ÂØÜÁöÑËØ¶ÁªÜÂÜÖÂÆπÂ∞±ÈúÄË¶ÅSSL„ÄÇ Âå∫Âà´Ôºö HttpsÂçèËÆÆÈúÄË¶ÅcaËØÅ‰π¶ÔºåË¥πÁî®ËæÉÈ´ò„ÄÇ httpÊòØË∂ÖÊñáÊú¨‰º†ËæìÂçèËÆÆÔºå‰ø°ÊÅØÊòØÊòéÊñá‰º†ËæìÔºåhttpsÂàôÊòØÂÖ∑ÊúâÂÆâÂÖ®ÊÄßÁöÑsslÂä†ÂØÜ‰º†ËæìÂçèËÆÆ„ÄÇ ‰ΩøÁî®‰∏çÂêåÁöÑÈìæÊé•ÊñπÂºèÔºåÁ´ØÂè£‰πü‰∏çÂêåÔºå‰∏ÄËà¨ËÄåË®ÄÔºåhttpÂçèËÆÆÁöÑÁ´ØÂè£‰∏∫80ÔºåhttpsÁöÑÁ´ØÂè£‰∏∫443 httpÁöÑËøûÊé•ÂæàÁÆÄÂçïÔºåÊòØÊó†Áä∂ÊÄÅÁöÑÔºõHTTPSÂçèËÆÆÊòØÁî±SSL+HTTPÂçèËÆÆÊûÑÂª∫ÁöÑÂèØËøõË°åÂä†ÂØÜ‰º†Ëæì„ÄÅË∫´‰ªΩËÆ§ËØÅÁöÑÁΩëÁªúÂçèËÆÆÔºåÊØîhttpÂçèËÆÆÂÆâÂÖ®„ÄÇ websocket WebSocketÊòØHTML5‰∏≠ÁöÑÂçèËÆÆÔºåÊîØÊåÅÊåÅ‰πÖËøûÁª≠ÔºåhttpÂçèËÆÆ‰∏çÊîØÊåÅÊåÅ‰πÖÊÄßËøûÊé•„ÄÇHttp1.0ÂíåHTTP1.1ÈÉΩ‰∏çÊîØÊåÅÊåÅ‰πÖÊÄßÁöÑÈìæÊé•ÔºåHTTP1.1‰∏≠ÁöÑkeep-aliveÔºåÂ∞ÜÂ§ö‰∏™httpËØ∑Ê±ÇÂêàÂπ∂‰∏∫1‰∏™ Cookie„ÄÅsessionStorage„ÄÅlocalStorageÁöÑÂå∫Âà´ ÂÖ±ÂêåÁÇπÔºöÈÉΩÊòØ‰øùÂ≠òÂú®ÊµèËßàÂô®Á´ØÔºåÂπ∂‰∏îÊòØÂêåÊ∫êÁöÑ cookieÊï∞ÊçÆÂßãÁªàÂú®ÂêåÊ∫êÁöÑhttpËØ∑Ê±Ç‰∏≠Êê∫Â∏¶(Âç≥‰Ωø‰∏çÈúÄË¶Å)ÔºåÂç≥cookieÂú®ÊµèËßàÂô®ÂíåÊúçÂä°Âô®Èó¥Êù•Âõû‰º†ÈÄí cookieÊï∞ÊçÆËøòÊúâË∑ØÂæÑÔºàpathÔºâÁöÑÊ¶ÇÂøµÔºåÂèØ‰ª•ÈôêÂà∂„ÄÇcookieÂè™Â±û‰∫éÊüê‰∏™Ë∑ØÂæÑ‰∏ã Â≠òÂÇ®Â§ßÂ∞èÈôêÂà∂‰πü‰∏çÂêå‚ÄìcookieÊï∞ÊçÆ‰∏çËÉΩË∂ÖËøá4KÔºåÂêåÊó∂Âõ†‰∏∫ÊØèÊ¨°httpËØ∑Ê±ÇÈÉΩ‰ºöÊê∫Â∏¶cookieÔºåÊâÄ‰ª•cookieÂè™ÈÄÇÂêà‰øùÂ≠òÂæàÂ∞èÁöÑÊï∞ÊçÆÔºåÂ¶ÇÂõûËØùÊ†áËØÜ„ÄÇ webStorageËôΩÁÑ∂‰πüÊúâÂ≠òÂÇ®Â§ßÂ∞èÁöÑÈôêÂà∂Ôºå‰ΩÜÊòØÊØîcookieÂ§ßÂæóÂ§öÔºåÂèØ‰ª•ËææÂà∞5MÊàñÊõ¥Â§ß Êï∞ÊçÆÁöÑÊúâÊïàÊúü‰∏çÂêå --sessionStorageÔºö‰ªÖÂú®ÂΩìÂâçÁöÑÊµèËßàÂô®Á™óÂè£ÂÖ≥Èó≠ÊúâÊïàÔºõlocalStorageÔºöÂßãÁªàÊúâÊïàÔºåÁ™óÂè£ÊàñÊµèËßàÂô®ÂÖ≥Èó≠‰πü‰∏ÄÁõ¥‰øùÂ≠òÔºåÂõ†Ê≠§Áî®‰ΩúÊåÅ‰πÖÊï∞ÊçÆÔºõcookieÔºöÂè™Âú®ËÆæÁΩÆÁöÑcookieËøáÊúüÊó∂Èó¥‰πãÂâç‰∏ÄÁõ¥ÊúâÊïàÔºåÂç≥‰ΩøÁ™óÂè£ÂíåÊµèËßàÂô®ÂÖ≥Èó≠ ‰ΩúÁî®Âüü‰∏çÂêå‚ÄìsessionStorageÔºö‰∏çÂú®‰∏çÂêåÁöÑÊµèËßàÂô®Á™óÂè£‰∏≠ÂÖ±‰∫´ÔºåÂç≥‰ΩøÊòØÂêå‰∏Ä‰∏™È°µÈù¢ÔºõlocalStorageÔºöÂú®ÊâÄÊúâÂêåÊ∫êÁ™óÂè£ÈÉΩÊòØÂÖ±‰∫´ÁöÑÔºõcookieÔºö‰πüÊòØÂú®ÊâÄÊúâÂêåÊ∫êÁ™óÂè£‰∏≠ÂÖ±‰∫´ÁöÑ","text":"HTMLÁØá ËØ≠‰πâÂåñ HTML5ËØ≠‰πâÂåñÊ†áÁ≠æÊòØÊåáÊ≠£Á°ÆÁöÑÊ†áÁ≠æÂåÖÂê´‰∫ÜÊ≠£Á°ÆÁöÑÂÜÖÂÆπÔºåÁªìÊûÑËâØÂ•ΩÔºå‰æø‰∫éÈòÖËØªÔºåÊØîÂ¶ÇnavË°®Á§∫ÂØºËà™Êù°ÔºåÁ±ª‰ººÁöÑËøòÊúâarticle„ÄÅheader„ÄÅfooterÁ≠âÁ≠âÊ†áÁ≠æ„ÄÇ ÁßªÂä®ËÆæÂ§áÂøΩÁï•Â∞ÜÈ°µÈù¢‰∏≠ÁöÑÊï∞Â≠óËØÜÂà´‰∏∫ÁîµËØùÂè∑Á†ÅÁöÑÊñπÊ≥ï Â¶ÇÊûúÂøΩÁï•È°µÈù¢‰∏≠ÁöÑÊï∞Â≠óËØÜÂà´‰∏∫ÁîµËØùÂè∑Á†Å, Âè™Ë¶ÅÊääËøô‰∏™ÈªòËÆ§Ë°å‰∏∫ÂÖ≥Èó≠Â∞±Ë°åÔºåÂè™Ë¶Å‰∏ÄË°å‰ª£Á†Å: &lt;meta name = \"format-detection\" content = \"telephone=no\"&gt; http vs https : ÂÆö‰πâÔºö http: Ë∂ÖÊñáÊú¨‰º†ËæìÂçèËÆÆÔºåÊòØ‰∫íËÅîÁΩë‰∏äÂ∫îÁî®ÊúÄ‰∏∫ÂπøÊ≥õÁöÑ‰∏ÄÁßçÁΩëÁªúÂçèËÆÆÔºåÊòØ‰∏Ä‰∏™ÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Âô®Á´ØËØ∑Ê±ÇÂíåÂ∫îÁ≠îÁöÑÊ†áÂáÜÔºàTCPÔºâÔºåÁî®‰∫é‰ªéWWWÊúçÂä°Âô®‰º†ËæìË∂ÖÊñáÊú¨Âà∞Êú¨Âú∞ÊµèËßàÂô®ÁöÑ‰º†ËæìÂçèËÆÆÔºåÂÆÉÂèØ‰ª•‰ΩøÊµèËßàÂô®Êõ¥Âä†È´òÊïàÔºå‰ΩøÁΩëÁªú‰º†ËæìÂáèÂ∞ë„ÄÇ https: ÊòØ‰ª•ÂÆâÂÖ®‰∏∫ÁõÆÊ†áÁöÑHTTPÈÄöÈÅìÔºåÁÆÄÂçïËÆ≤ÊòØHTTPÁöÑÂÆâÂÖ®ÁâàÔºåÂç≥HTTP‰∏ãÂä†ÂÖ•SSLÂ±ÇÔºåHTTPSÁöÑÂÆâÂÖ®Âü∫Á°ÄÊòØSSLÔºåÂõ†Ê≠§Âä†ÂØÜÁöÑËØ¶ÁªÜÂÜÖÂÆπÂ∞±ÈúÄË¶ÅSSL„ÄÇ Âå∫Âà´Ôºö HttpsÂçèËÆÆÈúÄË¶ÅcaËØÅ‰π¶ÔºåË¥πÁî®ËæÉÈ´ò„ÄÇ httpÊòØË∂ÖÊñáÊú¨‰º†ËæìÂçèËÆÆÔºå‰ø°ÊÅØÊòØÊòéÊñá‰º†ËæìÔºåhttpsÂàôÊòØÂÖ∑ÊúâÂÆâÂÖ®ÊÄßÁöÑsslÂä†ÂØÜ‰º†ËæìÂçèËÆÆ„ÄÇ ‰ΩøÁî®‰∏çÂêåÁöÑÈìæÊé•ÊñπÂºèÔºåÁ´ØÂè£‰πü‰∏çÂêåÔºå‰∏ÄËà¨ËÄåË®ÄÔºåhttpÂçèËÆÆÁöÑÁ´ØÂè£‰∏∫80ÔºåhttpsÁöÑÁ´ØÂè£‰∏∫443 httpÁöÑËøûÊé•ÂæàÁÆÄÂçïÔºåÊòØÊó†Áä∂ÊÄÅÁöÑÔºõHTTPSÂçèËÆÆÊòØÁî±SSL+HTTPÂçèËÆÆÊûÑÂª∫ÁöÑÂèØËøõË°åÂä†ÂØÜ‰º†Ëæì„ÄÅË∫´‰ªΩËÆ§ËØÅÁöÑÁΩëÁªúÂçèËÆÆÔºåÊØîhttpÂçèËÆÆÂÆâÂÖ®„ÄÇ websocket WebSocketÊòØHTML5‰∏≠ÁöÑÂçèËÆÆÔºåÊîØÊåÅÊåÅ‰πÖËøûÁª≠ÔºåhttpÂçèËÆÆ‰∏çÊîØÊåÅÊåÅ‰πÖÊÄßËøûÊé•„ÄÇHttp1.0ÂíåHTTP1.1ÈÉΩ‰∏çÊîØÊåÅÊåÅ‰πÖÊÄßÁöÑÈìæÊé•ÔºåHTTP1.1‰∏≠ÁöÑkeep-aliveÔºåÂ∞ÜÂ§ö‰∏™httpËØ∑Ê±ÇÂêàÂπ∂‰∏∫1‰∏™ Cookie„ÄÅsessionStorage„ÄÅlocalStorageÁöÑÂå∫Âà´ ÂÖ±ÂêåÁÇπÔºöÈÉΩÊòØ‰øùÂ≠òÂú®ÊµèËßàÂô®Á´ØÔºåÂπ∂‰∏îÊòØÂêåÊ∫êÁöÑ cookieÊï∞ÊçÆÂßãÁªàÂú®ÂêåÊ∫êÁöÑhttpËØ∑Ê±Ç‰∏≠Êê∫Â∏¶(Âç≥‰Ωø‰∏çÈúÄË¶Å)ÔºåÂç≥cookieÂú®ÊµèËßàÂô®ÂíåÊúçÂä°Âô®Èó¥Êù•Âõû‰º†ÈÄí cookieÊï∞ÊçÆËøòÊúâË∑ØÂæÑÔºàpathÔºâÁöÑÊ¶ÇÂøµÔºåÂèØ‰ª•ÈôêÂà∂„ÄÇcookieÂè™Â±û‰∫éÊüê‰∏™Ë∑ØÂæÑ‰∏ã Â≠òÂÇ®Â§ßÂ∞èÈôêÂà∂‰πü‰∏çÂêå‚ÄìcookieÊï∞ÊçÆ‰∏çËÉΩË∂ÖËøá4KÔºåÂêåÊó∂Âõ†‰∏∫ÊØèÊ¨°httpËØ∑Ê±ÇÈÉΩ‰ºöÊê∫Â∏¶cookieÔºåÊâÄ‰ª•cookieÂè™ÈÄÇÂêà‰øùÂ≠òÂæàÂ∞èÁöÑÊï∞ÊçÆÔºåÂ¶ÇÂõûËØùÊ†áËØÜ„ÄÇ webStorageËôΩÁÑ∂‰πüÊúâÂ≠òÂÇ®Â§ßÂ∞èÁöÑÈôêÂà∂Ôºå‰ΩÜÊòØÊØîcookieÂ§ßÂæóÂ§öÔºåÂèØ‰ª•ËææÂà∞5MÊàñÊõ¥Â§ß Êï∞ÊçÆÁöÑÊúâÊïàÊúü‰∏çÂêå --sessionStorageÔºö‰ªÖÂú®ÂΩìÂâçÁöÑÊµèËßàÂô®Á™óÂè£ÂÖ≥Èó≠ÊúâÊïàÔºõlocalStorageÔºöÂßãÁªàÊúâÊïàÔºåÁ™óÂè£ÊàñÊµèËßàÂô®ÂÖ≥Èó≠‰πü‰∏ÄÁõ¥‰øùÂ≠òÔºåÂõ†Ê≠§Áî®‰ΩúÊåÅ‰πÖÊï∞ÊçÆÔºõcookieÔºöÂè™Âú®ËÆæÁΩÆÁöÑcookieËøáÊúüÊó∂Èó¥‰πãÂâç‰∏ÄÁõ¥ÊúâÊïàÔºåÂç≥‰ΩøÁ™óÂè£ÂíåÊµèËßàÂô®ÂÖ≥Èó≠ ‰ΩúÁî®Âüü‰∏çÂêå‚ÄìsessionStorageÔºö‰∏çÂú®‰∏çÂêåÁöÑÊµèËßàÂô®Á™óÂè£‰∏≠ÂÖ±‰∫´ÔºåÂç≥‰ΩøÊòØÂêå‰∏Ä‰∏™È°µÈù¢ÔºõlocalStorageÔºöÂú®ÊâÄÊúâÂêåÊ∫êÁ™óÂè£ÈÉΩÊòØÂÖ±‰∫´ÁöÑÔºõcookieÔºö‰πüÊòØÂú®ÊâÄÊúâÂêåÊ∫êÁ™óÂè£‰∏≠ÂÖ±‰∫´ÁöÑ cookie sessionÂå∫Âà´ 1.cookieÊï∞ÊçÆÂ≠òÊîæÂú®ÂÆ¢Êà∑ÁöÑÊµèËßàÂô®‰∏äÔºåsessionÊï∞ÊçÆÊîæÂú®ÊúçÂä°Âô®‰∏ä„ÄÇ 2.cookie‰∏çÊòØÂæàÂÆâÂÖ®ÔºåÂà´‰∫∫ÂèØ‰ª•ÂàÜÊûêÂ≠òÊîæÂú®Êú¨Âú∞ÁöÑCOOKIEÂπ∂ËøõË°åCOOKIEÊ¨∫È™óÔºåËÄÉËôëÂà∞ÂÆâÂÖ®Â∫îÂΩì‰ΩøÁî®session„ÄÇ 3.session‰ºöÂú®‰∏ÄÂÆöÊó∂Èó¥ÂÜÖ‰øùÂ≠òÂú®ÊúçÂä°Âô®‰∏ä„ÄÇÂΩìËÆøÈóÆÂ¢ûÂ§öÔºå‰ºöÊØîËæÉÂç†Áî®‰Ω†ÊúçÂä°Âô®ÁöÑÊÄßËÉΩÔºåËÄÉËôëÂà∞ÂáèËΩªÊúçÂä°Âô®ÊÄßËÉΩÊñπÈù¢ÔºåÂ∫îÂΩì‰ΩøÁî®COOKIE„ÄÇ 4.Âçï‰∏™cookie‰øùÂ≠òÁöÑÊï∞ÊçÆ‰∏çËÉΩË∂ÖËøá4KÔºåÂæàÂ§öÊµèËßàÂô®ÈÉΩÈôêÂà∂‰∏Ä‰∏™Á´ôÁÇπÊúÄÂ§ö‰øùÂ≠ò20‰∏™cookie Doctype‰ΩúÁî®?‰∏•Ê†ºÊ®°Âºè‰∏éÊ∑∑ÊùÇÊ®°ÂºèÂ¶Ç‰ΩïÂå∫ÂàÜÔºüÂÆÉ‰ª¨Êúâ‰ΩïÊÑè‰πâ? DoctypeÂ£∞Êòé‰∫éÊñáÊ°£ÊúÄÂâçÈù¢ÔºåÂëäËØâÊµèËßàÂô®‰ª•‰ΩïÁßçÊñπÂºèÊù•Ê∏≤ÊüìÈ°µÈù¢ÔºåËøôÈáåÊúâ‰∏§ÁßçÊ®°ÂºèÔºå‰∏•Ê†ºÊ®°ÂºèÂíåÊ∑∑ÊùÇÊ®°Âºè„ÄÇ ‰∏•Ê†ºÊ®°ÂºèÁöÑÊéíÁâàÂíåJS Ëøê‰ΩúÊ®°ÂºèÊòØ ‰ª•ËØ•ÊµèËßàÂô®ÊîØÊåÅÁöÑÊúÄÈ´òÊ†áÂáÜËøêË°å„ÄÇ Ê∑∑ÊùÇÊ®°ÂºèÔºåÂêëÂêéÂÖºÂÆπÔºåÊ®°ÊãüËÄÅÂºèÊµèËßàÂô®ÔºåÈò≤Ê≠¢ÊµèËßàÂô®Êó†Ê≥ïÂÖºÂÆπÈ°µÈù¢„ÄÇ ÊµèËßàÂô®ÁºìÂ≠òÔºåÂº∫/ÂçèÂïÜÁºìÂ≠ò ÊµèËßàÂô®ÁºìÂ≠òÊòØÊµèËßàÂô®Âú®Êú¨Âú∞Á£ÅÁõòÂØπÁî®Êà∑ÊúÄËøëËØ∑Ê±ÇËøáÁöÑÊñáÊ°£ËøõË°åÂ≠òÂÇ®ÔºåÂΩìËÆøÈóÆËÄÖÂÜçÊ¨°ËÆøÈóÆÂêå‰∏ÄÈ°µÈù¢Êó∂ÔºåÊµèËßàÂô®Â∞±ÂèØ‰ª•Áõ¥Êé•‰ªéÊú¨Âú∞Á£ÅÁõòÂä†ËΩΩÊñáÊ°£„ÄÇ ÁºìÂ≠òÂàÜ‰∏∫‰∏§ÁßçÔºöÂº∫ÁºìÂ≠òÂíåÂçèÂïÜÁºìÂ≠òÔºåÊ†πÊçÆÂìçÂ∫îÁöÑheaderÂÜÖÂÆπÊù•ÂÜ≥ÂÆö„ÄÇ Âº∫ÁºìÂ≠òÁõ∏ÂÖ≥Â≠óÊÆµÊúâexpiresÔºåcache-control„ÄÇÂ¶ÇÊûúcache-control‰∏éexpiresÂêåÊó∂Â≠òÂú®ÁöÑËØùÔºåcache-controlÁöÑ‰ºòÂÖàÁ∫ßÈ´ò‰∫éexpires„ÄÇ ÂçèÂïÜÁºìÂ≠òÁõ∏ÂÖ≥Â≠óÊÆµÊúâLast-Modified/If-Modified-SinceÔºåEtag/If-None-Match ÁºìÂ≠òÁ±ªÂûã Ëé∑ÂèñËµÑÊ∫êÂΩ¢Âºè Áä∂ÊÄÅÁ†Å ÂèëÈÄÅËØ∑Ê±ÇÂà∞ÊúçÂä°Âô® ÂçèÂïÜÁºìÂ≠ò ‰ªéÁºìÂ≠òÂèñ 200(from cache) Âê¶ÔºåÁõ¥Êé•‰ªéÁºìÂ≠òÂèñ Âº∫ÁºìÂ≠ò ‰ªéÁºìÂ≠òÂèñ 304(undefined) ÊòØÔºåÈÄöËøáÊúçÂä°Âô®Êù•ÂëäÁü•ÁºìÂ≠òÊòØÂê¶ÂèØÁî® ‰ªÄ‰πàÊó∂ÂÄôÁî®Âì™‰∏™Ôºü Âõ†‰∏∫ÊúçÂä°Âô®‰∏äÁöÑËµÑÊ∫ê‰∏çÊòØ‰∏ÄÁõ¥Âõ∫ÂÆö‰∏çÂèòÁöÑÔºåÂ§ßÂ§öÊï∞ÊÉÖÂÜµ‰∏ãÂÆÉ‰ºöÊõ¥Êñ∞ÔºåËøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúÊàë‰ª¨ËøòËÆøÈóÆÊú¨Âú∞ÁºìÂ≠òÔºåÈÇ£‰πàÂØπÁî®Êà∑Êù•ËØ¥ÔºåÈÇ£Â∞±Áõ∏ÂΩì‰∫éËµÑÊ∫êÊ≤°ÊúâÊõ¥Êñ∞ÔºåÁî®Êà∑ÁúãÂà∞ÁöÑËøòÊòØÊóßÁöÑËµÑÊ∫êÔºõÊâÄ‰ª•Êàë‰ª¨Â∏åÊúõÊúçÂä°Âô®‰∏äÁöÑËµÑÊ∫êÊõ¥Êñ∞‰∫ÜÊµèËßàÂô®Â∞±ËØ∑Ê±ÇÊñ∞ÁöÑËµÑÊ∫êÔºåÊ≤°ÊúâÊõ¥Êñ∞Â∞±‰ΩøÁî®Êú¨Âú∞ÁöÑÁºìÂ≠òÔºå‰ª•ÊúÄÂ§ßÁ®ãÂ∫¶ÁöÑÂáèÂ∞ëÂõ†ÁΩëÁªúËØ∑Ê±ÇËÄå‰∫ßÁîüÁöÑËµÑÊ∫êÊµ™Ë¥π„ÄÇ 304Áä∂ÊÄÅÁ†Å 304ÔºöÂ¶ÇÊûúÂÆ¢Êà∑Á´ØÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Â∏¶Êù°‰ª∂ÁöÑGET ËØ∑Ê±Ç‰∏îËØ•ËØ∑Ê±ÇÂ∑≤Ë¢´ÂÖÅËÆ∏ÔºåËÄåÊñáÊ°£ÁöÑÂÜÖÂÆπÔºàËá™‰∏äÊ¨°ËÆøÈóÆ‰ª•Êù•ÊàñËÄÖÊ†πÊçÆËØ∑Ê±ÇÁöÑÊù°‰ª∂ÔºâÂπ∂Ê≤°ÊúâÊîπÂèòÔºåÂàôÊúçÂä°Âô®Â∫îÂΩìËøîÂõûËøô‰∏™304Áä∂ÊÄÅÁ†Å„ÄÇ ÂâçÁ´Ø‰ºòÂåñ Èôç‰ΩéËØ∑Ê±ÇÈáèÔºöÂêàÂπ∂ËµÑÊ∫êÔºåÂáèÂ∞ëHTTP ËØ∑Ê±ÇÊï∞Ôºåminify / gzip ÂéãÁº©ÔºåwebPÔºålazyLoad„ÄÇ Âä†Âø´ËØ∑Ê±ÇÈÄüÂ∫¶ÔºöÈ¢ÑËß£ÊûêDNSÔºåÂáèÂ∞ëÂüüÂêçÊï∞ÔºåÂπ∂Ë°åÂä†ËΩΩÔºåCDN ÂàÜÂèë„ÄÇ ÁºìÂ≠òÔºöHTTP ÂçèËÆÆÁºìÂ≠òËØ∑Ê±ÇÔºåÁ¶ªÁ∫øÁºìÂ≠ò manifestÔºåÁ¶ªÁ∫øÊï∞ÊçÆÁºìÂ≠òlocalStorage„ÄÇ Ê∏≤ÊüìÔºöJS/CSS‰ºòÂåñÔºåÂä†ËΩΩÈ°∫Â∫èÔºåÊúçÂä°Á´ØÊ∏≤ÊüìÔºåpipeline„ÄÇ GETÂíåPOSTÁöÑÂå∫Âà´ getÂèÇÊï∞ÈÄöËøáurl‰º†ÈÄíÔºåpostÊîæÂú®request body‰∏≠„ÄÇ getËØ∑Ê±ÇÂú®url‰∏≠‰º†ÈÄíÁöÑÂèÇÊï∞ÊòØÊúâÈïøÂ∫¶ÈôêÂà∂ÁöÑÔºåËÄåpostÊ≤°Êúâ„ÄÇ getÊØîpostÊõ¥‰∏çÂÆâÂÖ®ÔºåÂõ†‰∏∫ÂèÇÊï∞Áõ¥Êé•Êö¥Èú≤Âú®url‰∏≠ÔºåÊâÄ‰ª•‰∏çËÉΩÁî®Êù•‰º†ÈÄíÊïèÊÑü‰ø°ÊÅØ„ÄÇ getËØ∑Ê±ÇÂè™ËÉΩËøõË°åurlÁºñÁ†ÅÔºåËÄåpostÊîØÊåÅÂ§öÁßçÁºñÁ†ÅÊñπÂºè getËØ∑Ê±Ç‰ºöÊµèËßàÂô®‰∏ªÂä®cacheÔºåËÄåpostÊîØÊåÅÂ§öÁßçÁºñÁ†ÅÊñπÂºè„ÄÇ getËØ∑Ê±ÇÂèÇÊï∞‰ºöË¢´ÂÆåÊï¥‰øùÁïôÂú®ÊµèËßàÂéÜÂè≤ËÆ∞ÂΩïÈáåÔºåËÄåpost‰∏≠ÁöÑÂèÇÊï∞‰∏ç‰ºöË¢´‰øùÁïô„ÄÇ GETÂíåPOSTÊú¨Ë¥®‰∏äÂ∞±ÊòØTCPÈìæÊé•ÔºåÂπ∂Êó†Â∑ÆÂà´„ÄÇ‰ΩÜÊòØÁî±‰∫éHTTPÁöÑËßÑÂÆöÂíåÊµèËßàÂô®/ÊúçÂä°Âô®ÁöÑÈôêÂà∂ÔºåÂØºËá¥‰ªñ‰ª¨Âú®Â∫îÁî®ËøáÁ®ã‰∏≠‰ΩìÁé∞Âá∫‰∏Ä‰∫õ‰∏çÂêå„ÄÇ GET‰∫ßÁîü‰∏Ä‰∏™TCPÊï∞ÊçÆÂåÖÔºõPOST‰∫ßÁîü‰∏§‰∏™TCPÊï∞ÊçÆÂåÖ„ÄÇ ÊµèËßàÂô®Ê∏≤ÊüìÂéüÁêÜÔºü 1ÔºâÈ¶ñÂÖàËß£ÊûêÊî∂Âà∞ÁöÑÊñáÊ°£ÔºåÊ†πÊçÆÊñáÊ°£ÂÆö‰πâÊûÑÂª∫‰∏ÄÊ£µ DOM Ê†ëÔºåDOM Ê†ëÊòØÁî± DOM ÂÖÉÁ¥†ÂèäÂ±ûÊÄßËäÇÁÇπÁªÑÊàêÁöÑ„ÄÇ 2ÔºâÁÑ∂ÂêéÂØπ CSS ËøõË°åËß£ÊûêÔºåÁîüÊàê CSSOM ËßÑÂàôÊ†ë„ÄÇ Ôºà3ÔºâÊ†πÊçÆ DOM Ê†ëÂíå CSSOM ËßÑÂàôÊ†ëÊûÑÂª∫Ê∏≤ÊüìÊ†ë„ÄÇÊ∏≤ÊüìÊ†ëÁöÑËäÇÁÇπË¢´Áß∞‰∏∫Ê∏≤ÊüìÂØπË±°ÔºåÊ∏≤ÊüìÂØπË±°ÊòØ‰∏Ä‰∏™ÂåÖÂê´ÊúâÈ¢úËâ≤ÂíåÂ§ßÂ∞èÁ≠âÂ±ûÊÄßÁöÑÁü© ÂΩ¢ÔºåÊ∏≤ÊüìÂØπË±°Âíå DOM ÂÖÉÁ¥†Áõ∏ÂØπÂ∫îÔºå‰ΩÜËøôÁßçÂØπÂ∫îÂÖ≥Á≥ª‰∏çÊòØ‰∏ÄÂØπ‰∏ÄÁöÑÔºå‰∏çÂèØËßÅÁöÑ DOM ÂÖÉÁ¥†‰∏ç‰ºöË¢´ÊèíÂÖ•Ê∏≤ÊüìÊ†ë„ÄÇËøòÊúâ‰∏Ä‰∫õ DOM ÂÖÉÁ¥†ÂØπÂ∫îÂá†‰∏™ÂèØËßÅÂØπË±°ÔºåÂÆÉ‰ª¨‰∏ÄËà¨ÊòØ‰∏Ä‰∫õÂÖ∑ÊúâÂ§çÊùÇÁªìÊûÑÁöÑÂÖÉÁ¥†ÔºåÊó†Ê≥ïÁî®‰∏Ä‰∏™Áü©ÂΩ¢Êù•ÊèèËø∞„ÄÇ Ôºà4ÔºâÂΩìÊ∏≤ÊüìÂØπË±°Ë¢´ÂàõÂª∫Âπ∂Ê∑ªÂä†Âà∞Ê†ë‰∏≠ÔºåÂÆÉ‰ª¨Âπ∂Ê≤°Êúâ‰ΩçÁΩÆÂíåÂ§ßÂ∞èÔºåÊâÄ‰ª•ÂΩìÊµèËßàÂô®ÁîüÊàêÊ∏≤ÊüìÊ†ë‰ª•ÂêéÔºåÂ∞±‰ºöÊ†πÊçÆÊ∏≤ÊüìÊ†ëÊù•ËøõË°åÂ∏ÉÂ±ÄÔºà‰πü ÂèØ‰ª•Âè´ÂÅöÂõûÊµÅÔºâ„ÄÇËøô‰∏ÄÈò∂ÊÆµÊµèËßàÂô®Ë¶ÅÂÅöÁöÑ‰∫ãÊÉÖÊòØË¶ÅÂºÑÊ∏ÖÊ•öÂêÑ‰∏™ËäÇÁÇπÂú®È°µÈù¢‰∏≠ÁöÑÁ°ÆÂàá‰ΩçÁΩÆÂíåÂ§ßÂ∞è„ÄÇÈÄöÂ∏∏Ëøô‰∏ÄË°å‰∏∫‰πüË¢´Áß∞‰∏∫‚ÄúËá™Âä® ÈáçÊéí‚Äù„ÄÇ Ôºà5ÔºâÂ∏ÉÂ±ÄÈò∂ÊÆµÁªìÊùüÂêéÊòØÁªòÂà∂Èò∂ÊÆµÔºåÈÅçÂéÜÊ∏≤ÊüìÊ†ëÂπ∂Ë∞ÉÁî®Ê∏≤ÊüìÂØπË±°ÁöÑ paint ÊñπÊ≥ïÂ∞ÜÂÆÉ‰ª¨ÁöÑÂÜÖÂÆπÊòæÁ§∫Âú®Â±èÂπï‰∏äÔºåÁªòÂà∂‰ΩøÁî® UI Âü∫Á°ÄÁªÑ ‰ª∂„ÄÇ ËæìÂÖ•url‰ºöÂèëÁîü‰ªÄ‰πàÔºü DNSËß£Êûê‚ÄìTCPËøûÊé•‚ÄìÂèëÈÄÅHTTPËØ∑Ê±Ç‚ÄìÊúçÂä°Âô®Â§ÑÁêÜËØ∑Ê±ÇÂπ∂ËøîÂõûHTTPÊä•Êñá‚ÄìÊµèËßàÂô®Ëß£ÊûêÊ∏≤ÊüìÈ°µÈù¢‚ÄìËøûÊé•ÁªìÊùü ËæìÂÖ•urlÂêéÔºåÈ¶ñÂÖàÈúÄË¶ÅÊâæÂà∞Ëøô‰∏™urlÂüüÂêçÁöÑÊúçÂä°Âô®ip,‰∏∫‰∫ÜÂØªÊâæËøô‰∏™ipÔºåÊµèËßàÂô®È¶ñÂÖà‰ºöÂØªÊâæÁºìÂ≠òÔºåÊü•ÁúãÁºìÂ≠ò‰∏≠ÊòØÂê¶ÊúâËÆ∞ÂΩïÔºåÁºìÂ≠òÁöÑÊü•ÊâæËÆ∞ÂΩï‰∏∫ÔºöÊµèËßàÂô®ÁºìÂ≠ò-„ÄãÁ≥ªÁªüÁºìÂ≠ò-„ÄãË∑ØÁî±Âô®ÁºìÂ≠òÔºåÁºìÂ≠ò‰∏≠Ê≤°ÊúâÂàôÊü•ÊâæÁ≥ªÁªüÁöÑhostsÊñá‰ª∂‰∏≠ÊòØÂê¶ÊúâËÆ∞ÂΩïÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÊü•ËØ¢DNSÊúçÂä°Âô®ÔºåÂæóÂà∞ÊúçÂä°Âô®ÁöÑipÂú∞ÂùÄÂêéÔºåÊµèËßàÂô®Ê†πÊçÆËøô‰∏™ip‰ª•ÂèäÁõ∏Â∫îÁöÑÁ´ØÂè£Âè∑ÔºåÊûÑÈÄ†‰∏Ä‰∏™httpËØ∑Ê±ÇÔºåËøô‰∏™ËØ∑Ê±ÇÊä•Êñá‰ºöÂåÖÊã¨ËøôÊ¨°ËØ∑Ê±ÇÁöÑ‰ø°ÊÅØÔºå‰∏ªË¶ÅÊòØËØ∑Ê±ÇÊñπÊ≥ïÔºåËØ∑Ê±ÇËØ¥ÊòéÂíåËØ∑Ê±ÇÈôÑÂ∏¶ÁöÑÊï∞ÊçÆÔºåÂπ∂Â∞ÜËøô‰∏™httpËØ∑Ê±ÇÂ∞ÅË£ÖÂú®‰∏Ä‰∏™tcpÂåÖ‰∏≠ÔºåËøô‰∏™tcpÂåÖ‰ºö‰æùÊ¨°ÁªèËøá‰º†ËæìÂ±ÇÔºåÁΩëÁªúÂ±ÇÔºåÊï∞ÊçÆÈìæË∑ØÂ±ÇÔºåÁâ©ÁêÜÂ±ÇÂà∞ËææÊúçÂä°Âô®ÔºåÊúçÂä°Âô®Ëß£ÊûêËøô‰∏™ËØ∑Ê±ÇÊù•‰ΩúÂá∫ÂìçÂ∫îÔºåËøîÂõûÁõ∏Â∫îÁöÑhtmlÁªôÊµèËßàÂô®ÔºåÂõ†‰∏∫htmlÊòØ‰∏Ä‰∏™Ê†ëÂΩ¢ÁªìÊûÑÔºåÊµèËßàÂô®Ê†πÊçÆËøô‰∏™htmlÊù•ÊûÑÂª∫DOMÊ†ëÔºåÂú®domÊ†ëÁöÑÊûÑÂª∫ËøáÁ®ã‰∏≠Â¶ÇÊûúÈÅáÂà∞JSËÑöÊú¨ÂíåÂ§ñÈÉ®JSËøûÊé•ÔºåÂàô‰ºöÂÅúÊ≠¢ÊûÑÂª∫DOMÊ†ëÊù•ÊâßË°åÂíå‰∏ãËΩΩÁõ∏Â∫îÁöÑ‰ª£Á†ÅÔºåËøô‰ºöÈÄ†ÊàêÈòªÂ°ûÔºåËøôÂ∞±ÊòØ‰∏∫‰ªÄ‰πàÊé®ËçêJS‰ª£Á†ÅÂ∫îËØ•ÊîæÂú®html‰ª£Á†ÅÁöÑÂêéÈù¢Ôºå‰πãÂêéÊ†πÊçÆÂ§ñÈÉ®Â§ÆËßÜÔºåÂÜÖÈÉ®Â§ÆËßÜÔºåÂÜÖËÅîÊ†∑ÂºèÊûÑÂª∫‰∏Ä‰∏™CSSÂØπË±°Ê®°ÂûãÊ†ëCSSOMÊ†ëÔºåÊûÑÂª∫ÂÆåÊàêÂêéÂíåDOMÊ†ëÂêàÂπ∂‰∏∫Ê∏≤ÊüìÊ†ëÔºåËøôÈáå‰∏ªË¶ÅÂÅöÁöÑÊòØÊéíÈô§ÈùûËßÜËßâËäÇÁÇπÔºåÊØîÂ¶ÇscriptÔºåmetaÊ†áÁ≠æÂíåÊéíÈô§display‰∏∫noneÁöÑËäÇÁÇπÔºå‰πãÂêéËøõË°åÂ∏ÉÂ±ÄÔºåÂ∏ÉÂ±Ä‰∏ªË¶ÅÊòØÁ°ÆÂÆöÂêÑ‰∏™ÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆÂíåÂ∞∫ÂØ∏Ôºå‰πãÂêéÊòØÊ∏≤ÊüìÈ°µÈù¢ÔºåÂõ†‰∏∫htmlÊñá‰ª∂‰∏≠‰ºöÂê´ÊúâÂõæÁâáÔºåËßÜÈ¢ëÔºåÈü≥È¢ëÁ≠âËµÑÊ∫êÔºåÂú®Ëß£ÊûêDOMÁöÑËøáÁ®ã‰∏≠ÔºåÈÅáÂà∞Ëøô‰∫õÈÉΩ‰ºöËøõË°åÂπ∂Ë°å‰∏ãËΩΩÔºåÊµèËßàÂô®ÂØπÊØè‰∏™ÂüüÁöÑÂπ∂Ë°å‰∏ãËΩΩÊï∞ÈáèÊúâ‰∏ÄÂÆöÁöÑÈôêÂà∂Ôºå‰∏ÄËà¨ÊòØ4-6‰∏™ÔºåÂΩìÁÑ∂Âú®Ëøô‰∫õÊâÄÊúâÁöÑËØ∑Ê±Ç‰∏≠Êàë‰ª¨ËøòÈúÄË¶ÅÂÖ≥Ê≥®ÁöÑÂ∞±ÊòØÁºìÂ≠òÔºåÁºìÂ≠ò‰∏ÄËà¨ÈÄöËøáCache-Control„ÄÅLast-Modify„ÄÅExpiresÁ≠âÈ¶ñÈÉ®Â≠óÊÆµÊéßÂà∂„ÄÇ Cache-ControlÂíåExpiresÁöÑÂå∫Âà´Âú®‰∫éCache-Control‰ΩøÁî®Áõ∏ÂØπÊó∂Èó¥ÔºåExpires‰ΩøÁî®ÁöÑÊòØÂü∫‰∫éÊúçÂä°Âô® Á´ØÁöÑÁªùÂØπÊó∂Èó¥ÔºåÂõ†‰∏∫Â≠òÂú®Êó∂Â∑ÆÈóÆÈ¢òÔºå‰∏ÄËà¨ÈááÁî®Cache-ControlÔºåÂú®ËØ∑Ê±ÇËøô‰∫õÊúâËÆæÁΩÆ‰∫ÜÁºìÂ≠òÁöÑÊï∞ÊçÆÊó∂Ôºå‰ºöÂÖà Êü•ÁúãÊòØÂê¶ËøáÊúüÔºåÂ¶ÇÊûúÊ≤°ÊúâËøáÊúüÂàôÁõ¥Êé•‰ΩøÁî®Êú¨Âú∞ÁºìÂ≠òÔºåËøáÊúüÂàôËØ∑Ê±ÇÂπ∂Âú®ÊúçÂä°Âô®Ê†°È™åÊñá‰ª∂ÊòØÂê¶‰øÆÊîπÔºåÂ¶ÇÊûú‰∏ä‰∏ÄÊ¨° ÂìçÂ∫îËÆæÁΩÆ‰∫ÜETagÂÄº‰ºöÂú®ËøôÊ¨°ËØ∑Ê±ÇÁöÑÊó∂ÂÄô‰Ωú‰∏∫If-None-MatchÁöÑÂÄº‰∫§ÁªôÊúçÂä°Âô®Ê†°È™åÔºåÂ¶ÇÊûú‰∏ÄËá¥ÔºåÁªßÁª≠Ê†°È™å Last-ModifiedÔºåÊ≤°ÊúâËÆæÁΩÆETagÂàôÁõ¥Êé•È™åËØÅLast-ModifiedÔºåÂÜçÂÜ≥ÂÆöÊòØÂê¶ËøîÂõû304 ÊèèËø∞‰∏Ä‰∏ãXSSÂíåCRSFÊîªÂáªÔºüÈò≤Âæ°ÊñπÊ≥ïÔºü XSS, Âç≥‰∏∫ÔºàCross Site ScriptingÔºâ, ‰∏≠ÊñáÂêç‰∏∫Ë∑®Á´ôËÑöÊú¨, ÊòØÂèëÁîüÂú®ÁõÆÊ†áÁî®Êà∑ÁöÑÊµèËßàÂô®Â±ÇÈù¢‰∏äÁöÑÔºåÂΩìÊ∏≤ÊüìDOMÊ†ëÁöÑËøáÁ®ãÊàêÂèëÁîü‰∫Ü‰∏çÂú®È¢ÑÊúüÂÜÖÊâßË°åÁöÑJS‰ª£Á†ÅÊó∂ÔºåÂ∞±ÂèëÁîü‰∫ÜXSSÊîªÂáª„ÄÇÂ§ßÂ§öÊï∞XSSÊîªÂáªÁöÑ‰∏ªË¶ÅÊñπÂºèÊòØÂµåÂÖ•‰∏ÄÊÆµËøúÁ®ãÊàñËÄÖÁ¨¨‰∏âÊñπÂüü‰∏äÁöÑJS‰ª£Á†Å„ÄÇÂÆûÈôÖ‰∏äÊòØÂú®ÁõÆÊ†áÁΩëÁ´ôÁöÑ‰ΩúÁî®Âüü‰∏ãÊâßË°å‰∫ÜËøôÊÆµjs‰ª£Á†Å„ÄÇ CSRFÔºàCross Site Request ForgeryÔºåË∑®Á´ôËØ∑Ê±Ç‰º™ÈÄ†ÔºâÔºåÂ≠óÈù¢ÁêÜËß£ÊÑèÊÄùÂ∞±ÊòØÂú®Âà´ÁöÑÁ´ôÁÇπ‰º™ÈÄ†‰∫Ü‰∏Ä‰∏™ËØ∑Ê±Ç„ÄÇ‰∏ì‰∏öÊúØËØ≠Êù•ËØ¥Â∞±ÊòØÂú®ÂèóÂÆ≥ËÄÖËÆøÈóÆ‰∏Ä‰∏™ÁΩëÁ´ôÊó∂ÔºåÂÖ∂ Cookie ËøòÊ≤°ÊúâËøáÊúüÁöÑÊÉÖÂÜµ‰∏ãÔºåÊîªÂáªËÄÖ‰º™ÈÄ†‰∏Ä‰∏™ÈìæÊé•Âú∞ÂùÄÂèëÈÄÅÂèóÂÆ≥ËÄÖÂπ∂Ê¨∫È™óËÆ©ÂÖ∂ÁÇπÂáªÔºå‰ªéËÄåÂΩ¢Êàê CSRF ÊîªÂáª„ÄÇ XSSÈò≤Âæ°ÁöÑÊÄª‰ΩìÊÄùË∑ØÊòØÔºöÂØπËæìÂÖ•(ÂíåURLÂèÇÊï∞)ËøõË°åËøáÊª§ÔºåÂØπËæìÂá∫ËøõË°åÁºñÁ†Å„ÄÇ‰πüÂ∞±ÊòØÂØπÊèê‰∫§ÁöÑÊâÄÊúâÂÜÖÂÆπËøõË°åËøáÊª§ÔºåÂØπurl‰∏≠ÁöÑÂèÇÊï∞ËøõË°åËøáÊª§ÔºåËøáÊª§Êéâ‰ºöÂØºËá¥ËÑöÊú¨ÊâßË°åÁöÑÁõ∏ÂÖ≥ÂÜÖÂÆπÔºõÁÑ∂ÂêéÂØπÂä®ÊÄÅËæìÂá∫Âà∞È°µÈù¢ÁöÑÂÜÖÂÆπËøõË°åhtmlÁºñÁ†ÅÔºå‰ΩøËÑöÊú¨Êó†Ê≥ïÂú®ÊµèËßàÂô®‰∏≠ÊâßË°å„ÄÇËôΩÁÑ∂ÂØπËæìÂÖ•ËøáÊª§ÂèØ‰ª•Ë¢´ÁªïËøáÔºå‰ΩÜÊòØ‰πüËøòÊòØ‰ºöÊã¶Êà™ÂæàÂ§ß‰∏ÄÈÉ®ÂàÜÁöÑXSSÊîªÂáª„ÄÇ Èò≤Âæ°CSRF ÊîªÂáª‰∏ªË¶ÅÊúâ‰∏âÁßçÁ≠ñÁï•ÔºöÈ™åËØÅ HTTP Referer Â≠óÊÆµÔºõÂú®ËØ∑Ê±ÇÂú∞ÂùÄ‰∏≠Ê∑ªÂä† token Âπ∂È™åËØÅÔºõÂú® HTTP Â§¥‰∏≠Ëá™ÂÆö‰πâÂ±ûÊÄßÂπ∂È™åËØÅ„ÄÇ","categories":[{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"}]},{"title":"Weekly Contest 178 üèÜ","slug":"contest04","date":"2020-03-01T04:02:09.000Z","updated":"2020-03-01T05:12:12.726Z","comments":true,"path":"2020/02/29/contest04/","link":"","permalink":"WangHngLeee.github.io/2020/02/29/contest04/","excerpt":"1351. Count Negative Numbers in a Sorted Matrix üîóQuestion Link My solution class Solution &#123; public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] res = new int[nums.length]; if(nums == null || nums.length == 0)return res; for(int i = 0 ;i&lt;nums.length;i++)&#123; int count = 0; for(int j = 0;j&lt;nums.length;j++)&#123; if(j == i)continue; if(nums[j]&lt;nums[i])count++; &#125; res[i] = count; &#125; return res; &#125;&#125; brute force„ÄÇ","text":"1351. Count Negative Numbers in a Sorted Matrix üîóQuestion Link My solution class Solution &#123; public int[] smallerNumbersThanCurrent(int[] nums) &#123; int[] res = new int[nums.length]; if(nums == null || nums.length == 0)return res; for(int i = 0 ;i&lt;nums.length;i++)&#123; int count = 0; for(int j = 0;j&lt;nums.length;j++)&#123; if(j == i)continue; if(nums[j]&lt;nums[i])count++; &#125; res[i] = count; &#125; return res; &#125;&#125; brute force„ÄÇ 1366. Rank Teams by Votes üîóQuestion Link class Solution &#123; public String rankTeams(String[] votes) &#123; Map&lt;Character, int[]&gt; map = new HashMap&lt;&gt;(); int len = votes[0].length(); for(String vote : votes)&#123; for(int i = 0; i &lt; len; i++)&#123; if(!map.containsKey(vote.charAt(i)))&#123; map.put(vote.charAt(i), new int[len]); &#125; map.get(vote.charAt(i))[i]++; &#125; &#125; PriorityQueue&lt;Character&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt; &#123; for(int i = 0 ;i&lt;len ;i++)&#123; if(map.get(a)[i] != map.get(b)[i])&#123; return map.get(b)[i] - map.get(a)[i]; &#125; &#125; return a-b; &#125;); for(Character ch : map.keySet())&#123; pq.add(ch); &#125; StringBuilder sb = new StringBuilder(); while(!pq.isEmpty())&#123; sb.append(pq.poll()); &#125; return sb.toString(); &#125;&#125; ‰∏∫ÊØè‰∏™charÂª∫‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫vote.length()ÁöÑÊï∞ÁªÑÔºåÁî®Êù•Â≠òËØ•charÂú®ÊØè‰∏™positionÁöÑfreq„ÄÇÁÑ∂ÂêéÁî®pqÊù•matchÊúÄÂêàÈÄÇÁöÑÔºåÊîæÂà∞ÊúÄÂâçÔºåÁÑ∂Âêé‰æùÊ¨°pollÂä†ÂÖ•stringbuilderËøîÂõû„ÄÇ 1367. Linked List in Binary Tree üîóQuestion Link class Solution &#123; public boolean isSubPath(ListNode head, TreeNode root) &#123; if(root == null)return false; return check(root,head) || isSubPath(head,root.left) || isSubPath(head,root.right); &#125; public boolean check(TreeNode root, ListNode head)&#123; if(head == null)return true; if(head == null || root == null)return false; if(head == null &amp;&amp; root == null)return true; if(head.val != root.val)return false; return check(root.left,head.next) || check(root.right,head.next); &#125;&#125; Âíå542‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇÂè™ÊúâÂΩìheadÂíårootÈÉΩ‰∏∫nullÊó∂ÂèØ‰ª•‰∏∫trueÔºåÂÖàÊ£ÄÊü•ÂΩìÂâçrootÂíåheadÊàñËÄÖÂØπleftÂíårightÂàÜÂà´ËøõË°åÈÄíÂΩíË∞ÉÁî®„ÄÇÂú®checkÂáΩÊï∞Èáå‰πüÊòØË¶ÅÂØπleftÂíåright‰∏§ÁßçÊÉÖÂÜµÈÉΩËÄÉËôëÔºåËøîÂõûÔΩúÔΩúÂÄºÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 85 üí™","slug":"chin-up-23","date":"2020-02-29T16:13:23.000Z","updated":"2020-02-29T21:37:14.536Z","comments":true,"path":"2020/02/29/chin-up-23/","link":"","permalink":"WangHngLeee.github.io/2020/02/29/chin-up-23/","excerpt":"875. Koko Eating Bananas üîóQuestion Link class Solution &#123; public int minEatingSpeed(int[] piles, int H) &#123; if(piles == null || piles.length == 0)return -1; int start = 1; int end = getmax(piles); while(start + 1 &lt; end)&#123; int mid = start + ( end - start)/2; if(caneatall(piles,H,mid))end = mid; else&#123; start = mid; &#125; &#125; if(caneatall(piles,H,start))return start; else return end; &#125; public boolean caneatall(int[] piles, int H, int start)&#123; int count = 0; for(int pile : piles)&#123; count+=pile/start; if(pile%start!=0)count++; &#125; return count&lt;= H; &#125; public int getmax(int[]piles)&#123; int max = Integer.MIN_VALUE; for(int pile : piles)&#123; if(pile &gt; max)&#123; max = pile; &#125; &#125; return max; &#125;&#125; ‰∫åÂàÜÂèëÊâæper hourÁöÑÊ∂àËÄóÈáè„ÄÇÂÖàÊâæÂà∞pilesÈáåÊúÄÂ§ßÂÄº‰Ωú‰∏∫Ê∂àËÄóÈÄüÁéáÔºåÂà§Êñ≠ÂΩìÂâçrateËÉΩÂê¶Âú®ÁªôÂÆöÂ∞èÊó∂ÂÜÖÊ∂àËÄóÂÆåÊâÄÊúâpiles„ÄÇÂ¶ÇÊûúÂèØ‰ª•ÂàôÂ∞ÜrateÈôç‰Ωé1ÔºåÂ¶ÇÊ≠§Âæ™ÁéØÊâæÂà∞ÊúÄÂ∞èÂÄº„ÄÇ","text":"875. Koko Eating Bananas üîóQuestion Link class Solution &#123; public int minEatingSpeed(int[] piles, int H) &#123; if(piles == null || piles.length == 0)return -1; int start = 1; int end = getmax(piles); while(start + 1 &lt; end)&#123; int mid = start + ( end - start)/2; if(caneatall(piles,H,mid))end = mid; else&#123; start = mid; &#125; &#125; if(caneatall(piles,H,start))return start; else return end; &#125; public boolean caneatall(int[] piles, int H, int start)&#123; int count = 0; for(int pile : piles)&#123; count+=pile/start; if(pile%start!=0)count++; &#125; return count&lt;= H; &#125; public int getmax(int[]piles)&#123; int max = Integer.MIN_VALUE; for(int pile : piles)&#123; if(pile &gt; max)&#123; max = pile; &#125; &#125; return max; &#125;&#125; ‰∫åÂàÜÂèëÊâæper hourÁöÑÊ∂àËÄóÈáè„ÄÇÂÖàÊâæÂà∞pilesÈáåÊúÄÂ§ßÂÄº‰Ωú‰∏∫Ê∂àËÄóÈÄüÁéáÔºåÂà§Êñ≠ÂΩìÂâçrateËÉΩÂê¶Âú®ÁªôÂÆöÂ∞èÊó∂ÂÜÖÊ∂àËÄóÂÆåÊâÄÊúâpiles„ÄÇÂ¶ÇÊûúÂèØ‰ª•ÂàôÂ∞ÜrateÈôç‰Ωé1ÔºåÂ¶ÇÊ≠§Âæ™ÁéØÊâæÂà∞ÊúÄÂ∞èÂÄº„ÄÇ 1011. Capacity To Ship Packages Within D Days üîóQuestion Link class Solution &#123; public int shipWithinDays(int[] weights, int D) &#123; if(weights == null || weights.length == 0)return -1; int left= 0; int right = 0; for(int w : weights)&#123; left = Math.max(left,w); right+=w; &#125; while(left &lt; right)&#123; int mid = left + (right-left)/2; int cur = 0; int need = 1; for(int w : weights)&#123; if(cur+w &gt; mid)&#123; need++; cur = 0; &#125; cur+=w; &#125; if(need &gt; D)left = mid + 1; else right = mid; &#125; return left; &#125;&#125; ÊúâË∂£ÁöÑ‰∏ÄÈÅìÈ¢ò„ÄÇright‰∏äÈôê‰∏∫Ë¥ßÁâ©ÊÄªÈáçÔºåÁÑ∂Âêé‰∫åÂàÜÊâæÂú®ÁªôÂÆöÂ§©Êï∞ÂÜÖÊê¨ÂÆåÊâÄÊúâÁöÑÊúÄÂ∞èÊó•ÂùáÈáè„ÄÇÈ¶ñÂÖàÂÆö‰πâcurÊù•Â≠òÊöÇÊó∂ÁöÑÊÄªÊê¨ËøêÈáèÔºåÂ¶ÇÊûúÂ§ß‰∫é‰∫ÜÂÅáÂÆöÁöÑmidÂÄºÔºåÂàôÈúÄË¶ÅÂ§ö‰∏ÄÂ§©ÔºåÂπ∂‰∏îÈáçÊñ∞ÂΩíÈõ∂curÂÄºÔºåËøõË°å‰∏ã‰∏ÄÊ¨°ÔºåÂê¶Âàôcur‰∏ÄÁõ¥Â¢ûÂä†„ÄÇÊúÄÂêéÂà§Êñ≠ÈúÄË¶ÅÁöÑÂ§©Êï∞ÂíåDÁöÑÂÖ≥Á≥ªÂç≥ÂèØ„ÄÇ 33. Search in Rotated Sorted Array üîóQuestion Link class Solution &#123; public int search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int len = nums.length; int left = 0; int right = len-1; while(left+1 &lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &gt;= nums[left])&#123; if(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125;else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if (nums[mid] == target) return mid; &#125; if(nums[left] == target)return left; else if (nums[right] == target) return right; else return -1; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇÁî®Êñ∞‰∫åÂàÜÊ®°ÁâàÂÜô‰∏Ä‰∏ã„ÄÇ 81. Search in Rotated Sorted Array II üîóQuestion Link class Solution &#123; public boolean search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return false; int len = nums.length; int left = 0; int right = len-1; while(left+1 &lt; right)&#123; int mid = left + (right - left)/2; if (nums[mid] == target) return true; else if(nums[mid] &gt; nums[left])&#123; if(target &lt;= nums[mid] &amp;&amp; target&gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125;else if(nums[left]==nums[mid])&#123; left++; &#125; else if(nums[right] == nums[mid])&#123; right--; &#125;else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; &#125; if(nums[left] == target)return true; else if (nums[right] == target) return true; else return false; &#125;&#125; Â§ö‰∫ÜÈáçÂ§çÁöÑÊï∞Â≠óÔºåË¶ÅÊ£ÄÊü•midÂíåleft right„ÄÇÂÖ∂‰ªñ‰∏çÂèò„ÄÇ 153. Find Minimum in Rotated Sorted Array üîóQuestion Link class Solution &#123; public int findMin(int[] nums) &#123; if(nums == null || nums.length == 0)return -1; int start = 0; int end = nums.length -1; while(start + 1 &lt;end)&#123; int mid = start + (end - start)/2; if(nums[mid] &gt; nums[end])&#123; start = mid; &#125;else&#123; end = mid; &#125; &#125; if(nums[start] &lt; nums[end])return nums[start]; else&#123; return nums[end]; &#125; &#125;&#125; ÊØèÊ¨°Âà∞Êõ¥Â∞èÁöÑ‰∏ÄÈÉ®ÂàÜÁªßÁª≠‰∫åÂàÜ„ÄÇ 154. Find Minimum in Rotated Sorted Array II üîóQuestion Link class Solution &#123; public int findMin(int[] nums) &#123; int left = 0; int right = nums.length -1; while(left + 1 &lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else if (nums[mid] &gt; nums[right])&#123; left = mid; &#125;else&#123; right--; &#125; &#125; if(nums[left] &lt; nums[right])return nums[left]; else return nums[right]; &#125;&#125; duplicateÂ≠òÂú®„ÄÇÁî±‰∫ésortedÔºåÊâÄ‰ª•ÊØèÊ¨°Âè™ÂØπnums[right]Ê£ÄÊü•„ÄÇ 162. Find Peak Element üîóQuestion Link 852. Peak Index in a Mountain Array üîóQuestion Link class Solution &#123; public int findPeakElement(int[] nums) &#123; if(nums == null || nums.length == 0)return -1; int left = 0; int right = nums.length -1; while(left + 1&lt; right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[mid + 1])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if(nums[left]&gt;nums[right])return left; else return right; &#125;&#125; Ëøô‰∏§ÈÅìÈ¢ò‰∏ÄÊ†∑ÁöÑsolution„ÄÇÊîæ‰∏ÄËµ∑‰∫Ü„ÄÇ ÊØèÊ¨°ÂØπmidÂíåmid+1ÊØîËæÉ„ÄÇÊõ¥Êñ∞Â∑¶Âè≥ËæπÁïåÂç≥ÂèØ„ÄÇ 74. Search a 2D Matrix üîóQuestion Link class Solution &#123; public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length == 0)return false; if(matrix[0].length == 0)return false; int row = matrix.length; int col = matrix[0].length; int start = 0; int end = row*col-1; while(start + 1&lt; end)&#123; int mid = start + (end - start)/2; if(matrix[mid/col][mid%col] == target)return true; else if (matrix[mid/col][mid%col] &lt; target)start = mid; else&#123; end = mid; &#125; &#125; if(matrix[start/col][start%col] == target)return true; else if (matrix[end/col][end%col] == target)return true; else return false; &#125;&#125; Á¨¨‰∫îÈÅç„ÄÇÂΩìÊàê‰∏Ä‰∏™Êï∞ÁªÑ‰∫åÂàÜÊü•Êâæ„ÄÇÊ≥®ÊÑècolÂíåÊï∞ÁªÑindexÁöÑÂÖ≥Á≥ª„ÄÇÈÉΩÁî®colÊù•ÊØîËæÉ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"}]},{"title":"Leetcode EveryDay 84 üí™","slug":"chin-up-22","date":"2020-02-28T18:13:23.000Z","updated":"2020-02-29T19:56:47.102Z","comments":true,"path":"2020/02/28/chin-up-22/","link":"","permalink":"WangHngLeee.github.io/2020/02/28/chin-up-22/","excerpt":"üìåÁÖéÁÜ¨ÁöÑmidtermÂë®ËøáÂéª‰∫ÜÔºåÂèàÂèØ‰ª•ÂºÄÂøÉÁöÑÂà∑È¢ò‰∫Ü(Âπ∂Ê≤°Êúâ) 784. Letter Case Permutation üîóQuestion Link class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String str : queue)&#123; res.add(str); &#125; return res; &#125;&#125; ÂõûÊ∫ØÔºåÊØèÊ¨°ÊîπÂÆå‰∏Ä‰∏™Â≠óÊØçË¶ÅÊääÂéüÊù•‰ΩÜÂèò‰ºöÂ∞èÂÜôÂä†Âõûqueue„ÄÇ","text":"üìåÁÖéÁÜ¨ÁöÑmidtermÂë®ËøáÂéª‰∫ÜÔºåÂèàÂèØ‰ª•ÂºÄÂøÉÁöÑÂà∑È¢ò‰∫Ü(Âπ∂Ê≤°Êúâ) 784. Letter Case Permutation üîóQuestion Link class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String str : queue)&#123; res.add(str); &#125; return res; &#125;&#125; ÂõûÊ∫ØÔºåÊØèÊ¨°ÊîπÂÆå‰∏Ä‰∏™Â≠óÊØçË¶ÅÊääÂéüÊù•‰ΩÜÂèò‰ºöÂ∞èÂÜôÂä†Âõûqueue„ÄÇ 301. Remove Invalid Parentheses üîóQuestion Link class Solution &#123; public List&lt;String&gt; removeInvalidParentheses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); Set&lt;String&gt; seen = new HashSet&lt;&gt;(); queue.add(s); seen.add(s); boolean found = false; while(!queue.isEmpty())&#123; String str = queue.poll(); if(isvalid(str))&#123; res.add(str); found = true; &#125; if(found)continue; for(int i = 0 ;i&lt;str.length();i++)&#123; if(str.charAt(i) != ')' &amp;&amp; str.charAt(i) != '(')continue; String temp = str.substring(0,i) + str.substring(i); if(!seen.contains(temp))&#123; queue.add(temp); seen.add(temp); &#125; &#125; &#125; return res; &#125; public boolean isvalid(String s)&#123; int count = 0; for(int i=0 ;i&lt;s.length();i++)&#123; char c = s.charAt(i); if (c == '(') count++; if (c == ')' &amp;&amp; count-- == 0) return false; &#125; return count == 0; &#125;&#125; BFSÊÄùË∑Ø„ÄÇÊ≥®ÊÑèisvalidÁöÑÂà§Êñ≠Êù°‰ª∂„ÄÇ 35. Search Insert Position üîóQuestion Link class Solution &#123; public int searchInsert(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int start = 0; int end = nums.length -1; while(start + 1&lt; end)&#123; int mid = start + (end - start)/2; if(nums[mid] == target)return mid; else if(nums[mid] &lt; target)&#123; start = mid; &#125;else&#123; end = mid; &#125; &#125; if(nums[start] &gt;= target)return start; else if (nums[end] &gt;= target)return end; else return end + 1; &#125;&#125; ÁªèÂÖ∏‰∫åÂàÜÊ®°Áâà„ÄÇ 34. Find First and Last Position of Element in Sorted Array üîóQuestion Link class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return new int[]&#123;-1,-1&#125;; int[] res = new int[2]; int start = 0; int end = nums.length-1; while(start + 1&lt; end)&#123; int mid = start + ( end - start )/2 ; if(nums[mid] == target)end = mid; else if(nums[mid] &gt; target)end = mid; else if(nums[mid] &lt; target)start = mid; &#125; if(nums[start] == target)res[0] = start; else if(nums[end] == target)res[0] = end; else&#123; res[0] = -1; res[1] = -1; return res; &#125; start = 0; end = nums.length-1; while(start + 1&lt; end)&#123; int mid = start + ( end - start )/2 ; if(nums[mid] == target)start = mid; else if(nums[mid] &gt; target)end = mid; else if(nums[mid] &lt; target)start = mid; &#125; if(nums[end] == target)res[1] = end; else if(nums[start] == target)res[1] = start; else&#123; res[0] = -1; res[1] = -1; return res; &#125; return res; &#125;&#125; ‰∏§Ê¨°‰∫åÂàÜÔºåÊâæ‰∏§‰∏™‰ΩçÁΩÆ„ÄÇÊ≥®ÊÑè‰∫åÂàÜÊñ∞ÂÜôÊ≥ïÊúÄÂêéÂà§Êñ≠startÂíåendÁöÑÈ°∫Â∫è„ÄÇ 981. Time Based Key-Value Store üîóQuestion Link class TimeMap &#123; Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map; /** Initialize your data structure here. */ public TimeMap() &#123; map = new HashMap&lt;&gt;(); &#125; public void set(String key, String value, int timestamp) &#123; if(!map.containsKey(key))&#123; map.put(key,new TreeMap&lt;&gt;()); &#125; map.get(key).put(timestamp,value); &#125; public String get(String key, int timestamp) &#123; TreeMap&lt;Integer,String&gt; treemap = map.get(key); if(treemap == null)return \"\"; Integer floor = treemap.floorKey(timestamp); if(floor == null)return \"\"; return treemap.get(floor); &#125;&#125; map + treemap„ÄÇmapÁî®keyÂÅökeyvalueÔºåtreemapÈáåÁî®timestamp‰Ωú‰∏∫keyvalue„ÄÇ treemapÈáåfloorKeyËøîÂõû&lt;=ÂΩìÂâçÂÄºÁöÑkey„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"}]},{"title":"Leetcode EveryDay 83 üí™","slug":"chin-up-21","date":"2020-02-21T15:13:23.000Z","updated":"2020-02-28T21:11:47.126Z","comments":true,"path":"2020/02/21/chin-up-21/","link":"","permalink":"WangHngLeee.github.io/2020/02/21/chin-up-21/","excerpt":"968. Binary Tree Cameras üîóQuestion Link class Solution &#123; int res = 0; public int minCameraCover(TreeNode root) &#123; return (dfs(root) == 0 ? 1 : 0) + res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 2; int left = dfs(root.left); int right = dfs(root.right); if(left == 0 || right == 0)&#123; res++; return 1; &#125; if(left == 1 || right == 1)&#123; return 2; &#125;else return 0; &#125;&#125; 0 : Âè∂ËäÇÁÇπ„ÄÇ 1 Ôºö cameraÁöÑ‰ΩçÁΩÆ„ÄÇ 2 Ôºö Â∑¶Âè≥Â≠êÊ†ë‰∏≠ÊúâcameraÔºåËøô‰∏™‰ΩçÁΩÆË¢´cover‰∫Ü„ÄÇ Â¶ÇÊûúÂ∑¶Âè≥‰∏≠Êúâ2ÔºåÂàôË°®ÊòéËØ•nodeÁöÑÂ≠©Â≠ê‰∏≠Â∑≤ÁªèË¢´cover‰∫ÜÔºåÂàôËØ•nodeÂèò‰∏∫Êñ∞ÁöÑÂè∂ËäÇÁÇπ„ÄÇ","text":"968. Binary Tree Cameras üîóQuestion Link class Solution &#123; int res = 0; public int minCameraCover(TreeNode root) &#123; return (dfs(root) == 0 ? 1 : 0) + res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 2; int left = dfs(root.left); int right = dfs(root.right); if(left == 0 || right == 0)&#123; res++; return 1; &#125; if(left == 1 || right == 1)&#123; return 2; &#125;else return 0; &#125;&#125; 0 : Âè∂ËäÇÁÇπ„ÄÇ 1 Ôºö cameraÁöÑ‰ΩçÁΩÆ„ÄÇ 2 Ôºö Â∑¶Âè≥Â≠êÊ†ë‰∏≠ÊúâcameraÔºåËøô‰∏™‰ΩçÁΩÆË¢´cover‰∫Ü„ÄÇ Â¶ÇÊûúÂ∑¶Âè≥‰∏≠Êúâ2ÔºåÂàôË°®ÊòéËØ•nodeÁöÑÂ≠©Â≠ê‰∏≠Â∑≤ÁªèË¢´cover‰∫ÜÔºåÂàôËØ•nodeÂèò‰∏∫Êñ∞ÁöÑÂè∂ËäÇÁÇπ„ÄÇ 337. House Robber III üîóQuestion Link class Solution &#123; public int rob(TreeNode root) &#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); return help(root,map); &#125; public int help(TreeNode root, Map&lt;TreeNode,Integer&gt; map)&#123; if(root == null)return 0; int val =0; if(map.containsKey(root))return map.get(root); // memoÂâ™Êûù if(root.left!=null)&#123; val= val + help(root.left.left,map) + help(root.left.right,map); &#125; if(root.right!=null)&#123; val = val + help(root.right.left,map) + help(root.right.right,map); &#125; val = Math.max(root.val + val,help(root.left,map) + help(root.right,map)); map.put(root,val); return val; &#125;&#125; dfs + memo„ÄÇÂØπÂΩìÂâçrootÂàÜ‰∏§ÁßçÊÉÖÂÜµËÆ®ËÆ∫„ÄÇ Â∑≤ÁªèË¢´robed ÔºåÂàôË∑≥ËøáÂ∑¶Âè≥Áõ¥Êé•Â≠©Â≠êÔºåÂéªgrand nodeÔºå root.left.left,root.left.right,root.right.left,root.right.right„ÄÇ Êú™Ë¢´robedÔºåÂàôÂ∑¶Âè≥Áõ¥Êé•Â≠©Â≠êÂèØ‰ª•Áî®„ÄÇÁõ¥Êé•Êìç‰Ωúroot.left root.rightÂç≥ÂèØ„ÄÇ ÊúÄÂêéÊØîËæÉ‰∏§ÁßçÊÉÖÂÜµËøîÂõûÁöÑvalÂÄºÂíåÔºåÂèñËæÉÂ§ßÂ≠òÂÖ•map„ÄÇ Âä†ÂÖ•memoÂâ™Êûù„ÄÇ 979. Distribute Coins in Binary Tree üîóQuestion Link class Solution &#123; int res = 0; public int distributeCoins(TreeNode root) &#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null)return 0; int left = dfs(root.left); int right =dfs(root.right); res += Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; Ë¶ÅÊ±ÇÂ∞ÜÊØè‰∏™‰ΩçÁΩÆÈÉΩÂèò‰∏∫1ÔºåÂπ∂‰∏îÊØèÊ¨°ÂèòÂä®Âè™ËÉΩ‰º†1‰∏™Á°¨Â∏ÅÔºåÊ±ÇÂèòÂä®Ê¨°Êï∞„ÄÇÂÖ∂ÂÆûÂèçËøáÊù•ÊÉ≥ÔºåÂ¶ÇÊûúÊüê‰∏™ËäÇÁÇπÂéüÊù•‰∏∫x,Ë¶ÅÂèò‰∏∫1ÔºåÈÇ£‰πàÂèòÂä®ÁöÑÊï∞ÂÄºÂ∞±ÊòØx-1ÁöÑÁªùÂØπÂÄºÔºå‰πüÂ∞±ÊòØÂêëÁà∂ËäÇÁÇπ‰º†ÈÄÅÁöÑÂÄºÊàñËÄÖÂêëÁà∂ËäÇÁÇπÁ¥¢Ë¶ÅÁöÑÂÄºÔºåÂç≥ÂèòÂä®Ê¨°Êï∞ÔºåÊúÄÂêéËøòË¶Å‰øùËØÅËØ•ËäÇÁÇπÂâ©‰∏ã‰∏Ä‰∏™Á°¨Â∏ÅÔºåÊâÄ‰ª•Ë¶ÅÊääÂ∑¶Âè≥Â≠©Â≠êÂèØ‰ª•Âà©Áî®ÁöÑÁ°¨Â∏ÅÊï∞ÂÖ®ÈÉ®Áõ∏Âä†ÁÑ∂Âêé-1ÔºåËøô‰∫õÂ∞±ÊòØËØ•nodeÁöÑÁà∂ËäÇÁÇπËÉΩÂ§üÁî®Âà∞ÁöÑÁ°¨Â∏ÅÊÄªÊï∞„ÄÇ 221. Maximal Square üîóQuestion Link class Solution &#123; public int maximalSquare(char[][] matrix) &#123; if(matrix == null || matrix.length == 0)return 0; int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m+1][n+1]; int max = 0; for(int i=1; i&lt;=m ;i++)&#123; for(int j =1 ; j&lt;=n ;j++)&#123; if(matrix[i-1][j-1] == '1')&#123; dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i][j-1], dp[i-1][j]))+1; max = Math.max(max,dp[i][j]); &#125; &#125; &#125; return max*max; &#125;&#125; dpÂ≠òÂè≥‰∏ãËßí‰∏∫1ÁöÑ‰ΩçÁΩÆÈáåÔºåÊúÄÂ§ßÁöÑÊ≠£ÊñπÂΩ¢ËæπÈïø„ÄÇ‰ªé1ÂºÄÂßãÂæ™ÁéØÔºå‰∏äÂ∑¶‰∏ã‰∏â‰∏™Êñπ‰ΩçÊâæÊúÄÂ∞èÁöÑËæπÈïøÔºåÂõ†‰∏∫Â¶ÇÊûú‰∏â‰∏™Êñπ‰Ωç‰∏çÊòØ1ÂàôÊúÄÂ∞èÁöÑ‰∏∫0Ôºå‰πüÂ∞±Â§ü‰∏çÊàêÊõ¥Â§ßÁöÑÊ≠£ÊñπÂΩ¢„ÄÇÊúÄÂêéÊõ¥Êñ∞max„ÄÇ 1277. Count Square Submatrices with All Ones üîóQuestion Link class Solution &#123; public int countSquares(int[][] matrix) &#123; int res = 0; int m = matrix.length; int n = matrix[0].length; for(int i = 0 ; i&lt; m ;i++)&#123; for(int j = 0; j&lt;n ;j++)&#123; if(matrix[i][j] == 1)&#123; if(i&gt;0 &amp;&amp; j &gt;0)&#123; matrix[i][j] = Math.min(matrix[i-1][j-1], Math.min(matrix[i][j-1],matrix[i-1][j]))+1; &#125; res+=matrix[i][j]; &#125;else&#123; continue; &#125; &#125; &#125; return res; &#125;&#125; Âíå221Á±ª‰ººÁöÑÊÄùË∑Ø„ÄÇËøôÈáå‰ªé0ÂºÄÂßãÈÅçÂéÜÔºåin placeÊîπÂèòmatrix„ÄÇmatrix[i][j]Â≠òÊúÄÂ§ßÁöÑÊ≠£ÊñπÂΩ¢ËæπÈïøÔºåÂêåÊó∂‰πüÊòØ‰ª•ËØ•‰ΩçÁΩÆ‰∏∫Âè≥‰∏ãËßíÁöÑÊ≠£ÊñπÂΩ¢‰∏™Êï∞„ÄÇ 1 11 1 Ê≠§Êó∂Âè≥‰∏ãËßíÁöÑmatrixÂÄº‰∏∫2ÔºåËÄå‰∫éÊ≠§ÂêåÊó∂‰ª•Âè≥‰∏ãËßíÁöÑ1‰∏∫Ê≠£ÊñπÂΩ¢ÁöÑ‰∏™Êï∞‰πüÊòØ2Ôºö‰∏Ä‰∏™ÂçïÁã¨ÁöÑÂè≥‰∏ãËßí1ÔºåËá™Â∑±ÊûÑÊàêÂ∞èÊ≠£ÊñπÂΩ¢Ôºõ‰∏Ä‰∏™ËæπÈïø‰∏∫2ÁöÑsquare„ÄÇ 70. Climbing Stairs üîóQuestion Link class Solution &#123; public int climbStairs(int n) &#123; int[] dp = new int[n+1]; if(n == 1)return 1; if(n == 2)return 2; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3 ; i&lt;= n ;i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n]; &#125;&#125; ÁªèÂÖ∏Ë¥πÁ∫≥Ê≥¢ÂàáÊï∞Âàódp„ÄÇ 746. Min Cost Climbing Stairs üîóQuestion Link class Solution &#123; public int minCostClimbingStairs(int[] cost) &#123; int first = cost[0]; int second = cost[1]; for(int i = 2; i&lt;cost.length ;i++)&#123; cost[i] = Math.min(first, second) + cost[i]; first = second; second = cost[i]; &#125; return Math.min(first,second); &#125;&#125; Áî±‰∫éÊØèÊ¨°Âè™ËÉΩËµ∞1or2‰∏™ÔºåÊâÄ‰ª•‰ªéÁ¨¨‰∏â‰∏™ÂºÄÂßãÔºåÈÄâÂâçÈù¢‰∏§‰∏™‰∏≠ÊúÄÂ∞ëÁöÑ‰∏Ä‰∏™ÔºåÊõ¥Êñ∞firstÂíåsecondÁöÑÂÄºÔºåÊúÄÂêéËøîÂõû‰∫åËÄÖ‰∏≠ÁöÑmin„ÄÇ 1137. N-th Tribonacci Number üîóQuestion Link class Solution &#123; public int tribonacci(int n) &#123; int first = 0, second = 1 , third = 1; for(int i=0;i&lt;n;i++)&#123; int next = first + second + third; first = second; second = third; third = next; &#125; return first; &#125;&#125; ÊÄùË∑ØÂíå‰∏ä‰∏ÄÈÅìÈ¢òÂæàÂÉèÔºåÈÉΩÊòØÂè™ËÉΩËµ∞Âõ∫ÂÆöÊ≠•Êï∞„ÄÇÁÑ∂Âêé‰∏çÊñ≠Ëø≠‰ª£Êõ¥Êñ∞ÂÄºÔºåÊúÄÂêéËøîÂõûfirst„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Leetcode EveryDay 82 üí™","slug":"chin-up-20","date":"2020-02-18T17:13:23.000Z","updated":"2020-02-18T19:53:12.899Z","comments":true,"path":"2020/02/18/chin-up-20/","link":"","permalink":"WangHngLeee.github.io/2020/02/18/chin-up-20/","excerpt":"297. Serialize and Deserialize Binary Tree üîóQuestion Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial (TreeNode root, StringBuilder sb)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(root.left,sb); serial(root.right,sb); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue); &#125; public TreeNode deserial(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"n\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = deserial(queue); node.right = deserial(queue); return node; &#125;&#125; preorderÊñπÂºèserial„ÄÇsplit‰πãÂêéÂÜçpreorder deserial„ÄÇ","text":"297. Serialize and Deserialize Binary Tree üîóQuestion Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial (TreeNode root, StringBuilder sb)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(root.left,sb); serial(root.right,sb); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue); &#125; public TreeNode deserial(Queue&lt;String&gt; queue)&#123; String cur = queue.poll(); if(cur.equals(\"n\"))return null; TreeNode node = new TreeNode(Integer.parseInt(cur)); node.left = deserial(queue); node.right = deserial(queue); return node; &#125;&#125; preorderÊñπÂºèserial„ÄÇsplit‰πãÂêéÂÜçpreorder deserial„ÄÇ 449. Serialize and Deserialize BST üîóQuestion Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(root,sb); return sb.toString(); &#125; public void serial(TreeNode root, StringBuilder sb)&#123; if(root == null)return; sb.append(root.val).append(\" \"); serial(root.left, sb); serial(root.right, sb); &#125; public TreeNode deserialize(String data)&#123; if(data.isEmpty())return null; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return deserial(queue,Integer.MIN_VALUE, Integer.MAX_VALUE); &#125; public TreeNode deserial(Queue&lt;String&gt; queue,int min, int max)&#123; if(queue.isEmpty())return null; String s = queue.peek(); int val = Integer.parseInt(s); if(val &lt; min || val &gt; max)return null; queue.poll(); TreeNode node = new TreeNode(val); node.left = deserial(queue, min, val); node.right = deserial(queue,val,max); return node; &#125;&#125; Áî±‰∫éÊòØBSTÔºåÂèØ‰ª•ËÆæÁΩÆ‰∏ä‰∏ãÁïåÊù•Âú®deserialÁöÑÊó∂ÂÄôÂà§ÂÆöÊòØÂê¶‰∏∫null„ÄÇÂÖ∂‰ΩôÁöÑÂíå‰∏ä‰∏ÄÈÅìBTÁöÑ‰∏ÄÊ†∑„ÄÇ 508. Most Frequent Subtree Sum üîóQuestion Link class Solution &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; public int[] findFrequentTreeSum(TreeNode root) &#123; if(root == null)return new int[]&#123;&#125;; dfs(root); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int key : map.keySet())&#123; if(map.get(key) == max)&#123; list.add(key); &#125; &#125; int[] res = new int[list.size()]; for(int i= 0; i&lt; list.size();i++)&#123; res[i] = list.get(i); &#125; return res; &#125; public int dfs(TreeNode root)&#123; if(root == null)return 0; int s = dfs(root.left) + dfs(root.right) + root.val; map.put(s,map.getOrDefault(s,0)+1); max = Math.max(max,map.get(s)); return s; &#125;&#125; map + dfs„ÄÇmapÂ≠òsumÂíåÊ¨°Êï∞ÔºådfsÈÅçÂéÜÊâÄÊúârootÂæóÂà∞ÊâÄÊúâÁöÑsumÊÉÖÂÜµ„ÄÇ 124. Binary Tree Maximum Path Sum üîóQuestion Link class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇÊ≥®ÊÑèleftÂíårightÂú®dfsÁöÑÊó∂ÂÄôË¶ÅËÄÉËôëË¥üÊï∞ÊÉÖÂÜµÔºåÊâÄ‰ª•Ë¶ÅÂíå0Âèñmax„ÄÇ 543. Diameter of Binary Tree üîóQuestion Link class Solution &#123; int max = 0; public int diameterOfBinaryTree(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return -1; int left = help(root.left) + 1; int right = help(root.right) + 1; max = Math.max(max,left+right); return Math.max(left,right); &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇÈ¢òÁõÆÁöÑÊÑèÊÄùÂ∞±ÊòØË¶ÅÊ±ÇÊâæÂ∑¶Âè≥Â≠êÊ†ëÊúÄÂ§ßÊ∑±Â∫¶Âíå„ÄÇmaxË¶ÅÂíåÂ∑¶Âè≥ÂíåÊØîËæÉÔºåÁÑ∂ÂêéËøîÂõûÂ∑¶Âè≥ÁöÑÊúÄÂ§ßÂÄº„ÄÇ 687. Longest Univalue Path üîóQuestion Link class Solution &#123; int max = 0; public int longestUnivaluePath(TreeNode root) &#123; if(root == null)return 0; help(root,root.val); return max; &#125; public int help(TreeNode root, int val)&#123; if(root == null)return 0; int left = help(root.left,root.val); int right = help(root.right,root.val); max = Math.max(left+right,max); // we need find the max edges instead of node, so we dont have to +1. if(val == root.val)return Math.max(left,right)+1; else return 0; &#125;&#125; Âíå‰πãÂâçÁöÑ‰∏ç‰∏ÄÊ†∑ÔºåËøôÈÅìÈ¢òÊòØÊâæÁõ∏ÂêåÁöÑnode‰πãÈó¥ÊúÄÂ§ßÁöÑedgeÔºåÊâÄ‰ª•Âú®Êõ¥Êñ∞maxÁöÑÊó∂ÂÄôleft+right‰∏çÈúÄË¶ÅÂÜç+1‰∫Ü„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Weekly Contest 176 üèÜ","slug":"contest03","date":"2020-02-16T04:02:09.000Z","updated":"2020-03-01T05:12:23.593Z","comments":true,"path":"2020/02/15/contest03/","link":"","permalink":"WangHngLeee.github.io/2020/02/15/contest03/","excerpt":"üìå ‰ªäÂ§©ÂÅöÂá∫Êù•‰∏âÈ¢òÔºå‰ΩÜÊòØÊúÄÂêé‰∏ÄÈ¢òÊ≠£Â•ΩÂç°Âú®Êó∂Èó¥ÁÇπ‰∏äÔºåÊ≤°ÊúâÁÆóËøõÂéªÔºå‰∏çËøáÊó†ÊâÄË∞ì‰∫ÜÔºåÁªßÁª≠Âä™Âäõ„ÄÇ 1354. Construct Target Array With Multiple Sums üîóQuestion Link ËøôÈÅìÈ¢òÊàëÂÜôÁöÑÈ¢òËß£voteÊï∞ÈáèÂú®discussÂå∫ÊéíÂâç‰∏â My Discuss Linküîó[Java] Think the problem from the end to start. ÊÑüËßâËøòÊòØÊå∫ÊúâÊî∂Ëé∑ÁöÑÔºåÊÄùË∑ØÊå∫ÊúâË∂£„ÄÇ My solution class Solution &#123; public boolean isPossible(int[] target) &#123; int max = 0; int index = 0; for(int i= 0; i&lt; target.length ;i++)&#123; if(target[i] &gt; max)&#123; max = target[i]; index = i; &#125; &#125; if(max == 1) return true; for(int i = 0 ;i&lt; target.length ;i++)&#123; if(i == index)continue; if(target[i] &gt; max)return false; max = max - target[i]; &#125; target[index] = max; return isPossible(target); &#125;&#125; Êï¥‰ΩìÊÄùË∑ØÂ∞±ÊòØÈÄÜÂêëÊÄùËÄÉ„ÄÇÊØèÊ¨°ÊâæarrayÈáåÊúÄÂ§ßÁöÑ‰∏Ä‰∏™Êï∞ÔºåÁî®ÂÆÉÂáèÂéªÂâ©‰∏ãÁöÑÊâÄÊúânumÔºåÂæóÂà∞ÁöÑÂÄºÂ∞±ÊòØ‰∏ä‰∏ÄËΩÆËØ•‰ΩçÁΩÆË¢´Êõ¥ÊîπÂâçÁöÑÂÄº„ÄÇÊé•ÁùÄÊàë‰ª¨ÊääËøô‰∏™‰ΩçÁΩÆÁöÑÊõøÊç¢ÊéâÔºåÁªßÁª≠Âæ™ÁéØ„ÄÇÂú®Á¨¨‰∫å‰∏™Âæ™ÁéØÈáåÔºåÈúÄË¶ÅË∑≥ËøáÊúÄÂ§ßÂÄºÁöÑindexÔºåÂπ∂‰∏îË¶ÅÊ£ÄÊü•Ââ©‰∏ãÁöÑÊâÄÊúânumÊòØÂê¶ÈÉΩÂ∞è‰∫éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÊûú‰∏çÊòØÂàôÁõ¥Êé•ËøîÂõûfalse„ÄÇËØ¶ÁªÜËß£ÊûêÂú®discuss„ÄÇ","text":"üìå ‰ªäÂ§©ÂÅöÂá∫Êù•‰∏âÈ¢òÔºå‰ΩÜÊòØÊúÄÂêé‰∏ÄÈ¢òÊ≠£Â•ΩÂç°Âú®Êó∂Èó¥ÁÇπ‰∏äÔºåÊ≤°ÊúâÁÆóËøõÂéªÔºå‰∏çËøáÊó†ÊâÄË∞ì‰∫ÜÔºåÁªßÁª≠Âä™Âäõ„ÄÇ 1354. Construct Target Array With Multiple Sums üîóQuestion Link ËøôÈÅìÈ¢òÊàëÂÜôÁöÑÈ¢òËß£voteÊï∞ÈáèÂú®discussÂå∫ÊéíÂâç‰∏â My Discuss Linküîó[Java] Think the problem from the end to start. ÊÑüËßâËøòÊòØÊå∫ÊúâÊî∂Ëé∑ÁöÑÔºåÊÄùË∑ØÊå∫ÊúâË∂£„ÄÇ My solution class Solution &#123; public boolean isPossible(int[] target) &#123; int max = 0; int index = 0; for(int i= 0; i&lt; target.length ;i++)&#123; if(target[i] &gt; max)&#123; max = target[i]; index = i; &#125; &#125; if(max == 1) return true; for(int i = 0 ;i&lt; target.length ;i++)&#123; if(i == index)continue; if(target[i] &gt; max)return false; max = max - target[i]; &#125; target[index] = max; return isPossible(target); &#125;&#125; Êï¥‰ΩìÊÄùË∑ØÂ∞±ÊòØÈÄÜÂêëÊÄùËÄÉ„ÄÇÊØèÊ¨°ÊâæarrayÈáåÊúÄÂ§ßÁöÑ‰∏Ä‰∏™Êï∞ÔºåÁî®ÂÆÉÂáèÂéªÂâ©‰∏ãÁöÑÊâÄÊúânumÔºåÂæóÂà∞ÁöÑÂÄºÂ∞±ÊòØ‰∏ä‰∏ÄËΩÆËØ•‰ΩçÁΩÆË¢´Êõ¥ÊîπÂâçÁöÑÂÄº„ÄÇÊé•ÁùÄÊàë‰ª¨ÊääËøô‰∏™‰ΩçÁΩÆÁöÑÊõøÊç¢ÊéâÔºåÁªßÁª≠Âæ™ÁéØ„ÄÇÂú®Á¨¨‰∫å‰∏™Âæ™ÁéØÈáåÔºåÈúÄË¶ÅË∑≥ËøáÊúÄÂ§ßÂÄºÁöÑindexÔºåÂπ∂‰∏îË¶ÅÊ£ÄÊü•Ââ©‰∏ãÁöÑÊâÄÊúânumÊòØÂê¶ÈÉΩÂ∞è‰∫éÊúÄÂ§ßÂÄºÔºåÂ¶ÇÊûú‰∏çÊòØÂàôÁõ¥Êé•ËøîÂõûfalse„ÄÇËØ¶ÁªÜËß£ÊûêÂú®discuss„ÄÇ 1351. Count Negative Numbers in a Sorted Matrix üîóQuestion Link First Solution class Solution &#123; public int countNegatives(int[][] grid) &#123; int sum = 0; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; for(int i= 0; i&lt; m;i++)&#123; for(int j= 0;j&lt;n ;j++)&#123; if(grid[i][j] &lt; 0)sum++; &#125; &#125; return sum; &#125;&#125; ÁªèÂÖ∏ÁöÑÈÅçÂéÜgraph„ÄÇO(N^2)Â§çÊùÇÂ∫¶„ÄÇ Optimized Solution ++++++++++--++++--+++---+-----+----- graphÊ≠£Ë¥üÊÉÖÂÜµÂ¶Ç‰∏äÂõæÔºåÂÖ∂ÂÆûÂæàÂÉèsearch 2D matrix IIËøôÈÅìÈ¢òÔºå‰ªéÂ∑¶‰∏äÊàñËÄÖÂè≥‰∏äÊâ´ÊèèÔºå‰øùËØÅÊòØO(N)ÁöÑÂ§çÊùÇÂ∫¶„ÄÇ class Solution&#123; public int countNegatives(int[][] grid) &#123; int m = grid.length, n = grid[0].length, r = m - 1, c = 0, cnt = 0; while (r &gt;= 0 &amp;&amp; c &lt; n) &#123; if (grid[r][c] &lt; 0) &#123; --r; cnt += n - c; // there are n - c negative numbers in current row. &#125;else &#123; ++c; &#125; &#125; return cnt; &#125;&#125; 1352. Product of the Last K Numbers üîóQuestion Link class ProductOfNumbers &#123; List&lt;Integer&gt; list; public ProductOfNumbers() &#123; list = new ArrayList&lt;&gt;(); &#125; public void add(int num) &#123; list.add(num); &#125; public int getProduct(int k) &#123; int len = list.size()-1; int sum = 1; for(int i= 0;i&lt;k;i++)&#123; sum = sum * list.get(len-i); &#125; return sum; &#125;&#125; Using list to store the nums. Then we make k loops from the tail.","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 81 üí™","slug":"chin-up-19","date":"2020-02-15T17:13:23.000Z","updated":"2020-02-18T18:12:10.598Z","comments":true,"path":"2020/02/15/chin-up-19/","link":"","permalink":"WangHngLeee.github.io/2020/02/15/chin-up-19/","excerpt":"128. Longest Consecutive Sequence üîóQuestion Link class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; // corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();// num --&gt; ËøûÁª≠ÈïøÂ∫¶ int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.containsKey(num-1) ? map.get(num-1) : 0;//Â∑¶ËæπËøûÁª≠ÈïøÂ∫¶ int right = map.containsKey(num + 1) ? map.get(num + 1) : 0;//Âè≥ËæπËøûÁª≠ÈïøÂ∫¶ sum+= left + right + 1; //Êõ¥Êñ∞ÊÄªÈïøÂ∫¶ // change the current num's maxlen ËøûÁª≠ÈïøÂ∫¶ map.put(num,sum); max = Math.max(max,sum);//Êõ¥Êñ∞max map.put(num - left, sum);//Êõ¥Êñ∞ÊúÄÂ∑¶ËæπnumÁöÑÈïøÂ∫¶ map.put(num + right, sum);//Êõ¥Êñ∞ÊúÄÂè≥ËæπnumÈïøÂ∫¶ &#125;else&#123; continue;// duplicate case &#125; &#125; return max; &#125;&#125; ÂÜôÂú®Ê≥®ÈáäÈáå„ÄÇ","text":"128. Longest Consecutive Sequence üîóQuestion Link class Solution &#123; public int longestConsecutive(int[] nums) &#123; if(nums == null || nums.length == 0)return 0; // corner case Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();// num --&gt; ËøûÁª≠ÈïøÂ∫¶ int max = 0; for(int num : nums)&#123; if(!map.containsKey(num))&#123; int sum = 0; int left = map.containsKey(num-1) ? map.get(num-1) : 0;//Â∑¶ËæπËøûÁª≠ÈïøÂ∫¶ int right = map.containsKey(num + 1) ? map.get(num + 1) : 0;//Âè≥ËæπËøûÁª≠ÈïøÂ∫¶ sum+= left + right + 1; //Êõ¥Êñ∞ÊÄªÈïøÂ∫¶ // change the current num's maxlen ËøûÁª≠ÈïøÂ∫¶ map.put(num,sum); max = Math.max(max,sum);//Êõ¥Êñ∞max map.put(num - left, sum);//Êõ¥Êñ∞ÊúÄÂ∑¶ËæπnumÁöÑÈïøÂ∫¶ map.put(num + right, sum);//Êõ¥Êñ∞ÊúÄÂè≥ËæπnumÈïøÂ∫¶ &#125;else&#123; continue;// duplicate case &#125; &#125; return max; &#125;&#125; ÂÜôÂú®Ê≥®ÈáäÈáå„ÄÇ 112. Path Sum üîóQuestion Link class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null)return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)return true; return hasPathSum(root.left,sum-root.val) || hasPathSum(root.right,sum - root.val); &#125;&#125; Ê≠£Â∏∏ÈÄíÂΩí„ÄÇ 113. Path Sum II üîóQuestion Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res,sum,templist); return res; &#125; public void help(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res, int sum, List&lt;Integer&gt; templist)&#123; if(root == null)return; templist.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)res.add(new ArrayList&lt;&gt;(templist)); else&#123; help(root.left,res,sum - root.val, templist); help(root.right,res,sum - root.val, templist); &#125; templist.remove(templist.size() -1); &#125;&#125; dfs + backtracking„ÄÇ 437. Path Sum III üîóQuestion Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,sum,0,map); return total; &#125; public void help(TreeNode root, int sum, int cursum, Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - sum))&#123; total+=map.get(cursum - sum); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,sum,cursum,map); help(root.right,sum,cursum,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; dfs + backtracking + presum„ÄÇ 129. Sum Root to Leaf Numbers üîóQuestion Link class Solution &#123; public int sumNumbers(TreeNode root) &#123; if(root == null)return 0; int res = help(root,0); return res; &#125; public int help(TreeNode root,int sum)&#123; if(root == null)return 0; sum = sum*10 + root.val; if(root.left == null &amp;&amp; root.right == null)return sum; int leftsum = help(root.left,sum); int rightsum = help(root.right,sum); return leftsum + rightsum; &#125;&#125; recursionÈáåËÆ°ÁÆósumÂπ∂‰∏î‰º†‰∏ãÂéª„ÄÇ‰∏ÄÂºÄÂßãÁî®dfs+backtracking+ËΩ¨numÂíåÈ∫ªÁÉ¶‰∫ÜÔºåËøô‰∏™ÁÆÄÂçï„ÄÇ 257. Binary Tree Paths üîóQuestion Link class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; StringBuilder sb = new StringBuilder(); help(root,sb,res); return res; &#125; public void help(TreeNode root, StringBuilder sb, List&lt;String&gt; res)&#123; if(root == null)return; int len = sb.length(); sb.append(root.val); if(root.left == null &amp;&amp; root.right == null)&#123; res.add(sb.toString()); &#125; sb.append(\"-&gt;\"); help(root.left,sb,res); help(root.right,sb,res); sb.setLength(len); &#125;&#125; dfs + backtracking.Ê≥®ÊÑèsb appendÁöÑÈ°∫Â∫è„ÄÇ‰∏ÄËà¨ÈÉΩÊòØÂÖàÂä†ÂÖ•list‰πãÂêéÂú®Âà§Êñ≠ÊòØÂê¶‰∏∫Âè∂ËäÇÁÇπ„ÄÇÂê¶ÂàôÂÆπÊòìÊºèÊéâ„ÄÇ 437. Path Sum III üîóQuestion Link class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left,p,q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right,p,q); &#125; return root; &#125;&#125; Áî±‰∫éÊòØBSTÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÈÄöËøáÂ§ßÂ∞èÂà§Êñ≠Â∞±ÂèØ‰ª•ÈÄâÊã©Â∑¶Âè≥Â≠êÊ†ë„ÄÇÂ¶ÇÊûúÂΩìÂâçrootÂÖ®ÈÉ®Â∞è‰∫ép,qÂàôËØ¥ÊòélcaÂú®Âè≥ËæπÁöÑtree„ÄÇËã•ÂÖ®Â∞è‰∫épÔºåqÂàôÂú®Â∑¶Ëæπ„ÄÇÂ¶ÇÊûúÂ§ß‰∫épÂ∞è‰∫éqÂàô‰ªñËá™Â∑±Êú¨Ë∫´Â∞±ÊòØÔºåÂ¶ÇÊûúÂ∞è‰∫épÂ§ß‰∫éqÂàôÊòØ‰∏çÂèØËÉΩ‰∫ã‰ª∂ÔºåËøîÂõûroot„ÄÇ 257. Binary Tree Paths üîóQuestion Link class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; return root; &#125;&#125; ‰∏çÊòØBSTÔºåÂè™ÊòØÂçïÁ∫ØÁöÑ‰∫åÂèâÊ†ë‰∫Ü„ÄÇ‰∏çËÉΩÁî®Â§ßÂ∞èËæπÁïåÊù•Âà§Êñ≠‰∫Ü„ÄÇË¶ÅÂàÜÊÉÖÂÜµÈÄíÂΩíËÆ®ËÆ∫„ÄÇ root‰∏∫Á©∫ÊàñËÄÖ rootÂè™‰∏∫pq‰∏≠ÁöÑ‰∏ÄËÄÖÔºåÈÇ£‰πàÁõ¥Êé•ËøîÂõûÂΩìÂâçroot„ÄÇ ÈÄíÂΩíÊâæÂ∑¶Âè≥Â≠êÊ†ë‰∏≠pqÁöÑlcaÔºåÂ¶ÇÊûúleft‰∏∫Á©∫ÔºåËØ¥ÊòéÂè™ËÉΩÂú®rightÔºåËøîÂõûright„ÄÇ Âèç‰πãËøîÂõûleft„ÄÇ Â¶ÇÊûúleftÂíåright1ÈÉΩ‰∏ç‰∏∫nullÔºåËØ¥Êòép q ‰∫åËÄÖÂêÑËá™ÂàÜÂ∏ÉÂú®Â∑¶Âè≥‰∏≠ÔºåÊâÄ‰ª•ËøîÂõûÂΩìÂâçroot„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"}]},{"title":"Leetcode EveryDay 80 üí™","slug":"chin-up-18","date":"2020-02-14T17:13:23.000Z","updated":"2020-02-14T21:37:55.471Z","comments":true,"path":"2020/02/14/chin-up-18/","link":"","permalink":"WangHngLeee.github.io/2020/02/14/chin-up-18/","excerpt":"872. Leaf-Similar Trees üîóQuestion Link class Solution &#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root1); stack2.push(root2); while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())&#123; if(getleaf(stack1) != getleaf(stack2))return false; &#125; return true; &#125; public int getleaf(Stack&lt;TreeNode&gt; stack)&#123; while(true)&#123; TreeNode node = stack.pop(); if(node.left != null)stack.push(node.left); if(node.right != null)stack.push(node.right); if(node.left == null &amp;&amp; node.right == null)return node.val; &#125; &#125;&#125; ‰∏§‰∏™stack dfsÊâæÂè∂ËäÇÁÇπÔºåÁî±‰∫éÂêåÊó∂ÊâæÊâÄ‰ª•ÊØîËæÉÁöÑ‰πüÊòØÂêå‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÂè∂ËäÇÁÇπ„ÄÇÊ≥®ÊÑèwhile(true)ÁöÑÂÜôÊ≥ï„ÄÇ","text":"872. Leaf-Similar Trees üîóQuestion Link class Solution &#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;(); stack1.push(root1); stack2.push(root2); while(!stack1.isEmpty() &amp;&amp; !stack2.isEmpty())&#123; if(getleaf(stack1) != getleaf(stack2))return false; &#125; return true; &#125; public int getleaf(Stack&lt;TreeNode&gt; stack)&#123; while(true)&#123; TreeNode node = stack.pop(); if(node.left != null)stack.push(node.left); if(node.right != null)stack.push(node.right); if(node.left == null &amp;&amp; node.right == null)return node.val; &#125; &#125;&#125; ‰∏§‰∏™stack dfsÊâæÂè∂ËäÇÁÇπÔºåÁî±‰∫éÂêåÊó∂ÊâæÊâÄ‰ª•ÊØîËæÉÁöÑ‰πüÊòØÂêå‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÂè∂ËäÇÁÇπ„ÄÇÊ≥®ÊÑèwhile(true)ÁöÑÂÜôÊ≥ï„ÄÇ 669. Trim a Binary Search Tree üîóQuestion Link class Solution &#123; public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root == null)return root; if(root.val &lt; L)return trimBST(root.right,L,R); if(root.val &gt; R)return trimBST(root.left,L,R); root.left = trimBST(root.left,L,R); root.right = trimBST(root.right,L,R); return root; &#125;&#125; Âà†ÊéâË∂ÖÂá∫LÔºåRËåÉÂõ¥ÂÜÖÁöÑËäÇÁÇπ„ÄÇÈÄíÂΩíÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ 1325. Delete Leaves With a Given Value üîóQuestion Link class Solution &#123; public TreeNode removeLeafNodes(TreeNode root, int target) &#123; if(root == null)return root; if(root.left != null)root.left = removeLeafNodes(root.left,target); if(root.right != null)root.right = removeLeafNodes(root.right,target); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == target)return null; else&#123; return root; &#125; &#125;&#125; recursive„ÄÇ Ê≥®ÊÑèÊúÄÂêéËøîÂõûÂÄºÔºåÂ¶ÇÊûúÂΩìÂâçÊòØleafÂπ∂‰∏îvalÁ≠â‰∫étargetÔºåË¶ÅËøîÂõûnullÔºåÂê¶ÂàôËøîÂõûÂéünode„ÄÇ 814. Binary Tree Pruning üîóQuestion Link class Solution &#123; public TreeNode pruneTree(TreeNode root) &#123; if(root == null)return null; if(root.left != null)root.left = pruneTree(root.left); if(root.right!= null)root.right = pruneTre(root.right); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0)return null; else return root; &#125;&#125; ‰ª£Á†ÅÂÖ∂ÂÆûÂíå1325‰∏ÄÊ†∑„ÄÇ1325ÊòØÂéªÊéâÊåáÂÆöÂÄºÁöÑÊâÄÊúâtargetÔºåËøôÈÅìÈ¢òÊòØË¶ÅÂà†ÊéâÊâÄÊúâ0ÁöÑsubtreeÔºåÂÖ∂ÂÆûÊÄßË¥®ÊòØ‰∏ÄÊ†∑ÁöÑÔºåcollect node‰πãÂêéÂà†Êéâ„ÄÇ‰ªéÂè∂ËäÇÁÇπÂêë‰∏äÂâ•Ê¥ãËë±„ÄÇ 684. Redundant Connection üîóQuestion Link class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int[] parents = new int[edges.length+1]; for(int i = 0 ;i&lt;edges.length ;i++)&#123; parents[i] = i; &#125; for(int[] link : edges)&#123; int root1 = find(parents,link[0]); int root2 = find(parents,link[1]); if(root1 == root2)&#123; return link; &#125; parents[root1] = root2; &#125; return new int[]&#123;&#125;; &#125; public int find(int[] parents, int i)&#123; if(i == parents[i])return i; return parents[i] = find(parents,parents[i]); &#125;&#125; union find „ÄÇ Â¶ÇÊûúÊâæÂà∞‰∏§‰∏™ÁÇπroot‰∏ÄÊ†∑ÔºåÂàôËØ¥Êòé‰πãÂâçÂ∑≤ÁªèlinkËøáÔºåÊòØÂ§ö‰ΩôÁöÑÔºåÁõ¥Êé•ËøîÂõû„ÄÇ 1319. Number of Operations to Make Network Connected üîóQuestion Link class Solution &#123; public int makeConnected(int n, int[][] connections) &#123; if(connections.length == 0 || connections == null)return -1; if(connections.length &lt; n-1)return -1; int[] parents = new int[n]; for(int i =0;i&lt;parents.length ;i++)&#123; parents[i] = i; &#125; int remain = n; for(int[] link : connections)&#123; int root1 = find(parents,link[0]); int root2 = find(parents, link[1]); if( root1 != root2)&#123; remain--; parents[root1] = root2; &#125; &#125; return remain -1; &#125; public int find(int[] parents, int a)&#123; if(parents[a] == a)return a; return parents[a] = find(parents, parents[a]); &#125;&#125; union find„ÄÇËÆ∞ÂΩïremainsÂâ©‰∏ãÊ≤°ËøûÊé•ÁöÑ‰∏™Êï∞ÔºåÊâÄ‰ª•ÊúÄÂêéÊúÄÂ∞ëÊï∞ÈáèÊòØÂâ©‰∏ãÁöÑ‰∏™Êï∞-„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"}]},{"title":"Leetcode EveryDay 79 üí™","slug":"chin-up-17","date":"2020-02-12T18:13:23.000Z","updated":"2020-02-13T02:44:13.480Z","comments":true,"path":"2020/02/12/chin-up-17/","link":"","permalink":"WangHngLeee.github.io/2020/02/12/chin-up-17/","excerpt":"","text":"99. Recover Binary Search Tree üîóQuestion Link class Solution &#123; public void recoverTree(TreeNode root) &#123; TreeNode pre = null; TreeNode first = null; TreeNode second = null; if(root == null)return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root!=null)&#123; stack.push(root); root = root.left; &#125; while(!stack.isEmpty())&#123; TreeNode temp = stack.pop(); if(pre!=null)&#123; if(pre.val &gt; temp.val)&#123; if(first == null)&#123; first = pre; &#125; second = temp; &#125; &#125; pre = temp; if(temp.right!=null)&#123; temp = temp.right; while(temp!=null)&#123; stack.push(temp); temp = temp.left; &#125; &#125; &#125; int temp = first.val; first.val = second.val; second.val = temp; &#125;&#125; in-orderÊ∑±Â∫¶ÈÅçÂéÜ„ÄÇÁÑ∂Âêé‰æùÊ¨°popÔºåÊâæÂà∞Á¨¨‰∏Ä‰∏™preÂ§ß‰∫écurÁöÑÔºåÂàôpreÊòØÁ¨¨‰∏Ä‰∏™ÈîôËØØÁöÑÂú∞ÊñπÔºåÁ¥ßÊé•ÁùÄÊâæÁ¨¨‰∫å‰∏™ÔºåÂ¶ÇÊûú‰πãÂâçfirst‰∏ç‰∏∫Á©∫ÔºåËØ¥ÊòéÊâæÂà∞‰∫ÜÔºåÂàôÊääÂΩìÂâçÁöÑÁªôsecond„ÄÇÊúÄÂêéswap‰∏Ä‰∏ãÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇ 450. Delete Node in a BST üîóQuestion Link class Solution &#123; public TreeNode deleteNode(TreeNode root, int key) &#123; if(root == null)return null; if(root.val &gt; key)root.left = deleteNode(root.left,key); else if(root.val &lt; key)root.right = deleteNode(root.right,key); else&#123; if(root.left == null)return root.right; if(root.right == null)return root.left; TreeNode smallest = root.right; while(smallest.left!=null)&#123; smallest = smallest.left; &#125; smallest.left = root.left; return root.right; &#125; return root; &#125;&#125; recursive.ÊâæÂà∞keyÂêéÔºåÂà§Êñ≠Â∑¶Âè≥ÊòØÂê¶‰∏∫Á©∫ÔºåÂ¶ÇÊûúÈÉΩ‰∏ç‰∏∫Á©∫ÔºåÂàôÂéªÂè≥Â≠êÊ†ëÊâæÊúÄÂ∞èÂÄºÔºåÊâæÂà∞ÂêéÊääÂΩìÂâçrootÂ∑¶Ê†ëÁªôÂà∞ÊúÄÂ∞èÂÄºÁöÑÂ∑¶Ê†ëÔºåËøîÂõûÊúÄÂ∞èÂÄºÁöÑÂè≥Ê†ë„ÄÇ Time : O(h) -&gt; h is the height of tree. 501. Find Mode in Binary Search Tree üîóQuestion Link class Solution &#123; int max = 0; public int[] findMode(TreeNode root) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; TreeNode temp = queue.poll(); if(temp!=null)&#123; map.put(temp.val,map.getOrDefault(temp.val,0)+1); max = Math.max(max,map.get(temp.val)); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; &#125; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int key : map.keySet())&#123; if(map.get(key) == max)&#123; res.add(key); &#125; &#125; int[] ans = new int[res.size()]; int i=0; for(int a : res)&#123; ans[i] = a; i++; &#125; return ans; &#125;&#125; level traversal + map„ÄÇ keep max to store the max frequency. 1302. Deepest Leaves Sum üîóQuestion Link class Solution &#123; public int deepestLeavesSum(TreeNode root) &#123; if(root == null)return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int res = 0; while(!queue.isEmpty())&#123; int size = queue.size(); res = 0; for(int i=0 ;i&lt;size ;i++)&#123; TreeNode temp = queue.poll(); res += temp.val; if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; ÂÖ∏Âûãlevel traversalÈáåÂä†‰∏Ä‰∏™resÊù•ËÆ°ÁÆóÂΩìÂâçpopÂá∫ÁöÑÊâÄÊúâËäÇÁÇπÁöÑÂíåÔºå‰ΩÜÊòØÊØèÊ¨°Ë¶ÅÂΩíÈõ∂ÔºåÊúÄÂêéËøîÂõûÁöÑÊâçÊòØÊúÄÂêé‰∏ÄÂ±ÇÁöÑnodeÁöÑÂíå„ÄÇ 429. N-ary Tree Level Order Traversal üîóQuestion Link class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i=0 ;i&lt;size ;i++)&#123; Node temp = queue.poll(); templist.add(temp.val); for(Node child : temp.children)&#123; if(child!=null)&#123; queue.add(child); &#125; &#125; &#125; res.add(templist); &#125; return res; &#125;&#125; ÂÖ∏ÂûãÂ±ÇÊ¨°ÈÅçÂéÜÔºåÂè™‰∏çËøáÂà§Êñ≠Â∑¶Âè≥Â≠©Â≠êÁöÑÊó∂ÂÄôÂèòÊàê‰∫ÜÂØπchildrenÁöÑÈÅçÂéÜ„ÄÇ 589. N-ary Tree Preorder Traversal üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public void help(Node root, List&lt;Integer&gt; res)&#123; if(root == null)return; res.add(root.val); for(Node child : root.children)&#123; help(child,res); &#125; &#125;&#125; preorderÈ°∫Â∫è„ÄÇÊ†π - Â∑¶ -Âè≥„ÄÇÂÖàÂØπÊ†πÂä†ÂÖ•resÔºåÂÜçÂØπÂ∑¶Âè≥Â≠©Â≠êÊìç‰Ωú„ÄÇ 590. N-ary Tree Postorder Traversal üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public void help(Node root, List&lt;Integer&gt; res)&#123; if(root == null)return; for(Node child : root.children)&#123; help(child,res); &#125; res.add(root.val); &#125;&#125; postorderÈ°∫Â∫è„ÄÇ 987. Vertical Order Traversal of a Binary Tree üîóQuestion Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; public pair(int x, int y, TreeNode n)&#123; this.x = x; this.y = y; node = n; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(0,0,root)); int min = 0; int max = 0; while(!queue.isEmpty())&#123; pair temp = queue.poll(); min = Math.min(min,temp.x); max = Math.max(max,temp.x); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(new pair(temp.x,temp.y,temp.node)); if(temp.node.left!=null)queue.add(new pair(temp.x-1,temp.y+1,temp.node.left)); if(temp.node.right!=null)queue.add(new pair(temp.x+1,temp.y+1,temp.node.right)); &#125; for(int i= min ;i&lt;= max; i++)&#123; Collections.sort(map.get(i), (a,b)-&gt; a.y == b.y ? a.node.val - b.node.val : 0); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j = 0; j&lt;map.get(i).size() ;j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; new ‰∏Ä‰∏™class Â≠ò x,y,node„ÄÇ mapÂ≠òÁõ∏ÂØπÂ∫îxÁöÑnodeÔºåÁÑ∂Âêé‰ªéÂ∑¶Âà∞Âè≥Ôºå‰ªémin-maxÂØπmapÈáåÂØπnodeËøõË°åÊéíÂ∫èÔºåÂ¶ÇÊûúÂêå‰∏ÄÂàóÁöÑnode yÂùêÊ†á‰πüÁõ∏ÂêåÔºåÂàôÊåâÂ∞èÂà∞Â§ßÊéíÔºåÂ¶ÇÊûú‰∏çÊòØÂàô‰∏çÊîπÂèòÈ°∫Â∫è„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 78 üí™","slug":"chin-up-16","date":"2020-02-11T18:13:23.000Z","updated":"2020-02-13T02:44:04.831Z","comments":true,"path":"2020/02/11/chin-up-16/","link":"","permalink":"WangHngLeee.github.io/2020/02/11/chin-up-16/","excerpt":"990. Satisfiability of Equality Equations üîóQuestion Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26 ;i++)&#123; UF[i] = i; // initialiaze uf array &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; // == case, the same as link between the two Â≠óÊØç UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a'); &#125; &#125; for(String str : equations)&#123; if( str.charAt(1) == '!')&#123; // != case, means cut off the link between two Â≠óÊØç if ( find(str.charAt(0)-'a') == find( str.charAt(3) -'a')) &#123; // only if the two char has been linked before but it is in != case then we can return false return false; &#125; &#125; &#125; return true; &#125; public int find(int a)&#123; // classic find function if( a!= UF[a]) UF[a] = find(UF[a]); return UF[a]; &#125;&#125; ufÊää==ÁöÑ‰∏§‰∏™Â≠óÊØçËøûËµ∑Êù•„ÄÇÁÑ∂ÂêéÂéªÂà§Êñ≠ÔºÅ=ÁöÑÊÉÖÂÜµÈáåÔºåÂ¶ÇÊûú‰∏§‰∏™Â≠óÊØçÂ∑≤ÁªèÊòØunionÁöÑ‰∫ÜÔºå‰ΩÜÊòØÂ§ÑÂú®ÔºÅ=ÊÉÖÂÜµÈáåÔºåÂàôËøîÂõûfalseÔºåË°®ÊòéËøô‰∏™ÊñπÁ®ãÁªÑÊó†Ëß£„ÄÇ","text":"990. Satisfiability of Equality Equations üîóQuestion Link class Solution &#123; int[] UF = new int[26]; public boolean equationsPossible(String[] equations) &#123; if(equations.length == 0 || equations == null)return false; // corner case for(int i=0 ;i&lt;26 ;i++)&#123; UF[i] = i; // initialiaze uf array &#125; for(String str : equations)&#123; if(str.charAt(1) == '=')&#123; // == case, the same as link between the two Â≠óÊØç UF[find(str.charAt(0)-'a')] = find(str.charAt(3)-'a'); &#125; &#125; for(String str : equations)&#123; if( str.charAt(1) == '!')&#123; // != case, means cut off the link between two Â≠óÊØç if ( find(str.charAt(0)-'a') == find( str.charAt(3) -'a')) &#123; // only if the two char has been linked before but it is in != case then we can return false return false; &#125; &#125; &#125; return true; &#125; public int find(int a)&#123; // classic find function if( a!= UF[a]) UF[a] = find(UF[a]); return UF[a]; &#125;&#125; ufÊää==ÁöÑ‰∏§‰∏™Â≠óÊØçËøûËµ∑Êù•„ÄÇÁÑ∂ÂêéÂéªÂà§Êñ≠ÔºÅ=ÁöÑÊÉÖÂÜµÈáåÔºåÂ¶ÇÊûú‰∏§‰∏™Â≠óÊØçÂ∑≤ÁªèÊòØunionÁöÑ‰∫ÜÔºå‰ΩÜÊòØÂ§ÑÂú®ÔºÅ=ÊÉÖÂÜµÈáåÔºåÂàôËøîÂõûfalseÔºåË°®ÊòéËøô‰∏™ÊñπÁ®ãÁªÑÊó†Ëß£„ÄÇ 98. Validate Binary Search Tree üîóQuestion Link class Solution &#123; public boolean isValidBST(TreeNode root)&#123; if(root == null) return true; return help(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean help(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val &lt;= min || root.val &gt;= max)return false; return help(root.left,min,root.val) &amp;&amp; help(root.right,root.val,max); &#125;&#125; recursive. BST ÁªèÂ∏∏Ë¶ÅÁî®ËÆæÁΩÆ‰∏ä‰∏ãÁïåÊù•Ëß£ÂÜ≥„ÄÇ 530. Minimum Absolute Difference in BST üîóQuestion Link Recursive class Solution &#123; int res = Integer.MAX_VALUE; public int getMinimumDifference(TreeNode root) &#123; if(root == null)return 0; help(root,Integer.MIN_VALUE,Integer.MAX_VALUE); return res; &#125; public void help(TreeNode root , int min, int max)&#123; if(root == null)return; if(min != Integer.MIN_VALUE)res=Math.min(res,root.val - min); if(max != Integer.MAX_VALUE)res=Math.min(res,max - root.val); help(root.left,min,root.val); help(root.right,root.val,max); &#125;&#125; Âíå‰∏ä‰∏ÄÈ¢ò‰∏ÄÊ†∑ÔºåËÆæÁΩÆ‰∏§‰∏™ËæπÁïåÔºåÊõ¥Êñ∞res‰∏∫ÊúÄÂ∞èÂÄºÂç≥ÂèØ„ÄÇ Stack Iteraive class Solution&#123; public int getMinimumDifference(TreeNode root)&#123; Stack&lt;TreeNode&gt;stack = new Stack&lt;&gt;(); int min = Integer.MAX_VALUE; TreeNode cur = root; TreeNode prev = null; while(cur!=null || !stack.isEmpty())&#123; if(cur!=null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); if(prev!=null)&#123; min = Math.min(min,cur.val - prev.val); &#125; prev = cur; cur = cur.right; &#125; &#125; return min; &#125;&#125; deep in-order traversal„ÄÇ BSTÂàôÊ∑±Â∫¶‰∏≠Â∫èÈÅçÂéÜÂ∞±ÂèØ‰ª•Ëß£ÂÜ≥„ÄÇËÆ∞‰Ωèstack traversalÊ®°Áâà„ÄÇ 700. Search in a Binary Search Tree üîóQuestion Link class Solution &#123; public TreeNode searchBST(TreeNode root, int val) &#123; if(root == null)return null; if(root.val &gt; val)return searchBST(root.left,val); if(root.val &lt; val)return searchBST(root.right,val); if(root.val == val)return root; return null; &#125;&#125; simple recursive with different cases with val and root.val. 701. Insert into a Binary Search Tree üîóQuestion Link class Solution &#123; public TreeNode insertIntoBST(TreeNode root, int val) &#123; if(root == null)return new TreeNode(val); if(root.val &lt; val)&#123; root.right = insertIntoBST(root.right,val); &#125; if(root.val &gt; val)&#123; root.left = insertIntoBST(root.left,val); &#125; return root; &#125;&#125; recursive. BSTÁªèÂ∏∏Áî®‰∏§‰∏™up / downÁöÑboundaryÊù•Âà§Êñ≠Êìç‰ΩúÊù°‰ª∂„ÄÇ 230. Kth Smallest Element in a BST üîóQuestion Link class Solution &#123; public int kthSmallest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null)return 0; TreeNode cur = root; while(cur!=null || !stack.isEmpty())&#123; if(cur!=null)&#123; stack.push(cur); cur = cur.left; &#125;else&#123; cur = stack.pop(); k--; if(k==0)return cur.val; cur = cur.right; &#125; &#125; return -1; &#125;&#125; ÂèàÊòØ‰∏ÄÈÅìBSTÊ∑±Â∫¶in-orderÁöÑÊÄùË∑Ø„ÄÇKth smallestÁöÑÈ¢ò„ÄÇ‰ªéÊúÄÂ∑¶ÂºÄÂßãÔºåÂ§ÑÁêÜÂà∞Á¨¨k‰∏™Â∞±ÊòØÁ¨¨kÂ∞è„ÄÇÂ¶ÇÊûúÊîπÊàêkth largestÔºåÂàôÂ∞±ÊòØÂ§ÑÁêÜÂà∞Á¨¨number of nodes -k‰∏™„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"}]},{"title":"Leetcode EveryDay 77 üí™","slug":"chin-up-15","date":"2020-02-10T19:13:23.000Z","updated":"2020-02-11T17:44:56.361Z","comments":true,"path":"2020/02/10/chin-up-15/","link":"","permalink":"WangHngLeee.github.io/2020/02/10/chin-up-15/","excerpt":"1267. Count Servers that Communicate üîóQuestion Link class Solution &#123; public int countServers(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int[] row = new int[m]; int[] col = new int[n]; int total = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; row[i]+=1; col[j]+=1; total++; &#125; &#125; &#125; for(int i=0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; if(row[i] == 1 &amp;&amp; col[j] == 1)&#123; total--; &#125; &#125; &#125; &#125; return total; &#125;&#125; col Âíå rowÁî®Êù•ËÆ∞ÂΩïËøô‰∏ÄË°åÊúâÂ§öÂ∞ë‰∏™ÁîµËÑëÔºåÂ¶ÇÊûúÊúÄÂêéÊüê‰∏™‰ΩçÁΩÆ‰∏∫ÁîµËÑëÂπ∂‰∏îÊâÄÂú®ÁöÑË°åÂíåÂàóÈÉΩÂè™Êúâ1‰∏™ÔºåÈÇ£‰πàÂ∞±ÊòØÊ≤°ÊúâËøûÊé•ÁöÑÔºåË¶Å‰ªétotalÈáåÂáèÂéª„ÄÇ","text":"1267. Count Servers that Communicate üîóQuestion Link class Solution &#123; public int countServers(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int[] row = new int[m]; int[] col = new int[n]; int total = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; row[i]+=1; col[j]+=1; total++; &#125; &#125; &#125; for(int i=0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; if(row[i] == 1 &amp;&amp; col[j] == 1)&#123; total--; &#125; &#125; &#125; &#125; return total; &#125;&#125; col Âíå rowÁî®Êù•ËÆ∞ÂΩïËøô‰∏ÄË°åÊúâÂ§öÂ∞ë‰∏™ÁîµËÑëÔºåÂ¶ÇÊûúÊúÄÂêéÊüê‰∏™‰ΩçÁΩÆ‰∏∫ÁîµËÑëÂπ∂‰∏îÊâÄÂú®ÁöÑË°åÂíåÂàóÈÉΩÂè™Êúâ1‰∏™ÔºåÈÇ£‰πàÂ∞±ÊòØÊ≤°ÊúâËøûÊé•ÁöÑÔºåË¶Å‰ªétotalÈáåÂáèÂéª„ÄÇ 207. Course Schedule üîóQuestion Link class Solution &#123; public boolean canFinish(int numCourses, int[][] prerequisites) &#123; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i=0 ;i&lt;indegree.length ;i++)&#123; if(indegree[i] == 0)queue.add(i); &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); numCourses--; for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]] == 0)&#123; queue.add(pair[0]); &#125; &#125; &#125; &#125; return numCourses == 0; &#125;&#125; toplogical sort.ÊåâÁÖßËØæÁ®ãÈ°∫Â∫èÂ¢ûÂä†indegree„ÄÇÁÑ∂Âêé‰ªéindegree0ÁöÑÂºÄÂßãÈÅçÂéÜ„ÄÇÂà§Êñ≠ÊúÄÂêéËØæÁ®ãÊòØÂê¶‰∏∫Èõ∂„ÄÇ 210. Course Schedule II üîóQuestion Link class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int index = 0; for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i = 0 ;i&lt;indegree.length ;i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); res[index] = i; index++; &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]] == 0)&#123; queue.add(pair[0]); res[index] = pair[0]; index++; &#125; &#125; &#125; &#125; return index == numCourses ? res : new int[]&#123;&#125;; &#125;&#125; Âíåcourse schedule ‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇÂè™‰∏çËøáËøôÈÅìÈ¢òË¶ÅÊ±ÇÊåâÈ°∫Â∫èËæìÂá∫ËØæÁ®ãÈ°∫Â∫èÔºåÂè™ÈúÄË¶ÅÁª¥Êä§‰∏Ä‰∏™resÂπ∂‰∏îÊõ¥Êñ∞indexÔºå‰∏çÊñ≠Âä†ÂÖ•indegree‰∏∫0ÁöÑËØæÁ®ãÂç≥ÂèØ„ÄÇ 802. Find Eventual Safe States üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int size = graph.length; int[] state = new int[size]; for(int i=0 ;i&lt;size ;i++)&#123; if(dfs(graph,i,state))res.add(i); &#125; return res; &#125; public boolean dfs(int[][] graph, int num, int[] state)&#123; if(state[num] != 0)return state[num] == 1; state[num] = 2; for(int n : graph[num])&#123; if(!dfs(graph,n,state))return false; &#125; state[num] = 1; return true; &#125;&#125; dfs. ÁõÆÁöÑÊòØÊâæÂà∞‰∏Ä‰∏™numÔºåÂÆÉ‰∏çËÉΩË∑≥ËΩ¨Âà∞Âà´ÁöÑÊï∞Â≠ó„ÄÇÊñπÊ≥ïÊòØÊâæÊï∞ÁªÑÈáåÁöÑcycle„ÄÇÊØè‰∏™Êï∞Êúâ‰∏âÁßçstateÔºå1-unvisited, 2- safe, 3-unsafe. Â¶ÇÊûúÂΩìÂâçÁöÑnumÂ≠òÂú®cycleÊàñËÄÖnumËÉΩÂà∞ËææÁöÑÊï∞ÈáåÂ≠òÂú®cycleÔºåÂàôËØ•Êï∞‰∏çÂÆâÂÖ®ÔºåÁä∂ÊÄÅ‰∏∫2. Â¶ÇÊûúÊ≤°ÊúâcycleÔºåÂàôÊòØÂÆâÂÖ®ÁöÑ„ÄÇdfsÈÄíÂΩíÂÅöÂ∞±ÂèØ‰ª•„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"Topological","slug":"Topological","permalink":"WangHngLeee.github.io/tags/Topological/"}]},{"title":"Leetcode EveryDay 76 üí™","slug":"chin-up-14","date":"2020-02-09T18:13:23.000Z","updated":"2020-02-10T02:13:15.543Z","comments":true,"path":"2020/02/09/chin-up-14/","link":"","permalink":"WangHngLeee.github.io/2020/02/09/chin-up-14/","excerpt":"1162. As Far from Land as Possible üîóQuestion Link class Solution &#123; public int maxDistance(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] seen = new boolean[m][n]; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; queue.add(new int[]&#123;i,j&#125;); seen[i][j] = true; &#125; &#125; &#125; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int steps = -1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt; size ;i++)&#123; int[] temp = queue.poll(); for(int[] move : moves)&#123; int x = temp[0] + move[0]; int y = temp[1] + move[1]; if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; grid[x][y] == 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; steps++; &#125; return steps&lt;=0?-1:steps; &#125;&#125; BFS.Store all 1 in to queue. Then try to explore out to 0, then level by level. When the iteration stop, we can find the max distacne.","text":"1162. As Far from Land as Possible üîóQuestion Link class Solution &#123; public int maxDistance(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] seen = new boolean[m][n]; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 1)&#123; queue.add(new int[]&#123;i,j&#125;); seen[i][j] = true; &#125; &#125; &#125; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; int steps = -1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt; size ;i++)&#123; int[] temp = queue.poll(); for(int[] move : moves)&#123; int x = temp[0] + move[0]; int y = temp[1] + move[1]; if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; grid[x][y] == 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; steps++; &#125; return steps&lt;=0?-1:steps; &#125;&#125; BFS.Store all 1 in to queue. Then try to explore out to 0, then level by level. When the iteration stop, we can find the max distacne. 841. Keys and Rooms üîóQuestion Link Iterative Solution class Solution &#123; public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(rooms == null || rooms.size() == 9)return false; stack.push(0); set.add(0); while(!stack.isEmpty())&#123; int temp = stack.pop(); for(int key : rooms.get(temp))&#123; if(!set.contains(key))&#123; set.add(key); stack.push(key); if(set.size() == rooms.size())return true; &#125; &#125; &#125; return set.size() == rooms.size(); &#125;&#125; Using set to store all rooms we can visit, and then iterative to visit every key that current rooms has. We only need to check whether the size of seen is equal to the total rooms. Recursive Solution class Solution &#123; //recursive solution public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; Set&lt;Integer&gt; seen = new HashSet&lt;&gt;(); help(0,rooms,seen); return rooms.size() == seen.size(); &#125; public void help(int room, List&lt;List&lt;Integer&gt;&gt; rooms, Set&lt;Integer&gt; seen)&#123; seen.add(room); for(int key : rooms.get(room))&#123; if(!seen.contains(key))help(key,rooms,seen); &#125; return; &#125;&#125; Change the iterative solution to recursive. The idea is the same. 1202. Smallest String With Swaps üîóQuestion Link class Solution &#123; public int[] parent; public String smallestStringWithSwaps(String s, List&lt;List&lt;Integer&gt;&gt; pairs) &#123; parent = new int[s.length()]; if(s == null || s.length() == 0)return null; for(int i=0 ;i&lt;s.length() ;i++)&#123; parent[i] = i; &#125; for(List&lt;Integer&gt; pair : pairs)&#123; union(pair.get(0),pair.get(1)); &#125; Map&lt;Integer,PriorityQueue&lt;Character&gt;&gt; map = new HashMap&lt;&gt;(); char[] chs = s.toCharArray(); for(int i=0 ;i&lt;s.length() ;i++)&#123; int root = find(i); if(map.get(root) == null)map.put(root, new PriorityQueue&lt;&gt;()); map.get(root).add(chs[i]); &#125; StringBuilder sb = new StringBuilder(); for(int i=0 ;i&lt;chs.length;i++)&#123; char temp = map.get(parent[i]).poll(); sb.append(temp); &#125; return sb.toString(); &#125; public int find(int i)&#123; while(parent[i]!=i)&#123; parent[i] = parent[parent[i]]; i = parent[i]; &#125; return i; &#125; public void union(int a, int b)&#123; int root1 = find(a); int root2 = find(b); if(root1 &lt; root2)&#123; parent[root2] = root1; &#125;else&#123; parent[root1] = root2; &#125; &#125;&#125; Á¨¨‰∏ÄÊ¨°ÈÅáÂà∞stringÁöÑunion findÈ¢ò„ÄÇÁî±‰∫éÂèØ‰ª•swapÂæàÂ§öÊ¨°ÔºåÊâÄ‰ª•Áõ¥Êé•ÂØπswapÁöÑ‰∏§‰∏™indexÂª∫Á´ãparent graphÔºå‰øùËØÅÊØè‰∏™ËøûÈÄöpardÁöÑrootÊúÄÂ∞èÔºåÂêÑ‰∏™ÈÉ®ÂàÜ‰ªéÂ∞èÂà∞Â§ß„ÄÇÁÑ∂ÂêéÈíàÂØπÊØè‰∏™ÊúÄÂ∞èÁöÑÂºÄÂßãrootÂª∫Á´ãpqÔºåÁî®Êù•ÂØπcharÊéíÂ∫è„ÄÇ‰øùËØÅËøûÈÄöÂõæÈáårootÈÉΩÊòØ‰ªéÂ∞èÂà∞Â§ßÈìæÊé•ÔºåÂπ∂‰∏îchar‰πüÊòØ‰ªéÂ∞èÂà∞Â§ß„ÄÇÁî®mapÂ≠òÂêÑ‰∏™charÂíåÂêÑËá™Ëµ∑ÂßãÁÇπÂØπÂ∫îÁöÑchar pq„ÄÇÊúÄÂêéÁõ¥Êé•ÊåâÈ°∫Â∫èappendËøîÂõû„ÄÇ 842. Split Array into Fibonacci Sequence üîóQuestion Link class Solution &#123; public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); dfs(S,res,0); return res; &#125; public boolean dfs(String s, List&lt;Integer&gt; res, int start)&#123; if(start == s.length() &amp;&amp; res.size() &gt; 2)return true; for(int i = start ;i&lt;s.length() ;i++)&#123; if(s.charAt(start)== '0' &amp;&amp; i&gt;start)break; long num = Long.parseLong(s.substring(start,i+1)); if(num &gt; Integer.MAX_VALUE)break; int size = res.size(); if(size &gt;= 2 &amp;&amp; num&gt;res.get(size-1) + res.get(size-2))break; if(size&lt;=1 || num == res.get(size-1) + res.get(size-2))&#123; res.add((int)num); if(dfs(s,res,i+1))&#123; return true; &#125; res.remove(res.size()-1); &#125; &#125; return false; &#125;&#125; ÁªèÂÖ∏dfs„ÄÇË¶ÅÊ±ÇÊñêÊ≥¢ÈÇ£Â•ëÊï∞ÂàóÔºåÊâÄ‰ª•resÁöÑÂ§ßÂ∞èËá≥Â∞ë‰∏∫2ÁöÑÊó∂ÂÄôÔºåÂæÖÂä†ÂÖ•ÁöÑnumÂøÖÈ°ª‰∏∫Ââç‰∏§‰∏™‰πãÂíå„ÄÇÂπ∂‰∏î0Âè™ËÉΩ‰Ωú‰∏∫0ÂçïÁã¨‰ΩøÁî®ÔºåÂ¶ÇÊûús charat startÊòØ0ÔºåÈÇ£ÂøÖÈ°ªÂè™ËÉΩËØ•‰ΩçÁΩÆÂèØ‰ª•Áî®ÔºåÂêéÈù¢ÁöÑ‰ΩçÁΩÆÈÉΩ‰∏çËÉΩÁî®0„ÄÇÊ≥®ÊÑèÈöêËóèÊù°‰ª∂ÔºånumËøò‰∏çËÉΩÂ§ß‰∫éInteger.MAX_VALUE„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Tricky","slug":"Tricky","permalink":"WangHngLeee.github.io/tags/Tricky/"}]},{"title":"Weekly Contest 175 üèÜ","slug":"contest02","date":"2020-02-09T04:02:09.000Z","updated":"2020-02-09T19:26:27.436Z","comments":true,"path":"2020/02/08/contest02/","link":"","permalink":"WangHngLeee.github.io/2020/02/08/contest02/","excerpt":"1346. Check If N and Its Double Exist üîóQuestion Link First Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; if(arr == null || arr.length == 0)return false; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0 ;i&lt;arr.length;i++)&#123; set.add(arr[i]); &#125; if(set.size() == 1 &amp;&amp; !set.add(0))return true; if(set.size() == 1) return false; for(int num : arr)&#123; if(num %2 != 0 || num == 0)&#123; continue; &#125; else if(set.contains(num/2))&#123; return true; &#125; &#125; return false; &#125;&#125; ÂΩìÊó∂ÊÄùË∑ØÔºö Áî®setÂ≠òÊØè‰∏™num„ÄÇÁÑ∂ÂêéÈÅçÂéÜarrÔºåÊâæÊòØÂê¶ÊúâÂΩìÂâçnum‰∫åÂÄçÊï∞ÁöÑÂ≠òÂú®„ÄÇÊ≥®ÊÑèÈõ∂ÁöÑÂ≠òÂú®„ÄÇ Optimized Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : arr)&#123; if(set.contains(num * 2 ) || num % 2 == 0 &amp;&amp; set.contains(num/2))return true; set.add(num); &#125; return false; &#125;&#125; Tricky„ÄÇÁõ¥Êé•Âú®Âä†ÂÖ•num‰πãÂâçÂÖàÂà§Êñ≠setÈáåÊúâÊó†ÂÆÉÁöÑ‰∫åÂÄçÊï∞ÊàñËÄÖÂÆÉÁöÑ1/2Êï∞„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂàôÂä†ÂÖ•ÔºåÊúâÂàôÁõ¥Êé•ËøîÂõûtrue„ÄÇ","text":"1346. Check If N and Its Double Exist üîóQuestion Link First Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; if(arr == null || arr.length == 0)return false; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i=0 ;i&lt;arr.length;i++)&#123; set.add(arr[i]); &#125; if(set.size() == 1 &amp;&amp; !set.add(0))return true; if(set.size() == 1) return false; for(int num : arr)&#123; if(num %2 != 0 || num == 0)&#123; continue; &#125; else if(set.contains(num/2))&#123; return true; &#125; &#125; return false; &#125;&#125; ÂΩìÊó∂ÊÄùË∑ØÔºö Áî®setÂ≠òÊØè‰∏™num„ÄÇÁÑ∂ÂêéÈÅçÂéÜarrÔºåÊâæÊòØÂê¶ÊúâÂΩìÂâçnum‰∫åÂÄçÊï∞ÁöÑÂ≠òÂú®„ÄÇÊ≥®ÊÑèÈõ∂ÁöÑÂ≠òÂú®„ÄÇ Optimized Solution class Solution &#123; public boolean checkIfExist(int[] arr) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : arr)&#123; if(set.contains(num * 2 ) || num % 2 == 0 &amp;&amp; set.contains(num/2))return true; set.add(num); &#125; return false; &#125;&#125; Tricky„ÄÇÁõ¥Êé•Âú®Âä†ÂÖ•num‰πãÂâçÂÖàÂà§Êñ≠setÈáåÊúâÊó†ÂÆÉÁöÑ‰∫åÂÄçÊï∞ÊàñËÄÖÂÆÉÁöÑ1/2Êï∞„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂàôÂä†ÂÖ•ÔºåÊúâÂàôÁõ¥Êé•ËøîÂõûtrue„ÄÇ 1347. Minimum Number of Steps to Make Two Strings Anagram üîóQuestion Link First Solution class Solution &#123; public int minSteps(String s, String t) &#123; int n = s.length(); int sum = 0; int[] arr = new int[26]; for(int i = 0; i &lt; n; i++) &#123; arr[s.charAt(i) - 'a']++; arr[t.charAt(i) - 'a']--; &#125; for(int i = 0; i &lt; arr.length; i++) if(arr[i] &gt; 0) sum += arr[i]; return sum; &#125;&#125; ÂΩìÊó∂ÊÄùË∑ØÔºöarrÂ≠òÊØè‰∏™Â≠óÊØçÁöÑ‰∏™Êï∞ÔºåÁ¨¨‰∏Ä‰∏™++ÔºåÁ¨¨‰∫å‰∏™‚ÄìÔºåÈÅçÂéÜarrÔºåÂè™Ë¶ÅÊää&gt;0ÁöÑÂÖ®ÈÉ®Âä†Ëµ∑Êù•Â∞±ÊòØÁªìÊûú„ÄÇÂΩìÁ¨¨‰∫å‰∏™Âéª‚ÄìÁöÑÊó∂ÂÄôÔºåÁõ∏ÂêåÁöÑ‰∏™Êï∞ËÇØÂÆö‰ªéarr‰∏≠ÂáèÂéªÔºåÂâ©‰∏ãÁöÑÊòØÂ∑ÆÁº∫ÁöÑ„ÄÇ Optimized Solution discussÈ´òÁ•®Á≠îÊ°àÂíåÊàëÂ∑Æ‰∏çÂ§öÊÄùË∑Ø„ÄÇ Ââ©‰∏ãÂæÖÊõ¥Êñ∞","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 75 üí™","slug":"chin-up-13","date":"2020-02-07T19:45:35.000Z","updated":"2020-02-09T21:34:44.846Z","comments":true,"path":"2020/02/07/chin-up-13/","link":"","permalink":"WangHngLeee.github.io/2020/02/07/chin-up-13/","excerpt":"133. Clone Graph üîóQuestion Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); map.put(node,dummy); while(!queue.isEmpty())&#123; Node temp = queue.poll(); for(Node nb : temp.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb, new Node(nb.val)); queue.add(nb); &#125; map.get(temp).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; Using map to store the node and its copy. Creating dummy node to keep track of the head. Using queue to make bfs of each node in the graph.","text":"133. Clone Graph üîóQuestion Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(node); map.put(node,dummy); while(!queue.isEmpty())&#123; Node temp = queue.poll(); for(Node nb : temp.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb, new Node(nb.val)); queue.add(nb); &#125; map.get(temp).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; Using map to store the node and its copy. Creating dummy node to keep track of the head. Using queue to make bfs of each node in the graph. 138. Copy List with Random Pointer üîóQuestion Link class Solution&#123; public Node copyRandomList(Node head) &#123; if(head == null)return null; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node node = head; while(node!=null)&#123; map.put(node,new Node(node.val)); node = node.next; &#125; node = head; while(node!=null)&#123; map.get(node).next = map.get(node.next); map.get(node).random = map.get(node.random); node = node.next; &#125; return map.get(head); &#125;&#125; Using map to store node and its copy, then we iteratively arrange the correct next node and random node to its copy.Loop the map for two times, one for store, another for arrangement. 200. Number of Islands üîóQuestion Link class Solution &#123; public int numIslands(char[][] grid) &#123; if(grid == null || grid.length == 0)return 0; // corner case int m = grid.length; int n = grid[0].length; int sum = 0; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == '1')&#123; dfs(grid,i,j,m,n); //dfs sum++;// if dfs end, it means we find an island. &#125; &#125; &#125; return sum; &#125; public void dfs(char[][] grid, int i, int j, int m, int n)&#123; if(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; j&gt;=0 &amp;&amp; j&lt;n &amp;&amp;grid[i][j] == '1')&#123; grid[i][j] = '0'; // try for different directions. dfs(grid,i+1,j,m,n); dfs(grid,i,j+1,m,n); dfs(grid,i-1,j,m,n); dfs(grid,i,j-1,m,n); &#125; &#125;&#125; Using DFS . When we meet 1, we using dfs to find 1 in four directions. If it stop, it means we find an island and we can not move to the other 1. So we increase sum. THen we try the other position of 1 in the grid. 547. Friend Circles üîóQuestion Link class Solution &#123; public int findCircleNum(int[][] M) &#123; if(M == null || M.length == 0)return 0;// corner case int sum = 0; boolean[] seen = new boolean[M.length]; for(int person = 0 ; person&lt;M.length ;person++)&#123; if(!seen[person])&#123; dfs(M,person,seen); sum++; &#125; &#125; return sum; &#125; public void dfs(int[][] M, int person ,boolean[] seen)&#123; for(int i = 0 ;i&lt;M[0].length ;i++)&#123; if(M[person][i] == 1 &amp;&amp; !seen[i])&#123; seen[i] = true; dfs(M,i,seen); &#125; &#125; &#125;&#125; Á±ª‰ººislandÁöÑÈ¢òÔºåÁî±‰∫éÊòØÊØè‰∏™ÂùêÊ†á‰ª£Ë°®‰∏Ä‰∏™‰∫∫ÔºåËøôÊ¨°Âè™ÈúÄË¶Å‰∏ÄË°å‰∏ÄË°ådfsÂ∞±ÂèØ‰ª•„ÄÇseenÊ£ÄÊü•ÊòØÂê¶ËÆøÈóÆËøáËØ•‰∫∫„ÄÇÂØπÂùêÊ†áÂÄº‰∏∫1ÁöÑÂú∞Êñπ‰∏ÄÂ±ÇÂ±ÇÈÄíÂΩídfsÂç≥ÂèØ„ÄÇÊ≥®ÊÑèÂµåÂ•óÂÜÖdfsÁöÑ Êñ∞person ÂÄºÊòØÂΩìÂâç person ÁöÑ friend„ÄÇ 695. Max Area of Island üîóQuestion Link class Solution &#123; public int maxAreaOfIsland(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;m ;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(grid[i][j] == 1)&#123; int area = dfs(grid,i,j,m,n,0); max = Math.max(max,area); &#125; &#125; &#125; return max; &#125; public int dfs(int[][] grid, int i, int j, int m, int n,int area)&#123; if(i &lt;0 || i&gt;=m || j&lt;0 ||j&gt;=n || grid[i][j] == 0)return area; grid[i][j] = 0; area++; area = dfs(grid,i+1,j,m,n,area); area = dfs(grid,i,j+1,m,n,area); area = dfs(grid,i-1,j,m,n,area); area = dfs(grid,i,j-1,m,n,area); return area; &#125;&#125; Âíå200È¢ò‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇdfsÊõ¥Êñ∞areaÔºå‰øùÊåÅ‰∏Ä‰∏™maxËÆ∞ÂΩïÊúÄÂ§ßÂÄº„ÄÇdfs‰∏≠Â¶ÇÊûúÈÅáÂà∞0ÊàñËÄÖËæπÁïåÈóÆÈ¢òÁõ¥Êé•ËøîÂõûarea„ÄÇ 733. Flood Fill üîóQuestion Link class Solution &#123; public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123; if(image == null || image.length == 0)return image; if(image[sr][sc] == newColor)return image; int m = image.length; int n = image[0].length; dfs(image,sr,sc,newColor,m,n,image[sr][sc]); return image; &#125; public void dfs(int[][] image, int sr, int sc, int newColor,int m ,int n,int color)&#123; if(sr &gt;=0 &amp;&amp; sc &gt;=0 &amp;&amp; sr&lt;m &amp;&amp; sc&lt;n &amp;&amp; image[sr][sc] == color)&#123; image[sr][sc] = newColor; dfs(image,sr+1,sc,newColor,m,n,color); dfs(image,sr,sc+1,newColor,m,n,color); dfs(image,sr-1,sc,newColor,m,n,color); dfs(image,sr,sc-1,newColor,m,n,color); &#125; &#125;&#125; dfs„ÄÇÊ≥®ÊÑèÊ£ÄÊü•‰∏ÄÂºÄÂßãsr sc‰ΩçÁΩÆÁöÑcolorÊòØÂê¶Â∑≤ÁªèÂíånewcolorÁõ∏ÂêåÔºåÂ¶ÇÊûúÊòØÁõ¥Êé•ËøîÂõûimageÔºåÂ∞±‰∏ç‰ºöstack overflow„ÄÇ‰∏çÊòØÁõ¥Êé•‰ªésr scÂºÄÂßãÊâ©Êï£dfs„ÄÇÂè™ÂØπÂΩìÂâç‰∏çÊòØnewcolorÁöÑËøõË°åÂèòËâ≤„ÄÇ 827. Making A Large Island üîóQuestion Link class Solution &#123; public int largestIsland(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; int max = Integer.MIN_VALUE; for(int i=0;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n ;j++)&#123; if(grid[i][j] == 0)&#123; grid[i][j] = 1; max = Math.max(max,dfs(i,j,grid,new boolean[m][n])); if(max == m*n)return max; grid[i][j] = 0; &#125; &#125; &#125; return max == Integer.MIN_VALUE ? m*n : max; &#125; public int dfs(int i, int j,int[][] grid, boolean[][] seen)&#123; if(i&gt;=0 &amp;&amp; j &gt;=0 &amp;&amp; i&lt;grid.length &amp;&amp;j&lt;grid[0].length &amp;&amp;!seen[i][j] &amp;&amp; grid[i][j]==1)&#123; seen[i][j] = true; int res = 1 + dfs(i+1,j,grid,seen) + dfs(i,j+1,grid,seen) + dfs(i-1,j,grid,seen) + dfs(i,j-1,grid,seen); return res; &#125;else&#123; return 0; &#125; &#125;&#125; dfs + backtracking. ÊÄùË∑ØÁ±ª‰ººisland 200. Êâæ0Âπ∂‰∏îbacktrackingÂõû1„ÄÇÊ≥®ÊÑèboolweanÊï∞ÁªÑ‰∏ÄÂÆöË¶ÅÂú®dfs‰∏≠ÂÆö‰πâÔºåÂõ†‰∏∫ÊØèÊ¨°dfs‰øùËØÅÈúÄË¶ÅÂè™ËßÅÂà∞‰∏ÄÊ¨°ÁöÑ‰ΩçÁΩÆ‰∏çÂêå„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 74 üí™","slug":"chin-up-12","date":"2020-02-07T18:05:35.000Z","updated":"2020-02-08T20:56:29.388Z","comments":true,"path":"2020/02/07/chin-up-12/","link":"","permalink":"WangHngLeee.github.io/2020/02/07/chin-up-12/","excerpt":"BFS È¢òÁõÆ 675. Cut Off Trees for Golf Event üîóQuestion Link class Solution &#123; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; if(forest == null || forest.get(0).size() == 0)return 0;//corner case PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(); int n = forest.get(0).size(); int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; for(int i= 0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;);//add all num that &gt; 1 to pq. &#125; &#125; &#125; int sum = 0; int[] start = new int[2]; while(!pq.isEmpty())&#123;// iterate for each num int[] tree = pq.poll(); int step = getmin(forest,start,tree,m,n,moves);// start bfs iterate to find minstep to get to the tree. if(step == -1)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; public int getmin(List&lt;List&lt;Integer&gt;&gt; forest, int[] start, int[] tree, int m, int n, int[][]moves)&#123; // normal bfs to find the min step. boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; int step = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; int[] temp = queue.poll(); if(temp[0] == tree[0] &amp;&amp; temp[1] == tree[1])return step; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125;&#125; pqÂ≠òÊØè‰∏™‰ΩçÁΩÆÁöÑÂ§ßÂ∞èÔºåÂπ∂‰∏îÊåâÁÖß‰ªéÂ∞èÂà∞Â§ßpollÂá∫„ÄÇÊääÂ§ß‰∫é1ÁöÑÁÇπÂ≠òËøõpqÔºåpollÂá∫Á¨¨‰∏Ä‰∏™ÁÇπÊòØË¶ÅÂà∞ËææÁöÑtreeÔºå‰∏ÄÂºÄÂßãÈªòËÆ§start‰∏∫0Ôºå0 „ÄÇbfsÂÜôÊ≥ïËôΩÁÑ∂ÁÜüÁªÉ‰ΩÜÊòØÁªÜËäÇËøòÊòØË¶ÅÊ≥®ÊÑè„ÄÇ","text":"BFS È¢òÁõÆ 675. Cut Off Trees for Golf Event üîóQuestion Link class Solution &#123; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; if(forest == null || forest.get(0).size() == 0)return 0;//corner case PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(); int n = forest.get(0).size(); int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;&#125;; for(int i= 0 ;i&lt;m;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;);//add all num that &gt; 1 to pq. &#125; &#125; &#125; int sum = 0; int[] start = new int[2]; while(!pq.isEmpty())&#123;// iterate for each num int[] tree = pq.poll(); int step = getmin(forest,start,tree,m,n,moves);// start bfs iterate to find minstep to get to the tree. if(step == -1)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; public int getmin(List&lt;List&lt;Integer&gt;&gt; forest, int[] start, int[] tree, int m, int n, int[][]moves)&#123; // normal bfs to find the min step. boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; int step = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; int[] temp = queue.poll(); if(temp[0] == tree[0] &amp;&amp; temp[1] == tree[1])return step; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt; m &amp;&amp; y&gt;=0 &amp;&amp; y&lt;n &amp;&amp; !seen[x][y] &amp;&amp; forest.get(x).get(y)!= 0)&#123; queue.add(new int[]&#123;x,y&#125;); seen[x][y] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125;&#125; pqÂ≠òÊØè‰∏™‰ΩçÁΩÆÁöÑÂ§ßÂ∞èÔºåÂπ∂‰∏îÊåâÁÖß‰ªéÂ∞èÂà∞Â§ßpollÂá∫„ÄÇÊääÂ§ß‰∫é1ÁöÑÁÇπÂ≠òËøõpqÔºåpollÂá∫Á¨¨‰∏Ä‰∏™ÁÇπÊòØË¶ÅÂà∞ËææÁöÑtreeÔºå‰∏ÄÂºÄÂßãÈªòËÆ§start‰∏∫0Ôºå0 „ÄÇbfsÂÜôÊ≥ïËôΩÁÑ∂ÁÜüÁªÉ‰ΩÜÊòØÁªÜËäÇËøòÊòØË¶ÅÊ≥®ÊÑè„ÄÇ 127. Word Ladder üîóQuestion Link class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(wordList); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(beginWord); int step = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; String temp = queue.poll(); for(int j=0 ;j &lt;endWord.length();j++)&#123; char[] chs = temp.toCharArray(); for(char c = 'a' ; c&lt;='z' ;c++)&#123; chs[j] = c; String newone = new String(chs); if(set.contains(newone))&#123; if(endWord.equals(newone))return step+1; set.remove(newone); queue.add(newone); &#125; &#125; &#125; &#125; step++; &#125; return 0; &#125;&#125; BFS„ÄÇÊØè‰∏™charÊîπÂèòÂêéËÆ∞Âæónew‰∏Ä‰∏™stringÊù•Ê£ÄÊü•„ÄÇÂ¶ÇÊûúÂ≠òÂú®setÈáåÔºåÂàôË¶ÅremoveÊéâÔºåÈÅøÂÖçÈáçÂ§çÁî®„ÄÇ Partition È¢òÁõÆ 698. Partition to K Equal Sum Subsets üîóQuestion Link class Solution &#123; public boolean canPartitionKSubsets(int[] nums, int k) &#123; int sum = 0; for(int num : nums)sum+=num; if( sum % k != 0 || k&lt;=0)return false; boolean[] seen = new boolean[nums.length]; return check(nums,seen,0,k,0,sum/k); &#125; public boolean check(int[] nums, boolean[]seen, int start, int k, int cursum,int target)&#123; if(k == 1)return true; if(cursum == target)return check(nums,seen,0,k-1,0,target); for(int i=start; i&lt;nums.length;i++)&#123; if(!seen[i])&#123; seen[i] = true; if(check(nums,seen,i+1, k ,cursum + nums[i], target))return true; seen[i] = false; &#125; &#125; return false; &#125;&#125; dfs„ÄÇk‰∏™sumÁõ∏ÂêåÁöÑsubstetÔºåÂç≥ÊØè‰∏™ÁöÑsumÈÉΩ‰∏∫numsÁöÑÂíå/k„ÄÇÈÄíÂΩíÂØªÊâæÔºåÂ¶ÇÊûúÂΩìÂâçcursumÁ≠â‰∫éÁõÆÊ†áÂÄºtargetÔºåËøîÂõû‰∏ä‰∏ÄÂ±ÇÈÄíÂΩíÔºåÊâæÂâ©‰∏ãÁöÑk-1‰∏™„ÄÇÂê¶ÂàôÂØπÊØè‰∏™Ê≤°ÈÅáÂà∞ÁöÑÊï∞ËøõË°ådfs+backtrackingÔºå‰πãÂêéÊääËØ•Êï∞Âèò‰∏∫Êú™ËßÅËøá„ÄÇ 93. Restore IP Addresses üîóQuestion Link class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int len = s.length(); for(int i=1;i&lt;4 &amp;&amp; i&lt;len-2;i++)&#123; for(int j=i+1;j&lt;i+4 &amp;&amp; j&lt;len-1;j++)&#123; for(int k=j+1;k&lt;j+4 &amp;&amp; k&lt;len;k++)&#123; String s1 = s.substring(0,i); String s2 = s.substring(i,j); String s3 = s.substring(j,k); String s4 = s.substring(k,len); if(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123; res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4); &#125; &#125; &#125; &#125; return res; &#125; public boolean check(String a)&#123; if(a.length()&gt;3||a.length()==0||(a.charAt(0)=='0' &amp;&amp; a.length()&gt;1))return false; if(Integer.parseInt(a) &gt; 255)return false; return true; &#125;&#125; ÂàÜpartËÆ®ËÆ∫„ÄÇÂÖ∑‰ΩìËß£Êûê‰πãÂâçÁöÑÊØèÊó•Á¨îËÆ∞ÂÜôËøá„ÄÇ 131. Palindrome Partitioning üîóQuestion Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;String&gt; templist = new ArrayList&lt;&gt;(); if(s == null || s.length() == 0)return res; help(res,templist,0,s); return res; &#125; public void help(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; templist, int start, String s)&#123; if(start == s.length())res.add(new ArrayList&lt;&gt;(templist)); else&#123; for(int i = start ;i &lt; s.length() ; i++)&#123; if(valid(s,start,i))&#123; templist.add(s.substring(start,i+1)); help(res,templist,i+1,s); templist.remove(templist.size()-1); &#125; &#125; &#125; &#125; public boolean valid(String s, int left, int right)&#123; while( left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right))return false; left++; right--; &#125; return true; &#125;&#125; dfs + backtracking. Add one function to check whether the string is Palindrome. Remember we start from the left most and right most, it‚Äôs different from the previous questions which start from the center to two sides. 241. Different Ways to Add Parentheses üîóQuestion Link class Solution &#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(input == null || input.length() == 0)return res; for(int i=0 ;i&lt;input.length();i++)&#123; char c = input.charAt(i); if(c == '+' || c== '-' || c=='*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; list1 = map.getOrDefault(part1,diffWaysToCompute(part1)); List&lt;Integer&gt; list2 = map.getOrDefault(part2,diffWaysToCompute(part2)); for(int num1 : list1)&#123; for(int num2 : list2)&#123; int cursum = 0; switch(c)&#123; case '+': cursum = num1 + num2; break; case '-': cursum = num1 - num2; break; case '*': cursum = num1 * num2; break; &#125; res.add(cursum); &#125; &#125; &#125; &#125; if(res.size() == 0)res.add(Integer.valueOf(input)); map.put(input,res); return res; &#125;&#125; Recursive + Memo. Using map to store the correspond total possible answers to the current part of string. This way can help reduce the total time because we have already store the key-value of them. In terms of different operation symbol, we have to add different number to the res„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"Partition","slug":"Partition","permalink":"WangHngLeee.github.io/tags/Partition/"}]},{"title":"Leetcode EveryDay 73 üí™","slug":"chin-up-11","date":"2020-02-06T19:01:53.000Z","updated":"2020-02-07T00:39:23.490Z","comments":true,"path":"2020/02/06/chin-up-11/","link":"","permalink":"WangHngLeee.github.io/2020/02/06/chin-up-11/","excerpt":"451. N-Queens üîóQuestion Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] chess = new char[n][n]; for(int i=0 ;i&lt;n;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; chess[i][j] = '.'; // used to created new chess board. &#125; &#125; dfs(chess,0,res); return res; &#125; public void dfs(char[][] chess, int row, List&lt;List&lt;String&gt;&gt; res)&#123; if(row == chess.length)&#123; res.add(build(chess)); return; &#125; for(int col = 0; col &lt; chess.length;col++)&#123; if(valid(row,col,chess))&#123; chess[row][col] = 'Q'; // ÊîπÊàêQ dfs(chess,row+1,res); // dfsÂà∞‰∏ã‰∏ÄË°å chess[row][col] = '.'; //ÊîπÂõû ‚Äô.' &#125; &#125; &#125; public boolean valid(int row ,int col, char[][]chess)&#123; for(int i=0;i&lt;row; i++)&#123; // Ê£ÄÊü•Âêå‰∏ÄÂàóÊúâÊó†QÔºåË°å‰∏çÁî®Ê£ÄÊü•Âõ†‰∏∫Ê†πÊçÆË°åÈÅçÂéÜ„ÄÇ if(chess[i][col] == 'Q')return false; &#125; for(int i = row-1,j=col+1;i&gt;=0 &amp;&amp;j&lt;chess.length;i--,j++)&#123; if(chess[i][j] == 'Q')return false;//Ê£ÄÊü•Ê≠£ÂØπËßíÁ∫øÊúâÊó†Q &#125; for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0 ;i--,j--)&#123; if(chess[i][j] =='Q')return false; &#125;//Ê£ÄÊü•ÈÄÜÂØπËßíÁ∫øÊúâÊó†Q return true; &#125; public List&lt;String&gt; build(char[][] chess)&#123; List&lt;String&gt; path = new ArrayList&lt;&gt;();//ÊúÄÂêéÊäächessÊ†πÊçÆÊØè‰∏ÄË°åÂä†ÂÖ•res„ÄÇ for(int i=0 ;i&lt;chess.length;i++)&#123; path.add(new String(chess[i])); &#125; return path; &#125;&#125; DFS„ÄÇqueenÊ∏∏ÊàèËßÑÂàôÊòØÂêå‰∏ÄÂàó/Âêå‰∏ÄË°å/Ê≠£ÂØπËßí/ÊñúÂØπËßí‰∏çËÉΩÊúâQÂ≠òÂú®ÔºåÁî±‰∫éÊàë‰ª¨Ê†πÊçÆË°åÊï∞Êù•ÈÅçÂéÜdfsÔºåÊâÄ‰ª•Ê£ÄÊü•validÂáΩÊï∞Ë¶ÅËÄÉËôëÔºàÂàó/Ê≠£ÂØπËßí/ÊñúÂØπËßíÔºâ‰∏âÁßçÊÉÖÂÜµ„ÄÇ","text":"451. N-Queens üîóQuestion Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] chess = new char[n][n]; for(int i=0 ;i&lt;n;i++)&#123; for(int j=0 ;j&lt;n;j++)&#123; chess[i][j] = '.'; // used to created new chess board. &#125; &#125; dfs(chess,0,res); return res; &#125; public void dfs(char[][] chess, int row, List&lt;List&lt;String&gt;&gt; res)&#123; if(row == chess.length)&#123; res.add(build(chess)); return; &#125; for(int col = 0; col &lt; chess.length;col++)&#123; if(valid(row,col,chess))&#123; chess[row][col] = 'Q'; // ÊîπÊàêQ dfs(chess,row+1,res); // dfsÂà∞‰∏ã‰∏ÄË°å chess[row][col] = '.'; //ÊîπÂõû ‚Äô.' &#125; &#125; &#125; public boolean valid(int row ,int col, char[][]chess)&#123; for(int i=0;i&lt;row; i++)&#123; // Ê£ÄÊü•Âêå‰∏ÄÂàóÊúâÊó†QÔºåË°å‰∏çÁî®Ê£ÄÊü•Âõ†‰∏∫Ê†πÊçÆË°åÈÅçÂéÜ„ÄÇ if(chess[i][col] == 'Q')return false; &#125; for(int i = row-1,j=col+1;i&gt;=0 &amp;&amp;j&lt;chess.length;i--,j++)&#123; if(chess[i][j] == 'Q')return false;//Ê£ÄÊü•Ê≠£ÂØπËßíÁ∫øÊúâÊó†Q &#125; for(int i=row-1,j=col-1;i&gt;=0 &amp;&amp; j&gt;=0 ;i--,j--)&#123; if(chess[i][j] =='Q')return false; &#125;//Ê£ÄÊü•ÈÄÜÂØπËßíÁ∫øÊúâÊó†Q return true; &#125; public List&lt;String&gt; build(char[][] chess)&#123; List&lt;String&gt; path = new ArrayList&lt;&gt;();//ÊúÄÂêéÊäächessÊ†πÊçÆÊØè‰∏ÄË°åÂä†ÂÖ•res„ÄÇ for(int i=0 ;i&lt;chess.length;i++)&#123; path.add(new String(chess[i])); &#125; return path; &#125;&#125; DFS„ÄÇqueenÊ∏∏ÊàèËßÑÂàôÊòØÂêå‰∏ÄÂàó/Âêå‰∏ÄË°å/Ê≠£ÂØπËßí/ÊñúÂØπËßí‰∏çËÉΩÊúâQÂ≠òÂú®ÔºåÁî±‰∫éÊàë‰ª¨Ê†πÊçÆË°åÊï∞Êù•ÈÅçÂéÜdfsÔºåÊâÄ‰ª•Ê£ÄÊü•validÂáΩÊï∞Ë¶ÅËÄÉËôëÔºàÂàó/Ê≠£ÂØπËßí/ÊñúÂØπËßíÔºâ‰∏âÁßçÊÉÖÂÜµ„ÄÇ 52. N-Queens II üîóQuestion Link class Solution &#123; int res = 0; public int totalNQueens(int n) &#123; boolean[] col = new boolean[n*2-1]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; public void solve (int row, int n, boolean[] col, boolean[] diag1, boolean[]diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0 ;j&lt;n;j++)&#123; if(!col[j] &amp;&amp; !diag1[j + row] &amp;&amp; !diag2[j-row+n-1])&#123; col[j] = diag1[j+row] = diag2[j-row+n-1] = true; solve(row+1,n,col,diag1,diag2); col[j] = diag1[j+row] = diag2[j-row+n-1] = false; &#125; &#125; &#125;&#125; DFS„ÄÇÂíåI‰∏çÂêå‰πãÂ§ÑÊòØË¶ÅËøîÂõûÂèØËÉΩÁöÑÊÉÖÂÜµ‰∏™Êï∞Ôºå‰ΩÜÊòØ‰∏çÁî®ÂÉèI‰∏ÄÊ†∑È∫ªÁÉ¶„ÄÇÊÄùË∑Ø‰∏ÄÊ†∑ÔºåÂØπ‰∏â‰∏™ÊñπÂêëÊ£ÄÊü•ÔºåtrueË°®ÊòéÊúâQÔºåfalseË°®ÊòéÊ≤°ÊúâQÔºåÂàõÂª∫‰∏â‰∏™ÊñπÂêëÁöÑbooleanÊï∞ÁªÑÔºåËøôÈáåË¶ÅÊ≥®ÊÑèÊ≠£/ÊñúÂØπËßíÁöÑ‰∏™Êï∞‰ª•ÂèäindexÂíårowÔºåcolÁöÑÂÖ≥Á≥ªÔºåÁîª‰∏™ÂõæÂ∞±ËÉΩÊòéÁôΩ„ÄÇ 37. Sudoku Solver üîóQuestion Link class Solution &#123; public void solveSudoku(char[][] board) &#123; if(board == null || board.length == 0)return; solve(board); &#125; public boolean solve(char[][] board)&#123; for(int i=0 ;i&lt;board.length;i++)&#123; for(int j=0 ;j&lt;board[0].length ;j++)&#123; if(board[i][j] =='.')&#123; for(char c = '1' ; c&lt;='9' ;c++)&#123; if(valid(board,i,j,c))&#123; board[i][j] = c; if(solve(board))return true; else&#123; board[i][j] = '.'; &#125; &#125; &#125; return false; &#125; &#125; &#125; return true; &#125; public boolean valid(char[][] board, int row, int col, char c)&#123; for(int i=0 ;i&lt;9 ;i++)&#123; if(board[i][col] != '.' &amp;&amp; board[i][col] == c)return false; // check each col; if(board[row][i] != '.' &amp;&amp; board[row][i] == c)return false; //check each row; if(board[3*(row /3)+i/3][3*(col/3)+i%3]!='.'&amp;&amp;board[3*(row/3)+i/3][3*(col/3)+i%3]==c)return false; &#125; return true; &#125;&#125; DFS„ÄÇÁ±ª‰ººqueenÁöÑÈ¢ò„ÄÇÈÅçÂéÜÂõæÔºåÂØπ‚Äò.‚ÄòÁöÑÁÇπËøõË°ådfs„ÄÇ‰ªé1-9ËøõË°åÈÄâÊã©ÔºåÁÑ∂ÂêéÊ£ÄÊü•ÂΩìÂâçÈÄâÊã©ÁöÑÊï∞ÊòØÂê¶ÂèØ‰ª•ÊîæÔºåÂ¶ÇÊûúÂèØ‰ª•ÂàôË∞ÉÁî®solveÂáΩÊï∞ÁªßÁª≠dfs„ÄÇÂ¶ÇÊûú‰∏çË°åÂàôÊääÂΩìÂâç‰ΩçÁΩÆÂèòÂõû‚Äô.‚Äô„ÄÇ ÈöæÁÇπÂú®validÂáΩÊï∞ÈáåÂØπÊØè‰∏Ä‰∏™3x3ÊñπÊ†ºÁöÑÊ£ÄÊü•„ÄÇË°åÁî®/ ÂàóÁî®%„ÄÇ 22. Generate Parentheses üîóQuestion Link class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(n == 0)return res; dfs(\"\",res,0,0,n); return res; &#125; public void dfs(String cur, List&lt;String&gt; res, int left, int right, int n)&#123; if(left == n &amp;&amp; right == n)res.add(cur); if(left &lt; n)&#123; dfs(cur+\"(\",res,left+1,right,n); &#125; if(right &lt; left)&#123; dfs(cur+\")\",res,left,right+1,n); &#125; &#125;&#125; dfs„ÄÇleftÂíårightÈÉΩ‰∏∫n‰∏™ÔºåÂàôÊäälistÂä†ÂÖ•res„ÄÇÂè™ÊúâÂΩìright&lt;leftÊó∂ÊâçÈÄíÂΩíÂä†ÂÖ•Âè≥Êã¨Âè∑„ÄÇ 542. 01 Matrix üîóQuestion Link class Solution &#123; public int[][] updateMatrix(int[][] matrix) &#123; if(matrix == null || matrix.length == 0)return null; Queue&lt;int[]&gt; queue = new LinkedList(); int m = matrix.length; int n = matrix[0].length; int[][] moves = &#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;&#125;; for(int i=0 ;i&lt;m;i++)&#123; for(int j = 0; j&lt;n;j++)&#123; if(matrix[i][j] == 1)&#123; matrix[i][j] = -1; &#125;else&#123; queue.add(new int[]&#123;i,j&#125;); &#125; &#125; &#125; while(!queue.isEmpty())&#123; int[] cur = queue.poll(); for(int[] move : moves)&#123; int x = cur[0] + move[0]; int y = cur[1] + move[1]; if(x&lt;0 || y&lt;0 || x&gt;=m ||y&gt;=n || matrix[x][y] !=-1 )continue; queue.add(new int[]&#123;x,y&#125;); matrix[x][y] = matrix[cur[0]][cur[1]]+1; &#125; &#125; return matrix; &#125;&#125; bfs„ÄÇÂÖàÊää0ÁöÑÂùêÊ†áÂä†ËøõqueueÔºåÊää‰∏ç‰∏∫Èõ∂ÁöÑ‰ΩçÁΩÆÂÄºÂèò‰∏∫-1„ÄÇ‰ªéÂ§ñÂõ¥ÂæÄÈáåÊâ´ÊèèÔºåÂ¶ÇÊûúÊõ¥Êñ∞ÂêéÁöÑ‰ΩçÁΩÆ‰∏ç‰∏∫-1ÔºåËØ¥ÊòéÊ≤°ÊúâÊâæÂà∞‰∏ç‰∏∫Èõ∂ÁöÑ‰ΩçÁΩÆÔºåÁªßÁª≠Êâ´Êèè„ÄÇÂ¶ÇÊûúÊõ¥Êñ∞ÂêéÁöÑ‰ΩçÁΩÆ‰∏∫-1ÔºåËØ¥ÊòéÂΩìÂâç‰ΩçÁΩÆÊòØ0ÔºåÊâÄ‰ª•ÊääÊõ¥Êñ∞Âêé‰ΩçÁΩÆÁöÑÂÄºÂèò‰∏∫ÂΩìÂâç‰ΩçÁΩÆ+1Ôºå‰æùÊ¨°Á±ªÊé®„ÄÇ 934. Shortest Bridge üîóQuestion Link class Solution &#123; public int shortestBridge(int[][] A) &#123; int m = A.length, n = A[0].length; boolean[][] visited = new boolean[m][n]; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;(); boolean found = false; // dfs to find the whole index of first island. for (int i = 0; i &lt; m; i++) &#123; if (found) &#123; break; &#125; for (int j = 0; j &lt; n; j++) &#123; if (A[i][j] == 1) &#123; dfs(A, visited, q, i, j, dirs); found = true; break; &#125; &#125; &#125; // using bfs to find the step to connect another island int step = 0; while (!q.isEmpty()) &#123; int size = q.size(); while (size-- &gt; 0) &#123; int[] cur = q.poll(); for (int[] dir : dirs) &#123; int i = cur[0] + dir[0]; int j = cur[1] + dir[1]; if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; m &amp;&amp; j &lt; n &amp;&amp; !visited[i][j]) &#123; if (A[i][j] == 1) &#123; return step; &#125; q.offer(new int[]&#123;i, j&#125;); visited[i][j] = true; &#125; &#125; &#125; step++; &#125; return -1; &#125; private void dfs(int[][] A, boolean[][] visited, Queue&lt;int[]&gt; q, int i, int j, int[][] dirs) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= A.length || j &gt;= A[0].length || visited[i][j] || A[i][j] == 0) &#123; return; &#125; visited[i][j] = true; q.offer(new int[]&#123;i, j&#125;); for (int[] dir : dirs) &#123; dfs(A, visited, q, i + dir[0], j + dir[1], dirs); &#125; &#125;&#125; dfs + bfs„ÄÇ dfsÊù•Êâæ‰ªªÊÑè‰∏Ä‰∏™1ÊâÄÂ±ûÁöÑislandÁöÑÊâÄÊúâ1ÁöÑÂùêÊ†á„ÄÇbfsÂàôÁî®Êù•Ê†πÊçÆÂΩìÂâçÊâæÂà∞ÁöÑislandÊâÄÊúâÂùêÊ†áÔºåÊù•ÊâæËÉΩËøûÊé•Âà∞Âè¶Â§ñ‰∏Ä‰∏™Â≤õÁöÑ1ÊâÄÈúÄË¶ÅÁöÑsteps„ÄÇdfsËøáÁ®ã‰∏≠ÈúÄÂÆö‰πâ‰∏Ä‰∏™booleanÂÄºÊù•Âà§Êñ≠ÊòØÂê¶ÊâæÂà∞ÂÖ®ÈÉ®ÁöÑÂ≤õÔºåÂ¶ÇÊûútrueÂàôÁõ¥Êé•ËøõÂÖ•bfs„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"}]},{"title":"Leetcode EveryDay 72 üí™","slug":"chin-up-10","date":"2020-02-05T19:27:43.000Z","updated":"2020-02-06T05:22:26.822Z","comments":true,"path":"2020/02/05/chin-up-10/","link":"","permalink":"WangHngLeee.github.io/2020/02/05/chin-up-10/","excerpt":"752. Open the Lock üîóQuestion Link class Solution &#123; public int openLock(String[] deadends, String target)&#123; Set&lt;String&gt; deads = new HashSet&lt;&gt;(); for(String str: deadends)&#123; deads.add(str); &#125; Set&lt;String&gt; seen = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(\"0000\"); seen.add(\"0000\"); int steps = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; String temp = queue.poll(); if(deads.contains(temp))continue; if(temp.equals(target))return steps; for(int j=0 ;j&lt;4;j++)&#123; char c = temp.charAt(j); String s1 = temp.substring(0,j) + ( c =='9' ? 0:c-'0'+1 ) + temp.substring(j+1); String s2 = temp.substring(0,j) + ( c =='0' ? 9:c-'0'-1 ) + temp.substring(j+1); if(!seen.contains(s1) &amp;&amp;!deads.contains(s1))&#123; queue.add(s1); seen.add(s1); &#125; if(!seen.contains(s2) &amp;&amp;!deads.contains(s2))&#123; queue.add(s2); seen.add(s2); &#125; &#125; &#125; steps++; &#125; return -1; &#125;&#125; ÁªèÂÖ∏BFS„ÄÇÊ≥®ÊÑèÂØπÂõõ‰ΩçÂàÜÂà´ËøõË°åÈ°∫Êó∂Èíà+1Âíå ÈÄÜÊó∂Èíà+1Êìç‰ΩúÔºåÂπ∂‰∏îÂà§Êñ≠Êñ∞ÁöÑstringÊòØÂê¶Âú®deadsÂíåseenÈáåÔºåÁÑ∂ÂêéÂä†ÂÖ•queue„ÄÇÊ≥®ÊÑè‰∏§‰∏™stringÂè™ËÉΩequalsÊØîËæÉÊòØÂê¶Áõ∏ÂêåÔºå==Ê≤°Áî®Ôºå‰ºö‰∏ÄÁõ¥‰∏çÊàêÂäü„ÄÇ","text":"752. Open the Lock üîóQuestion Link class Solution &#123; public int openLock(String[] deadends, String target)&#123; Set&lt;String&gt; deads = new HashSet&lt;&gt;(); for(String str: deadends)&#123; deads.add(str); &#125; Set&lt;String&gt; seen = new HashSet&lt;&gt;(); Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(\"0000\"); seen.add(\"0000\"); int steps = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size ;i++)&#123; String temp = queue.poll(); if(deads.contains(temp))continue; if(temp.equals(target))return steps; for(int j=0 ;j&lt;4;j++)&#123; char c = temp.charAt(j); String s1 = temp.substring(0,j) + ( c =='9' ? 0:c-'0'+1 ) + temp.substring(j+1); String s2 = temp.substring(0,j) + ( c =='0' ? 9:c-'0'-1 ) + temp.substring(j+1); if(!seen.contains(s1) &amp;&amp;!deads.contains(s1))&#123; queue.add(s1); seen.add(s1); &#125; if(!seen.contains(s2) &amp;&amp;!deads.contains(s2))&#123; queue.add(s2); seen.add(s2); &#125; &#125; &#125; steps++; &#125; return -1; &#125;&#125; ÁªèÂÖ∏BFS„ÄÇÊ≥®ÊÑèÂØπÂõõ‰ΩçÂàÜÂà´ËøõË°åÈ°∫Êó∂Èíà+1Âíå ÈÄÜÊó∂Èíà+1Êìç‰ΩúÔºåÂπ∂‰∏îÂà§Êñ≠Êñ∞ÁöÑstringÊòØÂê¶Âú®deadsÂíåseenÈáåÔºåÁÑ∂ÂêéÂä†ÂÖ•queue„ÄÇÊ≥®ÊÑè‰∏§‰∏™stringÂè™ËÉΩequalsÊØîËæÉÊòØÂê¶Áõ∏ÂêåÔºå==Ê≤°Áî®Ôºå‰ºö‰∏ÄÁõ¥‰∏çÊàêÂäü„ÄÇ 33. Search in Rotated Sorted Array üîóQuestion Link class Solution &#123; public int search(int[] nums, int target) &#123; if(nums == null || nums.length == 0)return -1; int len = nums.length-1; int left=0; int right = len; while(left + 1 &lt; right)&#123; int mid = left + (right-left)/2; if(nums[mid] &gt;= nums[left])&#123; if(target&lt;= nums[mid] &amp;&amp; target &gt;= nums[left])&#123; right = mid; &#125;else&#123; left = mid; &#125; &#125; else&#123; if(nums[mid] &lt; target &amp;&amp; target &lt;= nums[len])&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; if(nums[mid] == target)return mid; &#125; if(nums[left] == target)return left; else if(nums[right] == target)return right; return -1; &#125;&#125; sortÁöÑÊï∞ÁªÑË¢´rotateÂêéËÇØÂÆöÊúâ‰∏§ÈÉ®ÂàÜÈÄíÂ¢ûÁöÑÂå∫Âüü„ÄÇmid&gt;leftËØ¥ÊòémidÂú®ËæÉÂ§ßÁöÑÈÄíÂ¢û‰∏Ä‰æßÔºåÂê¶ÂàôÊòØÂú®ËæÉÂ∞èÁöÑÈÄíÂ¢ûÂå∫„ÄÇÈíàÂØπÊØè‰∏™Âå∫ÔºåËøõË°åÊ≠£Â∏∏ÁöÑbinary searchÊìç‰ΩúÔºåÂØπleftÂíårightÊìç‰Ωú„ÄÇ Áî±‰∫éÁî®ÁöÑÊòØwhile left + 1 &lt; rightÁöÑÂÜôÊ≥ïÔºåÊâÄ‰ª•ÊúÄÂêéË¶ÅÂÖàÊ£ÄÊü•leftÊòØÂê¶Á≠â‰∫étargetÔºåÁÑ∂ÂêéÂÜçÊ£ÄÊü•right„ÄÇ 79. Word Search üîóQuestion Link class Solution &#123; public boolean exist(char[][] board, String word) &#123; if(board == null || board.length == 0)return false; int m = board.length; int n = board[0].length; for(int i=0 ; i&lt;m ;i++)&#123; for(int j=0 ; j&lt;n; j++)&#123; if(find(board,i,j,word,0))return true; &#125; &#125; return false; &#125; public boolean find(char[][] board, int i, int j,String word, int index)&#123; if(index == word.length())return true; if(i&lt;0 || i&gt;=board.length || j&lt;0 || j&gt;=board[0].length || board[i][j] != word.charAt(index))return false; board[i][j] = '*'; boolean res = find(board,i+1,j,word,index+1) || find(board,i,j+1,word,index+1) || find(board,i,j-1,word,index+1) || find(board,i-1,j,word,index+1); board[i][j] = word.charAt(index); return res; &#125;&#125; dfs + backtracking. Ê≥®ÊÑèdfs‰πãÂâçÊääÊîπ‰∏∫ÂÄºÁöÑÂ≠óÁ¨¶Âèò‰∏∫*Ôºådfs‰πãÂêéÂÜçÊÅ¢Â§ç„ÄÇÊú¨Ë¥®Â∞±ÊòØÂú®ÊêúÁ¥¢Ê†ëÁöÑÊâÄÊúâÊÉÖÂÜµÈáåÊâæÊòØÂê¶Â≠òÂú®wordËøô‰∏™ÊéíÂàóÁªÑÂêà„ÄÇ 784. Letter Case Permutation üîóQuestion Link BFS Solution class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); if(S == null || S.length() == 0)return res; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.add(S); for(int i=0 ; i&lt;S.length();i++)&#123; if(Character.isDigit(S.charAt(i)))continue; int size = queue.size(); for(int j=0 ;j&lt;size;j++)&#123; String str = queue.poll(); char[] ch = str.toCharArray(); // upper case ch[i] = Character.toUpperCase(ch[i]); queue.add(String.valueOf(ch)); //lower case ch[i] = Character.toLowerCase(ch[i]); queue.add(String.valueOf(ch)); &#125; &#125; for(String s : queue)&#123; res.add(s); &#125; return res; &#125;&#125; ÊääÊØè‰∏™Â≠óÊØçÂ§ßÂ∞èÂÜôÊÉÖÂÜµÂÖ®Âä†ËøõqueueÔºåÁÑ∂Âêé‰æùÊ¨°ÂæÄÂêéÂæ™ÁéØÈÅçÂéÜÔºåÊúÄÂêéÊääS‰∏≠ÊØè‰∏™Â≠óÊØçÂ§ßÂ∞èÂÜôÁöÑÊâÄÊúâÊÉÖÂÜµÂÖ®ÈÉ®Âä†ÂÖ•‰∫Üqueue„ÄÇÊ≥®ÊÑèË∑≥Ëøá‰∏∫Êï∞Â≠óÁöÑchar„ÄÇÊúÄÂêéqueue‰∏≠ÁöÑ‰∏™Êï∞Â∫îËØ•ÊòØSÂ≠óÊØçÈïøÂ∫¶ÁöÑÈò∂‰πò„ÄÇ DFS Solution class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; char[] s = S.toCharArray(); help(s,res,0); return res; &#125; public void help(char[] s, List&lt;String&gt; res, int pos)&#123; if(pos == s.length)&#123; res.add(new String(s)); return; &#125; // ignore digit case if(s[pos]&gt;='0' &amp;&amp; s[pos]&lt;='9')&#123; help(s,res,pos+1); return; &#125; //upper case s[pos] = Character.toUpperCase(s[pos]); help(s,res,pos+1); // lower case s[pos] = Character.toLowerCase(s[pos]); help(s,res,pos+1); &#125;&#125; upper Âíå lowerÁöÑÊÉÖÂÜµÈÉΩË¶ÅÂêÑËá™ËøõË°ådfs„ÄÇ 560. Subarray Sum Equals K üîóQuestion Link class Solution &#123; public int subarraySum(int[] nums, int k) &#123; if(nums == null || nums.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); int sum = 0; int count = 0; for(int num : nums)&#123; sum+=num; if(map.containsKey(sum - k))&#123; count += map.get(sum- k); &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; Á¨¨‰∏âÈÅç„ÄÇPresumÊñπÊ≥ï„ÄÇsum‰∏ÄÁõ¥Á¥ØÂä†ÔºåmapÂ≠òÂêÑ‰∏™sumÂÄºÁöÑÊ¨°Êï∞„ÄÇcountÂä†‰∏äsum-kÂ∞±ÊòØÁõÆÂâçÁöÑsubarrayÊï∞Èáè„ÄÇ 55. Jump Game üîóQuestion Link class Solution &#123; public boolean canJump(int[] nums) &#123; int dist = 0; for(int i = 0 ;i&lt;nums.length;i++)&#123; if(i&gt;dist)return false; dist = Math.max(dist,i+nums[i]); &#125; return true; &#125;&#125; greedy„ÄÇ 45. Jump Game II üîóQuestion Link class Solution &#123; public int jump(int[] nums) &#123; int curend = 0, fast = 0, steps = 0; for(int i = 0 ;i&lt;nums.length-1;i++)&#123; fast = Math.max(fast,i+nums[i]); if(i == curend)&#123; curend = fast; steps++; &#125; &#125; return steps; &#125;&#125; curendÊòØ‰∏ä‰∏ÄÊ≠•ÊúÄËøúË∑ùÁ¶ªÔºåÂ¶ÇÊûúÂà∞Ëææ‰∫ÜcurendÔºåÂàôstep++ÔºåËØ¥Êòé‰∏ä‰∏ÄÊ≠•ÁöÑËµ∑Ë∑≥Â∑≤ÁªèÁªìÊùü„ÄÇÂ∞Ü‰∏ã‰∏Ä‰∏™curendÊõ¥Êñ∞‰∏∫fast„ÄÇ 1306. Jump Game III üîóQuestion Link Recursive Soluiton class Solution &#123; public boolean canReach(int[] arr, int start) &#123; if(start&gt;= 0 &amp;&amp; start &lt; arr.length &amp;&amp; arr[start] &gt;=0 &amp;&amp; arr[start] &lt; arr.length)&#123; int jumpto = arr[start]; arr[start] = -1; if(jumpto == 0)&#123; return true; &#125;else&#123; return canReach(arr,start + jumpto) || canReach(arr,start - jumpto); &#125; &#125; return false; &#125;&#125; jumpÊòØÂΩìÂâçËÉΩË∑≥ÁöÑÊ≠•Êï∞ÔºåÁÑ∂ÂêéÂ∞ÜÂÖ∂Âèò‰∏∫-1„ÄÇÂ¶ÇÊûújumptoÊòØ0ÔºåÂàôÁõ¥Êé•ËøîÂõûtrue„ÄÇÂê¶ÂàôÈÄíÂΩíË∞ÉÁî®ÂêëÂ∑¶ÊàñÂêëÂè≥Ë∑≥ÁöÑÊÉÖÂÜµ„ÄÇ Iterative Solution class Solution &#123; public boolean canReach(int[] arr, int start) &#123; if(arr == null || arr.length == 0)return false; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); HashSet&lt;Integer&gt; seen = new HashSet&lt;&gt;(); while(!queue.isEmpty())&#123; int idx = queue.poll(); if(arr[idx] == 0)return true; if(seen.contains(idx))continue; seen.add(idx); if(idx + arr[idx]&lt;arr.length)&#123; queue.add(idx + arr[idx]); &#125; if(idx - arr[idx] &gt;=0)&#123; queue.add(idx - arr[idx]); &#125; &#125; return false; &#125;&#125; queue bfs„ÄÇ seenÂà§Êñ≠ÊòØÂê¶Ëµ∞Ëøá„ÄÇ‰øùËØÅÂΩìÂâçÂùêÊ†áÂä†‰∏äÊúÄÂ§ßÊ≠•Êï∞Â∞è‰∫éarr.length ‰ª•Âèä &gt;=0„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"Presum","slug":"Presum","permalink":"WangHngLeee.github.io/tags/Presum/"}]},{"title":"Study Go Day 1 üö©","slug":"go1","date":"2020-02-05T04:11:20.000Z","updated":"2020-02-05T23:57:17.486Z","comments":true,"path":"2020/02/04/go1/","link":"","permalink":"WangHngLeee.github.io/2020/02/04/go1/","excerpt":"‰ªäÂ§©Â≠¶‰π†‰∫ÜGoÁöÑÂü∫Êú¨ËØ≠Ê≥ïÂíåÊï∞ÊçÆÁªìÊûÑ„ÄÇÊÑüËßâÂíåRubyÊúâÁÇπÂÉè‚Ä¶ ‰ª•‰∏ãÊòØÂíå‰ª•ÂæÄÂ≠¶‰π†ÁöÑËØ≠Ë®ÄÊúâÂæàÂ§ß‰∏çÂêåÁöÑÂú∞Êñπ„ÄÇ Â£∞ÊòéÁ±ªÂûã GOÂíåjavaÁöÑÁ±ªÂûãÂ£∞ÊòéÊ≠£Â•ΩÁõ∏ÂèçÔºåjavaÁ±ªÂûãÂÜôÂú®ÂèòÈáèÂâçÈù¢ÔºåËÄåGoÂÜôÂú®ÂèòÈáèÂêéÈù¢„ÄÇvar name type = xxx. ‰æãÂ¶ÇÔºövar a int = avar a float64 = 1.3423","text":"‰ªäÂ§©Â≠¶‰π†‰∫ÜGoÁöÑÂü∫Êú¨ËØ≠Ê≥ïÂíåÊï∞ÊçÆÁªìÊûÑ„ÄÇÊÑüËßâÂíåRubyÊúâÁÇπÂÉè‚Ä¶ ‰ª•‰∏ãÊòØÂíå‰ª•ÂæÄÂ≠¶‰π†ÁöÑËØ≠Ë®ÄÊúâÂæàÂ§ß‰∏çÂêåÁöÑÂú∞Êñπ„ÄÇ Â£∞ÊòéÁ±ªÂûã GOÂíåjavaÁöÑÁ±ªÂûãÂ£∞ÊòéÊ≠£Â•ΩÁõ∏ÂèçÔºåjavaÁ±ªÂûãÂÜôÂú®ÂèòÈáèÂâçÈù¢ÔºåËÄåGoÂÜôÂú®ÂèòÈáèÂêéÈù¢„ÄÇvar name type = xxx. ‰æãÂ¶ÇÔºövar a int = avar a float64 = 1.3423 GoËØ≠Ë®ÄÁöÑÂü∫Êú¨Á±ªÂûãÊúâÔºö bool string int„ÄÅint8„ÄÅint16„ÄÅint32„ÄÅint64 uint„ÄÅuint8„ÄÅuint16„ÄÅuint32„ÄÅuint64„ÄÅuintptr byte // uint8 ÁöÑÂà´Âêç rune // int32 ÁöÑÂà´Âêç ‰ª£Ë°®‰∏Ä‰∏™ Unicode Á†Å float32„ÄÅfloat64 complex64„ÄÅcomplex128 ÊâπÈáèÊ†ºÂºè ÊØèË°åÈÉΩÁî® var Â£∞ÊòéÂèòÈáèÊØîËæÉÈ∫ªÁÉ¶ÔºåÊâÄ‰ª•Êàë‰ª¨ËøòÂèØ‰ª•ÊâπÈáèÂÆö‰πâÂèòÈáèÔºö var ( a int b string c []float32 d func() bool e struct &#123; x int &#125;) ‰ΩøÁî®ÂÖ≥ÈîÆÂ≠ó var ÂíåÊã¨Âè∑ÔºåÂèØ‰ª•Â∞Ü‰∏ÄÁªÑÂèòÈáèÂÆö‰πâÊîæÂú®‰∏ÄËµ∑„ÄÇ ÁÆÄÁü≠Ê†ºÂºè Èô§ var ÂÖ≥ÈîÆÂ≠óÂ§ñÔºåËøòÂèØ‰ΩøÁî®Êõ¥Âä†ÁÆÄÁü≠ÁöÑÂèòÈáèÂÆö‰πâÂíåÂàùÂßãÂåñËØ≠Ê≥ï„ÄÇ ÂêçÂ≠ó := Ë°®ËææÂºè ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºåÁÆÄÁü≠Ê®°ÂºèÔºàshort variable declarationÔºâÊúâ‰ª•‰∏ãÈôêÂà∂Ôºö ÂÆö‰πâÂèòÈáèÔºåÂêåÊó∂ÊòæÂºèÂàùÂßãÂåñ„ÄÇ ‰∏çËÉΩÊèê‰æõÊï∞ÊçÆÁ±ªÂûã„ÄÇÂè™ËÉΩÁî®Âú®ÂáΩÊï∞ÂÜÖÈÉ®„ÄÇ Âíå var ÂΩ¢ÂºèÂ£∞ÊòéËØ≠Âè•‰∏ÄÊ†∑ÔºåÁÆÄÁü≠ÂèòÈáèÂ£∞ÊòéËØ≠Âè•‰πüÂèØ‰ª•Áî®Êù•Â£∞ÊòéÂíåÂàùÂßãÂåñ‰∏ÄÁªÑÂèòÈáèÔºö i := 0j := 1a := falseb := \"ewarwar\"","categories":[{"name":"Language","slug":"Language","permalink":"WangHngLeee.github.io/categories/Language/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"WangHngLeee.github.io/tags/Golang/"}]},{"title":"Leetcode EveryDay 71 üí™","slug":"chin-up-09","date":"2020-02-04T15:23:15.000Z","updated":"2020-02-05T23:57:14.555Z","comments":true,"path":"2020/02/04/chin-up-09/","link":"","permalink":"WangHngLeee.github.io/2020/02/04/chin-up-09/","excerpt":"11. Container With Most Water üîóQuestion Link class Solution &#123; public int maxArea(int[] height)&#123; int left = 0; int right = height.length-1; int max = Integer.MIN_VALUE; while(left &lt; right)&#123; max = Math.max(max,Math.min(height[left],height[right]) * (right - left )); if(height[left] &lt; height[right])&#123; left++; &#125;else&#123; right--; &#125; &#125; return max; &#125;&#125; ÂèåÊåáÈíà„ÄÇÂèñÂΩìÂâçheight[left] height[right]ÁöÑÊúÄÂ∞èÂÄº‰∏∫È´òÔºårightÂíåleftÁöÑÂ∑Æ‰∏∫ÈïøÔºåÁõ∏‰πò‰∏∫ÂΩìÂâçareaÔºå‰∏émaxÊØîËæÉ„ÄÇÂ¶ÇÊûúleftÁöÑheightÂ∞è‰∫érightÔºåÂàôleft++ÔºåÂê¶Âàôright‚Äì„ÄÇÁõÆÁöÑÊòØ‰øùËØÅ‰∏Ä‰æß‰∏∫ÊúÄÂ§ßÈ´òÂ∫¶„ÄÇ","text":"11. Container With Most Water üîóQuestion Link class Solution &#123; public int maxArea(int[] height)&#123; int left = 0; int right = height.length-1; int max = Integer.MIN_VALUE; while(left &lt; right)&#123; max = Math.max(max,Math.min(height[left],height[right]) * (right - left )); if(height[left] &lt; height[right])&#123; left++; &#125;else&#123; right--; &#125; &#125; return max; &#125;&#125; ÂèåÊåáÈíà„ÄÇÂèñÂΩìÂâçheight[left] height[right]ÁöÑÊúÄÂ∞èÂÄº‰∏∫È´òÔºårightÂíåleftÁöÑÂ∑Æ‰∏∫ÈïøÔºåÁõ∏‰πò‰∏∫ÂΩìÂâçareaÔºå‰∏émaxÊØîËæÉ„ÄÇÂ¶ÇÊûúleftÁöÑheightÂ∞è‰∫érightÔºåÂàôleft++ÔºåÂê¶Âàôright‚Äì„ÄÇÁõÆÁöÑÊòØ‰øùËØÅ‰∏Ä‰æß‰∏∫ÊúÄÂ§ßÈ´òÂ∫¶„ÄÇ 42. Trapping Rain Water üîóQuestion Link class Solution &#123; public int trap(int[] height) &#123; if(height == null || height.length == 0)return 0; int leftmost = Integer.MIN_VALUE; int rightmost = Integer.MIN_VALUE; int left = 0; int right = height.length-1; int area = 0; while(left &lt; right)&#123; leftmost = Math.max(leftmost,height[left]); rightmost = Math.max(rightmost,height[right]); if(leftmost &lt; rightmost)&#123; area+=leftmost-height[left]; left++; &#125;else&#123; area+=rightmost-height[right]; right--; &#125; &#125; return area; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇÂèåÊåáÈíà„ÄÇÁª¥Êä§ÊúÄÂ∑¶ÂíåÊúÄÂè≥ËæπÁöÑÊúÄÂ§ßÈ´òÂ∫¶ÔºåÂ¶ÇÊûúÊúÄÂ∑¶ËæπÊúÄÈ´òÂ∞è‰∫éÊúÄÂè≥ËæπÊúÄÈ´òÔºåÈÄöËøáÁü≠ÊùøÊú®Ê°∂ÂéüÁêÜÔºåÂèØÁü•ÂΩìÂâçÊúÄÂ§ßÂ≠òÊ∞¥Âè™ËÉΩÂú®ÊúÄÂ∑¶ËæπÔºåÊâÄ‰ª•Áî®height[left]ÂíåleftmostÊØîËæÉÔºå‰ªñ‰ø©ÁöÑÂ∑ÆÂ∞±ÊòØÂ∑¶ËæπÂå∫ÂüüÂèØ‰ª•Â≠òÁöÑÊ∞¥Èáè„ÄÇÂè≥ËæπÂêåÁêÜ„ÄÇ 986. Interval List Intersections üîóQuestion Link class Solution &#123; public int[][] intervalIntersection(int[][] A, int[][] B) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int a= 0, b = 0; while(a &lt; A.length &amp;&amp; b &lt; B.length)&#123; int start = Math.max( A[a][0] , B[b][0] ); int end = Math.min( A[a][1] , B[b][1] ); if(start &lt;= end)res.add(new int[]&#123;start,end&#125;); if( A[a][1] &lt; B[b][1] ) a++; else b++; &#125; int[][] ans = new int[res.size()][2]; int i= 0; for(int[] num : res)&#123; ans[i] = num; i++; &#125; return ans; &#125;&#125; two pointer„ÄÇÂè™ÊúâÂΩì‰∏§‰∏™intervalÁöÑÂºÄÂ§¥ÊúÄÂ§ßÂÄº Â∞è‰∫é ÁªìÊùüÊúÄÂ∞èÂÄºÊó∂ÔºåÊâç‰ºöÊúâoverlap„ÄÇÊé•ÁùÄÔºå‰∏çËÆ∫ÊúâÊ≤°ÊúâoverlapÔºåÂ¶ÇÊûúÁ¨¨‰∏Ä‰∏™ÁöÑÁªìÂ∞æÂ∞è‰∫éÁ¨¨‰∫å‰∏™ÁöÑÁªìÂ∞æÔºåÂ∞ÜÁ¨¨‰∏Ä‰∏™ÂêëÂêéÁßªÂä®ÔºåÂê¶ÂàôÁ¨¨‰∫å‰∏™ÂêëÂêéÁßªÂä®ÔºåÁªßÁª≠ÈÅçÂéÜ„ÄÇ 209. Minimum Size Subarray Sum üîóQuestion Link class Solution &#123; public int minSubArrayLen(int s, int[] nums) &#123; if(nums == null || nums.length == 0)return 0;//corner case int start = 0, sum = 0, min = Integer.MAX_VALUE; for(int i = 0;i&lt;nums.length ;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-start+1); sum-=nums[start]; start++; &#125; &#125; return min == Integer.MAX_VALUE ? 0 : min; &#125;&#125; two pointer„ÄÇÂΩìsum &gt; sÁöÑÊó∂ÂÄôÔºå‰ªéstartÂºÄÂßãÂáè„ÄÇÁª¥Êä§‰∏Ä‰∏™minÊúÄÂêéËøîÂõû„ÄÇ 75. Sort Color üîóQuestion Link class Solution &#123; public void sortColors(int[] nums) &#123; int[] bucket = new int[3]; for(int num : nums)&#123; bucket[num]++; &#125; int pos = 0; for(int i=0;i&lt;bucket.length;i++)&#123; for(int count = 0; count &lt; bucket[i] ;count++)&#123; nums[pos] = i; pos++; &#125; &#125; &#125;&#125; bucket sort. 349. Intersection of Two Arrays üîóQuestion Link class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(); for(int num : nums1)&#123; set1.add(num); &#125; for(int num : nums2)&#123; if(set1.contains(num))&#123; set2.add(num); &#125; &#125; int[] res = new int[set2.size()]; int i=0; for(int num : set2)&#123; res[i] = num; i++; &#125; return res; &#125;&#125; ‰∏§‰∏™setÊ£ÄÊü•ÈáçÂ§çÂÖÉÁ¥†ÔºåÊúÄÂêéËøîÂõûset2. 350. Intersection of Two Arrays II üîóQuestion Link class Solution &#123; public int[] intersect(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums1)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; for(int num : nums2)&#123; if(map.containsKey(num) &amp;&amp; map.get(num)&gt;0)&#123; temp.add(num); map.put(num,map.get(num)-1); &#125; &#125; int[] ans = new int[temp.size()]; for(int i=0 ;i&lt;temp.size();i++)&#123; ans[i] = temp.get(i); &#125; return ans; &#125;&#125; Âíå‰∏ä‰∏ÄÈÅìÈ¢ò‰∏çÂêåÁÇπÂú®‰∫éË¶ÅËøîÂõûÊâÄÊúâÈáçÂ§çÈÉ®ÂàÜÁöÑÊï∞Â≠óÔºå‰∏çÂçïÂçïÊòØ‰∏Ä‰∏™‰ª£Ë°®‰∫Ü„ÄÇÊâÄ‰ª•Ë¶ÅÁî®Âà∞mapÊù•Â≠òÂá∫Áé∞Ê¨°Êï∞„ÄÇÊ¨°Êï∞‰∏∫Èõ∂ or Ê¨°Êï∞‰∏ç‰∏∫Èõ∂‰ΩÜÊòØ‰∏çÂÜçÂá∫Áé∞ËØ•Êï∞Â≠óÊó∂ÔºåÊâæ‰∏ã‰∏Ä‰∏™Êï∞Â≠ó„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"WangHngLeee.github.io/tags/TwoPointers/"},{"name":"BucketSort","slug":"BucketSort","permalink":"WangHngLeee.github.io/tags/BucketSort/"}]},{"title":"Leetcode EveryDay 70 üí™","slug":"chin-up-08","date":"2020-02-03T16:39:28.000Z","updated":"2020-02-04T03:53:05.706Z","comments":true,"path":"2020/02/03/chin-up-08/","link":"","permalink":"WangHngLeee.github.io/2020/02/03/chin-up-08/","excerpt":"437. Path Sum III üîóQuestion Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,0,sum,map); return total; &#125; public void help(TreeNode root, int cursum, int target,Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - target))&#123; total+=map.get(cursum - target); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,cursum,target,map); help(root.right,cursum,target,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; presum + backtracking„ÄÇ‰∏ÄÂÆöË¶ÅËÆ∞‰ΩèÊúÄÂêébacktrackÂáè1„ÄÇ","text":"437. Path Sum III üîóQuestion Link class Solution &#123; int total = 0; public int pathSum(TreeNode root, int sum) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); map.put(0,1); help(root,0,sum,map); return total; &#125; public void help(TreeNode root, int cursum, int target,Map&lt;Integer,Integer&gt; map)&#123; if(root == null)return; cursum+=root.val; if(map.containsKey(cursum - target))&#123; total+=map.get(cursum - target); &#125; map.put(cursum,map.getOrDefault(cursum,0)+1); help(root.left,cursum,target,map); help(root.right,cursum,target,map); map.put(cursum,map.get(cursum)-1); &#125;&#125; presum + backtracking„ÄÇ‰∏ÄÂÆöË¶ÅËÆ∞‰ΩèÊúÄÂêébacktrackÂáè1„ÄÇ 95. Unique Binary Search Trees II üîóQuestion Link class Solution &#123; public List&lt;TreeNode&gt; generateTrees(int n) &#123; if(n == 0)return new ArrayList&lt;&gt;(); return help(1,n); &#125; public List&lt;TreeNode&gt; help(int start, int end)&#123; List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); if(start &gt; end)res.add(null); for(int i=start ;i&lt;=end;i++)&#123; List&lt;TreeNode&gt; leftset = help(start,i-1); List&lt;TreeNode&gt; rightset = help(i+1,end); for(TreeNode left : leftset)&#123; for(TreeNode right : rightset)&#123; TreeNode node = new TreeNode(i); node.left = left; node.right = right; res.add(node); &#125; &#125; &#125; return res; &#125;&#125; ‰ªé1-&gt;nÊòØËäÇÁÇπ1Âà∞nÁöÑ‰ªª‰ΩïBSTÁöÑin-orderÈÅçÂéÜ„ÄÇÂõ†Ê≠§ÔºåÂ¶ÇÊûúÈÄâÊã©Á¨¨i‰∏™ËäÇÁÇπ‰Ωú‰∏∫Ê†πÔºåÂàôÂ∑¶Â≠êÊ†ëÂ∞ÜÂåÖÂê´ÂÖÉÁ¥†1Ëá≥Ôºài-1ÔºâÔºåËÄåÂè≥Â≠êÊ†ëÂ∞ÜÂåÖÂê´ÂÖÉÁ¥†Ôºài + 1ÔºâËá≥n„ÄÇ‰ΩøÁî®ÈÄíÂΩíË∞ÉÁî®Êù•Ëé∑ÂèñÂ∑¶Âè≥Â≠êÊ†ëÁöÑÊâÄÊúâÂèØËÉΩÊ†ëÔºåÂπ∂Â∞ÜÊâÄÊúâÂèØËÉΩÁöÑÊñπÂºèÂ∞Ü‰∏éÊ†πÁªÑÂêà„ÄÇ 114. Flatten Binary Tree to Linked List üîóQuestion Link class Solution &#123; public TreeNode pre = null; public void flatten(TreeNode root) &#123; if(root == null)return ; flatten(root.right); flatten(root.left); root.right = pre; root.left=null; pre = root; &#125;&#125; ÂÖàÈÄíÂΩíÂà∞ÊúÄÂè≥ËäÇÁÇπÔºå‰æùÊ¨°ËøûÊé•ËäÇÁÇπÔºåÁÑ∂ÂêéÂú®‰ªéÂ∑¶Â≠êÊ†ëÂºÄÂßãÁªßÁª≠ÂêëÂè≥ÈÄíÂΩíÔºåpre‰øùÂ≠òÂà∞ÊòØ‰∏ä‰∏ÄÊ¨°ÈÄíÂΩíÁªìÊùüÊó∂ÁöÑnodeÔºåÊäänodeËøûÂà∞ÂΩìÂâçrootÂà∞rightÔºåÁÑ∂ÂêéleftÂèònullÔºåÁªßÁª≠ÈÄíÂΩí„ÄÇËßÜÈ¢ëËÆ≤Ëß£‚¨áÔ∏è 116. Populating Next Right Pointers in Each Node üîóQuestion Link class Solution &#123; public Node connect(Node root) &#123; if(root == null)return root; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; Node node = queue.poll(); node.next = i&lt;size-1 ? queue.peek() : null; if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; &#125; return root; &#125;&#125; Á¨¨‰∏âÈÅç„ÄÇÂ∏∏ËßÑlevel traversalÂÜôÊ≥ïÔºåÂè™Âú®ÂΩìÂâçÂ±ÇÊúÄÂêé‰∏Ä‰∏™nodeÊó∂ÊäänextÁªôÂà∞nullÔºåÂÖ∂‰ªñÁöÑnextÈÉΩÊòØqueueÈáåÁöÑ‰∏ã‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂç≥Ê®™ÂêëÂè≥ËæπÁöÑnode„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"}]},{"title":"Leetcode EveryDay 69 üí™","slug":"chin-up-07","date":"2020-02-02T15:32:17.000Z","updated":"2020-02-04T03:50:02.365Z","comments":true,"path":"2020/02/02/chin-up-07/","link":"","permalink":"WangHngLeee.github.io/2020/02/02/chin-up-07/","excerpt":"163. Missing Ranges üîóQuestion Link class Solution &#123; public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int next = lower; for (int i = 0; i &lt; nums.length; i++) &#123; if (next == nums[i]) &#123; next++; &#125; else if(nums[i]&lt;next)continue; else &#123; res.add(range(next, nums[i] - 1)); next = nums[i] + 1; &#125; if (next == Integer.MIN_VALUE)return res; &#125; if (next &lt;= upper) res.add(range(next, upper)); return res; &#125; public String range(int low, int high) &#123; return low == high ? String.valueOf(low) : (low + \"-&gt;\" + high); &#125;&#125; ÈÅçÂéÜnumsÔºåÊõ¥Êñ∞nextÔºåÂ¶ÇÊûúnext &lt; &gt;nums[i]ÂàôÂ≠òÂú®gapÔºåÂä†ÂÖ•resÔºå‰πãÂêéÊõ¥Êñ∞next‰∏∫ÂΩìÂâçnums[i]+1ÁªßÁª≠ÈÅçÂéÜ„ÄÇ","text":"163. Missing Ranges üîóQuestion Link class Solution &#123; public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int next = lower; for (int i = 0; i &lt; nums.length; i++) &#123; if (next == nums[i]) &#123; next++; &#125; else if(nums[i]&lt;next)continue; else &#123; res.add(range(next, nums[i] - 1)); next = nums[i] + 1; &#125; if (next == Integer.MIN_VALUE)return res; &#125; if (next &lt;= upper) res.add(range(next, upper)); return res; &#125; public String range(int low, int high) &#123; return low == high ? String.valueOf(low) : (low + \"-&gt;\" + high); &#125;&#125; ÈÅçÂéÜnumsÔºåÊõ¥Êñ∞nextÔºåÂ¶ÇÊûúnext &lt; &gt;nums[i]ÂàôÂ≠òÂú®gapÔºåÂä†ÂÖ•resÔºå‰πãÂêéÊõ¥Êñ∞next‰∏∫ÂΩìÂâçnums[i]+1ÁªßÁª≠ÈÅçÂéÜ„ÄÇ 168. Excel Sheet Column Title üîóQuestion Link class Solution &#123; public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while(n&gt;0)&#123; n--; sb.append((char)('A' + n%26)); n = n/26; &#125; sb.reverse(); return sb.toString(); &#125;&#125; ‰ªéÂêéÂæÄÂâçÊâæÔºåÂÖàÂèñ‰ΩôÊï∞ÂÜçÂèñÊë∏ÔºåÊúÄÂêéreverse‰∏Ä‰∏ãÂ∞±ÊòØÊ≠£Á°ÆÈ°∫Â∫èÁöÑres„ÄÇ Time Complexity : O(N) 93. Restore IP Addresses üîóQuestion Link class Solution &#123; public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); int len = s.length(); for(int i=1;i&lt;4 &amp;&amp; i&lt;len-2;i++)&#123; for(int j=i+1;j&lt;i+4 &amp;&amp; j&lt;len-1;j++)&#123; for(int k=j+1;k&lt;j+4 &amp;&amp; k&lt;len;k++)&#123; String s1 = s.substring(0,i); String s2 = s.substring(i,j); String s3 = s.substring(j,k); String s4 = s.substring(k,len); if(check(s1) &amp;&amp; check(s2) &amp;&amp; check(s3) &amp;&amp; check(s4))&#123; res.add(s1+\".\"+s2+\".\"+s3+\".\"+s4); &#125; &#125; &#125; &#125; return res; &#125; public boolean check(String a)&#123; if(a.length()&gt;3||a.length()==0||(a.charAt(0)=='0' &amp;&amp; a.length()&gt;1))return false; if(Integer.parseInt(a) &gt; 255)return false; return true; &#125;&#125; ÂêàÊ†ºIPÂú∞ÂùÄ ÔºöÊúÄÂ§ö3‰ΩçÔºåÊúÄÂ§ß255ÔºåÂ¶ÇÊûúÊòØ0Âè™Êúâ‰∏Ä‰Ωç„ÄÇ‰∏âÂ±ÇÂæ™ÁéØÊääsÂàÜÊàêÂõõÈÉ®ÂàÜÔºå‰æùÊ¨°Âæ™ÁéØÊØîËæÉ„ÄÇ Time ComplexityÔºöO(N) 32. Longest Valid Parentheses üîóQuestion Link class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;len;i++)&#123; if(s.charAt(i) == '(')open++; else if(open &gt;0 &amp;&amp; s.charAt(i) == ')')&#123; dp[i] = dp[i-1] + 2; if(i-dp[i]&gt;0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; dp„ÄÇopen&gt;0Êó∂ÊâçÂØπ ÔºâÊìç‰Ωú„ÄÇÊ≥®ÊÑèÈ¢òÁõÆË¶ÅÊ±ÇÊúÄÈïøËøûÁª≠validÔºåÊâÄ‰ª•Ë¶ÅÊ£ÄÊü•‰∏Ä‰∏ãi-dp[i]ÔºåÂç≥ÔºöÂú®ÂΩìÂâçÂêàÊ†ºÁöÑÊã¨Âè∑ÈïøÂ∫¶‰πãÂâçÔºåÊúâÊó†ÂêàÊ†ºÁöÑÈïøÂ∫¶Â≠òÂú®ÔºåÊúâÁöÑËØùÂä†Ëµ∑Êù•ÔºåÊ≤°ÊúâÂàôÁªßÁª≠dp„ÄÇ 125. Valid Palindrome üîóQuestion Link class Solution &#123; public boolean isPalindrome(String s)&#123; if(s == null || s.length() == 0)return true; int left = 0; int right = s.length()-1; while(left &lt;= right)&#123; char l = s.charAt(left); char r = s.charAt(right); if(!Character.isLetterOrDigit(l))&#123; left++; &#125; else if(!Character.isLetterOrDigit(r))&#123; right--; &#125;else&#123; if(Character.toLowerCase(l) != Character.toLowerCase(r))return false; right--; left++; &#125; &#125; return true; &#125;&#125; ÂèåÊåáÈíà„ÄÇÊ≥®ÊÑèisLetterOrDigitÂíåtoLowerCaseÁöÑÁî®Ê≥ï„ÄÇ 819. Most Common Word üîóQuestion Link class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; String res = \"\"; if(paragraph == null || paragraph.length() == 0)return res; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; ban = new HashSet&lt;&gt;(); String[] strs = paragraph.toLowerCase().split(\"\\\\W++\"); for(String str : banned)&#123; ban.add(str); &#125; for(String str : strs)&#123; if(ban.contains(str))continue; else map.put(str,map.getOrDefault(str,0)+1); &#125; int max = 0; for(String key : map.keySet())&#123; if(map.get(key) &gt; max)&#123; max = map.get(key); res = key; &#125; &#125; return res; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇsetÂ≠òbanned wordÔºå mapÂ≠ò‰∏çÂú®setÈáåÁöÑwordÊ¨°Êï∞„ÄÇÁª¥Êä§maxÂíåres‰∏çÊñ≠ÈÅçÂéÜmapÁöÑkeyset„ÄÇÊúÄÂêéËøîÂõûres„ÄÇ 72. Edit Distance üîóQuestion Link class Solution &#123; public int minDistance(String word1, String word2) &#123; int len1 = word1.length(); int len2 = word2.length(); int[][] edit = new int[len1+1][len2+1]; for(int i=0 ;i&lt;=len1 ;i++)&#123; edit[i][0] = i; &#125; for(int i=0 ;i&lt;=len2 ;i++)&#123; edit[0][i] = i; &#125; for(int i=0 ;i&lt;len1 ;i++)&#123; for(int j=0 ;j&lt;len2 ;j++)&#123; if(word1.charAt(i) == word2.charAt(j))&#123; edit[i+1][j+1] = edit[i][j]; &#125;else&#123; int replace = edit[i][j]; int delete = edit[i+1][j]; int insert = edit[i][j+1]; edit[i+1][j+1] = Math.min(replace,Math.min(delete,insert))+1; &#125; &#125; &#125; return edit[len1][len2]; &#125;&#125; Á¨¨ÂõõÈÅç„ÄÇÂÖàÂàùÂßãÂåñedit‰∏§‰∏™ËæπÁºòÁöÑÂÄº„ÄÇÁÑ∂Âêé‰∏Ä‰∏ÄÈÅçÂéÜ„ÄÇÈô§‰∫ÜÁõ∏Âêå‰ª•Â§ñÔºåÊúâ‰∏âÁßçÊìç‰ΩúÔºåÊâÄ‰ª•ÂΩìÂâçÊìç‰ΩúÊ¨°Êï∞‰∏∫‰∏âÁßçÊúÄÂ∞èÂÄº+1„ÄÇ 13. Roman to Integer üîóQuestion Link class Solution: def romanToInt(self, s: str) -&gt; int: roman = &#123;'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000&#125; z = 0; for i in range(0,len(s)-1): if roman[s[i]] &lt; roman[s[i+1]]: z-=roman[s[i]] else: z+=roman[s[i]] return z + roman[s[-1]] python„ÄÇÂª∫mapÂ≠òÂØπÂ∫îÂÄº„ÄÇIV ËøôÁßçÊÉÖÂÜµÂáèÊ≥ïÊìç‰ΩúÔºåVIËøôÁßçÊÉÖÂÜµÂä†Ê≥ïÊìç‰Ωú„ÄÇ 97. Interleaving String üîóQuestion Link class Solution &#123; public boolean isInterleave(String s1, String s2, String s3) &#123; if((s1.length() + s2.length())!= s3.length())return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1]; matrix[0][0] = true; for(int i = 1;i&lt;matrix[0].length;i++)&#123; matrix[0][i] = matrix[0][i-1] &amp;&amp; (s1.charAt(i-1) == s3.charAt(i-1)); &#125; for(int i =1;i&lt;matrix.length;i++)&#123; matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i-1)); &#125; for(int i = 1; i&lt;matrix.length;i++)&#123; for(int j = 1; j&lt;matrix[0].length;j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1)== s3.charAt(i+j-1))); &#125; &#125; return matrix[s2.length()][s1.length()]; &#125;&#125; DPË°®Ë°®Á§∫ÂΩìs1Âú®Á¨¨i‰∏™‰ΩçÁΩÆÂπ∂‰∏îs2Âú®Á¨¨j‰∏™‰ΩçÁΩÆÊó∂Ôºås3ÊòØÂê¶Âú®Á¨¨Ôºài + jÔºâ‰∏™‰ΩçÁΩÆ‰∫§Áªá„ÄÇÁ¨¨0‰ΩçË°®Á§∫Á©∫Â≠óÁ¨¶‰∏≤„ÄÇ Âõ†Ê≠§ÔºåÂ¶ÇÊûús1Âíås2ÂΩìÂâçÈÉΩ‰∏∫Á©∫ÔºåÂàôs3‰πü‰∏∫Á©∫ÔºåÂπ∂‰∏îË¢´ËÆ§‰∏∫ÊòØ‰∫§ÁªáÁöÑ„ÄÇÂ¶ÇÊûúÂè™Êúâs1‰∏∫Á©∫ÔºåÂàôÂ¶ÇÊûúÂÖàÂâçÁöÑs2‰ΩçÁΩÆÊ≠£Âú®‰∫§ÁªáÂπ∂‰∏îÂΩìÂâçs2‰ΩçÁΩÆcharÁ≠â‰∫és3ÂΩìÂâç‰ΩçÁΩÆcharÔºåÂàôËÆ§‰∏∫ÊòØ‰∫§Áªá„ÄÇÁ±ª‰ººÁöÑÊÉ≥Ê≥ï‰πüÈÄÇÁî®‰∫és2‰∏∫Á©∫ÁöÑÊÉÖÂÜµ„ÄÇÂΩìs1Âíås2ÈÉΩ‰∏ç‰∏∫Á©∫Êó∂ÔºåÂ¶ÇÊûúÊàë‰ª¨‰ªéi-1ÔºåjÂà∞ËææiÔºåjÔºåÂàôÂ¶ÇÊûúi-1ÔºåjÂ∑≤Áªè‰∫§ÁªáÂπ∂‰∏îiÂíåÂΩìÂâçs3‰ΩçÁΩÆÁõ∏Á≠âÔºåÂàô‰∏∫‰∫§Áªá„ÄÇÂ¶ÇÊûúÊàë‰ª¨‰ªéiÔºåj-1Âà∞ËææiÔºåjÔºåÂàôÂ¶ÇÊûúiÔºåj-1Â∑≤Áªè‰∫§ÁªáÂπ∂‰∏îjÂíåÂΩìÂâçs3‰ΩçÁΩÆÁõ∏Á≠â„ÄÇÂÆÉÊòØ‰∫§ÈîôÁöÑ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"}]},{"title":"Weekly Contest 174 üèÜ","slug":"contest01","date":"2020-02-02T04:01:09.000Z","updated":"2020-03-16T00:11:02.703Z","comments":true,"path":"2020/02/01/contest01/","link":"","permalink":"WangHngLeee.github.io/2020/02/01/contest01/","excerpt":"üìå ‰ªäÂ§©Ëµ∑ÊØèÂë®ÁöÑlc contest‰πüÊÄªÁªì‰∏Ä‰∏ã„ÄÇËá™Â∑±ÁöÑÁ≠îÊ°àÂíå‰ºòÁßÄÁ≠îÊ°àÂÜôÂú®‰∏ÄËµ∑„ÄÇ 5328. The K Weakest Rows in a Matrix üîóQuestion Link First Solution class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; if(mat == null || mat.length == 0)return null; int[] res = new int[k]; int m = mat.length; int n = mat[0].length; int[][] arr = new int[m][2]; for(int i=0 ;i&lt;m;i++)&#123; int num = 0; for(int j=0 ;j&lt;n;j++)&#123; if(mat[i][j] == 1)&#123; num++; &#125; &#125; arr[i]=new int[]&#123;num,i&#125;; &#125; Arrays.sort(arr,(a,b)-&gt;a[0]-b[0]); for(int i=0 ;i&lt;k;i++)&#123; res[i] = arr[i][1]; &#125; return res; &#125;&#125; ÂΩìÊó∂ÊÄùË∑ØÔºö‰∫åÁª¥Êï∞ÁªÑÂ≠ò1ÁöÑ‰∏™Êï∞‰ª•ÂèäË°åÁöÑindex„ÄÇÁÑ∂ÂêéÁî®numÂØπarrËøõË°åsortÔºåÊúÄÂêéÊåâÂ∫èÂ∞ÜÂõ∫ÂÆök‰∏™iÂ≠òÂÖ•res„ÄÇ Optimized Solution Áúã‰∫Ü‰∏ÄÂúàdisscussÂü∫Êú¨ÊÄùË∑ØÂíåÊàë‰∏ÄÊ†∑„ÄÇÂè™‰∏çËøáÊúâ‰∫∫Áî®priorityqueue ÈáçÂÜôsortÔºåÊ†∏ÂøÉÊ≤°Âèò„ÄÇ","text":"üìå ‰ªäÂ§©Ëµ∑ÊØèÂë®ÁöÑlc contest‰πüÊÄªÁªì‰∏Ä‰∏ã„ÄÇËá™Â∑±ÁöÑÁ≠îÊ°àÂíå‰ºòÁßÄÁ≠îÊ°àÂÜôÂú®‰∏ÄËµ∑„ÄÇ 5328. The K Weakest Rows in a Matrix üîóQuestion Link First Solution class Solution &#123; public int[] kWeakestRows(int[][] mat, int k) &#123; if(mat == null || mat.length == 0)return null; int[] res = new int[k]; int m = mat.length; int n = mat[0].length; int[][] arr = new int[m][2]; for(int i=0 ;i&lt;m;i++)&#123; int num = 0; for(int j=0 ;j&lt;n;j++)&#123; if(mat[i][j] == 1)&#123; num++; &#125; &#125; arr[i]=new int[]&#123;num,i&#125;; &#125; Arrays.sort(arr,(a,b)-&gt;a[0]-b[0]); for(int i=0 ;i&lt;k;i++)&#123; res[i] = arr[i][1]; &#125; return res; &#125;&#125; ÂΩìÊó∂ÊÄùË∑ØÔºö‰∫åÁª¥Êï∞ÁªÑÂ≠ò1ÁöÑ‰∏™Êï∞‰ª•ÂèäË°åÁöÑindex„ÄÇÁÑ∂ÂêéÁî®numÂØπarrËøõË°åsortÔºåÊúÄÂêéÊåâÂ∫èÂ∞ÜÂõ∫ÂÆök‰∏™iÂ≠òÂÖ•res„ÄÇ Optimized Solution Áúã‰∫Ü‰∏ÄÂúàdisscussÂü∫Êú¨ÊÄùË∑ØÂíåÊàë‰∏ÄÊ†∑„ÄÇÂè™‰∏çËøáÊúâ‰∫∫Áî®priorityqueue ÈáçÂÜôsortÔºåÊ†∏ÂøÉÊ≤°Âèò„ÄÇ 5329. Reduce Array Size to The Half üîóQuestion Link First Solution class Solution &#123; public int minSetSize(int[] arr) &#123; if(arr == null || arr.length == 0)return 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt;map.get(b)-map.get(a)); Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int len = arr.length; int halflen = len/2; if(arr == null || arr.length == 0)return 0; for(int num : arr)&#123; map.put(num,map.getOrDefault(num,0)+1); &#125; for(int a : arr)&#123; if(!set.contains(a))&#123; queue.add(a); set.add(a); &#125; &#125; int res = 0; while(!queue.isEmpty())&#123; int temp = queue.poll(); int templen = map.get(temp); res++; len-=templen; if(len &lt;= halflen)return res; &#125; return -1; &#125;&#125; mapÂ≠òÂÖÉÁ¥†‰∏™Êï∞Ôºåpq‰ªéÂ§ßÂà∞Â∞èÊéíÂ∫èÔºåset‰øùËØÅÂä†ÂÖ•queueÁöÑÊòØÂîØ‰∏ÄÊï∞Â≠ó„ÄÇÊØèÊ¨°pollÂá∫Ê¨°Êï∞ÊúÄÂ§öÁöÑÊï∞Â≠óÔºåÊõ¥Êñ∞lenÔºåÂíåhalflenÊØîËæÉÔºåÂ¶ÇÊûúÂ∞è‰∫éÂàôÁõ¥Êé•ËøîÂõûres„ÄÇÂê¶ÂàôÁªßÁª≠poll„ÄÇ PS: ÂΩìÊó∂‰∏ÄÁõ¥Êä•ÈîôÂõ†‰∏∫Â≠òÂú®queue‰ºöÂä†ÂÖ•ÈáçÂ§çÊï∞Â≠óÁöÑÊÉÖÂÜµÔºåÂä†ÂÖ•set‰πãÂêéÂÆåÁæéAccepted„ÄÇ Optimized Solution class Solution&#123; public int minSetSize(int[] arr) &#123; int n = arr.length; PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;((e1, e2) -&gt; (e2.getValue() - e1.getValue())); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; map.put(arr[i], map.getOrDefault(arr[i], 0) + 1); &#125; pq.addAll(map.entrySet()); int count = 0, res = 0; while (true) &#123; count += pq.poll().getValue(); res++; if (count &gt;= n / 2) &#123; break; &#125; &#125; return res; &#125;&#125; ÊÄùË∑Ø‰∏ÄÊë∏‰∏ÄÊ†∑„ÄÇÂÜôÊ≥ïÁÆÄÊ¥Å‰∫ÜËÆ∏Â§ö„ÄÇ‰ª•ÂêéÁöÑcodeÂ∞ΩÈáè‰∏ÄË°åÂ§öoperation„ÄÇ 1343. Maximum Product of Splitted Binary Tree üîóQuestion Link Optimized Solution class Solution &#123; long sum; long max; public int maxProduct(TreeNode root) &#123; sum = 0; max = 0; dfs(root); check(root); return (int)(max%((int)Math.pow(10,9)+7)); &#125; public void dfs(TreeNode root)&#123; if(root == null)return; sum+=root.val; dfs(root.left); dfs(root.right); &#125; public long check(TreeNode root)&#123; if(root == null)return 0; long l = check(root.left); long r = check(root.right); max = Math.max(max,(l+r+root.val) * (sum - l - r - root.val)); return l + r + root.val; &#125;&#125; ÂÖàdfsÂæóÂà∞treeÁöÑtotal sum ÈÄíÂΩíÊâæmaxproduct„ÄÇcheckÈáåËøîÂõûÁöÑÊòØÂ∑¶Âè≥Â≠êÊ†ëÁöÑsumÂíåÔºåÊõ¥Êñ∞maxÊó∂Ê≥®ÊÑèÊäätotal sumÂàÜÊàê‰∏§ÈÉ®ÂàÜ‰πòÁßØÂç≥ÂèØ„ÄÇ","categories":[{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"}]},{"title":"Leetcode EveryDay 68 üí™","slug":"chin-up-06","date":"2020-02-01T18:02:38.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/02/01/chin-up-06/","link":"","permalink":"WangHngLeee.github.io/2020/02/01/chin-up-06/","excerpt":"56. Merge Intervals Question Link &gt;&gt;&gt; class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0)return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] time : intervals)&#123; if(end &gt;= time[0])&#123; end = Math.max(end,time[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = time[0]; end = time[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125;&#125; ÊåâÁÖßstart sort‰∏Ä‰∏ã„ÄÇÂè™ÊúâendÂ§ß‰∫éÂΩìÂâçtimeÁöÑstartÊó∂Ôºå‰∏§‰∏™intervalÊâçÂ≠òÂú®overlap„ÄÇÊõ¥Êñ∞end‰∏∫ÊúÄÂ§ßÁöÑ„ÄÇÂê¶ÂàôÂ∞ÜÂΩìÂâçstartÔºåendÂä†ÂÖ•res„ÄÇÊõ¥Êñ∞startÂíåend‰∏∫time[0] Âíåtime[1]„ÄÇ","text":"56. Merge Intervals Question Link &gt;&gt;&gt; class Solution&#123; public int[][] merge(int[][] intervals)&#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); if(intervals == null || intervals.length == 0)return res.toArray(new int[0][]); Arrays.sort(intervals,(a,b)-&gt;a[0]-b[0]); int start = intervals[0][0]; int end = intervals[0][1]; for(int[] time : intervals)&#123; if(end &gt;= time[0])&#123; end = Math.max(end,time[1]); &#125;else&#123; res.add(new int[]&#123;start,end&#125;); start = time[0]; end = time[1]; &#125; &#125; res.add(new int[]&#123;start,end&#125;); return res.toArray(new int[0][]); &#125;&#125; ÊåâÁÖßstart sort‰∏Ä‰∏ã„ÄÇÂè™ÊúâendÂ§ß‰∫éÂΩìÂâçtimeÁöÑstartÊó∂Ôºå‰∏§‰∏™intervalÊâçÂ≠òÂú®overlap„ÄÇÊõ¥Êñ∞end‰∏∫ÊúÄÂ§ßÁöÑ„ÄÇÂê¶ÂàôÂ∞ÜÂΩìÂâçstartÔºåendÂä†ÂÖ•res„ÄÇÊõ¥Êñ∞startÂíåend‰∏∫time[0] Âíåtime[1]„ÄÇ 253. Meeting Rooms II Question Link &gt;&gt;&gt; class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if(intervals == null || intervals.length == 0)return 0; int[] start = new int[intervals.length]; int[] end = new int[intervals.length]; int rooms = 0; for(int i=0 ;i&lt;intervals.length;i++)&#123; start[i] = intervals[i][0]; end[i] = intervals[i][1]; &#125; Arrays.sort(start); Arrays.sort(end); int endidx = 0; for(int i=0 ;i&lt;start.length;i++)&#123; if(start[i] &lt; end[endidx])rooms++; else&#123; endidx++; &#125; &#125; return rooms; &#125;&#125; start Âíå end ÂÖ®ÈÉ®sort„ÄÇÈÅçÂéÜstartÔºåÈÅáÂà∞Â∞è‰∫éend[]endidx]ÁöÑstartÂàô+1ÔºåÂê¶ÂàôÊõ¥Êñ∞endidx„ÄÇ 973. K Closest Points to Origin Question Link &gt;&gt;&gt; class Solution &#123; public int[][] kClosest(int[][] points, int K) &#123; int[][] res = new int[K][2]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt;getdist(a)-getdist(b)); for(int[] point : points)&#123; queue.add(point); &#125; for(int i=0 ;i&lt;K;i++)&#123; res[i] = queue.poll(); &#125; return res; &#125; public int getdist(int[] point)&#123; return point[0]*point[0] + point[1]*point[1]; &#125;&#125; ‰∏ÄËà¨top kÁöÑÈ¢òÈÉΩÁî®pq + ÈáçÂÜôsortÔºåÁÑ∂ÂêéÁª¥Êä§kÂ§ßÁöÑpqÔºåÊúÄÂêéË¶Å‰πàËøîÂõûpeekË¶Å‰πàpoll kÊ¨°Â∞±ÂèØ‰ª•„ÄÇËøôÈÅìÈ¢òÂÜôÊ≥ïÊ≤°ÊúâÁª¥Êä§kÂ§ß„ÄÇÊúÄÂêépoll kÊ¨°Âç≥ÂèØ„ÄÇ 57. Insert Interval Question Link &gt;&gt;&gt; class Solution &#123; public int[][] insert(int[][] intervals, int[] newInterval) &#123; List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); for(int[] interval : intervals)&#123; if(newInterval[1] &lt; interval[0])&#123; res.add(newInterval); newInterval = interval; &#125;else if(newInterval[0] &gt; interval[1])&#123; res.add(interval); &#125;else&#123; newInterval[0] = Math.min(interval[0],newInterval[0]); newInterval[1] = Math.max(interval[1],newInterval[1]); &#125; &#125; res.add(newInterval); return res.toArray(new int[0][]); &#125;&#125; Âíå56Áõ∏‰ººÁöÑÊÄùË∑Ø„ÄÇ‰∏âÁßçÊÉÖÂÜµÔºö intervalÂÆåÂÖ® &lt; newInterval newIntervalÂÆåÂÖ®&lt; interval Ê≠§Êó∂intervalÂèò‰∏∫newintervalÁªßÁª≠Âæ™ÁéØ„ÄÇ ‰∫åËÄÖÊúâoverlap„ÄÇ 242. Valid Anagram Question Link &gt;&gt;&gt; class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] arr = new int[26]; for(int i=0 ; i&lt;t.length() ; i++)&#123; arr[t.charAt(i)-'a']++; &#125; for(int i=0 ;i&lt;s.length() ;i++)&#123; arr[s.charAt(i)-'a']--; &#125; for(int i=0 ;i&lt;arr.length;i++)&#123; if(arr[i]!=0)return false; &#125; return true; &#125;&#125; ‰∏Ä‰∏™26ÁöÑarrÔºåÈÅçÂéÜs++ÔºåÈÅçÂéÜt‚ÄìÔºåÂ¶ÇÊûú‰∏§‰∏™Áõ∏ÂêåÂàôÊúÄÂêéarrÈáåÂ∫îËØ•ÈÉΩÊòØ0ÔºåÂê¶Âàô‰∏∫false„ÄÇ 75. Sort Colors Question Link &gt;&gt;&gt; class Solution &#123; public void sortColors(int[] nums) &#123; int[] bucket = new int[3]; for(int num : nums)&#123; bucket[num]++; &#125; int pos = 0; for(int i=0 ;i&lt;bucket.length;i++)&#123; for(int count = 0;count &lt; bucket[i] ; count++)&#123; nums[pos] = i; pos++; &#125; &#125; &#125;&#125; bucket sort + inplace change numsÊï∞ÁªÑ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"WangHngLeee.github.io/tags/Sort/"},{"name":"Interval","slug":"Interval","permalink":"WangHngLeee.github.io/tags/Interval/"}]},{"title":"Leetcode EveryDay 67","slug":"chin-up-05","date":"2020-01-31T17:01:27.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2020/01/31/chin-up-05/","link":"","permalink":"WangHngLeee.github.io/2020/01/31/chin-up-05/","excerpt":"909. Snakes and Ladders üîóQuestion Link class Solution &#123; public int snakesAndLadders(int[][] board) &#123; if(board == null || board.length == 0)return 0; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] seen = new boolean[m*m+1]; queue.add(1); int steps = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int temp = queue.poll(); for(int j=1;j&lt;=6;j++)&#123; int next = temp + j; int[] pos = getpos(next,m); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == m*m)return steps; if(!seen[next])&#123; seen[next] = true; queue.add(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; public int[] getpos(int next, int m)&#123; int row = (next-1)/m; int col = (next-1)%m; int x = m-row-1; int y = row%2 == 0?col : m-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; queueÂ≠ònumberÔºåÈÄöËøágetposËé∑ÂæónumÂØπÂ∫îÂùêÊ†á„ÄÇÁªèÂÖ∏bfsÊ®°Áâà„ÄÇ","text":"909. Snakes and Ladders üîóQuestion Link class Solution &#123; public int snakesAndLadders(int[][] board) &#123; if(board == null || board.length == 0)return 0; int m = board.length; int n = board[0].length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] seen = new boolean[m*m+1]; queue.add(1); int steps = 1; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int temp = queue.poll(); for(int j=1;j&lt;=6;j++)&#123; int next = temp + j; int[] pos = getpos(next,m); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == m*m)return steps; if(!seen[next])&#123; seen[next] = true; queue.add(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; public int[] getpos(int next, int m)&#123; int row = (next-1)/m; int col = (next-1)%m; int x = m-row-1; int y = row%2 == 0?col : m-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; queueÂ≠ònumberÔºåÈÄöËøágetposËé∑ÂæónumÂØπÂ∫îÂùêÊ†á„ÄÇÁªèÂÖ∏bfsÊ®°Áâà„ÄÇ 1091. Shortest Path in Binary Matrix üîóQuestion Link class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; int m = grid.length; int n = grid[0].length; if(grid[0][0] == 1 || grid[m-1][n-1] == 1)return -1; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;&#125;; boolean[][] seen = new boolean[m][n]; seen[0][0] = true; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0,0&#125;); int ans = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; int[] temp = queue.poll(); if(temp[0] == m-1 &amp;&amp; temp[1] == n-1)return ans+1; for(int[] move : moves)&#123; int x = temp[0]+move[0]; int y = temp[1]+move[1]; if(x&gt;=0 &amp;&amp; x&lt;m &amp;&amp; y&gt;=0 &amp;&amp;y&lt;n &amp;&amp; grid[x][y] == 0 &amp;&amp; !seen[x][y])&#123; seen[x][y] = true; queue.add(new int[]&#123;x,y&#125;); &#125; &#125; &#125; ans++; &#125; return -1; &#125;&#125; ÁªèÂÖ∏bfsÊ®°Áâà„ÄÇÂàõÂª∫moveÊï∞ÁªÑ„ÄÇÈÅáÂà∞1Â∞±ÂÅúÊ≠¢„ÄÇÈÅáÂà∞0ÂàôÂä†ÂÖ•queueÁªßÁª≠bfs„ÄÇ 130. Surrounded Region üîóQuestion Link class Solution &#123; public void solve(char[][] board) &#123; if (board.length == 0 || board[0].length == 0) return; if (board.length &lt; 3 || board[0].length &lt; 3) return; int m = board.length; int n = board[0].length; for (int i = 0; i &lt; m; i++) &#123; if (board[i][0] == 'O') helper(board, i, 0); if (board[i][n - 1] == 'O') helper(board, i, n - 1); &#125; for (int j = 1; j &lt; n - 1; j++) &#123; if (board[0][j] == 'O') helper(board, 0, j); if (board[m - 1][j] == 'O') helper(board, m - 1, j); &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == 'O') board[i][j] = 'X'; if (board[i][j] == '1') board[i][j] = 'O'; &#125; &#125; &#125; private void helper(char[][] board, int r, int c) &#123; if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt;= board.length - 1 &amp;&amp; c &lt;= board[0].length - 1 &amp;&amp; board[r][c] == 'O')&#123; board[r][c] = '1'; helper(board, r + 1, c); helper(board, r - 1, c); helper(board, r, c + 1); helper(board, r, c - 1); &#125; &#125;&#125; Âè™ÊúâÂíåËæπÁïå0Áõ∏ËøûÁöÑ0Êâç‰∏ç‰ºöÂèòÊàêxÔºåÊâÄ‰ª•Á¨¨‰∏ÄÊ≠•Â∞±ÊòØÂ∞ÜÂíåËæπÁºò0Áõ∏ËøûÁöÑ0ÂèòÊàê*ÔºåÁÑ∂ÂêéÂÜçÊâ´ÊèèÊï¥‰∏™graphÔºåÊääÊ≤°ÊúâËøû‰∏äÁöÑ0ÂèòÊàêxÔºå*ÂèòÂõû0„ÄÇ 111. Minimum Depth of Binary Tree üîóQuestion Link class Solution &#123; public int minDepth(TreeNode root) &#123; if(root == null)return 0; if(root.left == null &amp;&amp; root.right == null) return 1; int left = minDepth(root.left); int right = minDepth(root.right); if(root.left == null)return right+1; if(root.right==null)return left+1; return Math.min(left,right)+1; &#125;&#125; recursiveÊâædepthÔºåÁª¥Êä§minÂç≥ÂèØ„ÄÇ 559. Maximum Depth of N-ary Tree üîóQuestion Link class Solution &#123; public int maxDepth(Node root) &#123; if(root == null)return 0; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int depth = 0; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; Node temp=queue.poll(); for(Node child : temp.children)&#123; queue.add(child); &#125; &#125; depth++; &#125; return depth; &#125;&#125; iterativeÊÄùË∑Ø„ÄÇlevel order ÈÅçÂéÜtree„ÄÇÁª¥Êä§depthÔºåÊúÄÂêéËøîÂõûdepthÂç≥‰∏∫maxdepth„ÄÇ 1319. Number of Operations to Make Network Connected üîóQuestion Link class Solution &#123; public int find(int[] parents,int n)&#123; if(parents[n] == n)return n; return parents[n] = find(parents,parents[n]); &#125; public int makeConnected(int n, int[][] connections) &#123; int[] parents = new int[n]; for(int i=0 ;i&lt;n ;i++)&#123; parents[i] = i; &#125; int m = connections.length; int components = 0; int extra = 0; for(int i=0 ;i&lt;m ;i++)&#123; int root1 = find(parents,connections[i][0]); int root2 = find(parents,connections[i][1]); if(root1 == root2)extra++; else parents[root1] = root2; &#125; for(int i= 0;i&lt;n;i++)&#123; if(parents[i] == i) components++; &#125; return (extra &gt;= components -1) ? components - 1 : -1; &#125;&#125; ÁÆÄÂåñÁâàunion find„ÄÇÂü∫Êú¨ÁöÑufÊìç‰ΩúÔºåÂ∞ÜunionÁöÑËøáÁ®ãÊîæÂú®‰∫Ü‰∏ªÂáΩÊï∞„ÄÇÊúÄÂêéÊâæcomponentÁöÑ‰∏™Êï∞ÔºåÁã¨Á´ãÁöÑÈÉ®ÂàÜ‰∏™Êï∞ÔºåÂàôÈúÄË¶ÅÈìæÊé•ÁöÑlink‰∏™Êï∞Â∞±ÊòØcomponent-1‰∏™„ÄÇÊâÄ‰ª•Âè™ÈúÄË¶ÅÂà§Êñ≠Â§ö‰ΩôÁöÑextraÊòØÂê¶Â§ß‰∫écomponent-1Âç≥ÂèØ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"}]},{"title":"Leetcode EveryDay 66","slug":"chin-up-04","date":"2020-01-30T17:48:49.000Z","updated":"2020-02-03T14:37:08.709Z","comments":true,"path":"2020/01/30/chin-up-04/","link":"","permalink":"WangHngLeee.github.io/2020/01/30/chin-up-04/","excerpt":"987. Vertical Order Traversal of a Binary Tree üîóQuestion Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; ÂÆö‰πâpairÁ±ªÔºåÂåÖÂê´Ê®™Âêë‰ΩçÁΩÆx„ÄÇmapÂ≠òx‰ΩçÁΩÆÂØπÂ∫îÁöÑnodeËäÇÁÇπÔºåqueue + bfsÔºåÈÅçÂéÜÊâÄÊúânodeÂπ∂‰∏îÂ≠òÂÖ•map„ÄÇ Âú®bfs‰∏≠Êõ¥Êñ∞minÂíåmaxÂÄºÔºåÊâæÂà∞treeÊúÄÂ∑¶ÂíåÊúÄÂè≥ËæπÁïå„ÄÇ ÈáçÂÜôsortÔºåÂ∞ÜÂêå‰∏Ä‰ΩçÁΩÆÁöÑnodeÊåâÂ∞è-Â§ßÊéíÂ∫è„ÄÇ ÈíàÂØπÊØè‰∏Ä‰∏™‰ΩçÁΩÆxÊñ∞Âª∫templistÔºåÊúÄÂêéÂ∞ÜtemplistÂä†ÂÖ•res‰∏≠„ÄÇ","text":"987. Vertical Order Traversal of a Binary Tree üîóQuestion Link class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; templist.add(map.get(i).get(j).node.val); &#125; res.add(templist); &#125; return res; &#125;&#125; ÂÆö‰πâpairÁ±ªÔºåÂåÖÂê´Ê®™Âêë‰ΩçÁΩÆx„ÄÇmapÂ≠òx‰ΩçÁΩÆÂØπÂ∫îÁöÑnodeËäÇÁÇπÔºåqueue + bfsÔºåÈÅçÂéÜÊâÄÊúânodeÂπ∂‰∏îÂ≠òÂÖ•map„ÄÇ Âú®bfs‰∏≠Êõ¥Êñ∞minÂíåmaxÂÄºÔºåÊâæÂà∞treeÊúÄÂ∑¶ÂíåÊúÄÂè≥ËæπÁïå„ÄÇ ÈáçÂÜôsortÔºåÂ∞ÜÂêå‰∏Ä‰ΩçÁΩÆÁöÑnodeÊåâÂ∞è-Â§ßÊéíÂ∫è„ÄÇ ÈíàÂØπÊØè‰∏Ä‰∏™‰ΩçÁΩÆxÊñ∞Âª∫templistÔºåÊúÄÂêéÂ∞ÜtemplistÂä†ÂÖ•res‰∏≠„ÄÇ 863. All Nodes Distance K in Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,target); dfs(root,0,K,res); return res; &#125; public int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; public void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)res.add(root.val); dfs(root.left,dist+1,K,res); dfs(root.right,dist+1,K,res); &#125;&#125; ÂÖàÂÆö‰πâfindÂáΩÊï∞ÔºåÁî®mapÂ≠òtarget‰∏äÊñπËäÇÁÇπË∑ùÁ¶ªtargetÁöÑË∑ùÁ¶ªÔºåtarget‰∏ãÊñπ‰∏çÂ≠ò„ÄÇ ÂÜçdfsÈÅçÂéÜÊâÄÊúâËäÇÁÇπÔºåÂ∞ÜË∑ùÁ¶ª‰∏∫kÁöÑÂ≠òÂÖ•res„ÄÇÂ¶ÇÊûúmap‰∏≠ÊúâËØ•ÁÇπÔºåÂàô‰∏∫target‰∏äÊñπÁöÑÁÇπ„ÄÇÁõ¥Êé•Â∞ÜdistÊõ¥Êñ∞‰∏∫mapÂØπÂ∫îÁöÑvalueÂç≥ÂèØ„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂàô‰∏ÄÊ≠•‰∏ÄÊ≠•Âêë‰∏ãÊ∑±ÂÖ• dist+1. 105. Construct Binary Tree from Preorder and Inorder Traversal Question Link &gt;&gt;&gt; class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder == null || preorder.length == 0 || inorder == null || inorder.length==0)&#123; return null; &#125; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); // store index of inorder for(int i=0;i&lt;inorder.length;i++)&#123; map.put(inorder[i],i); &#125; return build(inorder,0,inorder.length-1,preorder,0,preorder.length-1,map); &#125; public TreeNode build(int[]inorder,int istart, int iend, int[] preorder, int pstart, int pend, Map&lt;Integer,Integer&gt; map)&#123; if(istart &gt;iend || pstart &gt; pend)return null; TreeNode node = new TreeNode(preorder[pstart]); int inidx = map.get(preorder[pstart]); int remains = inidx - istart; node.left = build(inorder,istart,inidx-1,preorder,pstart+1,pstart + remains,map); node.right = build(inorder,inidx+1,iend,preorder,pstart + remains + 1,pend,map); return node; &#125;&#125; Âà©Áî®preorderÊâæÂà∞Ê†πËäÇÁÇπÔºåÁÑ∂ÂêéÂéªinorderÈáåÊâæÂà∞Â∑¶Âè≥partÁöÑindexÔºåÂà©Áî®‰∏çÂêåÁöÑindexÂØπÂ∑¶Âè≥Â≠êÊ†ëËøõË°åbuild„ÄÇ 449. Serialize and Deserialize BST Question Link &gt;&gt;&gt; ËøôÈÅìÈ¢ò‰∏çËÆ∫BSTÊàñËÄÖBTÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑÂÜôÊ≥ï„ÄÇÈÉΩÊòØpreorderËΩ¨ÊàêstringÔºåÁÑ∂ÂêésplitÁ©∫Ê†ºÔºåÂÜçÁî®preorderÊñπÂºèËøõË°åÂª∫Ê†ë„ÄÇ ËøôÈÅìÈ¢òÊòØBSTÔºå Âè¶Â§ñ‰∏ÄÈÅìBTÁöÑÈ¢òÁõÆÈìæÊé•Âú®ËøôÈáå‚¨áÔ∏è public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder st = new StringBuilder(); serialize(root, st); return st.toString(); &#125; public void serialize(TreeNode root, StringBuilder st) &#123; if (root == null) st.append(\"n\" + \" \"); else &#123; st.append(root.val + \" \"); serialize(root.left, st); serialize(root.right, st); &#125; &#125; public TreeNode deserialize(String data) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); queue.addAll(Arrays.asList(data.split(\" \"))); return deseralize(queue); &#125; public TreeNode deseralize(Queue&lt;String&gt; queue) &#123; String cur = queue.poll(); if (cur.equals(\"n\")) return null; TreeNode root = new TreeNode(Integer.parseInt(cur)); root.left = deseralize(queue); root.right = deseralize(queue); return root; &#125;&#125; ÊÄùË∑Ø&amp;code Âíå297‰∏ÄÊ®°‰∏ÄÊ†∑„ÄÇ 103. Binary Tree Zigzag Level Order Traversal Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); boolean zig = false; queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;size;i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; templist.add(0,node.val); &#125;else&#123; templist.add(node.val); &#125; if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(templist); zig=!zig; &#125; return res; &#125;&#125; level traversal„ÄÇÂä†‰∏Ä‰∏™zigÂà§Êñ≠Ê∑ªÂä†È°∫Â∫è„ÄÇzigÁöÑÈÄÜÂ∫èÔºå‰∏çÊñ≠add(0,val)„ÄÇ 102. Binary Tree Level Order Traversal Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; size;i++)&#123; TreeNode node = queue.poll(); templist.add(node.val); if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(templist); &#125; return res; &#125;&#125; ÁªèÂÖ∏tree level traversalÊ®°Áâà„ÄÇÂíå103‰∏Ä‰∏™ÊÄùË∑Ø„ÄÇÂè™‰∏çËøá103ÈúÄË¶ÅËÄÉËôëzigÔºåËøôÈÅìÈ¢òÂçïÁ∫ØÁöÑtraversalÂ∞±ÂèØ‰ª•„ÄÇ 96. Unique Binary Search Trees Question Link &gt;&gt;&gt; class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i &lt;=n;i++)&#123; for(int j = 1 ; j&lt;=i ; j ++)&#123; dp[i] += dp[j-1]*dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; dpÊÄùË∑Ø„ÄÇÊï∞Â≠¶ÊÄùË∑ØÊØîËæÉË¥πÊó∂Èó¥„ÄÇyoutbeËßÜÈ¢ëËÆ≤Ëß£‚¨áÔ∏è„ÄÇ 366. Find Leaves of Binary Tree Question Link &gt;&gt;&gt; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; help(root,res); return res; &#125; public int help(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return -1; int level = 1 + Math.max(help(root.left,res),help(root.right,res)); if(res.size() &lt; level + 1)res.add(new ArrayList&lt;&gt;()); res.get(level).add(root.val); return level; &#125;&#125; ÊâætreeÁöÑÊ∑±Â∫¶levelÔºåresÂ§ßÂ∞èÂíålevel‰∏ÄÊ†∑„ÄÇÁÑ∂ÂêéÈÄöËøágetÔºàlevelÔºâÊâæÂà∞ÂØπÂ∫îÁöÑ‰ΩçÁΩÆÔºåÊ∑ªÂä†root.val„ÄÇ 545. Boundary of Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root==null)return res; res.add(root.val); findleft(root.left,res); leaf(root.left,res); leaf(root.right,res); findright(root.right,res); return res; &#125; public void findleft(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null || root.left==null &amp;&amp; root.right == null)return; res.add(root.val); if(root.left == null)findleft(root.right,res); else findleft(root.left,res); &#125; public void leaf(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null)return; if(root.left==null &amp;&amp; root.right == null)res.add(root.val); leaf(root.left,res); leaf(root.right,res); &#125; public void findright(TreeNode root, List&lt;Integer&gt; res)&#123; if(root == null || root.left==null &amp;&amp; root.right == null)return; if(root.right == null)findright(root.left,res); else findright(root.right,res); res.add(root.val); &#125;&#125; Â∑¶-Âè∂Â≠ê-Âè≥ ÁöÑÈ°∫Â∫è„ÄÇÂÆö‰πâ‰∏â‰∏™ÂáΩÊï∞ÂêÑËá™ÊâæÂ∑¶Âè∂Âè≥„ÄÇÊ≥®ÊÑèÂ∑¶Âè≥ÂáΩÊï∞ÈáåÔºåÂΩìrootÂ∑¶Âè≥ÈÉΩ‰∏∫Á©∫Êó∂Ë¶ÅËøîÂõûÂÅúÊ≠¢„ÄÇÂè™ÊúâÊâæÂè∂Â≠êÁªìÁÇπÊó∂Êâçres.add„ÄÇ Ê≥®ÊÑèÊâæÂè≥Êó∂Ôºåres.addÈ°∫Â∫èÂú®ÈÄíÂΩí‰πãÂêé„ÄÇ 222. Count Complete Tree Nodes Question Link &gt;&gt;&gt; class Solution &#123; public int countNodes(TreeNode root) &#123; int left = countleft(root); int right = countright(root); if(left == right)&#123; return (1&lt;&lt;left) -1; &#125;else&#123; return 1 + countNodes(root.left) + countNodes(root.right); &#125; &#125; public int countleft(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; dep++; root = root.left; &#125; return dep; &#125; public int countright(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; dep++; root = root.right; &#125; return dep; &#125;&#125; Complete Tree Wiki ÂÆö‰πâ ÊâÄ‰ª•Â¶ÇÊûúÊúÄÂ∑¶ÊàñËÄÖÊúÄÂè≥Êúâ‰∏Ä‰∏™Á©∫Áº∫Â∞±‰∏çÊòØcomplete tree„ÄÇÊâÄ‰ª•ÊâæÊúÄÂ∑¶ÊúÄÂè≥ÁöÑÊ∑±Â∫¶„ÄÇ Â¶ÇÊûúÁõ∏ÂêåÔºåÂàôÁõ¥Êé•ËøîÂõûÊ†ë 1&lt;&lt;Ê∑±Â∫¶ -1Â∞±ÊòØnodeÁöÑ‰∏™Êï∞„ÄÇ&lt;&lt;Áõ∏ÂΩì‰∫éÂØπÊ∑±Â∫¶Âèñ2ÁöÑÂØπÊï∞„ÄÇ Â¶ÇÊûúÂ∑¶Âè≥Ê∑±Â∫¶‰∏çÁõ∏ÂêåÂàôÈÄíÂΩíÁªßÁª≠ÊâæÂêÑËá™Â∑¶Âè≥Â≠êÊ†ëÂπ∂‰∏îÂä†1ÔºàÂΩìÂâçnodeÔºâ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 65","slug":"chin-up-03","date":"2020-01-26T15:14:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/01/26/chin-up-03/","link":"","permalink":"WangHngLeee.github.io/2020/01/26/chin-up-03/","excerpt":"297. Serialize and Deserialize Binary Tree üîóQuestion Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(sb,root); return sb.toString(); &#125; public void serial(StringBuilder sb, TreeNode root)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(sb,root.left); serial(sb,root.right); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return buildTree(queue); &#125; public TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val.equals(\"n\"))return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left=buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; preorderÈÅçÂéÜËΩ¨‰∏∫stringÔºåÁî®Á©∫Ê†ºÈöîÂºÄÔºåÂª∫Ê†ëÁöÑÊó∂ÂÄôsplitÁ©∫Ê†ºÔºåÁÑ∂ÂêépreorderÂª∫Ê†ë„ÄÇÁî®queueÂ≠ò‰∏ãpreorderÁöÑstringÁªìÊûú„ÄÇ","text":"297. Serialize and Deserialize Binary Tree üîóQuestion Link public class Codec &#123; public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); serial(sb,root); return sb.toString(); &#125; public void serial(StringBuilder sb, TreeNode root)&#123; if(root == null)sb.append(\"n\").append(\" \"); else&#123; sb.append(root.val).append(\" \"); serial(sb,root.left); serial(sb,root.right); &#125; &#125; public TreeNode deserialize(String data)&#123; Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); String[] strs = data.split(\" \"); for(String str : strs)&#123; queue.add(str); &#125; return buildTree(queue); &#125; public TreeNode buildTree(Queue&lt;String&gt; queue)&#123; String val = queue.poll(); if(val.equals(\"n\"))return null; TreeNode root = new TreeNode(Integer.parseInt(val)); root.left=buildTree(queue); root.right = buildTree(queue); return root; &#125;&#125; preorderÈÅçÂéÜËΩ¨‰∏∫stringÔºåÁî®Á©∫Ê†ºÈöîÂºÄÔºåÂª∫Ê†ëÁöÑÊó∂ÂÄôsplitÁ©∫Ê†ºÔºåÁÑ∂ÂêépreorderÂª∫Ê†ë„ÄÇÁî®queueÂ≠ò‰∏ãpreorderÁöÑstringÁªìÊûú„ÄÇ 1130. Minimum Cost Tree From Leaf Values Question Link &gt;&gt;&gt; class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int num : arr)&#123; list.add(num); &#125; int res = 0; while(list.size() &gt; 1)&#123; int product = Integer.MAX_VALUE; int index = 0; for(int i=0 ;i&lt;list.size()-1;i++)&#123; if(product &gt; list.get(i) * list.get(i+1))&#123; product = list.get(i) * list.get(i+1); index = i; &#125; &#125; list.set(index,Math.max(list.get(index),list.get(index+1))); list.remove(index+1); res += product; &#125; return res; &#125;&#125; ÂÆûË¥®ÊòØÊï∞ÁªÑÈ¢ò„ÄÇÈÅçÂéÜÊâæproductÊúÄÂ∞èÁöÑ‰∏§Êï∞ÔºåÂπ∂‰∏îËÆ∞ÂΩïÁ¨¨‰∏Ä‰∏™Êï∞ÁöÑÂùêÊ†á„ÄÇÁÑ∂ÂêéÊõ¥Êç¢ËØ•‰ΩçÁΩÆÁöÑÊï∞„ÄÇ 124. Binary Tree Maximum Path Sum Question Link &gt;&gt;&gt; class Solution &#123; int max = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) &#123; if(root == null)return 0; help(root); return max; &#125; public int help(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(0,help(root.left)); int right = Math.max(0,help(root.right)); max = Math.max(max,left+right+root.val); return Math.max(left,right)+root.val; &#125;&#125; maxËÆ∞ÂΩïÂΩìÂâçÊúÄÂ§ßÁöÑsum„ÄÇ‰ΩÜÊòØrecursiveËøîÂõûÁöÑÊòØleftÂíårightÊúÄÂ§ßÂÄºÂä†‰∏äÂΩìÂâçrootÂÄº„ÄÇ 199. Binary Tree Right Side View Question Link &gt;&gt;&gt; class Solution &#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if( i&gt;= size-1)res.add(temp.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; ÁªèÂÖ∏tree bfs„ÄÇÂîØ‰∏Ä‰∏çÂêåÊòØÂà§Êñ≠ÂΩìÂâçÊòØÂê¶ÊòØÁ¨¨size-1‰∏™ÔºåÂä†ÂÖ•res„ÄÇËøôÊ†∑Â∞±‰øùËØÅÊòØtreeÊúÄright side view‰∫Ü„ÄÇ 98. Validate Binary Search Tree Question Link &gt;&gt;&gt; class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return true; return check(root,Long.MIN_VALUE,Long.MAX_VALUE); &#125; public boolean check(TreeNode root, long min, long max)&#123; if(root == null)return true; if(root.val&lt;= min || root.val &gt;=max)return false; return check(root.left,min,root.val) &amp;&amp; check(root.right,root.val,max); &#125;&#125; ËÆæ‰∏§‰∏™ËåÉÂõ¥Ôºå‰øùËØÅbstÊØè‰∏™ËäÇÁÇπÈÉΩÂú®min Âíåmax‰πãÈó¥Â∞±ÂèØ‰ª•„ÄÇ 236. Lowest Common Ancestor of a Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null)return null; if(root == p || root == q)return root; TreeNode left = lowestCommonAncestor(root.left,p,q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; return root; &#125;&#125; lcaÁöÑÈ¢ò„ÄÇÈÄíÂΩíÂâçÂÖàÂà§Êñ≠ËØ•rootÊòØÂê¶Âíåp or qÁõ∏Âêå„ÄÇÂ¶ÇÊûúÁõ∏ÂêåÂàôÁõ¥Êé•ËøîÂõûÊîπÂÄº„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÂàôÂ∑¶Âè≥ÈÄíÂΩí„ÄÇËã•Â∑¶Ê≤°ÊúâÂàô‰ª£Ë°®ÈÉΩÂú®Âè≥Ëæπ„ÄÇËã•Âè≥Ê≤°ÊúâÂàô‰ª£Ë°®Âú®Â∑¶Ëæπ„ÄÇÂ¶ÇÊûú‰∏§Èù¢ÈÉΩÊúâÂàôËøîÂõûÂΩìÂâçroot„ÄÇÂõ†‰∏∫Â∑¶Âè≥ÈÉΩÊúâËÇØÂÆöÂΩìÂâçroot‰∏∫lca„ÄÇ 543. Diameter of Binary Tree Question Link &gt;&gt;&gt; class Solution &#123; int ans = 0; public int diameterOfBinaryTree(TreeNode root) &#123; help(root); return ans; &#125; public int help(TreeNode root)&#123; if(root == null)return -1; int left = help(root.left)+1; int right = help(root.right)+1; ans = Math.max(ans,left+right); return Math.max(left,right); &#125;&#125; Â∑¶Âè≥ÂêÑËá™ÊâæÊúÄÈïødepthÔºåÊõ¥Êñ∞ansÔºåÊúÄÂêéÈÄíÂΩíËøîÂõûleftÂíårightÁöÑÊúÄÂ§ßÂÄº„ÄÇ 173. Binary Search Tree Iterator Question Link &gt;&gt;&gt; class BSTIterator &#123; public Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); public BSTIterator(TreeNode root) &#123; pushall(root); &#125; public int next() &#123; TreeNode temp = stack.pop(); if(temp.right!=null)&#123; pushall(temp.right); &#125; return temp.val; &#125; public boolean hasNext() &#123; return !stack.isEmpty(); &#125; public void pushall(TreeNode root)&#123; while(root!=null)&#123; stack.push(root); root = root.left; &#125; &#125;&#125; ÂÆö‰πâpushallÂáΩÊï∞ÔºåÂ∞ÜÊâÄÊúâleftËäÇÁÇπÂ≠òÂÖ•stack„ÄÇÊúÄÂêéÊ†àÈ°∂ÂàôÊòØÂΩìÂâçÁöÑminÂÄº„ÄÇnextÊó∂ÂÄôÂÖàpopÂá∫peekÂÖÉÁ¥†ÔºåÁÑ∂ÂêéÂØπpeekÂÖÉÁ¥†pushallÔºåÊõ¥Êñ∞minÂÄºÔºåÁÑ∂ÂêéËøîÂõûpopÂÄº„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"}]},{"title":"Leetcode EveryDay 64","slug":"chin-up-02","date":"2020-01-22T18:20:42.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2020/01/22/chin-up-02/","link":"","permalink":"WangHngLeee.github.io/2020/01/22/chin-up-02/","excerpt":"5. Longest Palindromic Substring üîóQuestion Link class Solution &#123; int start, maxlen; public String longestPalindrome(String s) &#123; for(int i=0 ;i&lt;s.length(); i++)&#123; check(s,i,i); check(s,i,i+1); &#125; return s.substring(start,start + maxlen); &#125; public void check(String s, int left, int right)&#123; while(left &gt;= 0 &amp;&amp; right &lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; if(right - left &gt; maxlen)&#123; maxlen = right - left-1; start = left + 1; &#125; &#125;&#125; Ê£ÄÊü•‰∏Ä‰Ωç or ‰∏§‰ΩçÁöÑÂõûÊñáÊÉÖÂÜµ„ÄÇcheckËá™Â∑±Êú¨Ë∫´‰ª•ÂèäËá™Â∑±ÂíåÂêé‰∏Ä‰Ωç„ÄÇ","text":"5. Longest Palindromic Substring üîóQuestion Link class Solution &#123; int start, maxlen; public String longestPalindrome(String s) &#123; for(int i=0 ;i&lt;s.length(); i++)&#123; check(s,i,i); check(s,i,i+1); &#125; return s.substring(start,start + maxlen); &#125; public void check(String s, int left, int right)&#123; while(left &gt;= 0 &amp;&amp; right &lt;s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123; left--; right++; &#125; if(right - left &gt; maxlen)&#123; maxlen = right - left-1; start = left + 1; &#125; &#125;&#125; Ê£ÄÊü•‰∏Ä‰Ωç or ‰∏§‰ΩçÁöÑÂõûÊñáÊÉÖÂÜµ„ÄÇcheckËá™Â∑±Êú¨Ë∫´‰ª•ÂèäËá™Â∑±ÂíåÂêé‰∏Ä‰Ωç„ÄÇ 20. Valid Parentheses üîóQuestion Link class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;();// to store the other part of parenthese for(int i= 0; i&lt;s.length();i++)&#123; if(s.charAt(i) ==' ')continue; if(s.charAt(i) == '&#123;')&#123; stack.push('&#125;'); &#125;else if(s.charAt(i) == '[')&#123; stack.push(']'); &#125;else if(s.charAt(i) == '(')&#123; stack.push(')'); &#125;else if(stack.isEmpty() || stack.pop() != s.charAt(i))return false; &#125; return stack.isEmpty(); &#125;&#125; Áî®stackÊù•‰øùÊåÅ‰∏ÄÂØπÂêàÊ†ºÁöÑÊã¨Âè∑„ÄÇÈÅáÂà∞ÂºÄÂè£Â∞±ÂêëstackÂ≠òÈó≠Âè£„ÄÇÂ¶ÇÊûú‰∏çÊòØÂºÄÂè£Â∞±Âà§Êñ≠popÂá∫Êù•ÁöÑÂíåÂΩìÂâçÊòØÂê¶Áõ∏Âêå„ÄÇ 3. Longest Substring Without Repeating Characters üîóQuestion Link class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int i = 0, j=0; int res = 0; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); while(i&lt;s.length() &amp;&amp; j&lt;s.length())&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j)); j++; res = Math.max(res,set.size()); &#125;else&#123; set.remove(s.charAt(i)); i++; &#125; &#125; return res; &#125;&#125; ÂèåÊåáÈíà„ÄÇsetÂ≠òÂîØ‰∏ÄÁöÑÂ≠óÁ¨¶„ÄÇÂ¶ÇÊûúÈÅáÂà∞ÈáçÂ§çÁöÑÔºåÂàô‰ªéÂ§¥ÂºÄÂßãÁßªÂá∫set„ÄÇ‰øùÊåÅres‰∏∫setÁöÑÊúÄÂ§ßsize„ÄÇ 22. Generate Parentheses üîóQuestion Link class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); help(\"\",res,0,0,n); return res; &#125; public void help(String cur, List&lt;String&gt; res, int open ,int close, int num)&#123; if(cur.length() == num *2)&#123; res.add(cur); return; &#125; if(open &lt; num)&#123; help(cur+\"(\",res,open+1,close,num); &#125; if(close &lt; open)&#123; help(cur + \")\",res,open,close+1,num); &#125; &#125;&#125; open Âíå closeÁî®Êù•ËÆ∞ÂΩïÂ∑¶Âè≥Êã¨Âè∑Êï∞ÔºåÁÑ∂ÂêéÂàÜÊÉÖÂÜµrecursiveË∞ÉÁî®„ÄÇÊúÄÂêécurÈïøÂ∫¶ËææÂà∞num*2Â∞±ÂèØ‰ª•ËøîÂõû‰∫Ü„ÄÇ 49. Group Anagrams üîóQuestion Link class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); if(strs == null || strs.length == 0)return res; for(String str : strs)&#123; int[] arr = new int[26]; for(int i=0 ;i&lt; str.length();i++)&#123; arr[str.charAt(i)-'a']++; &#125; String key = Arrays.toString(arr); if(!map.containsKey(key))&#123; map.put(key,new ArrayList&lt;&gt;()); &#125; map.get(key).add(str); &#125; for(String key : map.keySet())&#123; res.add(map.get(key)); &#125; return res; &#125;&#125; ÁªèÂÖ∏ÁöÑarr[26]ÊñπÊ≥ï„ÄÇÂ∞Üarr[]ËΩ¨ÊàêkeyÂ≠òÂÖ•mapÔºåÁî®ÂÖ∂Êù•ÂØπÂ∫îÁªÑÊàêÂ≠óÊØçÁõ∏ÂêåÁöÑword„ÄÇÊúÄÂêéËøîÂõûÁõ∏ÂêåÂ≠óÊØçÁöÑwordÈõÜÂêà„ÄÇ 91. Decode Ways üîóQuestion Link class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() == 0)return 0; int n = s.length(); int[] dp = new int[n+1]; dp[0] = 1; dp[1] = s.charAt(0) == '0' ? 0 : 1; for(int i=2 ;i&lt;=s.length();i++)&#123; int first = Integer.valueOf(s.substring(i-1,i)); int second = Integer.valueOf(s.substring(i-2,i)); if(first &gt;=1 &amp;&amp; first&lt;=9)&#123; dp[i]+=dp[i-1]; &#125; if(second&gt;=10 &amp;&amp; second &lt;=26)&#123; dp[i]+=dp[i-2]; &#125; &#125; return dp[n]; &#125;&#125; ÈÅáÂà∞ËøîÂõûÊâÄÊúâÊÉÖÂÜµËÄå‰∏îÂ≠òÂú®‰∏çËøûÁª≠ÁöÑÊÉÖÂÜµÔºåÂü∫Êú¨Áî®dpËß£ÂÜ≥„ÄÇÂàÜ1‰ΩçÊï∞Âíå2‰ΩçÊï∞Êù•Ëß£ÂÜ≥„ÄÇÂ¶ÇÊûú1‰ΩçÊï∞Âú®1-9‰πãÈó¥ÔºåÂèØ‰ª•ÂØπÂ∫îA-I,Â¶ÇÊûú2‰ΩçÊï∞Âú®10-26‰πãÈó¥ÔºåÂèØ‰ª•ÂØπÂ∫îJ-Z„ÄÇdp‰∏çÊñ≠Êõ¥Êñ∞ÂèØÊûÑÊàêÁöÑÊúÄÂ§öÊÉÖÂÜµÔºåÊúÄÂêéËøîÂõûÊúÄÂêé‰∏Ä‰ΩçdpÂÄºÂç≥ÂèØ„ÄÇ 32. Longest Valid Parentheses üîóQuestion Link class Solution &#123; public int longestValidParentheses(String s) &#123; if(s == null || s.length() == 0)return 0; int len = s.length(); int[] dp = new int[len]; int open = 0; int max = Integer.MIN_VALUE; for(int i=0 ;i&lt;len;i++)&#123; if(s.charAt(i) == '(')&#123; open++; &#125;else if(s.charAt(i) ==')' &amp;&amp; open &gt; 0)&#123; dp[i] = dp[i-1]+2; if(i-dp[i] &gt; 0)&#123; dp[i]+=dp[i-dp[i]]; &#125; open--; &#125; max = Math.max(max,dp[i]); &#125; return max; &#125;&#125; dpÊÄùË∑Ø„ÄÇopenËÆ∞ÂΩïÂºÄÂè£Êï∞ÔºåÂè™ÊúâÂΩìopen&gt;0ÊâçÂØπcloseÂíådpÊìç‰Ωú„ÄÇÈ¶ñÂÖàÊõ¥Êñ∞dp=dp[i-1]+2ÔºåÂä†‰∏ä‰∏ÄÂØπÂêàÊ†ºÂØπÊã¨Âè∑„ÄÇ‰πãÂêéÂ¶ÇÊûúi-dp[i]&gt;0ËØ¥Êòéi‰πãÂâçËøòÊòØÊúâÂêàÊ†ºÊã¨Âè∑ÂØπÂ≠òÂú®ÔºåÊääËøô‰∫õ‰πüÂä†‰∏ä„ÄÇÊúÄÂêéÁî®maxËÆ∞ÂΩïÊúÄÂ§ßÔºåËøîÂõûmax„ÄÇ 125. Valid Palindrome üîóQuestion Link class Solution &#123; public boolean isPalindrome(String s) &#123; if(s == null || s.length()==0)return true; int left = 0; int right = s.length()-1; while(left&lt;=right)&#123; char l = s.charAt(left); char r = s.charAt(right); if(!Character.isLetterOrDigit(l))&#123; left++; &#125; else if(!Character.isLetterOrDigit(r))&#123; right--; &#125; else&#123; if(Character.toLowerCase(l) != Character.toLowerCase(r))return false; right--; left++; &#125; &#125; return true; &#125;&#125; two pointers„ÄÇÂâçÂêéÂêÑËá™Êâ´Êèè‰∏∫Â≠óÊØçÁöÑ‰ΩçÁΩÆ„ÄÇÂ¶ÇÊûú‰∏§‰∏™‰∏çÁõ∏ÂêåÁõ¥Êé•falseÔºåÂ¶ÇÊûúÁõ∏ÂêåÂàôÁªßÁª≠ÂæÄÈáåÊî∂Áº©„ÄÇ 819. Most Common Word üîóQuestion Link class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; banset = new HashSet&lt;&gt;(); String[] words = paragraph.toLowerCase().split(\"\\\\W++\"); for(String ban : banned)&#123; banset.add(ban); &#125; for(String word : words)&#123; if(!banset.contains(word))&#123; map.put(word,map.getOrDefault(word,0)+1); &#125; &#125; int max = 0; String res = \"\"; for(String key : map.keySet())&#123; if(map.get(key) &gt; max)&#123; max = map.get(key); res = key; &#125; &#125; return res; &#125;&#125; bannedÂçïËØçÂä†ÂÖ•setÔºåmapÂ≠ò‰∏çÂú®bannedÈáåÁöÑÂçïËØçÁöÑÊ¨°Êï∞ÔºåÁÑ∂ÂêéÊâæÂà∞ÊúÄÂ§öÊ¨°Êï∞ÁöÑÂçïËØçËøîÂõû„ÄÇ 227. Basic Calculator II üîóQuestion Link class Solution &#123; public int calculate(String s) &#123; int len = s.length(); if(s == null || len == 0)return 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int num = 0; char sign = '+'; for(int i=0 ;i&lt;s.length();i++)&#123; if(Character.isDigit(s.charAt(i)))&#123; num = num*10 + s.charAt(i)-'0'; &#125; if( (!Character.isDigit(s.charAt(i)) &amp;&amp; s.charAt(i)!=' ') || i == len-1)&#123; if(sign == '-')&#123; stack.push(-num); &#125; if(sign == '+')&#123; stack.push(num); &#125; if(sign == '*')&#123; stack.push(stack.pop() * num); &#125; if(sign == '/')&#123; stack.push(stack.pop() / num); &#125; sign = s.charAt(i); num=0; &#125; &#125; int res = 0; for(int nums : stack)&#123; res+=nums; &#125; return res; &#125;&#125; ÈÄÜÊ≥¢ÂÖ∞ÂºèÂ≠êÁöÑÂ∫îÁî®„ÄÇstackÂ≠òÊï∞Â≠óÔºåÁÑ∂ÂêéÂàùÂßãÂåñËøêÁÆóÁ¨¶‰∏∫+Âè∑„ÄÇÊõ¥Êñ∞ÂÆåvalueÂêéÂÜçÊääÁ¨¶Âè∑Êõ¥Êñ∞‰∏∫ÂΩìÂâçÁöÑÁ¨¶Âè∑„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"}]},{"title":"Leetcode EveryDay 63","slug":"chin-up-01","date":"2020-01-20T17:13:54.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2020/01/20/chin-up-01/","link":"","permalink":"WangHngLeee.github.io/2020/01/20/chin-up-01/","excerpt":"ÂâçË®ÄÔΩúSay something‚Ä¶ HiÔºåÂæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞blog‰∫ÜÔºåËøôÊúüÈó¥ÁªèÂéÜ‰∫ÜËÆ∏Â§öÔºå‰πüÂØπËá™Â∑±Êúâ‰∫ÜÊñ∞ÁöÑËÆ§ËØÜÔºåÂà∑È¢ò‰πüÊúâ‰∫ÜÊñ∞ÁöÑÊñπÊ≥ï„ÄÇ ËôΩÁÑ∂Âæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞blog‰∫ÜÔºå‰ΩÜÊòØÊØèÂ§©ÈÉΩÊúâÂú®ÂÅöÈ¢òÔºåÂâç‰∏ÄÊúàÂàùÁöÑÊó∂ÂÄôËææÊàê‰∫ÜÂà∑È¢ò430ÈÅìÔºåÁÆóÊòØ‰∏Ä‰∏™Â∞èÊàêÂ∞±ÂêßÔºåÊé•‰∏ãÊù•‰πü‰∏çÊâìÁÆóÂÅöÊñ∞È¢ò‰∫ÜÔºå‰∏ªË¶ÅÂ§ç‰π†ÊÄªÁªì‰πãÂâçÂÅöËøáÁöÑÈ¢òÁõÆ„ÄÇ ÊúÄËøë‰πüÈôÜÈôÜÁª≠Áª≠Êî∂Âà∞Âà´ÁöÑÂÖ¨Âè∏ÁöÑoaÂíåÈù¢ËØïÔºåÂ∏åÊúõËá™Â∑±Â•ΩÂ•ΩÂáÜÂ§á„ÄÇ Keep head on and Chin up ! 199. Binary Tree Right Side View üîóQuestion Link class Solution&#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue= new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if(i&gt;=size-1)res.add(root.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; ÂÖ∏Âûãtree+bfs+queueÁöÑlevel traversalÔºåÂîØ‰∏ÄdifferenceÊòØÂΩìsizeÂà∞ËææÊîπÂ±ÇÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Êó∂ÊâçÂä†ÂÖ•res„ÄÇ","text":"ÂâçË®ÄÔΩúSay something‚Ä¶ HiÔºåÂæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞blog‰∫ÜÔºåËøôÊúüÈó¥ÁªèÂéÜ‰∫ÜËÆ∏Â§öÔºå‰πüÂØπËá™Â∑±Êúâ‰∫ÜÊñ∞ÁöÑËÆ§ËØÜÔºåÂà∑È¢ò‰πüÊúâ‰∫ÜÊñ∞ÁöÑÊñπÊ≥ï„ÄÇ ËôΩÁÑ∂Âæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞blog‰∫ÜÔºå‰ΩÜÊòØÊØèÂ§©ÈÉΩÊúâÂú®ÂÅöÈ¢òÔºåÂâç‰∏ÄÊúàÂàùÁöÑÊó∂ÂÄôËææÊàê‰∫ÜÂà∑È¢ò430ÈÅìÔºåÁÆóÊòØ‰∏Ä‰∏™Â∞èÊàêÂ∞±ÂêßÔºåÊé•‰∏ãÊù•‰πü‰∏çÊâìÁÆóÂÅöÊñ∞È¢ò‰∫ÜÔºå‰∏ªË¶ÅÂ§ç‰π†ÊÄªÁªì‰πãÂâçÂÅöËøáÁöÑÈ¢òÁõÆ„ÄÇ ÊúÄËøë‰πüÈôÜÈôÜÁª≠Áª≠Êî∂Âà∞Âà´ÁöÑÂÖ¨Âè∏ÁöÑoaÂíåÈù¢ËØïÔºåÂ∏åÊúõËá™Â∑±Â•ΩÂ•ΩÂáÜÂ§á„ÄÇ Keep head on and Chin up ! 199. Binary Tree Right Side View üîóQuestion Link class Solution&#123; public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue= new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); for(int i=0 ;i&lt;size;i++)&#123; TreeNode temp = queue.poll(); if(i&gt;=size-1)res.add(root.val); if(temp.left!=null)queue.add(temp.left); if(temp.right!=null)queue.add(temp.right); &#125; &#125; return res; &#125;&#125; ÂÖ∏Âûãtree+bfs+queueÁöÑlevel traversalÔºåÂîØ‰∏ÄdifferenceÊòØÂΩìsizeÂà∞ËææÊîπÂ±ÇÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Êó∂ÊâçÂä†ÂÖ•res„ÄÇ 863. All Nodes Distance K in Binary Tree üîóQuestion Link class Solution&#123; Map&lt;TreeNode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root,TreeNode target, int K) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; find(root,target); dfs(root,0,K,res); return res; &#125; public int find(TreeNode root, int target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; public void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(key); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.right,dist+1,K,res)l &#125;&#125; findÂáΩÊï∞Â∞Ütaregt‰∏äÊñπÊâÄÊúâËäÇÁÇπ ‰∏étargetÁöÑdist Â≠òËøõmap„ÄÇdfsÂáΩÊï∞ÈáåÈ¶ñÂÖàÂà§Êñ≠ËØ•ËäÇÁÇπÊòØÂê¶Â≠òËøõmapÔºåÂ¶ÇÊûúÊúâÂàôÊäädistÊõ¥Êñ∞‰∏∫mapÈáåÁöÑÂÄºÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰∏çÂèòÔºådfsÊØèËøõË°å‰∏ÄÊ¨°dist+1„ÄÇ 207. Course Schedule üîóQuestion Link class Solution&#123; public boolean canFinish(int numCourses, int[] prerequisites)&#123; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; for(int i=0 ;i&lt;indegree.length;i++)&#123; if(indegree[i] ==0)&#123; queue.add(i); &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); numCourse--; for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]]==0)&#123; queue.add(pair[0]); &#125; &#125; &#125; &#125; return numCourse == 0; &#125;&#125; ÂÖ∏ÂûãÊãìÊâëÊéíÂ∫è„ÄÇÁî®indegreeÂ≠òÊØè‰∏™ËØæÁöÑÂÖ•Â∫¶„ÄÇÁÑ∂ÂêéÂ∞ÜÂÖ•Â∫¶‰∏∫0ÔºåÂç≥ÂèØ‰ª•‰ºòÂÖà‰∏äÁöÑËØæÂä†ÂÖ•queue„ÄÇbfsÊõ¥Êñ∞indegreeÔºåÂ¶ÇÊûúÂÜçÂèëÁé∞indegree‰∏∫Èõ∂ÔºåÂàôÂú®Âä†ÂÖ•queue„ÄÇÊúÄÂêéÂà§Êñ≠Ââ©‰∏ãÁöÑËØæÊòØÂê¶‰∏∫0„ÄÇÂ¶ÇÊûúÂèØ‰ª•‰∏äÂàôÂ∫îËØ•Ê≤°ÊúâÂâ©ËØæ„ÄÇÂê¶ÂàôËøîÂõûfalse„ÄÇ 210. Course Schedule II üîóQuestion Link class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] res = new int[numCourses]; int[] indegree = new int[numCourses]; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int[] pair : prerequisites)&#123; indegree[pair[0]]++; &#125; int index = 0; for(int i=0 ;i&lt;indegree.length;i++)&#123; if(indegree[i] == 0)&#123; queue.add(i); res[index] = i; index++; &#125; &#125; while(!queue.isEmpty())&#123; int course = queue.poll(); for(int[] pair : prerequisites)&#123; if(pair[1] == course)&#123; indegree[pair[0]]--; if(indegree[pair[0]]==0)&#123; queue.add(pair[0]); res[index]=pair[0]; index++; &#125; &#125; &#125; &#125; return index == numCourses ? res : new int[]&#123;&#125;; &#125;&#125; ÊÄùË∑ØÂíå‰∏ä‰∏ÄÈ¢ò‰∏ÄÊ†∑ÔºåÂè™‰∏çËøáÈúÄË¶ÅÁª¥Êä§‰∏Ä‰∏™Â§ßÂ∞è‰∏∫ËØæÁ®ãÊï∞ÁöÑÊï∞ÁªÑÔºåÊåâÂ∫èÂ≠òÂÖ•ËØæÁ®ãÂç≥ÂèØ„ÄÇ 529. Minesweeper üîóQuestion Link class Solution &#123; public char[][] updateBoard(char[][] board, int[] click) &#123; int m = board.length; int n = board[0].length; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(click); while(!queue.isEmpty())&#123; int[] temp = queue.poll(); int row = temp[0]; int col = temp[1]; if(board[row][col] == 'M')&#123; board[row][col] = 'X'; &#125;else&#123; int count = 0; for(int i=-1 ;i&lt;2;i++)&#123; for(int j=-1;j&lt;2;j++)&#123; if(i == 0 &amp;&amp; j == 0)continue; int r = row + i; int c = col + j; if(r&gt;=0 &amp;&amp; r&lt;m &amp;&amp; c&gt;=0 &amp;&amp; c&lt;n &amp;&amp; (board[r][c] == 'M' || board[r][c] =='X') )&#123; count++; &#125; &#125; &#125; if(count &gt; 0)&#123; board[row][col] = (char)(count+'0'); &#125;else&#123; board[row][col] = 'B'; for(int i=-1 ;i&lt;2;i++)&#123; for(int j=-1 ;j&lt;2;j++)&#123; int r = row + i; int c = col + j; if(j == 0 &amp;&amp; i ==0)continue; if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &lt; 0 || c &gt;= n) continue; if(board[r][c] == 'E')&#123; queue.add(new int[]&#123;r,c&#125;); board[r][c] = 'B'; &#125; &#125; &#125; &#125; &#125; &#125; return board; &#125;&#125; ÁªèÂÖ∏bfs„ÄÇÈ¶ñÂÖàÂà§Êñ≠ÊòØÂê¶ÊòØÈõ∑ÔºåÂ¶ÇÊûúÊòØÂàôÂèò‰∏∫x„ÄÇÁÑ∂ÂêéÊï∞Âë®Âõ¥Èõ∑ÊàñËÄÖxÁöÑ‰∏™Êï∞„ÄÇÂ¶ÇÊûú‰∏™Êï∞‰∏ç‰∏∫Èõ∂ÔºåÂàôËØ¥ÊòéËØ•‰ΩçÁΩÆÂë®Âõ¥ÊúâÈõ∑ÔºåÂ∞ÜËØ•‰ΩçÁΩÆÂèò‰∏∫Èõ∑ÁöÑ‰∏™Êï∞„ÄÇÂ¶ÇÊûú‰∏™Êï∞‰∏∫Èõ∂ÔºåËØ¥Êòé‰∏∫ËæπÁïåÔºåÂàôÁªßÁª≠bfsÊâ©Â§ßËæπÁïå„ÄÇ 133. Clone Graph üîóQuestion Link class Solution &#123; public Node cloneGraph(Node node) &#123; if(node == null)return null; Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node dummy = new Node(node.val); Queue&lt;Node&gt;queue=new LinkedList&lt;&gt;(); map.put(node,dummy); queue.add(node); while(!queue.isEmpty())&#123; Node cur = queue.poll(); for(Node nb:cur.neighbors)&#123; if(!map.containsKey(nb))&#123; map.put(nb,new Node(nb.val)); queue.add(nb); &#125; map.get(cur).neighbors.add(map.get(nb)); &#125; &#125; return dummy; &#125;&#125; Áî®mapÂ≠òÂéünodeÂíåÂÖãÈöÜÁöÑÊñ∞nodeÔºåÂØπÂéünodeÁöÑÈÇªÂ±ÖËøõË°åÈÅçÂéÜÔºåÂ¶ÇÊûúmapÈáåÊ≤°ÊúâÂàôÊääËØ•ÈÇªÂ±ÖËäÇÁÇπÂÖãÈöÜÔºåÁÑ∂ÂêéputËøõmapÔºåÂä†ÂÖ•queue„ÄÇÂ¶ÇÊûúÂ≠òÂú®‰∫ÜÂ∞±ÊääÂΩìÂâçnodeÁöÑÈÇªÂ±ÖËäÇÁÇπÁöÑÂÖãÈöÜËäÇÁÇπÂ≠òÂÖ•ÂΩìÂâçnodeÁöÑÂÖãÈöÜËäÇÁÇπÁöÑÈÇªÂ±ÖËäÇÁÇπÈáå„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"}]},{"title":"Leetcode EveryDay 62 / LinkedList","slug":"leetcode62","date":"2019-11-18T20:13:54.000Z","updated":"2020-02-03T01:16:22.110Z","comments":true,"path":"2019/11/18/leetcode62/","link":"","permalink":"WangHngLeee.github.io/2019/11/18/leetcode62/","excerpt":"92. Reverse Linked List II class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i =0;i&lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; Âü∫Êú¨ÁöÑÈìæË°®Êìç‰Ωú„ÄÇÊ≥®ÊÑèÊõ¥Êñ∞Êó∂‰ª£Á†ÅÁöÑÂÜôÊ≥ï„ÄÇ","text":"92. Reverse Linked List II class Solution &#123; public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i =0;i&lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; Âü∫Êú¨ÁöÑÈìæË°®Êìç‰Ωú„ÄÇÊ≥®ÊÑèÊõ¥Êñ∞Êó∂‰ª£Á†ÅÁöÑÂÜôÊ≥ï„ÄÇ 725. Split Linked List in Parts class solution&#123; public ListNode[] splitListToParts(ListNode root, int k) &#123; ListNode[] res = new ListNode[k]; int size = 0; for(ListNode node = root; node!=null ; node = node.next)&#123; size++; &#125; int n = size/k,r = size%k; ListNode prev = null, node = root; for(int i = 0 ; node!=null &amp;&amp; i&lt;k ; i++,r--)&#123; res[i] = node; for(int j = 0; j &lt; n + ( r &gt; 0 ? 1 : 0); j++)&#123; prev = node; node = node.next; &#125; prev.next = null; &#125; return res; &#125;&#125; ÂÖàÂ∞ÜrootÂ≠òÂÖ•res[0]ÔºåÁÑ∂ÂêéÊ†πÊçÆnÂíårÂØπÊï∞ÁªÑÂ§ßÂ∞èËøõË°åÁ°ÆÂÆöÔºåÁÑ∂ÂêéÈÅçÂéÜÔºåËÆ∞‰ΩèprevÊòØËØ•Êï∞ÁªÑÁöÑÂ∞æÔºåËÄånodeÂàôÊòØÊõ¥Êñ∞‰∏∫‰∫Ü‰∏ã‰∏Ä‰∏™resÁöÑÂ§¥ËäÇÁÇπ„ÄÇÁõ∏ÂΩì‰∫éÁî®prev.next==null Êù•Êñ≠ÈìæË°®„ÄÇ 148. Sort List class Solution &#123; public ListNode sortList(ListNode head) &#123; ListNode dummy = new ListNode(0); dummy.next = head; int n = 0; while (head != null) &#123; head = head.next; n++; &#125; for (int step = 1; step &lt; n; step &lt;&lt;= 1) &#123; ListNode prev = dummy; ListNode cur = dummy.next; while (cur != null) &#123; ListNode left = cur; ListNode right = split(left, step); cur = split(right, step); prev = merge(left, right, prev); &#125; &#125; return dummy.next; &#125; private ListNode split(ListNode head, int step) &#123; if (head == null) return null; for (int i = 1; head.next != null &amp;&amp; i &lt; step; i++) &#123; head = head.next; &#125; ListNode right = head.next; head.next = null; return right; &#125; private ListNode merge(ListNode left, ListNode right, ListNode prev) &#123; ListNode cur = prev; while (left != null &amp;&amp; right != null) &#123; if (left.val &lt; right.val) &#123; cur.next = left; left = left.next; &#125; else &#123; cur.next = right; right = right.next; &#125; cur = cur.next; &#125; if (left != null) cur.next = left; else if (right != null) cur.next = right; while (cur.next != null) cur = cur.next; return cur; &#125;&#125; bottom-up„ÄÇ Â∞ÜnodeÊåâ‰∏™Êï∞‰∏∫1Ôºå2Ôºå4Ôºå8Ôºå„ÄÇ„ÄÇ„ÄÇÁöÑÈ°∫Â∫èÂàÜÂà´ÊéíÂ∫èÔºåstep&lt;&lt;=1Â∞±ÊòØÂ∞Üstep*2.splitÊòØËøîÂõûÊñ≠ÂºÄÂêéÂè≥ËæπÁöÑlistnodeÔºåmergeÂ∞±ÊòØÂêàÂπ∂Ôºå‰ΩÜË¶ÅÊ≥®ÊÑèËøîÂõûÁöÑÊòØÂêàÂπ∂ÂêéÁöÑÂ∞æÈÉ®ÁöÑnodeÔºåÊñπ‰æø‰∏ã‰∏ÄÊ¨°Âæ™ÁéØÈìæÊé•„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 61 / LinkedList","slug":"leetcode61","date":"2019-11-17T20:13:54.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/11/17/leetcode61/","link":"","permalink":"WangHngLeee.github.io/2019/11/17/leetcode61/","excerpt":"61. Rotate List class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(head == null)return null; int size = 1; ListNode fast = head,slow = head; while(fast.next!=null)&#123; size++; fast = fast.next; &#125; for(int i = size - k%size;i&gt;1;i--)&#123; slow = slow.next; &#125; fast.next = head; head= slow.next; slow.next = null; return head; &#125;&#125; Á°ÆÂÆölistnodeÈïøÂ∫¶ÔºåÊâæÂà∞Á¨¨k-k%sizeÁ¨¨ÂÖÉÁ¥†ÔºåÁÑ∂ÂêéÂ∞ÜÂÖ∂ÂêéÂÖÉÁ¥†ÂÖ®ÈÉ®ÊèêÂâçÂç≥ÂèØ„ÄÇ","text":"61. Rotate List class Solution &#123; public ListNode rotateRight(ListNode head, int k) &#123; if(head == null)return null; int size = 1; ListNode fast = head,slow = head; while(fast.next!=null)&#123; size++; fast = fast.next; &#125; for(int i = size - k%size;i&gt;1;i--)&#123; slow = slow.next; &#125; fast.next = head; head= slow.next; slow.next = null; return head; &#125;&#125; Á°ÆÂÆölistnodeÈïøÂ∫¶ÔºåÊâæÂà∞Á¨¨k-k%sizeÁ¨¨ÂÖÉÁ¥†ÔºåÁÑ∂ÂêéÂ∞ÜÂÖ∂ÂêéÂÖÉÁ¥†ÂÖ®ÈÉ®ÊèêÂâçÂç≥ÂèØ„ÄÇ 82. Remove Duplicates from Sorted List II class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null)return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode cur = head; ListNode pre = dummy; while(cur!=null)&#123; while(cur.next!=null &amp;&amp; cur.val == cur.next.val)&#123; cur = cur.next; &#125; if(pre.next == cur)&#123; pre = pre.next; &#125;else&#123; pre.next = cur.next; &#125; cur = cur.next; &#125; return dummy.next; &#125;&#125; curÂíåpreÂèåÊåáÈíà„ÄÇÈ¶ñÂÖàÂà§Êñ≠curÂíåcur nextÂÄºÊòØÂê¶Áõ∏Á≠â„ÄÇÂ¶ÇÊûúÁõ∏Á≠âÂàôË∑≥ËøáÔºåpreÈíàÂØπcurÂ¶ÇÊûúÊúâË∑≥Ë∑ÉÔºåÂàôÁõ¥Êé•Â∞Üpre next Êõ¥Êñ∞‰∏∫Êñ∞cur nextÔºå Â¶ÇÊûúÊ≤°ÊúâË∑≥Ë∑ÉÂàôÂ∞±‰∏∫pre next„ÄÇ Âõ†‰∏∫Ê≤°ÊúâË∑≥Ë∑ÉÁöÑËØùpreÂßãÁªàÂú®curÁöÑÂâçÈù¢„ÄÇ 141. Linked List Cycle class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast=head,slow=head; while(fast!=null)&#123; if(fast.next==null)return false; fast=fast.next.next; slow=slow.next; if(fast == slow)return true; &#125; return false; &#125;&#125; ÁªèÂÖ∏Âø´ÊÖ¢ÊåáÈíà„ÄÇfastËµ∞‰∏§‰∏™ÔºåslowËµ∞‰∏Ä‰∏™ÔºåÂ¶ÇÊûú‰∏§‰∏™Êüê‰∏™Êó∂ÂàªÈáçÂêàÔºåËØ¥ÊòéÊúâÁéØ„ÄÇÂê¶ÂàôÊ≤°Êúâ„ÄÇ 21. Merge Two Sorted Lists (1.iterative / 2. recursive) 1.Iterative ÊñπÊ≥ï class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode res = dummy; while(l1 !=null &amp;&amp; l2 !=null)&#123; if(l1.val &lt; l2.val)&#123; res.next = l1; l1 = l1.next; &#125;else&#123; res.next = l2; l2=l2.next; &#125; res = res.next; &#125; if(l1 == null)res.next = l2; if(l2 == null)res.next = l1; return dummy.next; &#125;&#125; straightforwardÊñπÊ≥ï„ÄÇÊñ∞Âª∫‰∏Ä‰∏™Â§¥ËäÇÁÇπdummyÔºåÂàÜÊÉÖÂÜµËÆ®ËÆ∫l1Âíål2ËäÇÁÇπÁöÑÂÄºÂ§ßÂ∞èÔºåÂàÜÂà´Âä†ÂÖ•dummy next„ÄÇÊúÄÂêéËÄÉËôëÊüê‰∏™listÂ∑≤ÁªèÈÅçÂéÜÂÆåÁöÑÊÉÖÂÜµÔºåÂàôÂ∞ÜÂè¶Â§ñ‰∏Ä‰∏™listÁõ¥Êé•Âä†Âà∞dummy ÂêéÈù¢„ÄÇ 2.Recursive ÊñπÊ≥ï class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null || l2 == null)return l1 == null ? l2:l1; if(l1.val &lt; l2.val)&#123; l1.next = mergeTwoLists(l1.next,l2); return l1; &#125;else&#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125; Âü∫Êú¨ÁöÑrecursiveÊñπÊ≥ïÔºåÂàÜÂà´ÂØπl1Âíål2ÈÄíÂΩí„ÄÇ 23. Merge k Sorted Lists (priorityqueue / recursive ) priorityqueue class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode node1, ListNode node2)&#123; if(node1.val &lt; node2.val)return -1; else if(node1.val == node2.val)return 0; else return 1; &#125; &#125;); ListNode dummy = new ListNode(0); ListNode last = dummy; for(ListNode node : lists)&#123; if(node != null)&#123; queue.add(node); &#125; &#125; while(!queue.isEmpty())&#123; last.next = queue.poll(); last = last.next; if(last.next!= null)&#123; queue.add(last.next); &#125; &#125; return dummy.next; &#125;&#125; Ëá™ÂÆö‰πâcomparatorÔºåÂ∞ÜÊØè‰∏™listÁ¨¨‰∏Ä‰∏™ËäÇÁÇπÂ≠òÂÖ•queueÔºåÁÑ∂ÂêéÂà§Êñ≠pollÂêéÁöÑqueueÂ§¥ÈÉ®ËäÇÁÇπÂíåpollÁöÑËäÇÁÇπnextÁöÑÂÄºÂ§ßÂ∞è„ÄÇÁÑ∂Âêé‰æùÊ¨°pollÂá∫Âç≥ÂèØ„ÄÇ recursive ( based on mergeTwolists solutions) class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; return mergeTwoList(lists,0,lists.length-1); &#125; public ListNode mergeTwoList(ListNode[] lists, int start, int end)&#123; if(start == end)return lists[start]; if(start &lt; end)&#123; int mid = (start + end)/2; ListNode l1 = mergeTwoList(lists,start,mid); ListNode l2 = mergeTwoList(lists,mid+1,end); return merge(l1,l2); &#125;else&#123; return null; &#125; &#125; public ListNode merge(ListNode l1, ListNode l2)&#123; if(l1==null) return l2; if(l2==null) return l1; if(l1.val&lt;l2.val)&#123; l1.next=merge(l1.next,l2); return l1; &#125;else&#123; l2.next=merge(l1,l2.next); return l2; &#125; &#125;&#125; Âü∫‰∫élc 21 mergetwolist ÁöÑÊñπÊ≥ï„ÄÇÊú¨È¢òÂèò‰∏∫k‰∏™listÔºåÈúÄË¶ÅÂ§ö‰∏ÄÂ±ÇÂØπlistËá™Ë∫´ÂØπÈÄíÂΩí„ÄÇ‰∫åÂàÜÈÄíÂΩí„ÄÇÁÑ∂ÂêéÂÜçÊé•‰∏ämergetwolistÁöÑÊÄùË∑ØÔºåÂØπÊåáÂÆöÂØπ‰∏§‰∏™listËøõË°åmerge„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 60 / LinkedList","slug":"leetcode60","date":"2019-11-16T17:27:29.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/16/leetcode60/","link":"","permalink":"WangHngLeee.github.io/2019/11/16/leetcode60/","excerpt":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jÂ∞±ÊòØËÆ°ÁÆóËøõ‰Ωç„ÄÇËÄåsum%10ÂàôÊòØËÆ°ÁÆóÂà®Èô§Ëøõ‰ΩçÂêéÈúÄË¶ÅÂä†ÁöÑÊï∞„ÄÇ","text":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jÂ∞±ÊòØËÆ°ÁÆóËøõ‰Ωç„ÄÇËÄåsum%10ÂàôÊòØËÆ°ÁÆóÂà®Èô§Ëøõ‰ΩçÂêéÈúÄË¶ÅÂä†ÁöÑÊï∞„ÄÇ 138. Copy List with Random Pointer class Solution &#123; public Node copyRandomList(Node head) &#123; if (head == null) return null; Node cur = head; while (cur != null) &#123; Node next = cur.next; cur.next = new Node(cur.val, next, null); cur = next; &#125; cur = head; while (cur != null) &#123; if (cur.random != null) cur.next.random = cur.random.next; cur = cur.next.next; &#125; cur = head; Node copyhead = head.next; while(cur!=null)&#123; Node curnext = cur.next.next;//curÈìæË°® Node copy = cur.next;//copyÈìæË°® cur.next = curnext; if(curnext!=null)&#123; copy.next = curnext.next; &#125; cur = curnext; &#125; return copyhead; &#125;&#125; ‰∏âÊ¨°ÈÅçÂéÜ„ÄÇ Á¨¨‰∏ÄÊ¨°Âú®ÂØπÂ∫îÁöÑnodeÂêéÈù¢Â§çÂà∂Ëá™Â∑±Êàê‰∏∫node‚Äô Á¨¨‰∫åÊ¨°Â∞Ünode‚ÄôÁöÑrandomËøûÁ∫ø Á¨¨‰∏âÊ¨°ÂêÑËá™ÊàêÁ∫ø„ÄÇ Â§ßÊ¶ÇÊÄùË∑ØÂ¶ÇÂõæÔºö 328. Odd Even Linked List class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head!=null)&#123; ListNode odd = head, even = head.next, evenhead = even; while(even !=null &amp;&amp; even.next !=null)&#123; odd.next = odd.next.next; even.next = even.next.next; odd = odd.next; even = even.next; &#125; odd.next = evenhead; &#125; return head; &#125;&#125; Âå∫ÂàÜoddÂíåevenÁöÑhead‰πãÂêéÂêÑËá™next.nextÈÅçÂéÜÂ∞±ÂèØ‰ª•„ÄÇÊúÄÂêéÂ∞ÜevenheadÂä†Âà∞oddÂêéÈù¢„ÄÇ 1019. Next Greater Node In Linked List class Solution &#123; public int[] nextLargerNodes(ListNode head) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(ListNode node = head; node!=null;node = node.next)&#123; list.add(node.val); &#125; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int size = list.size(); int[] res = new int[size]; for(int i = 0 ; i &lt; size;i++)&#123; while(!stack.isEmpty() &amp;&amp; list.get(stack.peek())&lt; list.get(i))&#123; res[stack.pop()] = list.get(i); &#125; stack.push(i); &#125; return res; &#125;&#125; listnodeÂ≠ò‰∏∫arraylist„ÄÇÁî®stackÂ≠òË¥ÆindexÔºåÁÑ∂ÂêéÂêÑËá™ÊØîËæÉ„ÄÇÁ±ª‰ººnext greator ÁöÑÈ¢òÔºå‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇ‰∏ã‰∏ÄÈ¢òÂ∞±ÊòØnext greater„ÄÇ 503. Next Greater Element II(circle) class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int size = nums.length; int res[] = new int[size]; Arrays.fill(res,-1); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;size*2;i++)&#123; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i%size])&#123; res[stack.pop()] = nums[i%size]; &#125; stack.push(i%size); &#125; return res; &#125;&#125; Loop once, we can get the Next Greater Number of a normal array. Loop twice, we can get the Next Greater Number of a circular array 496. Next Greater Element I class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num:nums2)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek() &lt; num)&#123; map.put(stack.pop(), num); &#125; stack.push(num); &#125; for(int i = 0;i&lt;nums1.length;i++)&#123; nums1[i]=map.getOrDefault(nums1[i],-1); &#125; return nums1; &#125;&#125; map + stack„ÄÇ 556. Next Greater Element III class Solution &#123; public int nextGreaterElement(int n) &#123; char[] number = (n+\"\").toCharArray(); int i,j; for (i = number.length-1; i &gt; 0; i--) if (number[i-1] &lt; number[i]) break;//‰ªéÂêéÂêëÂâçÈÅçÂéÜÔºåÊâæÂà∞Á¨¨‰∏Ä‰∏™Â∑¶ËæπÂ∞è‰∫éÂè≥ËæπÁöÑindex„ÄÇ if (i == 0)//Â¶ÇÊûúÊ≤°ÊúâÔºå‰πüÂ∞±ÊòØÊï¥‰∏™Â∫èÂàóÈÉΩÊòØÈôçÂ∫èÔºåÊú¨Ë∫´Â∞±ÊòØÊúÄÂ§ßÂÄº‰∫Ü„ÄÇ return -1; int x = number[i-1], smallest = i;// ËÆ∞‰ΩèÂ∞èÁöÑÊï∞ÂÄºÔºåËÆ∞ÂΩïÂè≥ËæπÊï∞ÂÄºÁöÑindex„ÄÇ for (j = i+1; j &lt; number.length; j++)// Âú®xÂà∞ÊúÄÂêé‰∏Ä‰Ωç‰πãÈó¥ÔºåÂØªÊâæÂ§ß‰∫éxÂÄºÂπ∂‰∏îÂ∞è‰∫éÂè≥ËæπÂÄºÁöÑÊúÄÂ∞èÂÄºindex if (number[j] &gt; x &amp;&amp; number[j] &lt;= number[smallest]) smallest = j; char temp = number[i-1];//Â∞ÜÂ∑¶ËæπÁöÑÂ∞èÊï∞ÂÄºÂíåÂè≥ËæπÈÉ®ÂàÜÁöÑÊúÄÂ∞èÂÄº‰∫íÊç¢„ÄÇ number[i-1] = number[smallest]; number[smallest] = temp; Arrays.sort(number, i, number.length);//Â∞ÜÂâ©‰∏ãÁöÑÂè≥ËæπÈÉ®ÂàÜsort long val = Long.parseLong(new String(number)); return (val &lt;= Integer.MAX_VALUE) ? (int) val : -1; &#125;&#125; ÊÄùË∑ØÈôÑÂú®codeÈáå„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"}]},{"title":"Leetcode EveryDay 59 / Tree","slug":"leetcode59","date":"2019-11-14T19:14:36.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/14/leetcode59/","link":"","permalink":"WangHngLeee.github.io/2019/11/14/leetcode59/","excerpt":"Tree Á±ªÈ¢òÊ®°Áâà Âçïtree ‰∏§‰∏™treeÊØîËæÉ tree ‰∏âÁßç ÈÅçÂéÜ 100. Same Tree class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null)return true; if(p == null || q == null)return false; boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right &amp;&amp; p.val == q.val; &#125;&#125; ÂçïtreeÊ®°Áâà„ÄÇ","text":"Tree Á±ªÈ¢òÊ®°Áâà Âçïtree ‰∏§‰∏™treeÊØîËæÉ tree ‰∏âÁßç ÈÅçÂéÜ 100. Same Tree class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null)return true; if(p == null || q == null)return false; boolean left = isSameTree(p.left,q.left); boolean right = isSameTree(p.right,q.right); return left &amp;&amp; right &amp;&amp; p.val == q.val; &#125;&#125; ÂçïtreeÊ®°Áâà„ÄÇ 101. Symmetric Tree class Solution &#123; public boolean isSymmetric(TreeNode root) &#123; return root == null || help(root.left,root.right); &#125; private boolean help(TreeNode node1, TreeNode node2)&#123; if(node1 == null &amp;&amp; node2 == null)return true; if(node1 == null || node2 == null)return false; boolean left = help(node1.left,node2.right); boolean right = help(node1.right,node2.left); return left&amp;&amp;right&amp;&amp;node1.val == node2.val; &#125;&#125; Âèåtree„ÄÇÁî±‰∫éÈ¢òÁõÆÁªôÂÆöÂçïfunctionÈáåÂè™Êúâ‰∏Ä‰∏™treeÔºåË¶ÅÂçïÁã¨ÂÜô‰∏Ä‰∏™private„ÄÇ 951. Flip Equivalent Binary Trees class Solution &#123; public boolean flipEquiv(TreeNode root1, TreeNode root2) &#123; if(root1 == null &amp;&amp; root2 == null)return true; if(root1 == null || root2 == null)return false; boolean left1 = flipEquiv(root1.left,root2.left);//no change boolean left2 = flipEquiv(root1.left,root2.right); // flipped boolean right1 = flipEquiv(root1.right,root2.right); // no change boolean right2 = flipEquiv(root1.right,root2.left); // flipped return root1.val == root2.val &amp;&amp;( ( left1 &amp;&amp; right1) || (left2 &amp;&amp; right2) );// we have to make sure the correct left and right part is unchanged or flipped. &#125;&#125; Âèåtree„ÄÇË¶ÅËÄÉËôëÂõõÁßçÊÉÖÂÜµ„ÄÇ left Ôºö change or flipped „ÄÇright‰∏ÄÊ†∑„ÄÇ 572. Subtree of Another Tree class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s==null)return false; return isSame(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t); &#125; private boolean isSame(TreeNode s, TreeNode t)&#123; if(s == null &amp;&amp; t == null)return true; if(s==null || t==null)return false; if(s.val!=t.val)return false; return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); &#125;&#125; Âíå100 same tree ‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇÂè™‰∏çËøásubtree‰∏ÄÊ†∑‰πüÂèØ‰ª•„ÄÇÊâÄ‰ª•main Èáåreturn‰∏≠ÊúâËÄÉËôëleft / right subtree ‰∏ÄÊ†∑ÂçïÊÉÖÂÜµ„ÄÇ 545. Boundary of Binary Tree class solutoin&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; if(root == null)return res; res.add(root.val); left(root.left); leaves(root.left); leaves(root.right); right(root.right); return res; &#125; public void left(TreeNode root)&#123; if(root == null || root.left == null &amp;&amp; root.right == null)return; res.add(root.val); if(root.left == null)left(root.right); else left(root.left); &#125; public void right(TreeNode root)&#123; if(root == null || root.left == null &amp;&amp; root.right == null)return; if(root.right == null)right(root.left); else right(root.right); res.add(root.val); &#125; public void leaves(TreeNode root)&#123; if(root == null)return; if(root.left == null &amp;&amp; root.right == null)res.add(root.val); leaves(root.left); leaves(root.right); &#125;&#125; Â∑¶ËæπÁïå - Â∑¶Âè∂Â≠ê - Âè≥Âè∂Â≠ê - Âè≥ËæπÁïå„ÄÇ Ê≥®ÊÑèÂ∑¶Âè≥add rootÁöÑÊó∂Êú∫‰∏çÂêå„ÄÇÂ∑¶ËæπÂÖàaddÂÜçÈÄíÂΩí„ÄÇÂè≥ËæπÊòØÂÖàÈÄíÂΩíÂÜçadd„ÄÇ Ê≥®ÊÑè‰∏âÁßçÊÉÖÂÜµÁöÑÂáΩÊï∞ÂÜôÊ≥ï„ÄÇleft /leaves /right 103. Binary Tree Zigzag Level Order Traversal class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null)return res; queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); int size = queue.size(); for(int i = 0;i&lt;size;i++)&#123; TreeNode cur = queue.poll(); if(zig)&#123; temp.add(0,cur.val); &#125; else&#123; temp.add(cur.val); &#125; if(cur.left!=null)queue.offer(cur.left); if(cur.right!=null)queue.offer(cur.right); &#125; res.add(temp); zig = !zig; &#125; return res; &#125;&#125; Áî®zigÊù•Ê†áËÆ∞ËØ•Ë°åÊòØÂê¶zigËæìÂá∫„ÄÇÂ¶ÇÊûúÊòØzigÁöÑ‰∏ÄË°åÔºåÂàôÂ∞ÜpollÂá∫Êù•ÁöÑ add(0,temp)Âà∞ tempÁöÑÂºÄÂ§¥„ÄÇÂê¶ÂàôÁöÑËØùÂ∞±ÊåâÈ°∫Â∫èaddÂà∞temp‰∏≠„ÄÇÊØè‰∏™teampÂ≠òÁöÑÊòØÊØè‰∏ÄË°åÁöÑÂÖÉÁ¥†ÔºåÊúÄÂêéÂ∞ÜtempÂä†ÂÖ•res‰∏≠„ÄÇ 124. Binary Tree Maximum Path Sum class Solution &#123; int max; public int maxPathSum(TreeNode root) &#123; max = Integer.MIN_VALUE; maxpath(root); return max; &#125; private int maxpath(TreeNode root)&#123; if(root == null)return 0; int left = Math.max(maxpath(root.left),0); int right = Math.max(maxpath(root.right),0); max = Math.max(max,left+right+root.val); return Math.max(left,right) + root.val; &#125;&#125; trickyÁöÑÂú∞ÊñπÂú®‰∫éÔºömaxËµãÂÄºÈÇ£ÈáåÔºåmathÈáåÈù¢ÁöÑmaxÊòØÂ∑¶Âè≥Â≠êÊ†ëÈÅçÂéÜÂêéÁöÑmaxÔºåËÄåÂ§ñÈù¢ÁöÑmaxËøòÊòØÊú™Êõ¥Êñ∞ÁöÑmax„ÄÇÊ≥®ÊÑèÊúÄÂêéreturnÂ∑¶Âè≥‰∏≠ÊúÄÂ§ßÁöÑÂä†‰∏äroot valÔºåËøîÂõûÁªô‰∏ä‰∏ÄÂ±ÇÁªßÁª≠ÈÄíÂΩí„ÄÇ 653. Two Sum IV - Input is a BST class Solution &#123; public boolean findTarget(TreeNode root, int k) &#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); return dfs(root,set,k); &#125; private boolean dfs(TreeNode root, HashSet&lt;Integer&gt; set , int k)&#123; if(root == null)return false; if(set.contains(k-root.val))return true; set.add(root.val); return dfs(root.left,k) || dfs(root.right,k); &#125;&#125; two sum ÂèòÁßç„ÄÇ‰æùÊóßÁî®setÂ≠ò‰∏ãÂá∫Áé∞ËøáÁöÑnodeÂÄº„ÄÇÂ¶ÇÊûúset‰∏≠ÊúânodeÊúâÁ≠â‰∫ék-root.valÔºåÂàôËøîÂõûtrue„ÄÇÊ≤°ÊúâÂ∞±ÁªßÁª≠Â∑¶Âè≥ÈÄíÂΩí„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"tree","slug":"tree","permalink":"WangHngLeee.github.io/tags/tree/"}]},{"title":"Leetcode EveryDay 58","slug":"leetcode58","date":"2019-11-13T20:45:36.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/13/leetcode58/","link":"","permalink":"WangHngLeee.github.io/2019/11/13/leetcode58/","excerpt":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jÂ∞±ÊòØËÆ°ÁÆóËøõ‰Ωç„ÄÇËÄåsum%10ÂàôÊòØËÆ°ÁÆóÂà®Èô§Ëøõ‰ΩçÂêéÈúÄË¶ÅÂä†ÁöÑÊï∞„ÄÇ","text":"2. Add Two Numbers class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode head = dummy; int sum = 0; while(l1!=null || l2!=null)&#123; sum/=10; if(l1!=null)&#123; sum+=l1.val; l1 = l1.next; &#125; if(l2!=null)&#123; sum+=l2.val; l2 = l2.next; &#125; dummy.next = new ListNode(sum%10); dummy = dummy.next; &#125; if(sum/10 == 1)dummy.next = new ListNode(1); return head.next; &#125;&#125; sum/10jÂ∞±ÊòØËÆ°ÁÆóËøõ‰Ωç„ÄÇËÄåsum%10ÂàôÊòØËÆ°ÁÆóÂà®Èô§Ëøõ‰ΩçÂêéÈúÄË¶ÅÂä†ÁöÑÊï∞„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 57","slug":"leetcode57","date":"2019-11-11T19:35:36.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/11/leetcode57/","link":"","permalink":"WangHngLeee.github.io/2019/11/11/leetcode57/","excerpt":"863. All Nodes Distance K in Binary Tree class Solution &#123; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); dfs(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)return 0; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; private void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.left,dist+1,K,res); &#125;&#125; findÂ∞ÜÂú®target‰πã‰∏äÁöÑnodeÂ≠òÂÖ•map„ÄÇÂú®target subtreeÈáåÁöÑ‰∏çËµãÂÄº„ÄÇ dfs‰∏≠ÔºåÂ¶ÇÊûúÊòØtarget‰πã‰∏äÁöÑËäÇÁÇπÔºåÂ∞ÜdistÊõ¥Êñ∞‰∏∫map‰∏≠Â≠òÁöÑÂà∞targetÁöÑË∑ùÁ¶ªÔºåÂÜçËøõË°ådfs dist+1„ÄÇ Â¶ÇÊûúÊòØtargetÁöÑsubtreeÔºåÂàôÂæ™ÁéØÂà∞targetËá™Ë∫´Êó∂Ôºådist‰ºöÂèò‰∏∫0ÔºåÁÑ∂ÂêédfsÊõ¥Êñ∞ÔºåÂΩìdist==kÊó∂ÔºåËØ•ËäÇÁÇπ‰πüÂ∞±ÊòØË¶ÅÂ≠òÂÖ•resÁöÑËäÇÁÇπ„ÄÇ","text":"863. All Nodes Distance K in Binary Tree class Solution &#123; Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) &#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); dfs(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)return 0; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); return right+1; &#125; return -1; &#125; private void dfs(TreeNode root, int dist, int K, List&lt;Integer&gt; res)&#123; if(root == null)return; if(map.containsKey(root))&#123; dist = map.get(root); &#125; if(dist == K)&#123; res.add(root.val); &#125; dfs(root.left,dist+1,K,res); dfs(root.left,dist+1,K,res); &#125;&#125; findÂ∞ÜÂú®target‰πã‰∏äÁöÑnodeÂ≠òÂÖ•map„ÄÇÂú®target subtreeÈáåÁöÑ‰∏çËµãÂÄº„ÄÇ dfs‰∏≠ÔºåÂ¶ÇÊûúÊòØtarget‰πã‰∏äÁöÑËäÇÁÇπÔºåÂ∞ÜdistÊõ¥Êñ∞‰∏∫map‰∏≠Â≠òÁöÑÂà∞targetÁöÑË∑ùÁ¶ªÔºåÂÜçËøõË°ådfs dist+1„ÄÇ Â¶ÇÊûúÊòØtargetÁöÑsubtreeÔºåÂàôÂæ™ÁéØÂà∞targetËá™Ë∫´Êó∂Ôºådist‰ºöÂèò‰∏∫0ÔºåÁÑ∂ÂêédfsÊõ¥Êñ∞ÔºåÂΩìdist==kÊó∂ÔºåËØ•ËäÇÁÇπ‰πüÂ∞±ÊòØË¶ÅÂ≠òÂÖ•resÁöÑËäÇÁÇπ„ÄÇ 987. Vertical Order Traversal of a Binary Tree class Solution &#123; class pair&#123; TreeNode node; int x; int y; pair(TreeNode n, int x, int y)&#123; node = n; this.x = x; this.y = y; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;Integer,List&lt;pair&gt;&gt; map = new HashMap&lt;&gt;(); Queue&lt;pair&gt; queue = new LinkedList&lt;&gt;(); queue.add(new pair(root,0,0)); int min = 0,max=0; while(!queue.isEmpty())&#123; pair temp = queue.remove(); min = Math.min(temp.x,min); max = Math.max(temp.x,max); if(!map.containsKey(temp.x))&#123; map.put(temp.x,new ArrayList&lt;&gt;()); &#125; map.get(temp.x).add(temp); if(temp.node.left!=null)queue.add(new pair(temp.node.left,temp.x-1,temp.y+1)); if(temp.node.right!=null)queue.add(new pair(temp.node.right,temp.x+1,temp.y+1)); &#125; for(int i = min; i &lt;= max; i++)&#123; Collections.sort(map.get(i),new Comparator&lt;pair&gt;()&#123; public int compare(pair a, pair b)&#123; if(a.y == b.y)return a.node.val - b.node.val; return 0; &#125; &#125;); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int j=0 ; j &lt; map.get(i).size();j++)&#123; list.add(map.get(i).get(j).node.val); &#125; res.add(list); &#125; return res; &#125;&#125; Êñ∞Âª∫pair Á±ªÔºåÁî®queueÂ≠òÊîæÊâÄÊúâÊ†ëËäÇÁÇπÔºåËÆ∞ÂΩïÊâÄÊúâÊ†ëËäÇÁÇπxÁöÑÊúÄÂ∞èÂÄºÂíåÊúÄÂ§ßÂÄºÔºå‰πãÂêéÈÅçÂéÜË¶ÅÁî®Âà∞„ÄÇ map Â≠òÊîæxÂùêÊ†áÈÉΩÁõ∏ÂêåÁöÑpai„ÄÇÁÑ∂ÂêéÁî®compare ‰ªéÂ∞èÂà∞Â§ßsort„ÄÇ ÁÑ∂ÂêéÈÄöËøáxÈ°∫Â∫èÈÅçÂéÜmapÔºåÂ∞ÜÁõ∏ÂêåxÁöÑÂÄºÂ≠òËøõÂêå‰∏Ä‰∏™listÔºåÂÜçÂä†ÂÖ•res‰∏≠„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 56","slug":"leetcode56","date":"2019-11-09T18:35:36.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/11/09/leetcode56/","link":"","permalink":"WangHngLeee.github.io/2019/11/09/leetcode56/","excerpt":"1130. Minimum Cost Tree From Leaf Values class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(arr == null)return 0; int res = 0; stack.push(Integer.MAX_VALUE); for(int a: arr)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek()&lt;= a)&#123; int mid = stack.pop(); res+= mid * Math.min(stack.peek(),a); &#125; stack.push(a); &#125; while(stack.size()&gt;2)&#123; res+=stack.pop()*stack.peek(); &#125; return res; &#125;&#125; Âæà‰∏çÈîôÁöÑ‰∏ÄÈÅìstackÈ¢ò„ÄÇÂ¶ÇÊûúÂΩìÂâçÂæÖÂ≠òÁöÑÊï∞Â§ß‰∫éÂΩìÂâçstackÂ†ÜÈ°∂ÁöÑÊï∞ÔºåÂàôÂ∞ÜÂ†ÜÈ°∂Êï∞popÂá∫Ôºåpop‰πãÂêéÁöÑÂ†ÜÈ°∂Êï∞ÂíåÂΩìÂâçÂæÖÂ≠òa‰∏≠ÊúÄÂ§ßÁöÑÊï∞‰πò‰ª•popÁöÑÊï∞„ÄÇ‰∏ÄÁõ¥Âæ™ÁéØÁõ¥Âà∞Â†ÜÈ°∂ÁöÑÂÖÉÁ¥†Â§ß‰∫éÂΩìÂâçÂæÖÂ≠òÊï∞ÂÄº„ÄÇ trickyÁöÑÂú∞ÊñπÂú®‰∫éÔºåÂΩìÊâÄÊúâÂÖÉÁ¥†ÈÅçÂéÜ‰∏ÄËæπÂêéÔºå‰ºöÊ£ÄÊü•ÂΩìÂâçstackÁöÑÂ§ßÂ∞èÔºåÂ¶ÇÊûúÂ§ß‰∫é2ÔºåÁªßÁª≠popÂπ∂‰∏î‰πò‰ª•ÂΩìÂâçpeekÔºåÁõ¥Âà∞&lt;2„ÄÇËøîÂõûresÔºõÂõ†‰∏∫Â¶ÇÊûústack size&lt;2 ËØ¥ÊòéÁ¨¨‰∏ÄËΩÆwhileÂæ™ÁéØÊó∂ÔºåÊúÄÂêé‰∏Ä‰∏™Êï∞ÂÄº‰ºöÂ§ß‰∫éÂâçÈù¢ÊâÄÊúâÁöÑÊï∞ÔºåÊâÄ‰ª•‰ºö‰∏ÄÁõ¥popÂπ∂‰∏îÊõ¥Êñ∞res„ÄÇ","text":"1130. Minimum Cost Tree From Leaf Values class Solution &#123; public int mctFromLeafValues(int[] arr) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); if(arr == null)return 0; int res = 0; stack.push(Integer.MAX_VALUE); for(int a: arr)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek()&lt;= a)&#123; int mid = stack.pop(); res+= mid * Math.min(stack.peek(),a); &#125; stack.push(a); &#125; while(stack.size()&gt;2)&#123; res+=stack.pop()*stack.peek(); &#125; return res; &#125;&#125; Âæà‰∏çÈîôÁöÑ‰∏ÄÈÅìstackÈ¢ò„ÄÇÂ¶ÇÊûúÂΩìÂâçÂæÖÂ≠òÁöÑÊï∞Â§ß‰∫éÂΩìÂâçstackÂ†ÜÈ°∂ÁöÑÊï∞ÔºåÂàôÂ∞ÜÂ†ÜÈ°∂Êï∞popÂá∫Ôºåpop‰πãÂêéÁöÑÂ†ÜÈ°∂Êï∞ÂíåÂΩìÂâçÂæÖÂ≠òa‰∏≠ÊúÄÂ§ßÁöÑÊï∞‰πò‰ª•popÁöÑÊï∞„ÄÇ‰∏ÄÁõ¥Âæ™ÁéØÁõ¥Âà∞Â†ÜÈ°∂ÁöÑÂÖÉÁ¥†Â§ß‰∫éÂΩìÂâçÂæÖÂ≠òÊï∞ÂÄº„ÄÇ trickyÁöÑÂú∞ÊñπÂú®‰∫éÔºåÂΩìÊâÄÊúâÂÖÉÁ¥†ÈÅçÂéÜ‰∏ÄËæπÂêéÔºå‰ºöÊ£ÄÊü•ÂΩìÂâçstackÁöÑÂ§ßÂ∞èÔºåÂ¶ÇÊûúÂ§ß‰∫é2ÔºåÁªßÁª≠popÂπ∂‰∏î‰πò‰ª•ÂΩìÂâçpeekÔºåÁõ¥Âà∞&lt;2„ÄÇËøîÂõûresÔºõÂõ†‰∏∫Â¶ÇÊûústack size&lt;2 ËØ¥ÊòéÁ¨¨‰∏ÄËΩÆwhileÂæ™ÁéØÊó∂ÔºåÊúÄÂêé‰∏Ä‰∏™Êï∞ÂÄº‰ºöÂ§ß‰∫éÂâçÈù¢ÊâÄÊúâÁöÑÊï∞ÔºåÊâÄ‰ª•‰ºö‰∏ÄÁõ¥popÂπ∂‰∏îÊõ¥Êñ∞res„ÄÇ 449. Serialize and Deserialize BST public class Codec &#123; private static final String SEP = \",\"; private static final String NULL = \"null\"; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; StringBuilder sb = new StringBuilder(); if (root == null) return NULL; //traverse it recursively if you want to, I am doing it iteratively here Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;(); st.push(root); while (!st.empty()) &#123; root = st.pop(); sb.append(root.val).append(SEP); if (root.right != null) st.push(root.right); if (root.left != null) st.push(root.left); &#125; return sb.toString(); &#125; public TreeNode deserialize(String data) &#123; if (data.equals(NULL)) return null; String[] strs = data.split(SEP); Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for (String e : strs) &#123; q.offer(Integer.parseInt(e)); &#125; return getNode(q); &#125; private TreeNode getNode(Queue&lt;Integer&gt; q) &#123; //q: 5,3,2,6,7 if (q.isEmpty()) return null; TreeNode root = new TreeNode(q.poll());//root (5) Queue&lt;Integer&gt; samllerQueue = new LinkedList&lt;&gt;(); while (!q.isEmpty() &amp;&amp; q.peek() &lt; root.val) &#123; samllerQueue.offer(q.poll()); &#125; //smallerQueue : 3,2 storing elements smaller than 5 (root) root.left = getNode(samllerQueue); //q: 6,7 storing elements bigger than 5 (root) root.right = getNode(q); return root; &#125;&#125; stackÂ≠òÂÇ®È°∫Â∫è‰∏∫ root left left left „ÄÇ„ÄÇ„ÄÇ right right right right Âª∫bstÊó∂Ë¶ÅÂàÜÂ§ßÂ∞èqueue„ÄÇ‰øùËØÅleftÁöÑÂÄºÂÖ®Âú®smallqueue‰∏≠Âèñ„ÄÇrightÁöÑÂú®Âá∫Èô§ÂéªleftÂÄºÁöÑq‰∏≠Âèñ„ÄÇ 593. Valid Square class solution&#123; public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4)&#123; int[] len = new int[]&#123;dist(p1,p2),dist(p1,p3),dist(p1,p4),dist(p2,p3),dist(p2,p4),dist(p3,p4)&#125;; int max = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i : len)&#123; max = Math.max(max,i); map.put(i,map.getOrDefault(i,0)+1); &#125; return map.size()==2&amp;&amp;map.get(max)==1; &#125; public int dist(int[]point1,int[]point2)&#123; return ((point2[0]-point[0])*()point2[0]-point[0]) + (point2[1]-point1[1])*(point2[1]-point1[1])); &#125;&#125; Âà§Êñ≠Âõõ‰∏™ÁÇπÊòØÂê¶‰∏∫‰∏Ä‰∏™square„ÄÇÁî®mapÂ≠òÂêÑ‰∏™ÁÇπ‰πãÈó¥Ë∑ùÁ¶ª„ÄÇÊúÄÂêéÂè™Ë¶Å‰øùËØÅmapÁÇπÂ§ßÂ∞è‰∏∫2(ËæπÈïøÂíåÂØπËßíÁ∫ø‰∏§ÁßçÈïøÂ∫¶)Ôºå‰∏îÊúÄÈïøÁöÑ(ÂØπËßíÁ∫ø)Êúâ‰∏îÂè™Êúâ‰∏§‰∏™„ÄÇ 759. Employee Free Time class solution&#123; public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) &#123; List&lt;Interval&gt; res = new ArrayList&lt;&gt;(); PriorityQueue&lt;Interval&gt; queue = new PriorityQueue&lt;&gt;((a,b)-&gt; a.start-b.start); schedule.forEach(e -&gt; queue.addAll(e)); while(!queue.isEmpty())&#123; temp = queue.poll(); if(temp.end &lt; queue.peek().start)&#123; res.add(new Interval(temp.end,queue.peek().start)); temp = queue.poll(); &#125;else&#123; temp = temp.end &lt; queue.peek().end ? queue.peek() : temp; queue.poll(); &#125; &#125; return res; &#125;&#125; priorityqueue Â≠òinterval„ÄÇpoll‰πãÂêéÂà§Êñ≠ÂΩìÂâçendÂíåpeekÁöÑstartÂ§ßÂ∞èÂÖ≥Á≥ªÂç≥ÂèØ„ÄÇÊ≥®ÊÑè‰∏çÁ¨¶ÂêàresÊù°‰ª∂ÂêéÂÖàË∑üpeekÊØîÁÑ∂ÂêéÂú®poll„ÄÇÁõ¥Êé•poll‰ºöTLE„ÄÇ 1091. Shortest Path in Binary Matrix class Solution &#123; public int shortestPathBinaryMatrix(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] dir = new int[][]&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,0&#125;,&#123;-1,0&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;,&#123;-1,-1&#125;,&#123;1,1&#125;&#125;; if(grid[0][0]==1 || grid[m-1][n-1]==1) &#123; return -1; &#125; boolean[][] visited = new boolean[m][n]; visited[0][0] = true; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(new int[]&#123;0,0&#125;); int ans=0; while (!queue.isEmpty()) &#123; int size = queue.size(); for(int i=0;i&lt;size;i++) &#123; int[] pop = queue.poll(); if(pop[0]==m-1 &amp;&amp; pop[1]==n-1) &#123; return ans+1; &#125; for (int[] d:dir) &#123; int nextX = d[0]+pop[0]; int nextY = d[1]+pop[1]; if(nextX&gt;=0 &amp;&amp; nextX&lt;m &amp;&amp; nextY&gt;=0 &amp;&amp; nextY&lt;n &amp;&amp; !visited[nextX][nextY] &amp;&amp; grid[nextX][nextY]==0) &#123; queue.add(new int[]&#123;nextX,nextY&#125;); visited[nextX][nextY]=true; &#125; &#125; &#125; ans++; &#125; return -1; &#125;&#125; queue + dir{}„ÄÇ Ê≥®ÊÑèÂΩìÈÅçÂéÜÂà∞ÊúÄÂêé‰∏Ä‰∏™ÁöÑÊó∂ÂÄôË¶ÅËøîÂõûans+1ÔºõÂõ†‰∏∫ansÂ≠òÁöÑÁ±ª‰ºº‰∫éÊ≠•È™§Ê¨°Êï∞ÔºåÂíå‰πãÂâçÂÅöÁöÑÈ¢òÁ±ª‰ººÔºå‰ΩÜÊòØËøôÈÅìÈ¢òÊòØËøîÂõûÁöÑË∑ùÁ¶ªÔºåÊâÄ‰ª•Ë¶ÅÁî®Ê¨°Êï∞+1.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 55","slug":"leetcode55","date":"2019-11-08T03:54:49.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/07/leetcode55/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode55/","excerpt":"503. Next Greater Element II class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] next = new int[n] Arrays.fill(next,-1); for(int i=0;i&lt; n*2 ;i++)&#123; int num = nums[i%n]; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)&#123; next[stack.pop()] = num; &#125; if(i&lt;n)&#123; stack.push(i); &#125; &#125; return next; &#125;&#125; Áî®stackÂ≠òÂéünumsÈáåÂÖÉÁ¥†ÁöÑindex„ÄÇÊñ∞Âª∫‰∏Ä‰∏™Á≠âÂ§ßÁöÑnextÂ≠òÊîæÁªìÊûú„ÄÇ ÂÖ®ÈÉ®ÂàùÂßã‰∏∫-1.ËøõË°ån*2Ê¨°ÈÅçÂéÜÔºå‰øùËØÅÂéünums‰∏≠ÊúÄÂêéÁöÑÂÖÉÁ¥†‰πüËÉΩÊâæÂà∞circle‰∏≠ÁöÑmax„ÄÇ Â¶ÇÊûústack peek()ÁöÑindexÂØπÂ∫îÁöÑnumsÈáåÁöÑÂÖÉÁ¥†Â∞è‰∫éÂΩìÂâçÁöÑnumÊó∂ÔºåË°®ÊòéindexÂØπÂ∫îÁöÑÂÖÉÁ¥†‰∏ã‰∏Ä‰∏™ÊúÄÂ§ßÂÄºÂ∞±ÊòØÂΩìÂâçÁöÑnum„ÄÇÂ∞ÜnumËµãÁªô next[stack.pop()]„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÊúÄÂ§ßÂÄºÁöÑ‰ΩçÁΩÆÊ∞∏ËøúÊòØ-1„ÄÇ","text":"503. Next Greater Element II class Solution &#123; public int[] nextGreaterElements(int[] nums) &#123; int n = nums.length; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int[] next = new int[n] Arrays.fill(next,-1); for(int i=0;i&lt; n*2 ;i++)&#123; int num = nums[i%n]; while(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num)&#123; next[stack.pop()] = num; &#125; if(i&lt;n)&#123; stack.push(i); &#125; &#125; return next; &#125;&#125; Áî®stackÂ≠òÂéünumsÈáåÂÖÉÁ¥†ÁöÑindex„ÄÇÊñ∞Âª∫‰∏Ä‰∏™Á≠âÂ§ßÁöÑnextÂ≠òÊîæÁªìÊûú„ÄÇ ÂÖ®ÈÉ®ÂàùÂßã‰∏∫-1.ËøõË°ån*2Ê¨°ÈÅçÂéÜÔºå‰øùËØÅÂéünums‰∏≠ÊúÄÂêéÁöÑÂÖÉÁ¥†‰πüËÉΩÊâæÂà∞circle‰∏≠ÁöÑmax„ÄÇ Â¶ÇÊûústack peek()ÁöÑindexÂØπÂ∫îÁöÑnumsÈáåÁöÑÂÖÉÁ¥†Â∞è‰∫éÂΩìÂâçÁöÑnumÊó∂ÔºåË°®ÊòéindexÂØπÂ∫îÁöÑÂÖÉÁ¥†‰∏ã‰∏Ä‰∏™ÊúÄÂ§ßÂÄºÂ∞±ÊòØÂΩìÂâçÁöÑnum„ÄÇÂ∞ÜnumËµãÁªô next[stack.pop()]„ÄÇÂ¶ÇÊûúÊ≤°ÊúâÊúÄÂ§ßÂÄºÁöÑ‰ΩçÁΩÆÊ∞∏ËøúÊòØ-1„ÄÇ Á±ª‰ººÁöÑÈ¢òÁõÆ 496. Next Greater Element I class Solution &#123; public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int i = 0 ; i &lt; nums2.length;i++)&#123; while(!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums2[i])&#123; map.put(stack.pop(),nums2[i]); &#125; stack.push(nums2[i]); &#125; for(int i = 0 ; i &lt; nums1.length;i++)&#123; num1[i] = map.getOrDefault(nums1[i],-1); &#125; return nums1; &#125;&#125; ‰∏ÄÊ†∑ÁöÑÊÄùË∑ØÔºåÂè™‰∏çËøáËøôÈÅìÈ¢òÁõ¥Êé•Â≠òÁöÑÊòØÂÖÉÁ¥†Êú¨Ë∫´ÔºåÂõ†‰∏∫Ê≤°ÊúâcircleÁöÑË¶ÅÊ±Ç„ÄÇÁî®mapÂ≠ò‰Ωènums2ÈáåÂÖÉÁ¥†Âíånext greaterÁöÑkey-value„ÄÇÊúÄÂêéÂØπnums1ËøõË°åÊõ¥Êñ∞„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 54","slug":"leetcode54","date":"2019-11-07T19:54:49.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/11/07/leetcode54/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode54/","excerpt":"Á¨¨‰∫åÈÅç 80. Remove Duplicates from Sorted Array II class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 2 || num &gt; nums[index-2])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; ÈÄªËæë‰∏çÈöæ„ÄÇÁïôÂá∫‰∏§‰∏™‰ΩçÁΩÆÔºåÂõ†‰∏∫È¢òÁõÆË¶ÅÊ±ÇÊúÄÂ§öÊúâ‰∏§‰∏™ÈáçÂ§çÂÖÉÁ¥†„ÄÇÂè™Ë¶ÅÂΩìÂâçnumÂíånums[index-2]Âç≥ÂèØ„ÄÇÂ∞ÜÂΩìÂâçnumÂ≠òÂÖ•indexÁöÑ‰ΩçÁΩÆ„ÄÇ","text":"Á¨¨‰∫åÈÅç 80. Remove Duplicates from Sorted Array II class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 2 || num &gt; nums[index-2])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; ÈÄªËæë‰∏çÈöæ„ÄÇÁïôÂá∫‰∏§‰∏™‰ΩçÁΩÆÔºåÂõ†‰∏∫È¢òÁõÆË¶ÅÊ±ÇÊúÄÂ§öÊúâ‰∏§‰∏™ÈáçÂ§çÂÖÉÁ¥†„ÄÇÂè™Ë¶ÅÂΩìÂâçnumÂíånums[index-2]Âç≥ÂèØ„ÄÇÂ∞ÜÂΩìÂâçnumÂ≠òÂÖ•indexÁöÑ‰ΩçÁΩÆ„ÄÇ Áõ∏ÂêåÁöÑÈÄªËæëÂ•óË∑Ø„ÄÇ 26. Remove Duplicates from Sorted Array class Solution &#123; public int removeDuplicates(int[] nums) &#123; int index = 0; for(int num : nums)&#123; if(index &lt; 1 || num &gt; nums[index-1])&#123; nums[index] = num; index++; &#125; &#125; return index; &#125;&#125; ‰∏ÄÊ†∑ÁöÑÂ•óË∑Ø„ÄÇËøôÈÅìÈ¢òÂÖÅËÆ∏ÈáçÂ§çÁöÑ‰∏™Êï∞Âè™Êúâ‰∏Ä‰∏™„ÄÇ 442. Find All Duplicates in an Array class solution&#123; public List&lt;Integer&gt; findDuplicates(int[] nums)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0;i&lt;nums.length;i++)&#123; int index = Math.abs(nums[i]) - 1; if(nums[index] &lt; 0)&#123; res.add(Math.abs(index + 1)); &#125; nums[index] = -nums[index]; &#125; return res; &#125;&#125; Â∞ÜnumÂØπÂ∫îÁöÑindexÂèò‰∏∫Ë¥üÊï∞ÔºåÂ¶ÇÊûúÈÅçÂéÜ‰∏≠ÈÅáÂà∞‰∫ÜËá™Â∑±ÂØπÂ∫îÁöÑindexÂ∑≤Áªè‰∏∫Ë¥üÔºåËØ¥ÊòéÂ∑≤ÁªèÂá∫Áé∞Ëøá‰∫ÜÔºåÂ≠òÂÖ•res„ÄÇ 5. Longest Palindromic Substring class Solution &#123; private int start, dist; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)return s; for(int i = 0;i&lt;s.length();i++)&#123; valid(s,i,i); valid(s,i,i+1); &#125; return s.substring(start,start+dist); &#125; private void valid(String s, int i, int j)&#123; while(i&gt;=0 &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j))&#123; j++; i--; &#125; if(dist &lt; j-i-1)&#123; dist = j-i-1; start = i+1; &#125; &#125;&#125; Á¨¨‰∏âÈÅçÈÅáÂà∞„ÄÇËøòÊòØË¶ÅÊ≥®ÊÑè‰∏§ÁßçÂØπÁß∞ÊÉÖÂÜµ„ÄÇ121or1221„ÄÇ 937. Reorder Data in Log Files Example 1: Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;] class Solution &#123; public String[] reorderLogFiles(String[] logs) &#123; Arrays.sort(logs,(s1,s2)-&gt;&#123; String[] split1 = s1.split(\" \",2); String[] split2 = s2.split(\" \",2); boolean isdigit1 = Character.isDigit(split1[1].charAt(0)); boolean isdigit2 = Character.isDigit(split2[1].charAt(0)); if(!isdigit1 &amp;&amp; !isdigit2)&#123; int compare_value = split1[1].compareTo(split2[1]); if(compare_value==0)&#123; return split1[0].compareTo(split2[0]); &#125; else return compare_value; &#125; else if(isdigit1 &amp;&amp; isdigit2)&#123; return 0; &#125; else if(isdigit1 &amp;&amp; !isdigit2)&#123; return 1; &#125;else&#123; return -1; &#125; &#125;); return logs; &#125;&#125; Á∫ØÁ≤πÁöÑstringÊìç‰ΩúÁü•ËØÜÁÇπ„ÄÇ È¶ñÂÖàÂà§Êñ≠Á¨¨‰∫å‰ΩçÊòØÊï∞Â≠óËøòÊòØÂ≠óÁ¨¶ÔºåÊï∞Â≠óÈù†ÂêéÊîæÔºåÂ≠óÁ¨¶ÂæÄÂâçÊèê„ÄÇËá™ÂÆö‰πâsortÈ°∫Â∫èÔºåÂΩìisdigit1/2 Âùá‰∏∫Êï∞Â≠óÊó∂Ôºå‰øùÊåÅÂéüÈ°∫Â∫èÔºå‰ºòÂÖàÂ∫¶‰∏∫0Ôºõ1‰∏∫digit2‰∏çÊòØÔºå‰ºòÂÖàÂ∫¶ÊúÄ‰ΩéÔºå‰∏∫1Ôºå1‰∏çÊòØdigit 2ÊòØdigitÔºå‰ºòÂÖàÂ∫¶ÊúÄÈ´òÔºå‰∏∫-1Ôºõ ÂΩìÈÉΩ‰∏çÊòØdigitÊó∂ÔºåÂØπ‰∏§ËÄÖÂØπÂ≠óÁ¨¶Â§ßÂ∞èÂà§Êñ≠ÔºåcompareToÂ¶ÇÊûú‰∏∫0ÔºåËØ¥ÊòéÁ¨¨‰∫å‰ΩçÂºÄÂ§¥Â≠óÊØç‰πü‰∏ÄÊ†∑„ÄÇÈÇ£Â∞±ÂØπÁ¨¨‰∏ÄÈÉ®ÂàÜÂØπstringËøõË°åÂ§ßÂ∞èÊéíÂ∫è„ÄÇ 60. Permutation Sequence class solution&#123; public String getPermutation(int n, int k) &#123; StringBuilder sb = new StringBuilder&lt;&gt;(); List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); int[] factorial = new int[n+1]; int sum = 1; for(int i = 1;i&lt;=n;i++)&#123; sum*=i; factorial[i] = sum; numbers.add(i); &#125; k=k-1; for(int i = 1; i &lt;= n;i++)&#123; int index = k/factorial[n-i]; sb.append(String.valueOf(numbers[index])); numbers.remove(index); k = k-index*factorial[n-i]; &#125; return String.valueOf(sb); &#125;&#125; È¶ñÂÖàÂª∫Á´ãfactorialÂíånumbersÔºåÂ≠ò‰ΩènÁöÑÈò∂‰πòÂÄºÂíåÊâÄÊúâÁöÑnumber„ÄÇÊâÄÊúâÁöÑÁªìÊûúÂ∫îËØ•ÊåâÂêÑËá™‰∏∫ÂºÄÂ§¥ÊéíÂàó„ÄÇÂè™Êúâ1ÁöÑÂÖ®ÈÉ®ÈÅçÂéÜÂÆå‰∫ÜÊâç‰ºöÂà∞2ÂºÄÂ§¥„ÄÇ„ÄÇ„ÄÇ ÂΩìÂâçÁ¨¨k‰∏™ÁªìÊûúÁöÑÁ¨¨‰∏Ä‰∏™Êï∞Â≠óÂú®numbersÈáåÁöÑindexÂèØ‰ª•Áî®index = k/factorial[n-i]Êù•ËÆ°ÁÆó„ÄÇ n-iÊòØÈô§ÂéªÂºÄÂ§¥Êï∞Â≠óÂâ©‰∏ãÊâÄÊúâÊÉÖÂÜµÔºåkÂàôÊòØË¶ÅÊ±ÇÁöÑ‰ΩçÁΩÆ„ÄÇk/factorial[n-i]ÂàôÂèØ‰ª•ÊâæÂá∫ÂºÄÂ§¥Êï∞Â≠óÁöÑ‰ΩçÁΩÆ„ÄÇÁÑ∂ÂêéÂéªnumbersÁî®indexÊ±ÇÂá∫ÂºÄÂ§¥Êï∞Â≠ó„ÄÇÊúÄÂêéË¶ÅÊõ¥Êñ∞kÔºåÂõ†‰∏∫ÂºÄÂ§¥Êï∞Â≠óÊâæÂà∞‰∫Ü‰ª•ÂêéÔºåÂÜçÊ±Ç‰πãÂêéÁöÑÊï∞Â≠óÊó∂ÔºåË¶ÅÁî®kÂáèÂéªÁ¨¨‰∏Ä‰∏™Êï∞Â≠óÊâÄÂú®ÁöÑËΩÆÊ¨°ÔºåÁÑ∂Âêé‰ª•Ê≠§Á±ªÊé®Âç≥ÂèØ„ÄÇ 71. Simplify Path class Solution &#123; public String simplifyPath(String path) &#123; Deque&lt;String&gt; deque = new LinkedList&lt;&gt;(); Set&lt;String&gt; banset = new HashSet&lt;&gt;(); for(String str : path.split(\"/\"))&#123; if(str.equals\"..\" &amp;&amp; !deque.isEmpty())deque.pop(); else if(!banset.contains(str))deque.push(str); &#125; String res = \"\"; while(!deque.isEmpty())&#123; res = \"/\" + deque.pop() + res; &#125; return res.isEmptuy() ? \"/\" : res; &#125;&#125; dequeLILOÔºåÈÅáÂà∞‚Ä¶‰∏îdeque‰∏≠ÊúâÂÖÉÁ¥†Âàôpop„ÄÇ 675. Cut Off Trees for Golf Event (hard) ÊÄùË∑Ø‰æùÊóßPriority + bfs + Êìç‰ΩúÊñπÂêëÈõÜ{} class solution&#123; static int[] dir&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;; public int cutOffTree(List&lt;List&lt;Integer&gt;&gt; forest) &#123; PriorityQueue&lt;int[]&gt; pq = new LinkedList&lt;&gt;((a,b)-&gt;a[2]-b[2]); int m = forest.size(), n=forest.get(0).size(); if(forest == null || forest.size() == 0)return 0; for(int i = 0;i&lt;m ;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(forest.get(i).get(j) &gt; 1)&#123; pq.add(new int[]&#123;i,j,forest.get(i).get(j)&#125;); &#125; &#125; &#125; int[] start = new int[2]; int sum = 0; while(!pq.isEmpty())&#123; int[] tree = pq.poll(); int step = getstep(forest,tree,start,m,n); if(step&lt;0)return -1; sum+=step; start[0] = tree[0]; start[1] = tree[1]; &#125; return sum; &#125; private int getstep(List&lt;List&lt;Integer&gt;&gt; forest, int[] tree, int[]start, int m, int n)&#123; int step = 0; boolean[][] seen = new boolean[m][n]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); seen[start[0]][start[1]] = true; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0 ; i &lt; size;i++)&#123; int[] curr = queue.poll(); if(curr[0] == tree[0] &amp;&amp; curr[1] == tree[1])return step; for(int[] d : dir)&#123; int nr = curr[0] + d[0]; int nc = curr[1] + d[1]; if(nr &lt; 0 || nr &gt; m || nc &lt;0 || nc &gt;n || forest.get(nr).get(nc) == 0 || seen[nr][nc])continue; queue.add(new int[]&#123;nr,nc&#125;); seen[nr][nc] = true; &#125; &#125; step++; &#125; return -1; &#125;&#125; Áî®priorityqueueÊåâÂ∞èÂà∞Â§ßÂ∞ÜtreeÂ≠ò‰∏ã„ÄÇÁÑ∂Âêé‰ªéÂ∞èÂà∞Â§ßpollÂá∫ÔºåËøõË°ådfs„ÄÇÂü∫Êú¨ÁöÑpriority + Êìç‰Ωú{} ÁöÑdfs„ÄÇÊ°ÜÊû∂Ë¶ÅÁÜüËÆ∞„ÄÇ startÁªôÂÆö‰ªé0Ôºå0ÂºÄÂßãÔºåÂΩìdsfËøáÂêéËÆ∞ÂæóÂ∞ÜstartÊõ¥Êñ∞‰∏∫Á¨¨‰∏Ä‰∏™treeÁöÑÂùêÊ†á:tree[0],tree[1].","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 53","slug":"leetcode53","date":"2019-11-07T05:34:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/11/07/leetcode53/","link":"","permalink":"WangHngLeee.github.io/2019/11/07/leetcode53/","excerpt":"‰∫öÈ∫ª VO Èù¢Áªè ÂáÜÂ§á 560. Subarray Sum Equals K two pointer sliding window + Êö¥ÂäõËß£ class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; if(nums == null || nums.length == 0)return 0; for(int i=0;i&lt;nums.length ;i++)&#123; sum=nums[i]; if(sum == k)count++; for(int j = i+1;j&lt;nums.length ; j++)&#123; sum+=num[j]; if(sum == k)count++; &#125; &#125; return count; &#125;&#125; Êö¥ÂäõËß£Ôºå‰∏§‰∏™ÊåáÈíàÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶o(nÊñπ)„ÄÇÁ©∫Èó¥Â§çÊùÇÂ∫¶o(1)","text":"‰∫öÈ∫ª VO Èù¢Áªè ÂáÜÂ§á 560. Subarray Sum Equals K two pointer sliding window + Êö¥ÂäõËß£ class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; if(nums == null || nums.length == 0)return 0; for(int i=0;i&lt;nums.length ;i++)&#123; sum=nums[i]; if(sum == k)count++; for(int j = i+1;j&lt;nums.length ; j++)&#123; sum+=num[j]; if(sum == k)count++; &#125; &#125; return count; &#125;&#125; Êö¥ÂäõËß£Ôºå‰∏§‰∏™ÊåáÈíàÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶o(nÊñπ)„ÄÇÁ©∫Èó¥Â§çÊùÇÂ∫¶o(1) Presum + HashMap class Solution &#123; public int subarraySum(int[] nums, int k) &#123; int sum = 0, count = 0; Map&lt;Integer,Integer&gt; presum = new HashMap&lt;&gt;(); presum.put(0,1); for(num : nums)&#123; sum+=num; if(presum.containsKey(sum-k))&#123; count+= presum.get(sum-k); &#125; presum.put(sum,presum.getOrDefault(sum,0)+1); &#125; return count; &#125;&#125; ÊÄùË∑Ø‰∏ªË¶ÅÊòØÈÄöËøá SUM[i, j] = SUM[0, j]-SUM[0, i - 1] ÂæóÊù•„ÄÇ Áõ∏ÂΩì‰∫é‰ªéÁ¨¨‰∏Ä‰ΩçÂà∞ÊúÄÂêé‰∏Ä‰ΩçÊâÄÊúâÁöÑsumÂ≠òÂÖ•map„ÄÇÂ¶ÇÊûúmapÂéÜÂè≤‰∏≠ÁöÑÊüê‰∏™sumÊ≠£Â•ΩÁ≠â‰∫éÂΩìÂâçÁöÑsum - kÔºåË°®Êòé‰πãÂâçsumÊà™Ê≠¢ÁöÑidxÂà∞ÂΩìÂâçÂà∞sumÊà™Ê≠¢idx‰∏≠Èó¥ÁöÑÂÖÉÁ¥†ÂíåÊ≠£Â•Ω‰∏∫k„ÄÇÊâÄ‰ª•countÂä†‰∏Ä„ÄÇ we know the key to solve this problem is SUM[i, j]. So if we know SUM[0, i - 1] and SUM[0, j], then we can easily get SUM[i, j]. To achieve this, we just need to go through the array, calculate the current sum and save number of all seen PreSum to a HashMap. Time complexity O(n), Space complexity O(n). sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmap-key --&gt; hashmap-key = sum - k","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 52","slug":"leetcode52","date":"2019-11-07T01:34:09.000Z","updated":"2020-02-03T01:16:22.110Z","comments":true,"path":"2019/11/06/leetcode52/","link":"","permalink":"WangHngLeee.github.io/2019/11/06/leetcode52/","excerpt":"Á¨¨‰∫åÈÅç 98. Validate Binary Search Tree stack Ëß£Ê≥ï class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return null Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); if(root !=null &amp;&amp; root.val &lt;= pre.val)return false; pre = root; root = root.right; &#125; return true; &#125;&#125;","text":"Á¨¨‰∫åÈÅç 98. Validate Binary Search Tree stack Ëß£Ê≥ï class Solution &#123; public boolean isValidBST(TreeNode root) &#123; if(root == null)return null Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode pre = null; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); if(root !=null &amp;&amp; root.val &lt;= pre.val)return false; pre = root; root = root.right; &#125; return true; &#125;&#125; Âà§Êñ≠BSTÊòØÂê¶ÂêàÁêÜÔºåÂà©Áî®stackÂÆûÁé∞in orderÁöÑÊìç‰Ωú„ÄÇÂ∑¶-Ê†π-Âè≥ÁöÑÈ°∫Â∫èÂ≠òÂÖ•stackÔºåÂà§Êñ≠preÂíårootÁöÑÂÄºÂ§ßÂ∞è„ÄÇÂ∑¶ÊîØÂ∞±ÊòØ‰∏ã-‰∏äÔºåpreÂú®root‰∏ãÈù¢ÔºõÂè≥ÊîØÊòØpreÂú®root‰∏äÈù¢„ÄÇ recursive Ëß£Ê≥ï (in-order-traverslÂÆûÁé∞ÔºåÂÖàÈÄíÂΩíleftÔºåÂÜçËÆøÈóÆrootÔºåÂÜçÈÄíÂΩíright) class solution&#123; private boolean valid = true; private TreeNode pre = null; public boolean isValidBST(TReeNode root)&#123; test(root); return valid; &#125; private void test(TreeNode root)&#123; if(root == null)return; test(root.left); if(pre!=null &amp;&amp; root.val &lt;= pre.val)&#123; valid = false; return; &#125; pre = root; test(root.right); &#125;&#125; 101. Symmetric Tree iterativeËß£Ê≥ï class solution&#123; public boolean symmetric(TreeNode root)&#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); if(root == null)return true; stack.push(root.left); stack.push(root.right); while(!stack.isEmpty())&#123; TreeNode tree1 = stack.pop(), tree2=stack.pop(); if(tree1 == null &amp;&amp; tree2 == null)continue; if(tree1 == null || tree2 == null || tree1.val !=tree2.val)return false; stack.push(tree1.left); stack.push(tree2.right); stack.push(tree1.right); stack.push(tree2.left); &#125; return true; &#125;&#125; iterative„ÄÇËÆ∞ÂæóÊäätree node ÂØπÁß∞Âú∞pushËøõstack„ÄÇ recursiveËß£Ê≥ï class solution&#123; public boolean isSymmetric(TreeNode root) &#123; return root == null || test(root.left,root.right); &#125; private boolean test(TreeNode node1, TreeNode node2)&#123; if(node1 == null || node2 == null)return node1 == node2; if(node1.val != node2.val)return false; return test(node1.left,node2.right) %% test(node1.right,node2.left); &#125;&#125; Ê≥®ÊÑèÊúÄÂêéÂêåÊó∂Ê£ÄÊü•ÂØπÁß∞„ÄÇ node1ÊàñËÄÖnode2Êúâ‰∏Ä‰∏™‰∏∫nullÊó∂Áõ¥Êé•ËøîÂõûnode1==node2Âç≥ÂèØ„ÄÇÁÆÄÊ¥Å„ÄÇ 94. Binary Tree Inorder Traversal Iterative Ëß£Ê≥ï class solution&#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; while(root!=null || !stack.isEmpty())&#123; while(root!=null)&#123; stack.push(root); root=root.left; &#125; root = stack.pop(); res.add(root); root=root.right; &#125; return res; &#125;&#125; in-order Â∞ÜËäÇÁÇπÂä†ÂÖ•res„ÄÇËÆ∞‰ΩèstackÊñπÊ≥ïÁöÑÊ°ÜÊû∂„ÄÇ 102. Binary Tree Level Order Traversal Iterative ÊñπÊ≥ï class solution&#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty())&#123; int size = queue.size(); List&lt;Integer&gt; templist= new ArrayList&lt;&gt;(); for(int i = 0 ; i &lt; size; i ++)&#123; TreeNode cur = queue.poll(); if(cur.left!=null)queue.add(cur.left); if(cur.right!=null)queue.add(cur.right); templist.add(cur.val); &#125; res.add(templist); &#125; return res; &#125;&#125; QueueËá™‰∏äËÄå‰∏ãÂ≠òËäÇÁÇπ„ÄÇsize‰∏∫ÂΩìÂâçËøô‰∏ÄË°åÁöÑÂÖÉÁ¥†‰∏™Êï∞ÔºåÈÅçÂéÜsizeÈÅçÔºåÂ∞ÜÊØè‰∏™ËäÇÁÇπÂ∑¶Âè≥Â≠©Â≠êÂä†ÂÖ•queueÂêéÔºåÂÜçÂ∞ÜÂÖ∂Êú¨Ë∫´Âä†ÂÖ•templist„ÄÇÈÅçÂéÜÁªìÊùüÂä†ÂÖ•res„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 51","slug":"leetcode51","date":"2019-11-06T19:34:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/06/leetcode51/","link":"","permalink":"WangHngLeee.github.io/2019/11/06/leetcode51/","excerpt":"Tree Problems 1104. Path In Zigzag Labelled Binary Tree class Solution &#123; public List&lt;Integer&gt; pathInZigZagTree(int label) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;()l int parent = label; res.addFirst(parent); while(parent!=1)&#123; int depth = (int)Math.log(parent)/Math.log(2); int remains = (int)Math.pow(2,depth+!)-parent-1; partne = (int)(Math.pow(2,depth) + reamins)/2; res.addFirst(parent); &#125; return res; &#125;&#125; Ëá™‰∏ãËÄå‰∏ä„ÄÇÂú®È°∫Â∫èÈ¢†ÂÄíÁöÑ‰∏ÄË°åÊó∂ÔºåÂÖàËÆ°ÁÆóÂá∫Ê∑±Â∫¶ÔºåÂÜçÁî±Ê∑±Â∫¶ËÆ°ÁÆóÂá∫ÂΩìÂâçlabelË∑ùÁ¶ªËØ•Ë°åÊúÄÂ§ßÂÄºÁöÑË∑ùÁ¶ªremainsÔºåÁÑ∂ÂêéÈÄöËøáÊ≠£Â∏∏È°∫Â∫èËÆ°ÁÆóÂá∫ÂØπÂ∫îÁöÑparent„ÄÇÂπ∂‰∏îaddFirstÂà∞res‰∏≠„ÄÇ","text":"Tree Problems 1104. Path In Zigzag Labelled Binary Tree class Solution &#123; public List&lt;Integer&gt; pathInZigZagTree(int label) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;()l int parent = label; res.addFirst(parent); while(parent!=1)&#123; int depth = (int)Math.log(parent)/Math.log(2); int remains = (int)Math.pow(2,depth+!)-parent-1; partne = (int)(Math.pow(2,depth) + reamins)/2; res.addFirst(parent); &#125; return res; &#125;&#125; Ëá™‰∏ãËÄå‰∏ä„ÄÇÂú®È°∫Â∫èÈ¢†ÂÄíÁöÑ‰∏ÄË°åÊó∂ÔºåÂÖàËÆ°ÁÆóÂá∫Ê∑±Â∫¶ÔºåÂÜçÁî±Ê∑±Â∫¶ËÆ°ÁÆóÂá∫ÂΩìÂâçlabelË∑ùÁ¶ªËØ•Ë°åÊúÄÂ§ßÂÄºÁöÑË∑ùÁ¶ªremainsÔºåÁÑ∂ÂêéÈÄöËøáÊ≠£Â∏∏È°∫Â∫èËÆ°ÁÆóÂá∫ÂØπÂ∫îÁöÑparent„ÄÇÂπ∂‰∏îaddFirstÂà∞res‰∏≠„ÄÇ 366. Find Leaves of Binary Tree class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); getheight(root,res); return res; &#125; private int getheight(TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)&#123; jf(root == null) return -1; int level = 1 + Math.max(getheight(root.left,res), getheight(root.right,res)); if(res.size() &lt; level +1)res.add(new ArrayList&lt;&gt;()); res.get(level).add(root); return level; &#125;&#125; recursive„ÄÇ ÂæóÂà∞ÊØè‰∏ÄÂ±ÇË∑ùÁ¶ªÂè∂ËäÇÁÇπÁöÑÊúÄÂ§ßË∑ùÁ¶ªlevelÔºåÂè∂ËäÇÁÇπlevel‰∏∫0ÔºåÂ≠òÂú®res[0]ÔºåËá™‰∏ãËÄå‰∏ärecursive„ÄÇÂ∞ÜÊØè‰∏™levelÁöÑËäÇÁÇπÂ≠òÂÖ•res„ÄÇ 897. Increasing Order Search Tree class Solution &#123; public TreeNode increasingBST(TreeNode root) &#123; return increase(root,null); &#125; public TreeNode increase(TreeNode root, TreeNode tail)&#123; if(root == null)return tail; TreeNode res = increase(root.left,root); root.left = null; root.right = increase(root.right,tail); return res; &#125;&#125; tailËÆ∞ÂΩïÊúÄÁªàÁªìÊûúÈáårootÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπ„ÄÇleftÂàÜÊîØ‰∏≠Ôºåroot.leftÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπÂ∞±ÊòØrootÁà∂ËäÇÁÇπ„ÄÇÂπ∂‰∏îÂ∞Üroot.left ËÆæ‰∏∫null„ÄÇÂè≥ÂàÜÊîØÂú®recursiveÊó∂ÔºåÂú®resËµãÂÄº‰∏≠ÔºåÂ∞ÜÂΩìÂâçrootÂΩì‰Ωú‰∏ã‰∏ÄËäÇÁÇπÂ≠òÂÖ•res„ÄÇ 1123. Lowest Common Ancestor of Deepest Leaves class Solution &#123; TreeNode lca; int deepest = 0; public TreeNode lcaDeepestLeaves(TreeNode root) &#123; deep(root,0); return lca; &#125; private int deep(TreeNode root, int depth)&#123; deepest = Math.max(deepest,depth); if(root == null)return depth; int left = deep(root.left,depth+1); int right = deep(root.right,depth+1); if(left == deepest &amp;&amp; right == deepest)&#123; lcn = root; &#125; return Math.max(left,right); &#125;&#125; Âè™Ë¶ÅÂΩìÊüê‰∏™rootÁöÑleft Âíå right Ê∑±Â∫¶ÈÉΩ‰∏∫deepestÊó∂ ÔºåËØ¥ÊòéËØ•‰ΩçÁΩÆÁöÑsubtreeÂØπÁß∞Ê∑±Â∫¶Áõ∏Âêå„ÄÇÈÇ£‰πàÁõ¥Êé•ËøîÂ∞ÜÂΩìÂâçÁöÑrootËµãÂÄºÁªôlcn„ÄÇ 1110. Delete Nodes And Return Forest class Solution &#123; public List&lt;TreeNode&gt; delNodes(TreeNode root, int[] to_delete) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;(); for(int i: to_delete)&#123; set.add(i); &#125; if(!set.contains(root))&#123; res.add(root); &#125; bfs(root,set,res); return res; &#125; private TreeNode dfs(TreeNode root, Set&lt;Integer&gt; set, List&lt;TreeNode&gt; res)&#123; if(root == null)return null; root.left = dfs(root.left,set,res); root.right = dfs(root.right,set, res); if(set.contains(root))&#123; if(root.left!-null)res.add(root.left); if(root.left!=null)res.add(root.right); return null; &#125; return root; &#125;&#125; dfs recursive„ÄÇÂ¶ÇÊûúÂΩìÂâçËäÇÁÇπÂú®deleteÂêçÂçïÈáåÔºåÁúãÂÆÉÂ∑¶Âè≥ËäÇÁÇπÊòØÂê¶‰∏∫Á©∫ÔºåÂ¶ÇÊûúÊúâ‰∏ç‰∏∫nullÁöÑÂ∞ÜÂÖ∂Â≠êËäÇÁÇπÂ≠òÂÖ•res„ÄÇÂ¶ÇÊûúÈÉΩ‰∏∫nullÂàôÂΩªÂ∫ïÂà†Èô§ËØ•ËäÇÁÇπÔºåËøîÂõûnull„ÄÇ Â¶ÇÊûú‰∏çÂê´ËØ•ËäÇÁÇπÔºåÂàôËøîÂõûËØ•ËäÇÁÇπ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 50","slug":"leetcode50","date":"2019-11-06T00:34:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/11/05/leetcode50/","link":"","permalink":"WangHngLeee.github.io/2019/11/05/leetcode50/","excerpt":"866. Prime Palindrome class solution&#123; public int primePalindrome(int N) &#123; if( 8 &lt;= N &amp;&amp; N &lt;= 11)return 11; for(int x = 1; x &lt; 100000; x++)&#123; String s = Integer.toString(x); String news = new StringBuilder(s).reverse().toString(); int y = Integer.parseInt(s + news.substring(1)); if( y &gt;=N &amp;&amp; isPrime(y))return y; &#125; return -1; &#125; private boolean isPrime(int y)&#123; if(y &lt; 2 || y%2 == 0)return y==2; for(int i =3; i*i&lt;=y;i+=2)&#123; if(y%i == 0)return false; &#125; return true; &#125;&#125; ÊÄùË∑ØÂæàÁÆÄÂçïÔºåÂè™ÈúÄË¶ÅËÄÉËôëÂ•áÊï∞‰ΩçÁöÑstringÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇÊ≥®ÊÑèÊûÑÂª∫palidromÁöÑÊñπÊ≥ï„ÄÇreverse‰πãÂêéÂèñÁ¨¨‰∫å‰∏™‰ΩçÁΩÆÂà∞ÊúÄÂêéÔºåÂä†Âà∞s‰∏≠„ÄÇ ËøòÊúâË¶ÅÊ≥®ÊÑèÁ¥†Êï∞Âà∞Âà§Êñ≠„ÄÇÊúÄÂ•ΩÂÖ®ËÆ∞‰Ωè„ÄÇ","text":"866. Prime Palindrome class solution&#123; public int primePalindrome(int N) &#123; if( 8 &lt;= N &amp;&amp; N &lt;= 11)return 11; for(int x = 1; x &lt; 100000; x++)&#123; String s = Integer.toString(x); String news = new StringBuilder(s).reverse().toString(); int y = Integer.parseInt(s + news.substring(1)); if( y &gt;=N &amp;&amp; isPrime(y))return y; &#125; return -1; &#125; private boolean isPrime(int y)&#123; if(y &lt; 2 || y%2 == 0)return y==2; for(int i =3; i*i&lt;=y;i+=2)&#123; if(y%i == 0)return false; &#125; return true; &#125;&#125; ÊÄùË∑ØÂæàÁÆÄÂçïÔºåÂè™ÈúÄË¶ÅËÄÉËôëÂ•áÊï∞‰ΩçÁöÑstringÂ∞±ÂèØ‰ª•‰∫Ü„ÄÇÊ≥®ÊÑèÊûÑÂª∫palidromÁöÑÊñπÊ≥ï„ÄÇreverse‰πãÂêéÂèñÁ¨¨‰∫å‰∏™‰ΩçÁΩÆÂà∞ÊúÄÂêéÔºåÂä†Âà∞s‰∏≠„ÄÇ ËøòÊúâË¶ÅÊ≥®ÊÑèÁ¥†Êï∞Âà∞Âà§Êñ≠„ÄÇÊúÄÂ•ΩÂÖ®ËÆ∞‰Ωè„ÄÇ 456. 132 Pattern class solution &#123; public boolean find132pattern(int[] nums) &#123; int two = Integer.MIN_VALUE; int index = nums.length; for (int i=nums.length-1; i&gt;=0; i--) &#123; if (nums[i] &lt; two) return true; while (index &lt; nums.length &amp;&amp; nums[i] &gt; nums[index]) &#123; two = nums[index++]; &#125; index--; nums[index] = nums[i]; &#125; return false; &#125;&#125; Áî®twoÊù•Â≠òÂ§ßÂ∞è‰∏∫Á¨¨‰∫åÂ§ßÁöÑÊï∞Â≠óÔºå‰ΩÜÊòØ‰ΩçÁΩÆÂ∫îËØ•ÊòØÂú®132‰∏≠ÊúÄÂêéÁöÑ‰ΩçÁΩÆ„ÄÇ 909. Snakes and Ladders È¢òÁõÆ On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following: You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N. (This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.) If S has a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S. solution class solution&#123; private int n; public snakesandladders(int[][]board)&#123; n = board.length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); int steps = 0; boolean[] seen = new boolean[n*n+1]; queue.offer(1); seen[1] = true; while(!queue.isEmpty())&#123; int size = queue.size(); for(int i = 0; i &lt; n;i++)&#123; int cur = queue.poll(); for(int k = 0;k &lt;=6;k++)&#123; int next = cur + k; int [] pos = NumToPos(next); if(board[pos[0]][pos[1]] &gt; 0)&#123; next = board[pos[0]][pos[1]]; &#125; if(next == n*n)return steps; if(!seen[next])&#123; seen[next] = true; queue.offer(next); &#125; &#125; &#125; steps++; &#125; return -1; &#125; private int NumToPos(int target)&#123; int row = (target-1)/n, col = (target-1)%n; int x = n-row-1; int y = row%2 == 0? col:n-col-1; return new int[]&#123;x,y&#125;; &#125;&#125; ÊÄùË∑Ø ‰∏çÁî®ÂçïÁã¨Âª∫‰∏Ä‰∏™‰∏Ä‰ΩçÊï∞ÁªÑÔºåÁõ¥Êé•ÁßÅÊúâ‰∏Ä‰∏™helperÂáΩÊï∞ÂÆûÁé∞numÂíåpostionÁöÑËΩ¨Êç¢„ÄÇ ËøôÁßçÂõæË∑ØÂæÑÁöÑÈóÆÈ¢òÂü∫Êú¨ÈÉΩÊòØqueue+Êìç‰ΩúÊñπÂêë/Ë∑ùÁ¶ªÈõÜÂêàÔºå‰πãÂâçÁöÑÈ¢òÈáåÊñπÂêëÈõÜÂêàÊ≥®ÊÑènew int[]{}ÁöÑÂàùÂßãÂåñÔºõËøôÈÅìÈ¢òÁõ¥Êé•forÈÅçÂéÜ1-6Ê≠•„ÄÇ ËøôÁßçÈ¢òË¶ÅÂä†‰∏äseenÂà§Êñ≠ÊòØÂê¶ËÆøÈóÆËøáËØ•ÁÇπÔºåÊ†πÊçÆÂΩìÂâçÁÇπÊòæÁ§∫Êï∞Â≠óÂ§ßÂ∞èÔºàÊ≠§È¢òÂè™ÊúâÁõÆÁöÑ‰ΩçÁΩÆÁöÑÊï∞Â≠óÂíå-1‰∏§ÁßçÔºâÔºåÂ∞ÜÁ¨¶ÂêàÁöÑÂÜçÂ≠òÂÖ•queue„ÄÇÊõ¥Êñ∞seen‰∏∫true„ÄÇ ÊÄùË∑ØÂ§ß‰Ωì‰∏∫num -&gt; pos -&gt; num, ÈÄöËøáNumToPosÂáΩÊï∞ÂÆûÁé∞numÁöÑË∑≥ËΩ¨„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 49","slug":"leetcode49","date":"2019-11-05T02:34:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/11/04/leetcode49/","link":"","permalink":"WangHngLeee.github.io/2019/11/04/leetcode49/","excerpt":"994. Rotting Oranges È¢òÂπ≤ In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.","text":"994. Rotting Oranges È¢òÂπ≤ In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead. ÊÄùË∑Ø ËøôÈÅìÈ¢òÂíåÂçöÂÆ¢leetcode48‰∏≠maxmium minum path scoreÊúâÁõ∏‰ººÁöÑÊÄùË∑Ø„ÄÇ BFSÊâ´ÊèèÔºåÂè™ÂØπgrid‰∏≠‰∏∫1ÁöÑÁÇπËøõË°åÊìç‰Ωú„ÄÇÊØèÊ¨°Êìç‰ΩúÂÆå‰∏Ä‰∏™ÁÇπ‰πãÂêéÂ∞Üminute+1„ÄÇ Âà©Áî®queueÊù•Â≠òËäÇÁÇπÂùêÊ†á„ÄÇÁî±‰∫éÊ≤°Êúâmin maxÈôêÂà∂ÔºåÊâÄ‰ª•Êàë‰ª¨Áõ¥Êé•Â≠òÂÖ•Â∞±ÂèØ‰ª•„ÄÇ ÂÖàÈÅçÂéÜ‰∏ÄËæπgridÔºåÂ≠ò‰∏ãfreshÔºà1ÔºâÁöÑ‰∏™Êï∞„ÄÇÁî±‰∫éÊòØ‰ªéÂùèÊéâÁöÑÂºÄÂßãÊâ©Êï£ÔºåÊâÄ‰ª•ÂÜçÂ∞ÜÂùèÊéâÁöÑÊ©ôÂ≠êÂùêÊ†áÂ≠òÂÖ•queue„ÄÇ ÂØπqueue pollÂá∫ÂØπÁÇπËøõË°åbfsÔºåÂç≥ÂùèÊéâ‰ΩçÁΩÆ Âª∫Á´ãÊìç‰ΩúÊñπ‰ΩçÁöÑÈõÜÂêàÔºåÊìç‰ΩúÊòØÂè™ÈúÄË¶ÅÈÅçÂéÜËØ•ÈõÜÂêàÂç≥ÂèØ„ÄÇ ÂØπÊõ¥Êñ∞‰ΩçÁΩÆÂêéÂÄº‰∏∫1ÁöÑÂùêÊ†á(newx,newy)ËøõË°åÊìç‰ΩúÔºåÂ∞ÜÂÖ∂Êîπ‰∏∫2ÔºåÂ≠òÂÖ•queueÔºåfreshÁöÑÊï∞Èáè-1„ÄÇ ÊúÄÂêéÂà§Êñ≠freshÁöÑ‰∏™Êï∞ÊòØÂê¶‰∏∫Èõ∂„ÄÇÂ∫îËØ•ÊòØ0„ÄÇÂ¶ÇÊûúÊòØ0ÂàôËøîÂõûminuteÔºõÂ¶ÇÊûú‰∏çÊòØÁöÑËØùÂ∞±ËøîÂõû-1. class Solution &#123; public int orangesRotting(int[][] grid) &#123; if(grid == null || grid.length == 0)return 0; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); int rows = grid.length; int cols = grid[0].length; int freshnums = 0; for(int i = 0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(grid[i][j] == 1)freshnums++; else if(grid[i][j] == 2)&#123; queue.offer(new int[]&#123;i,j&#125;); &#125; &#125; &#125; if(freshnums == 0)return 0; int minutes = 0; int[][] moves = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;; while(!queue.isEmpty())&#123; if(freshnums == 0)return minutes; minutes++; int size = queue.size(); for(int i=0;i&lt;size;i++)&#123; int[] point = queue.poll(); for(int[] move : moves)&#123; int newx = point[0] + move[0]; int newy = point[1] + move[1]; if(newx &lt; 0 || newy &lt; 0 || newx &gt;= rows || newy &gt;= cols || grid[newx][newy] == 0 || grid[newx][newy] == 2)continue; grid[newx][newy] = 2; queue.offer(new int[]&#123;newx,newy&#125;); freshnums--; &#125; &#125; &#125; return freshnums == 0 ? minutes: -1; &#125;&#125; 545. Boundary of Binary Tree class Solution &#123; List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;(1000); public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123; if(root == null) return nodes; nodes.add(root.val); leftBoundary(root.left); leaves(root.left); leaves(root.right); rightBoundary(root.right); return nodes; &#125; public void leftBoundary(TreeNode root) &#123; if(root == null || (root.left == null &amp;&amp; root.right == null)) return; nodes.add(root.val); if(root.left == null) leftBoundary(root.right); else leftBoundary(root.left); &#125; public void rightBoundary(TreeNode root) &#123; if(root == null || (root.right == null &amp;&amp; root.left == null)) return; if(root.right == null)rightBoundary(root.left); else rightBoundary(root.right); nodes.add(root.val); // add after child visit(reverse) &#125; public void leaves(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) &#123; nodes.add(root.val); return; &#125; leaves(root.left); leaves(root.right); &#125;&#125; ÊåâÁÖßÂ∑¶ËæπÁïåÔºåÂ∑¶Â≠êËäÇÁÇπÔºåÂè≥Â≠êËäÇÁÇπÔºåÂè≥ËæπÁïåÂØπÈ°∫Â∫è„ÄÇ leavesË¶Å‰∏ÄËá¥Êâ´ÊèèÂà∞ÊúÄÂêéÁöÑËäÇÁÇπÂÜçËøîÂõû„ÄÇrightboundary‰∏≠ËÆ∞ÂæóË¶ÅÂú®ËÆøÈóÆÂ≠êËäÇÁÇπ‰πãÂêéÂÜçÂ∞ÜrootÂÄºÂ≠òÂÖ•node„ÄÇ Âõ†‰∏∫Â∑¶ËæπÁïåÊòØËá™‰∏äËÄå‰∏ãÔºåËÄåÂè≥ËæπÁïåÊòØËá™‰∏ãËÄå‰∏äÂ≠òÂÖ•node„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 48","slug":"leetcode48","date":"2019-11-04T18:34:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/11/04/leetcode48/","link":"","permalink":"WangHngLeee.github.io/2019/11/04/leetcode48/","excerpt":"209. Minimum Size Subarray Sum class solution&#123; public minsizesub(int[]nums,int s)&#123; int start = 0,sum=0,min = Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-from+1); sum-=nums[start]; start++; &#125; &#125; return (min == Integer.MAX_VALUE) ? 0:min; &#125;&#125; two pointersÊñπÊ≥ï„ÄÇÊ≠£Â∫èÊâ´ÊèèÁ¥ØÂä†ÔºåÂΩìÂ§ß‰∫ésÁöÑÊó∂ÂÄôÔºåÂáèÂéªnums[from],Â≠ò‰ΩèÂΩìÂâçminÁöÑÂÄºÔºåÁõ¥Âà∞ÂΩìÂâçfromÂà∞iÂÜÖÁöÑÂíåÂ∞è‰∫és‰∏∫Ê≠¢ÔºåiÁªßÁª≠ÂêëÂêéÈÅçÂéÜ„ÄÇ orner case Ë¶ÅÂà§Êñ≠minÊòØÂê¶ÂèòÂåñÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôËøîÂõû0„ÄÇ","text":"209. Minimum Size Subarray Sum class solution&#123; public minsizesub(int[]nums,int s)&#123; int start = 0,sum=0,min = Integer.MAX_VALUE; for(int i=0;i&lt;nums.length;i++)&#123; sum+=nums[i]; while(sum &gt;= s)&#123; min = Math.min(min,i-from+1); sum-=nums[start]; start++; &#125; &#125; return (min == Integer.MAX_VALUE) ? 0:min; &#125;&#125; two pointersÊñπÊ≥ï„ÄÇÊ≠£Â∫èÊâ´ÊèèÁ¥ØÂä†ÔºåÂΩìÂ§ß‰∫ésÁöÑÊó∂ÂÄôÔºåÂáèÂéªnums[from],Â≠ò‰ΩèÂΩìÂâçminÁöÑÂÄºÔºåÁõ¥Âà∞ÂΩìÂâçfromÂà∞iÂÜÖÁöÑÂíåÂ∞è‰∫és‰∏∫Ê≠¢ÔºåiÁªßÁª≠ÂêëÂêéÈÅçÂéÜ„ÄÇ orner case Ë¶ÅÂà§Êñ≠minÊòØÂê¶ÂèòÂåñÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôËøîÂõû0„ÄÇ 1004. Max Consecutive Ones III class solution&#123; pubic maxconsecutive(int[] A,int K)&#123; int start=0,res=0,zeronums=0; for(int end =0;end&lt;A.length;end++)&#123; if(A[end] == 0)zeronums++; while(zeronums&gt;K)&#123; if(A[start] == 0)zeronums--; start++; &#125; res = Math.max(res,end-start+1); &#125; return res; &#125;&#125; sliding windowÊñπÊ≥ï„ÄÇÊ∞∏Ëøú‰øùËØÅwindowÈáå0ÁöÑ‰∏™Êï∞‰∏∫K‰∏™ÔºåÂ¶ÇÊûúË∂ÖËøáÂ∞±Ë¶ÅÂÜçÁî®startÂºÄÂßãÈÅçÂéÜÔºå‰øùËØÅ0ÁöÑ‰∏™Êï∞ÂßãÁªà‰∏∫KÔºåÁÑ∂ÂêéÂ∞ÜÊúÄÈïøÁöÑsubstringÂ≠ò‰∏∫res„ÄÇ ÂàáËÆ∞‰∏çË¶ÅË¢´endÂíåstartÁöÑÂ≠óÈù¢ÊÑèÊÄùËø∑ÊÉë„ÄÇËøôÈÅìÈ¢òÁöÑÂÖ≥ÈîÆÂ∞±ÊòØ‰øùÊåÅwindowÈáå0ÁöÑ‰∏™Êï∞‰∏∫K„ÄÇ 1099. Two Sum Less Than K class solution&#123; public twosumlessthanK(int[] A, int K)&#123; Arrays.sort(A); int i=0,j=0,max=-1; while(i&lt;j)&#123; int sum = A[i]+A[j]; if(sum &lt; K)&#123; max = Math.max(max,sum); i++; &#125;else&#123; j--; &#125; &#125; return max; &#125;&#125; two pointers„ÄÇ ÂÖàsortÔºåÁÑ∂Âêé‰∏§ÈÅçÂêÑËá™Âêë‰∏≠Èó¥Êâ´ÊèèÔºåÂ§ß‰∫ékÂ∞±Âè≥ËæπÁº©Â∞è‰∏Ä‰ΩçÔºåÂ∞è‰∫éKÂ∞±Â∑¶ËæπÊâ©Â§ß‰∏Ä‰ΩçÔºåÂè™ÊúâÂ∞è‰∫éKÊó∂Êõ¥Êñ∞maxÔºåÂ§ß‰∫éÁöÑÊó∂ÂÄôÁõ¥Êé•j‚ÄìÂ∞±ÂèØ‰ª•„ÄÇ 572. Subtree of Another Tree class solution&#123; public boolean isSubtree(TreeNode s, TreeNode t)&#123; if(s == null)return false; return isSame(s,t)|| isSubtree(s.left,t) || isSubtree(s.right,t); &#125; private boolean isSame(TreeNode s, TreeNode t)&#123; if(s == null &amp;&amp; t==null)return true; if(s == null || t == null) return false; if(s.val!= t.val)return false; return isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right); &#125;&#125; treeÁöÑpre-traversal„ÄÇÂÖàÂà§Êñ≠ÂΩìÂâçsÂíåtÊòØÂê¶isSame,ÊàñËÄÖs.left/s.rightÂíåtÊòØÂê¶‰∏∫isSubTree„ÄÇ isSameÈáå‰∏§ÁßçÊÉÖÂÜµ‰∏∫trueÔºö valÂùáÁõ∏Á≠â ÈÉΩ‰∏∫null ÂêÑËá™Â∑¶Âè≥Â≠êÊ†ë‰πü‰∏∫issame„ÄÇ 1102. Path With Maximum Minimum Value class Solution &#123; int M,N; public int maximumMinimumPath(int[][] A) &#123; M = A.length; N = A[0].length; int[] dx = new int[]&#123;1,-1,0,0&#125;; int[] dy = new int[]&#123;0,0,1,-1&#125;; boolean[][] seen = new boolean[M][N]; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; b[0] - a[0]);//‰ª•ÂÄº‰∏∫ÂèÇËÄÉËøõË°åcomparre queue.offer(new int[]&#123;A[0][0],0,0&#125;); seen[0][0] = true; while(!queue.isEmpty())&#123; int[] cur = queue.poll(); if(cur[1] == M-1 &amp;&amp; cur[2] == N-1)&#123; return cur[0]; &#125; for(int i=0;i&lt;4;i++)&#123; int nx = cur[1] + dx[i]; int ny = cur[2] + dy[i]; if(nx &gt;= 0 &amp;&amp; nx &lt;M &amp;&amp; ny &gt;=0 &amp;&amp; ny &lt; N &amp;&amp; !seen[nx][ny])&#123; seen[nx][ny] = true; queue.offer(new int[]&#123;Math.min(cur[0],A[nx][ny]),nx,ny&#125;); &#125; &#125; &#125; return -1; &#125;&#125; PriorityQueue‰ª•Â§ßÊ†πÂ†ÜÁöÑÂΩ¢ÂºèÂ≠ò‰ΩèÂêÑ‰∏™‰ΩçÁΩÆÁöÑÂÄº„ÄÇ Â∞ÜÊØè‰∏™‰ΩçÁΩÆ‰ª• {ÂÄºÔºåxÂùêÊ†áÔºåyÂùêÊ†á} ÁöÑÂΩ¢ÂºèÂ≠òÂÖ•priority„ÄÇ‰ª•ÂÄº‰∏∫ÂèÇËÄÉËøõË°åËá™ÂÆö‰πâcompare„ÄÇ Âú®nx nyÁßªÂä®ÁöÑÈÉ®ÂàÜÔºåÂ∞ÜÊñ∞‰ΩçÁΩÆÁöÑÂÄºÂíå‰πãÂâçcurÁöÑÂÄºËøõË°åÊØîËæÉÔºå‰æùÊ¨°Â≠òÂÖ•priorityqueueÔºåÊúÄÊ†πÈÉ®ÁöÑÂàôÊòØËøô‰∫õÊúÄÂ∞èÂÄº‰∏≠ÊúÄÂ§ßÁöÑÂÄº„ÄÇ ‰ª•‰æõ‰∏ãÊ¨°Âæ™ÁéØÊó∂poll‰ΩøÁî®„ÄÇpollÂá∫Êù•ÁöÑÂùá‰∏∫‰∏ä‰∏ÄÊ¨°Êâ´Êèè‰∏≠ÊúÄÂ∞èÂÄº‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇÂú®Êõ¥Êñ∞‰ΩçÁΩÆÂâçË¶ÅÂà§Êñ≠ÊòØÂê¶‰∏∫ÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÂ¶ÇÊûúÊòØÁõ¥Êé•ËøîÂõûcur[0]„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 47","slug":"leetcode47","date":"2019-11-03T19:34:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/11/03/leetcode47/","link":"","permalink":"WangHngLeee.github.io/2019/11/03/leetcode47/","excerpt":"295. Find Median from Data Stream class MedianFinder &#123; PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()) max; PriorityQueue&lt;Integer&gt;() min; public MedianFinder()&#123; max = PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()); min = PriorityQueue&lt;Integer&gt;(); &#125; public void addnum(int num)&#123; min.offer(num); max.offer(min.poll()); if(min.size() &lt; max.size())&#123; min.offer(max.poll()); &#125; &#125; public double findmedian()&#123; if(min.size() == max.size())&#123; return ((min.peek() + max.peek()) / 2.0); &#125;else&#123; return min.peek(); &#125; &#125;&#125; ‰∏§‰∏™heapÔºå‰∏Ä‰∏™Â≠òÂ∞èÁöÑ‰∏ÄÂçäÔºå‰∏Ä‰∏™Â≠òÂ§ßÁöÑ‰∏ÄÂçä„ÄÇfindÁöÑÊó∂ÂÄôÂà§Êñ≠‰∏§ÈÉ®ÂàÜÈïøÂ∫¶ÊòØÂê¶Áõ∏Á≠â„ÄÇ max‰∏≠ËæÉÂ∞èÁöÑÈÉ®ÂàÜÈù†ÂêéÔºå‰ºòÂÖàpeekÔºõminÊ≠£Â∏∏Â§ßpqÔºåÂ§ßÊï∞Èù†Âêé‰ºòÂÖàpeek„ÄÇ","text":"295. Find Median from Data Stream class MedianFinder &#123; PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()) max; PriorityQueue&lt;Integer&gt;() min; public MedianFinder()&#123; max = PriorityQueue&lt;Integer&gt;(Comparator.reverseOrder()); min = PriorityQueue&lt;Integer&gt;(); &#125; public void addnum(int num)&#123; min.offer(num); max.offer(min.poll()); if(min.size() &lt; max.size())&#123; min.offer(max.poll()); &#125; &#125; public double findmedian()&#123; if(min.size() == max.size())&#123; return ((min.peek() + max.peek()) / 2.0); &#125;else&#123; return min.peek(); &#125; &#125;&#125; ‰∏§‰∏™heapÔºå‰∏Ä‰∏™Â≠òÂ∞èÁöÑ‰∏ÄÂçäÔºå‰∏Ä‰∏™Â≠òÂ§ßÁöÑ‰∏ÄÂçä„ÄÇfindÁöÑÊó∂ÂÄôÂà§Êñ≠‰∏§ÈÉ®ÂàÜÈïøÂ∫¶ÊòØÂê¶Áõ∏Á≠â„ÄÇ max‰∏≠ËæÉÂ∞èÁöÑÈÉ®ÂàÜÈù†ÂêéÔºå‰ºòÂÖàpeekÔºõminÊ≠£Â∏∏Â§ßpqÔºåÂ§ßÊï∞Èù†Âêé‰ºòÂÖàpeek„ÄÇ 561. Array Partition I class solution&#123; public arraypart(int[] nums)&#123; int res = 0; Arrays.sort(nums); for(int i =0; i &lt; nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125; ÊÄùË∑ØÂæàÁÆÄÂçïÔºåsort‰πãÂêéÈöî2‰ΩçÁõ¥Êé•Áõ∏Âä†Â∞±ÊòØÊúÄÁªàÁ≠îÊ°à„ÄÇÂÖ∑‰ΩìÁÆóÊ≥ïËß£ÊûêÂú®ËøôÈáåleetcode 561 167. Two Sum II - Input array is sorted class solution&#123; public twosumSorted(int[] numbers, int target)&#123; int[] idx = new int[2]; int left = 0, right = numbers.length-1; if(numbers == null || numbers.length &lt;2)return idx; while(left &lt; right)&#123; int temp = numbers[left] + numbers[right]; if(temp == target)&#123; idx[0] = left + 1; idx[1] = right + 1; break; &#125;else if(temp &gt; target)&#123; right--; &#125;else&#123; left++; &#125; &#125; return idx; &#125;&#125; ÂèòÁßçtwo sumÔºå ËæìÂÖ•ÁöÑnumbersÂ∑≤ÁªèsortedÔºåÂà©Áî®ÂèåÊåáÈíàÂâçÂêéÊâ´ÊèèÔºåÂ§ß‰∫étargetÂ∞±Âè≥ËæπÊî∂Áº©ÔºåÂ∞è‰∫étargetÂ∞±Â∑¶ËæπÊâ©Â§ß„ÄÇ 27. Remove Element class solution&#123; public remove(int[] nums, int target)&#123; int m = 0; for(int i = 0 ; i &lt; nums.length;i++)&#123; if(nums[i]!=target)&#123; nums[m] = nums[i]; m++; &#125; &#125; return m; &#125;&#125; Áõ¥Êé•Âæ™ÁéØÊâ´ÊèèÔºåÂπ∂Áî®m-indexÂ∞ÜÊñ∞ÁöÑÂÄºÂ≠òÂ¶ÇÊï∞ÁªÑÔºåÊØèÊ¨°Âæ™ÁéØÊúÄÂêéÂ∞Üm++.m++. 472. Concatenated Words dpËß£Ê≥ï class solution&#123; public concatenatedword(String[] words)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); Set&lt;String&gt; prewords = new HashSet&lt;&gt;(); Arrays.sort(words, new Comparator&lt;String&gt;()&#123; @Override public int compare(String s1, String s2)&#123; return s1.length()-s2.length(); &#125; &#125;) for(int i = 0 ; i &lt; words.length;i++)&#123; if(form(words[i],prewords))&#123; res.add(words[i]); &#125; prewords.add(words[i]); &#125; return res; &#125; private static boolean form(String word, Set&lt;String&gt; dict)&#123; if(dict.isEmpty())return false; boolean[] dp = new boolean[word.length()+1]; dp[0] = true; for(int i = 1; i &lt; word.length();i++)&#123; for(int j = 0;j&lt;i;j++)&#123; if(!dp[j])continue; if(dict.contains(word.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[word.length()] &#125;&#125; ÂÖàÁî®comparatorÂ∞Üword sort„ÄÇ dpÂ≠ò‰ΩèÂΩìÂâçÂ≠óÊØç‰πãÂâçÁöÑwordÊòØÂê¶Â∑≤ÁªèÂú®dist‰∏≠Â≠òÂú®„ÄÇÂ¶ÇÊûúÊúâÂàôËØ•ÈïøwordÂèØ‰ª•Áî®‰πãÂâçÁöÑÁü≠wordÊûÑÊàê„ÄÇ dfs Ëß£Ê≥ï class solution&#123; public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123; Arrays.sort(words,(a,b)-&gt; a.length()-b.length()); Set&lt;String&gt; set = new HashSet&lt;&gt;(); List&lt;String&gt; res = new ArraysList&lt;&gt;(); for(int i = 0 ; i &lt; words.length;i++)&#123; if(words[i].length != 0 &amp;&amp; valid(set,words[i]))&#123; res.add(words[i]); &#125; set.add(words[i]); &#125; return res; &#125; private boolean valid(Set&lt;String&gt; set, String word)&#123; if(word == null || word.length() == 0)return true; if(set.contains(word))return true; int len = word.length(); for(int i = 0; i &lt; len;i++)&#123; String temp = word.substring(0,i); if(set.contains(temp))&#123; if(valid(set,word.substring(i)))&#123; set.add(word); return true; &#125; &#125; &#125; return false; &#125;&#125; dfsÊÄùË∑Ø„ÄÇpart1ÂíådpÊÄùË∑Ø‰∏ÄËá¥„ÄÇprivateÊñπÊ≥ïÈáåÊ≥®ÊÑèdfs‰πãÂêéË¶ÅÂ∞ÜÁõÆÂâçÁöÑwordÂ≠òÂÖ•set„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 46","slug":"leetcode46","date":"2019-10-27T22:49:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/27/leetcode46/","link":"","permalink":"WangHngLeee.github.io/2019/10/27/leetcode46/","excerpt":"123. Best Time to Buy and Sell Stock III class solution&#123; public int maxprofit(int[] prices)&#123; int onebuy = 0; int twobuy = 0; int onebuyonesell = Integer.MAX_VALUE; int twobuytwosell = Integer.MAX_VALUE; for(int i = 0; i &lt;prices.length;i++)&#123; int p = price[i]; onebuy = Math.min(p,onebuy); onebuyonesell = Math.max(p-onebuy,onebuyonesell); twobuy = Math.min(twobuy, p - onebuyonesell); twobuytwosell = Math.max(twobuytwosell, p - twobuy); &#125; return twobuytwusell; &#125;&#125; use onebuy and twobuy to store the min cost, and onebuyonesell &amp; twobuytwosell are used to store the max profit.","text":"123. Best Time to Buy and Sell Stock III class solution&#123; public int maxprofit(int[] prices)&#123; int onebuy = 0; int twobuy = 0; int onebuyonesell = Integer.MAX_VALUE; int twobuytwosell = Integer.MAX_VALUE; for(int i = 0; i &lt;prices.length;i++)&#123; int p = price[i]; onebuy = Math.min(p,onebuy); onebuyonesell = Math.max(p-onebuy,onebuyonesell); twobuy = Math.min(twobuy, p - onebuyonesell); twobuytwosell = Math.max(twobuytwosell, p - twobuy); &#125; return twobuytwusell; &#125;&#125; use onebuy and twobuy to store the min cost, and onebuyonesell &amp; twobuytwosell are used to store the max profit. 309. Best Time to Buy and Sell Stock with Cooldown class solitoin&#123; public int maxprofit(int[] prices)&#123; int sell = 0,presell = 0, buy = Integer.MIN_VALUE,prebuy; for(int price: prices)&#123; prebuy = buy; buy = Math.max(presell - price, prebuy); presell = sell; sell = Math.max(prebuy + price, presell); &#125; return sell; &#125;&#125; hard one. buy, sell are both used to store the max profit of the action queue which is ended with ‚Äòbuy‚Äô or ‚Äòsell‚Äô. When it is ended with buy, we compare the prebuy and presell - price(buying action cause profit to decrease, so minus the price) to choose the larger one. When it is ended with sell, we compare the presell and prebuy + price. Hint: we can not have two same actions like ‚Äòbuy‚Äô ‚Äòbuy‚Äô or ‚Äòsell‚Äô‚Äòsell‚Äô. So in the comparision, we use different params instead of both sell or both buy.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 45","slug":"leetcode45","date":"2019-10-20T19:49:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/20/leetcode45/","link":"","permalink":"WangHngLeee.github.io/2019/10/20/leetcode45/","excerpt":"241. Different Ways to Add Parentheses class solution&#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length;i++)&#123; char c = input.charAt(i); if(c == '+' || c == '-' || c == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; p1 = map.getOrDefault(p1,diffWaysToCompute(part1)); List&lt;Integer&gt; p2 = map.getOrDefault(p2,diffWaysToCompute(part2)); for(Integer v1 : p1)&#123; for(Integer v2 : p2)&#123; int r = 0; switch (c) &#123; case('+'): r = p1+p2; break; case('-'): r = p1 - p2; break; case('*'): r = p1*p2; break; &#125; res.add(r); &#125; &#125; &#125; &#125; if(res.size() == 0)&#123; res.add(Integer.valueOf(input)); &#125; map.put(input,res); &#125;&#125; Áî®mapÂ≠ò‰ΩèstringÂØπÂ∫îÁöÑÊâÄÊúâÁªìÊûúÂíåÔºåÂáèÂ∞ëÊó∂Èó¥„ÄÇÊ†πÊçÆÁ¨¶Âè∑Âà§Êñ≠ÂΩìÂâçËøêÁÆóÊñπÊ≥ïÔºåÊúÄÂêéËÆ∞ÂæóÂ∞ÜresÂíåÂΩìÂâçÁöÑinputÂ≠òÂÖ•map„ÄÇ","text":"241. Different Ways to Add Parentheses class solution&#123; Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; diffWaysToCompute(String input)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;input.length;i++)&#123; char c = input.charAt(i); if(c == '+' || c == '-' || c == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; p1 = map.getOrDefault(p1,diffWaysToCompute(part1)); List&lt;Integer&gt; p2 = map.getOrDefault(p2,diffWaysToCompute(part2)); for(Integer v1 : p1)&#123; for(Integer v2 : p2)&#123; int r = 0; switch (c) &#123; case('+'): r = p1+p2; break; case('-'): r = p1 - p2; break; case('*'): r = p1*p2; break; &#125; res.add(r); &#125; &#125; &#125; &#125; if(res.size() == 0)&#123; res.add(Integer.valueOf(input)); &#125; map.put(input,res); &#125;&#125; Áî®mapÂ≠ò‰ΩèstringÂØπÂ∫îÁöÑÊâÄÊúâÁªìÊûúÂíåÔºåÂáèÂ∞ëÊó∂Èó¥„ÄÇÊ†πÊçÆÁ¨¶Âè∑Âà§Êñ≠ÂΩìÂâçËøêÁÆóÊñπÊ≥ïÔºåÊúÄÂêéËÆ∞ÂæóÂ∞ÜresÂíåÂΩìÂâçÁöÑinputÂ≠òÂÖ•map„ÄÇ 282. Expression Add Operators class solution&#123; public List&lt;String&gt; addOperators(String num, int target) &#123; StringBuilder sb = new StringBuilder(); List&lt;String&gt; res = new ArrayList&lt;&gt;(); find(res,sb,num,0,target,0,0); return res; &#125; public void find(List&lt;Integer&gt; res , StringBuilder sb, String num, int pos, int target, int prev, int after)&#123; if(pos == num.length() )&#123; if(target == prev)&#123; res.add(sb.toString()); return; &#125; &#125; for(int i = 0; i &lt; num.length(); i++)&#123; if(num.charAt(pos) == '0' &amp;&amp; i!=pos)break; long cur = Long.parseLong(num.substring(pos,i+1)); int len = sb.length(); if(pos == 0)&#123; find(res,sb.append(curr),num,i+1,target,curr,curr); sb.setLength(length); &#125; else&#123; find(res,sb.append('+').append(curr),num,i+1,target,prev + curr, curr); sb.setLength(length); find(res,sb.append('-').append(curr),num,i+1,target,prev - curr, -curr); sb.setLength(length); find(res,sb.append('*').append(curr),num,i+1,target,prev - after + after*curr, after*curr); sb.setLength(length); &#125; &#125; &#125;&#125; hard„ÄÇ Âà©Áî®stringbuildeÊñπÊ≥ïÊØîÁõ¥Êé•Áî®stringÊõ¥Âø´„ÄÇÊ≥®ÊÑèÊØè‰∏ÄÊ¨°findÂêéË¶ÅbacktrackingÔºåÂ∞ÜsbÁöÑlengthË∞ÉÊï¥Âõû‰∏ÄÂºÄÂßãÁöÑÂÄºÔºåÂ∞±ÊòØÊØèÊ¨°findÈáåÂ£∞ÊòéÁöÑsbÁöÑÈïøÂ∫¶„ÄÇ Âà©Áî®longÂûãÈÅøÂÖçÂá∫Èîô„ÄÇÊ≥®ÊÑèLong.parseLongÁöÑÁî®Ê≥ï„ÄÇÁ¨¨‰∏ÄÊ≠•ÁöÑÊó∂ÂÄôÂ∞ÜafterÂíåprevÈÉΩËÆæ‰∏∫curr„ÄÇ‰πãÂêéÊâç‰ºöÁªÜÂàÜ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 44","slug":"leetcode44","date":"2019-10-18T19:49:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/10/18/leetcode44/","link":"","permalink":"WangHngLeee.github.io/2019/10/18/leetcode44/","excerpt":"","text":"23. Merge k Sorted Lists class solution&#123; public kmergelist(ListNode[] lists)&#123; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(new Comparator &lt;ListNode&gt;()&#123; @override public int compare(ListNode node1, ListNode node2)&#123; if(node1.val &lt; node2.val)return -1; else if(node1.val == node2.val)return 0; else return 1; &#125; &#125;) ListNode dummy = new ListNode(0); ListNode last = dummy; for(ListNode node : lists)&#123; if(node!=null)queue.add(node); &#125; while(!queue.isEmpty)&#123; last.next = queue.poll(); last = last.next; if(last.next!=null)queue.add(last.next); &#125; return dummy.next; &#125;&#125; hard„ÄÇÈ¶ñÂÖàË¶ÅÂà©Áî®‰ºòÂÖàÈòüÂàóÔºåÁÑ∂ÂêéÂÆö‰πâcomparatorÔºåÂ∞ÜÂ∞èÁöÑÂÄºÊîæÂú®ÊúÄÈ´ò‰ºòÂÖàÂ∫¶„ÄÇqueueÁ¨¨‰∏ÄÊ¨°Âä†ÁöÑÊòØÊØè‰∏™linkedlistÁöÑÂ§¥ËäÇÁÇπ„ÄÇÁ±ª‰ººminheap„ÄÇ 973. K Closest Points to Origin class Solution &#123; public int[][] kClosest(int[][] points, int K) &#123; PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] left, int[] right)&#123;// Just keep the highest priority to small dist. if( dist(left) &lt; dist(right) ) return -1; else if( dist(left) == dist(right) ) return 0; else return 1; &#125; &#125;); for(int[] point : points)&#123; queue.add(point); &#125; int[][] res = new int[K][2]; while(K&gt;0)&#123;// Keep in mind that Kth point is in int[K-1] position K--; res[K] = queue.poll(); &#125; return res; &#125; private int dist(int[] point)&#123; return point[0]*point[0] + point[1]*point[1]; &#125;&#125; ComparatorÊñπÊ≥ï„ÄÇÂ∞ÜdistÂ∞èÁöÑpointËµãÁªôÊúÄÈ´òÁöÑ‰ºòÂÖàÂ∫¶„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"IBM È´òÈ¢ë Online Assignments","slug":"ibmoa","date":"2019-10-17T02:31:09.000Z","updated":"2019-10-17T03:27:54.086Z","comments":true,"path":"2019/10/16/ibmoa/","link":"","permalink":"WangHngLeee.github.io/2019/10/16/ibmoa/","excerpt":"IBM | OA 2020 È´òÈ¢ë | Two Strings class solution&#123; public static void main(String[] args)&#123; String[] a = &#123;\"ab\", \"cd\", \"ef\"&#125;; String[] b = &#123;\"af\", \"ee\", \"ef\"&#125;; String[] res = commonSubstring(a,b); for(String ans : res)&#123; System.out.println(ans); &#125; &#125; private void commonSubstring(String[] a, String[] b)&#123; String res = new String[a.length]; for(i = 0;i&lt;a.length;i++)&#123; int twobitA = 0; int twobitB = 0; for(int j = 0;j&lt;a[i].length;j++)&#123; char a = a[i].charAt(j); char b = b[i].charAt(j); twobitA ÔΩú= 1 &lt;&lt; (a-'a'); twobitB ÔΩú= 1 &lt;&lt; (b-'a'); &#125; res[i] = (twobitA &amp;&amp; twobitB ) &gt; 0 ? \"Yes\" : \"No\"; &#125; return res; &#125;&#125; trickyÔºöÂà©Áî®‰∫åËøõÂà∂Áõ∏ÂêåËøîÂõûÂÄºÂ§ß‰∫é0Âê¶Âàô‰∏∫00000‚Ä¶ÁöÑÊñπÊ≥ï„ÄÇÔΩú= ÊòØ‰∫åËøõÂà∂ÈáåÁöÑ+=ÔºåÂç≥Â∞ÜËØ•‰ΩçÁΩÆÁöÑÊâÄÊúâ‰∫åËøõÂà∂ÁªìÊûúÁõ∏Âä†ÔºåÊúÄÂêéÂíåbÁöÑÁõ∏ÊØîËæÉÔºåËã•ÊúâÁõ∏ÂêåÁöÑÔºåÂàôËøîÂõûÁöÑ‰∫åËøõÂà∂ËÇØÂÆö‰∏çÊòØ0ÔºåËã•Ê≤°ÊúâÔºåÂàôËøîÂõûÁöÑ‰∏ÄÂÆöÊòØ00000‚Ä¶","text":"IBM | OA 2020 È´òÈ¢ë | Two Strings class solution&#123; public static void main(String[] args)&#123; String[] a = &#123;\"ab\", \"cd\", \"ef\"&#125;; String[] b = &#123;\"af\", \"ee\", \"ef\"&#125;; String[] res = commonSubstring(a,b); for(String ans : res)&#123; System.out.println(ans); &#125; &#125; private void commonSubstring(String[] a, String[] b)&#123; String res = new String[a.length]; for(i = 0;i&lt;a.length;i++)&#123; int twobitA = 0; int twobitB = 0; for(int j = 0;j&lt;a[i].length;j++)&#123; char a = a[i].charAt(j); char b = b[i].charAt(j); twobitA ÔΩú= 1 &lt;&lt; (a-'a'); twobitB ÔΩú= 1 &lt;&lt; (b-'a'); &#125; res[i] = (twobitA &amp;&amp; twobitB ) &gt; 0 ? \"Yes\" : \"No\"; &#125; return res; &#125;&#125; trickyÔºöÂà©Áî®‰∫åËøõÂà∂Áõ∏ÂêåËøîÂõûÂÄºÂ§ß‰∫é0Âê¶Âàô‰∏∫00000‚Ä¶ÁöÑÊñπÊ≥ï„ÄÇÔΩú= ÊòØ‰∫åËøõÂà∂ÈáåÁöÑ+=ÔºåÂç≥Â∞ÜËØ•‰ΩçÁΩÆÁöÑÊâÄÊúâ‰∫åËøõÂà∂ÁªìÊûúÁõ∏Âä†ÔºåÊúÄÂêéÂíåbÁöÑÁõ∏ÊØîËæÉÔºåËã•ÊúâÁõ∏ÂêåÁöÑÔºåÂàôËøîÂõûÁöÑ‰∫åËøõÂà∂ËÇØÂÆö‰∏çÊòØ0ÔºåËã•Ê≤°ÊúâÔºåÂàôËøîÂõûÁöÑ‰∏ÄÂÆöÊòØ00000‚Ä¶ IBM | OA 2020 È´òÈ¢ë | Aladdin and his Carpet class solution&#123; pubic static int optimalpoints(List&lt;Integer&gt; magic, List&lt;Integer&gt; dist)&#123; int pos = 0,cur=0,total=0; for(int i = 0; i &lt; magic.size();i++)&#123; int cost = magic.get(i) - dist.get(i); cur+=cost; total+=cost; if(cur&lt;0)&#123; pos = i; cur = 0; &#125; &#125; return total &gt; 0 ? pos+1 : -1; &#125;&#125; gas stationÁöÑÁ±ªÂûãÈ¢òÔºåÂà§Êñ≠ÈÇ£‰∏™‰ΩçÁΩÆÂèØ‰ª•ÂºÄÂßãËøõË°åÂæ™ÁéØÂêéÊúÄÁªàÂÄº‰∏çÂ∞è‰∫éÈõ∂„ÄÇÁõ∏ÂêåÁöÑÈ¢òÁõÆÈìæÊé• leetcode‚Äìgasstation","categories":[{"name":"IBM-OA","slug":"IBM-OA","permalink":"WangHngLeee.github.io/categories/IBM-OA/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"},{"name":"OnlineAssignments","slug":"OnlineAssignments","permalink":"WangHngLeee.github.io/tags/OnlineAssignments/"}]},{"title":"Leetcode EveryDay 43","slug":"leetcode43","date":"2019-10-16T23:49:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/10/16/leetcode43/","link":"","permalink":"WangHngLeee.github.io/2019/10/16/leetcode43/","excerpt":"","text":"199. Binary Tree Right Side View class solution&#123; public List&lt;Integer&gt; rightsideview(TreeNode root)&#123; if(root == null) return new ArrayList(); Queue&lt;Integer&gt; queue = new LinkedList(); queue.offer(root); List&lt;Integer&gt; res = new ArrayList(); while(!queue.isEmpty())&#123; int size = queue.size(); while(size -- &gt;0)&#123; TreeNode cur = queue.poll(); if(size == 0)&#123; res.add(cur.val); &#125;if(cur.left!=null)&#123; queue.offer(cur.left); &#125;if(cur.right!=null)&#123; queue.offer(cur.right); &#125; &#125; &#125;return res; &#125;&#125; bfsÊñπÊ≥ïËøîÂõûÊúÄÂè≥‰æßÁöÑËäÇÁÇπ„ÄÇÂà©Áî®size‰Ωú‰∏∫flagÊù•ËÆ∞ÂΩïÂΩìÂâçÂ±ÇÊòØÂê¶ÈÅçÂéÜÂÆå„ÄÇ ‚Äì &gt;ÊòØÊØîËæÉ‰πãÂêéËá™Ë∫´Âáè‰∏Ä„ÄÇqueue.poll‰ªéÂâçÔºåstack.pop‰ªéÂêé„ÄÇ 236. Lowest Common Ancestor of a Binary Tree class solution&#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)&#123; if(root == q || root==p || root == null)return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right,p,q); if(left == null)return right; if(right == null)return left; else&#123; return root; &#125; &#125;&#125; Á¨¨‰∏âÈÅç„ÄÇËá™Ë∫´Ë∞ÉÁî®ÔºåleftÂ∞±ÊòØÂ∑¶Â≠êÊ†ëÁöÑÊúÄÂ∞èÁà∂ËäÇÁÇπÔºårightÂ∞±ÊòØÂè≥Â≠êÊ†ëÁöÑÊúÄÂ∞èÁà∂ËäÇÁÇπ„ÄÇ‰∏çÁî®ÊÉ≥Â§™Â§öÔºåË∞ÉÁî®ÂêéÁõ¥Êé•Áî®ËøîÂõûÂÄºËøõË°åÊØîËæÉÔºåÂæàÁÆÄÂçïÔºåleft‰∏∫nullÂàôË°®Á§∫Â∑¶ËæπÊ≤°ÊúâÊúÄÂ∞èÁà∂ËäÇÁÇπÔºåËøîÂõûÂè≥Â≠êÊ†ëÁöÑÊÉÖÂÜµ„ÄÇÂêåÁêÜÔºåright‰∏∫nullÊó∂ËøîÂõûÂ∑¶Â≠êÊ†ëÁöÑÊÉÖÂÜµ„ÄÇÂ¶ÇÊûú‰∏§ËæπÈÉΩÊ≤°ÊúâÔºåÈÇ£‰πàÂ∞±ÊòØrootÊú¨Ë∫´‰∫Ü„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 42","slug":"leetcode42","date":"2019-10-15T14:33:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/15/leetcode42/","link":"","permalink":"WangHngLeee.github.io/2019/10/15/leetcode42/","excerpt":"129. Sum Root to Leaf Numbers class solution&#123; public int sumnumbers(TreeNode root)&#123; return sum(root,0); &#125; public int sum(TreeNode n, int s)&#123; if(n == null)return 0; if(n.left == null &amp;&amp; n.right==null )&#123; return s*10 + n.val; &#125; return sum(n.left,s*10+n.val) + sum(n.right,s*10+n.val) &#125;&#125;","text":"129. Sum Root to Leaf Numbers class solution&#123; public int sumnumbers(TreeNode root)&#123; return sum(root,0); &#125; public int sum(TreeNode n, int s)&#123; if(n == null)return 0; if(n.left == null &amp;&amp; n.right==null )&#123; return s*10 + n.val; &#125; return sum(n.left,s*10+n.val) + sum(n.right,s*10+n.val) &#125;&#125; Â∞ÜÊØè‰∏ÄÊù°Â≠êÊ†ëÈìæ‰∏äÊï∞Â≠óÂä†Ëµ∑Êù•ÁªÑÊàêÂ§ö‰ΩçÊï∞„ÄÇÁÑ∂ÂêéÂ∞ÜÊúÄÂêéÁªìÊûúÁõ∏Âä†„ÄÇËá™Ë∫´‰∏∫Á©∫Êó∂ËøîÂõû0„ÄÇleftÊàñËÄÖright‰∏∫Á©∫Êó∂ÂàôÂ∞Ü‰∏ä‰∏Ä‰ΩçÁöÑÁöÑÁªìÊûú‰πò10ÂÜçÂä†‰∏äËá™Ë∫´ÂÄº„ÄÇ 222. Count Complete Tree Nodes class solution&#123; public int countnum(TreeNode root)&#123; int leftdepth = leftdepth(root); int rightdepth = rightdepth(root); if(leftdepth == rightdepth)&#123; return (1 &lt;&lt; leftdepth)-1; &#125;else&#123; return 1+countnum(root.left) + countnum(root.right); &#125; &#125; private int leftdepth(TreeNode root)&#123; int depth = 0; if(root!=null)&#123; depth++; root = root.left; &#125; return depth; &#125; private int rightdepth(TreeNode root)&#123; int depth = 0; if(root!=null)&#123; depth++; root = root.right; &#125; return depth; &#125;&#125; 1&lt;&lt; ÊòØlog2()ÁöÑÊÑèÊÄùÔºåÂõ†‰∏∫ÊÄªËäÇÁÇπÊï∞Á≠â‰∫é2ÁöÑÂ±ÇÊï∞Á´ãÊñπ-1„ÄÇleftÂíårightdepthÈÉΩÁõ∏Á≠âÊó∂ÔºåÂèØ‰ª•Áõ¥Êé•ËøîÂõûleftÁöÑdepthÂÖ¨Âºè„ÄÇ Â¶ÇÊûú‰∏çÁõ∏Á≠âÔºåÂàôÈúÄË¶ÅrecursiveËøõË°åËÆ°ÁÆó„ÄÇËÆ∞ÂæóÊúÄÂêéÂä†1ÔºåÁÆó‰∏ärootÊ†πÁªìÁÇπ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 41","slug":"leetcode41","date":"2019-10-14T15:15:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/14/leetcode41/","link":"","permalink":"WangHngLeee.github.io/2019/10/14/leetcode41/","excerpt":"105. Construct Binary Tree from Preorder and Inorder Traversal class solution&#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0,0,inorder.length-1,preorder,inorder); &#125; public TreeNode helper(int prestart, int instart, int inend, int[] preorder, int[] inorder)&#123; if(prestart &gt; preorder.length-1 || instart &gt; inend)return null; TreeNode root = new TreeNode(preorder[prestart]); int idx=0; for(int i = 0;i&lt;=inorder.length;i++)&#123; if(inorder[i]==root.val)&#123; idx = i; &#125; &#125; root.left = helper(prestart+1,instart,idx-1,preorder,inorder); root.right = helper(prestart+idx-instart+1,idx+1,inend,preorder,inorder); return root; &#125;&#125; preorderÁ¨¨‰∏Ä‰∏™Ê∞∏ËøúÊòØÊ†πÁªìÁÇπÔºåÊ†πÊçÆpreorderÁöÑÊ†πÁªìÁÇπÂú®inorderÈáåÊâæÂà∞Â∞±ÂèØ‰ª•ÂàíÂàÜÂ∑¶Âè≥Â≠êÊ†ë‰∫Ü„ÄÇÂ∑¶ËæπÊòØ‰ªéinstartÂà∞idx-1ÔºåÂè≥ËæπÊòØ‰ªéidx+1Âà∞inend„ÄÇ ËÄå‰∏îpreorder‰∏≠Ë¶ÅË∑≥ËøáÂ∑¶Â≠êÊ†ëÁöÑÈÉ®ÂàÜÔºå‰∏∫idx-instart.","text":"105. Construct Binary Tree from Preorder and Inorder Traversal class solution&#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return helper(0,0,inorder.length-1,preorder,inorder); &#125; public TreeNode helper(int prestart, int instart, int inend, int[] preorder, int[] inorder)&#123; if(prestart &gt; preorder.length-1 || instart &gt; inend)return null; TreeNode root = new TreeNode(preorder[prestart]); int idx=0; for(int i = 0;i&lt;=inorder.length;i++)&#123; if(inorder[i]==root.val)&#123; idx = i; &#125; &#125; root.left = helper(prestart+1,instart,idx-1,preorder,inorder); root.right = helper(prestart+idx-instart+1,idx+1,inend,preorder,inorder); return root; &#125;&#125; preorderÁ¨¨‰∏Ä‰∏™Ê∞∏ËøúÊòØÊ†πÁªìÁÇπÔºåÊ†πÊçÆpreorderÁöÑÊ†πÁªìÁÇπÂú®inorderÈáåÊâæÂà∞Â∞±ÂèØ‰ª•ÂàíÂàÜÂ∑¶Âè≥Â≠êÊ†ë‰∫Ü„ÄÇÂ∑¶ËæπÊòØ‰ªéinstartÂà∞idx-1ÔºåÂè≥ËæπÊòØ‰ªéidx+1Âà∞inend„ÄÇ ËÄå‰∏îpreorder‰∏≠Ë¶ÅË∑≥ËøáÂ∑¶Â≠êÊ†ëÁöÑÈÉ®ÂàÜÔºå‰∏∫idx-instart. 106. Construct Binary Tree from Inorder and Postorder Traversal Ëß£Ê≥ï1: 1ms class Solution &#123; int indexpost; int indexinorder; private TreeNode buildTree(int[] inorder, int[] postorder, TreeNode end) &#123; if(indexpost &lt; 0) return null; TreeNode n = new TreeNode(postorder[indexpost]); indexpost--; if(inorder[indexinorder] != n.val)&#123; n.right = buildTree(inorder,postorder,n); &#125; indexinorder--; if((end ==null) || (inorder[indexinorder]!=end.val))&#123; n.left = buildTree(inorder,postorder,end); &#125; return n; &#125; public TreeNode buildTree(int[] inorder, int[] postorder)&#123; indexpost = postorder.length -1; indexinorder = inorder.length-1; return buildTree(inorder,postorder,null); &#125;&#125; postorderÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Ê∞∏ËøúÊòØÊ†πËäÇÁÇπ„ÄÇÂΩìinorderÂÖÉÁ¥†ÂíåpostorderÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†‰∏çÁõ∏ÂêåÔºåË¶ÅÁªßÁª≠ÂæÄ‰∏ãÂæ™ÁéØÔºåÊûÑÂª∫rightÂ≠êÊ†ë„ÄÇÂΩìÂè≥Â≠êÊ†ëÊûÑÂª∫ÂÆåÊàê/inorderÈáåÈÅáÂà∞‰∫ÜpostorderÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Ôºå‰πüÂ∞±ÊòØÊ†πÁªìÁÇπÔºåÂºÄÂßãËøõË°åÂ∑¶Â≠êÊ†ëÁöÑÊûÑÂª∫Âæ™ÁéØ„ÄÇ Ëß£Ê≥ï2: 3ms class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (inorder == null || postorder == null || inorder.length != postorder.length) return null; HashMap&lt;Integer, Integer&gt; hm = new HashMap&lt;Integer,Integer&gt;(); for (int i=0;i&lt;inorder.length;++i) hm.put(inorder[i], i); return buildTreePostIn(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1,hm); &#125; private TreeNode buildTreePostIn(int[] inorder, int is, int ie, int[] postorder, int ps, int pe, HashMap&lt;Integer,Integer&gt; hm)&#123; if (ps&gt;pe || is&gt;ie) return null; TreeNode root = new TreeNode(postorder[pe]); int ri = hm.get(postorder[pe]); root.left = buildTreePostIn(inorder, is, ri-1, postorder, ps, ps+ri-is-1, hm); root.right= buildTreePostIn(inorder,ri+1, ie, postorder, ps+ri-is, pe-1, hm); return root; &#125;&#125; Âà©Áî®hashmapÂ≠òËäÇÁÇπÂíåÂØπÂ∫îÁöÑ‰ΩçÁΩÆ„ÄÇÁÑ∂ÂêéÊ†πÊçÆpostorderÈáåÊ†πÁªìÁÇπÁöÑ‰ΩçÁΩÆÔºåËøõË°åÂØπÂ∫îÁöÑleftÂíårightÂ≠êÊ†ëÊûÑÂª∫„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 40","slug":"leetcode40","date":"2019-10-12T15:15:09.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/10/12/leetcode40/","link":"","permalink":"WangHngLeee.github.io/2019/10/12/leetcode40/","excerpt":"103. Binary Tree Zigzag Level Order Traversal class solution&#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt;temp = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; queue.size();i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; temp.add(0,node.val); &#125;else&#123; temp.add(node.val); &#125;if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(temp); zig=!zig; &#125;return res; &#125;&#125; Â•áÊï∞Â±Çzig‰∏∫falseÔºåÂÅ∂Êï∞Â±Çzig‰∏∫true„ÄÇtrueÂä†Âà∞queueÂâçÈù¢ÔºåfalseÂàôÂú®ÂêéÈù¢ÊåâÈ°∫Â∫èÊ∑ªÂä†„ÄÇ","text":"103. Binary Tree Zigzag Level Order Traversal class solution&#123; public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null)return res; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); boolean zig = false; while(!queue.isEmpty())&#123; List&lt;Integer&gt;temp = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; queue.size();i++)&#123; TreeNode node = queue.poll(); if(zig)&#123; temp.add(0,node.val); &#125;else&#123; temp.add(node.val); &#125;if(node.left!=null)queue.add(node.left); if(node.right!=null)queue.add(node.right); &#125; res.add(temp); zig=!zig; &#125;return res; &#125;&#125; Â•áÊï∞Â±Çzig‰∏∫falseÔºåÂÅ∂Êï∞Â±Çzig‰∏∫true„ÄÇtrueÂä†Âà∞queueÂâçÈù¢ÔºåfalseÂàôÂú®ÂêéÈù¢ÊåâÈ°∫Â∫èÊ∑ªÂä†„ÄÇ 297. Serialize and Deserialize Binary Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; return serial(new StringBuilder(),root).toString(); &#125; private StringBuilder serial(StringBuilder str, TreeNode root)&#123; if(root == null)return str.append(\"null\"); str.append(root.val).append(','); serial(str,root.left).append(\",\"); serial(str,root.right); return str; &#125; // Decodes your encoded data to tree. public TreeNode deserialize(String data) &#123; return deserial(new LinkedList&lt;&gt;(Arrays.asList(data.split(',')))); &#125; private TreeNode deserial(Queue&lt;String&gt;q)&#123; String val = q.poll(); if(\"null\"equals(val))return null; TreeNode root = new TreeNode(valueOf(val)); root.left = deserial(q); root.right = deserial(q); return root; &#125;&#125; Á¨¨‰∏âÊ¨°ÂÅö„ÄÇÊúâÁÇπÂøò„ÄÇenocdeÊ≥®ÊÑèËæπÁïåÊù°‰ª∂„ÄÇserial‰∏≠Èó¥Âä†ÈÄóÂè∑„ÄÇËøõË°årightÊó∂‰∏çÁî®Âä†ÔºåÂõ†‰∏∫ÊòØÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆ„ÄÇ decodeÊó∂Ê≥®ÊÑèdeserialÈáåÈù¢ÁöÑÂÜôÊ≥ïÔºåaslistÂíåsplit„ÄÇÂêåÊ†∑Ê≥®ÊÑèËæπÁïåÊù°‰ª∂„ÄÇÂÆÉÊòØ‰ªéÊúÄÂêé‰∏Ä‰ΩçÂæÄÂâçËø≠‰ª£„ÄÇÁõ¥Âà∞Á¨¨‰∏Ä‰ΩçÊó∂Á≠îÊ°àÊâç‰ºöÊòØÊúÄÂÖ®ÁöÑ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 39","slug":"leetcode39","date":"2019-10-12T15:15:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/12/leetcode39/","link":"","permalink":"WangHngLeee.github.io/2019/10/12/leetcode39/","excerpt":"144. Binary Tree Preorder Traversal class solution&#123; public List&lt;Integer&gt; preoeder(TreeNode root)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedLIst&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node != null)&#123; res.add(node.val); stack.push(node.right); stack.push(node.left); &#125; &#125; return res; &#125;&#125;","text":"144. Binary Tree Preorder Traversal class solution&#123; public List&lt;Integer&gt; preoeder(TreeNode root)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new LinkedLIst&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; TreeNode node = stack.pop(); if(node != null)&#123; res.add(node.val); stack.push(node.right); stack.push(node.left); &#125; &#125; return res; &#125;&#125; preorder,ÊåâÁÖßÂè≥Â∑¶È°∫Â∫èÊîæÂÖ•dequeÔºåÂÜçÊåâÂ∑¶Âè≥È°∫Â∫èpopÂá∫„ÄÇ 145. Binary Tree Postorder Traversal class solution&#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); if(root == null) return res; while(!stack.isEmpty())&#123; root = stack.pop(); res.addFirst(root); if(root.left!=null)stack.push(root.left); if(root.right!=null)stack.push(root.right); &#125; return res; &#125;&#125; Âíå‰∏ä‰∏ÄÈÅìÈ¢òÁ±ª‰ººÔºå‰∏çËøáÊòØÈÄÜÂ∫èËæìÂá∫ÔºåÂè™ÈúÄË¶ÅÂ∞ÜaddÊîπ‰∏∫addFristÂç≥ÂèØ„ÄÇDequeÁöÑÁâπÊÄß„ÄÇ Amazon È´òÈ¢ëÈ¢ò Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 ‚Üí 4 ‚Üí 5 ‚Üí 9 is 4. You can only move either down or right at any point in time. Example 1:Input:[[5, 1], [4, 5]]Output: 4Explanation:Possible paths:5 ‚Üí 1 ‚Üí 5 =&gt; min value is 15 ‚Üí 4 ‚Üí 5 =&gt; min value is 4Return the max value among minimum values =&gt; max(4, 1) = 4. class solution&#123; public int mincvalue(int[][] mattix)&#123; int m = matrix.length; int n = matrix(0).length; int[] dp = new int[n]; dp[0]-matrix[0][0]; for(int i = 0;i&lt;m;i++)&#123; for(int j =0;j&lt;n;j++)&#123; if(i==0&amp;&amp;j==0)continue; if(j==0&amp;&amp;i!==)&#123; dp[j]=Math.min(matrix[i][j],dp[j]); &#125;else if(j!=0 &amp;&amp; i == 0)&#123; dp[j] = Math.min(matrix[i][j],dp[j-1]); &#125;else&#123; dp[j]= Math.min(Math.max(dp[j-1],dp[j]),matrix[i][j]); &#125; &#125; &#125; return dp[n-1]; &#125;&#125; ‰∏ÄÁª¥Êï∞ÁªÑÂØ∏‰ΩèÁªìÊûú„ÄÇÂè™ËÉΩÂêë‰∏ãÊàñËÄÖÂêëÂè≥Êâ´Êèè„ÄÇ 5. Longest Palindromic Substring class solution&#123; private int lo, maxlength; public String longestPalindrome(String s) &#123; if(s.length() &lt; 2)return s; for(int i = 0 : i &lt; s.length()-1;i++)&#123; valid(s,i,i); valid(s,i,i+1); &#125; return s.substring(lo,lo+maxlength); &#125; private void valid(String s, int j, int k)&#123; while(j&gt;=0 &amp;&amp; k&lt;s.length() &amp;&amp; s.charAt(j) == s.charAt(k))&#123; j--; k++; &#125; if(maxlength &lt; k-j-1)&#123; lo = j+1; maxlength = k-j-1; &#125; &#125;&#125; ËÆ∞‰Ωè‰∏§ÁßçÊÉÖÂÜµ ‰∏Ä‰∏™Â≠óÊØçÈáçÂ§ç aba ÊàñËÄÖ‰∏§‰∏™Â≠óÊØçÈáçÂ§ç abba","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 38","slug":"leetcode38","date":"2019-10-11T02:15:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/10/10/leetcode38/","link":"","permalink":"WangHngLeee.github.io/2019/10/10/leetcode38/","excerpt":"113. Path Sum II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; pathsum(TreeNode root, int sum)&#123; re pathsum(root,sum); &#125; public void pathsum(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return; cur.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123; res.add(new ArrayList(cur)); &#125;else&#123; pathsum(root.left,sum-root.val,cur,res); pathsum(root.right,sum-root.val,cur,res); &#125; cur.remove(cur.size()-1); &#125;&#125; Â¶ÇÊûúÂΩìÂâçroot‰∏∫leafÊó∂Ôºåroot val == sum ÔºåÈÇ£‰πàÁõ¥Êé•Â≠òÂÖ•curÔºõÂ¶ÇÊûú‰∏çÁ≠â‰∫ésumÔºåÂàôÁªßÁª≠iterateÔºåÂ∞Üsum=sum-root.val„ÄÇ ËÆ∞ÂæóÊúÄÂêébacktrackingÂ∞ÜcurÂ§ßÂ∞èÂáè‰∏ÄÔºå‰øùËØÅÂÖ∂‰ªñÁ≠îÊ°à‰∏çË¢´Ë¶ÜÁõñ„ÄÇ","text":"113. Path Sum II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; pathsum(TreeNode root, int sum)&#123; re pathsum(root,sum); &#125; public void pathsum(TreeNode root, int sum, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)&#123; if(root == null)return; cur.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123; res.add(new ArrayList(cur)); &#125;else&#123; pathsum(root.left,sum-root.val,cur,res); pathsum(root.right,sum-root.val,cur,res); &#125; cur.remove(cur.size()-1); &#125;&#125; Â¶ÇÊûúÂΩìÂâçroot‰∏∫leafÊó∂Ôºåroot val == sum ÔºåÈÇ£‰πàÁõ¥Êé•Â≠òÂÖ•curÔºõÂ¶ÇÊûú‰∏çÁ≠â‰∫ésumÔºåÂàôÁªßÁª≠iterateÔºåÂ∞Üsum=sum-root.val„ÄÇ ËÆ∞ÂæóÊúÄÂêébacktrackingÂ∞ÜcurÂ§ßÂ∞èÂáè‰∏ÄÔºå‰øùËØÅÂÖ∂‰ªñÁ≠îÊ°à‰∏çË¢´Ë¶ÜÁõñ„ÄÇ 114. Flatten Binary Tree to Linked List class solution&#123; public void flatten(TreeNode root) &#123; flatten(root,null); &#125; private TreeNode flatten(TreeNode root, TreeNode pre)&#123; if(root == null)return pre; pre=flatten(root.right,pre); pre=flatten(root.left,pre); root.right = pre; root.left = null; pre = root; return pre; &#125;&#125; dfsÁöÑÊÄùË∑ØÔºåÂÖà‰ªérightÂàÜÊîØÊâæÂà∞ÊúÄÂêé‰∏Ä‰∏™rootÔºåÂ∞ÜÂÖ∂ËÆæ‰∏∫preÔºåÁÑ∂ÂêéÈÄêÊ∏êÈÄíÂΩíÔºå‰æùÊ¨°Â∞ÜrootÂ≠òÂÖ•preÔºåÂπ∂‰∏îÂ∞ÜÂΩìÂâçrootËÆæ‰∏∫preÔºåÂπ∂‰∏îÂ∞ÜleftËÆæ‰∏∫null„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 37","slug":"leetcode37","date":"2019-10-08T03:15:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/07/leetcode37/","link":"","permalink":"WangHngLeee.github.io/2019/10/07/leetcode37/","excerpt":"","text":"Aamazon ËøëÊúüÈ´òÈ¢ëÈ¢ò ÔºÅ 5. Longest Palindromic Substring class solution&#123; private lowpos,maxlength; public String longest(String s)&#123; if(s.length()&lt;2)return s; for(int i =0; i &lt; s.length()-1; i++)&#123; valid(s,i,i); //abaÊÉÖÂÜµ valid(s,i,i+1); //baabÊÉÖÂÜµ &#125; return s.substring(lowpos,lowpos+maxlength); &#125; private void valid(String s, int j, int k)&#123; while(j&gt;=0 &amp;&amp; k &lt; s.length() &amp;&amp; charAt(j) == charAt(k))&#123; j--; k++; &#125; if(maxlength&lt;k-j+1)&#123; lowpos = j+!; maxlength = k-j+1; &#125; &#125;&#125; ÂèàÈÅáÂà∞‰∫ÜÁ¨¨‰∫îÈ¢òÔºåÂü∫Êú¨ÊÄùË∑ØÂ∞±ÊòØÂàÜabaÂíåbaabÁöÑÊÉÖÂÜµÂàÜÂà´Âæ™ÁéØ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 36","slug":"leetcode36","date":"2019-10-04T04:15:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/10/04/leetcode36/","link":"","permalink":"WangHngLeee.github.io/2019/10/04/leetcode36/","excerpt":"","text":"Aamazon ËøëÊúüÈ´òÈ¢ëÈ¢ò ÔºÅ Problem Given a matrix with r rows and c columns, find the maximum score of a path starting at [0, 0] and ending at [r - 1, c - 1]. The score of a path is the minimum value in that path. For example, the score of the path 8 ‚Üí 4 ‚Üí 5 ‚Üí 9 is 4. You can only move either down or right at any point in time. Example 1: Input:[[5, 1], [4, 5]]Output: 4Explanation:Possible paths:5 ‚Üí 1 ‚Üí 5 =&gt; min value is 15 ‚Üí 4 ‚Üí 5 =&gt; min value is 4Return the max value among minimum values =&gt; max(4, 1) = 4. ÊúâÁÇπÁ±ª‰ººunique path problemIIÔºåËøôÈÅìÈ¢òË¶ÅÊ±ÇËøîÂõûÊØè‰∏™Ë∑ØÂæÑ‰∏äÊúÄÂ∞èÂÄº‰∏≠ÁöÑÊúÄÂ§ßÂÄº„ÄÇ class solution&#123; public int maxPath(int[][] grid)&#123; int m = grid.length(); int n = grid[0].length(); int[] dp = new int[n]; dp[0] = grid[0][0]; for(int i = 0 ; i &lt;m;i++)&#123; for(int j = 0 ; j &lt; n ; j ++)&#123; if(!i &amp;&amp; !j)continue; else if(j == 0)dp[j] = Math.min(grid[i][j],dp[j]); else if(i == 0)dp[j] = Math.min(grid[i][j],dp[j-1]); else&#123; dp[j] = Math.max(Math.min(grid[i][j],dp[j]),Math.min(grid[i][j],dp[j-1])); &#125; &#125; &#125; return dp[n-1]; &#125;&#125; Â¶ÇÊûúÊòØÁ¨¨‰∏ÄË°å ÂàôÊ®™ÂêëÊØîËæÉÊõ¥Êñ∞ÊúÄÂ∞èÂÄºÔºõËã•Á¨¨‰∏ÄÂàóÔºåÁ∫µÂêëÊØîËæÉÔºõÂ∞ÜÂÄºÂ≠òÂú®dp[j]Èáå„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 35","slug":"leetcode35","date":"2019-10-01T19:25:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/10/01/leetcode35/","link":"","permalink":"WangHngLeee.github.io/2019/10/01/leetcode35/","excerpt":"Aamazon ËøëÊúüÈ´òÈ¢ëÈ¢ò ÔºÅ 1167. Minimum Cost to Connect Sticks class solution&#123; public int stickscost(int [] sticks)&#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(int s : sticks)&#123; queue.offer(s); &#125; int sum = 0; while(queue.size&gt;1)&#123; int temp = queue.poll() + queue.poll(); sum += temp; queue.offer(temp); &#125; return sum; &#125;&#125; Âà©Áî®priority queueÁöÑËá™Âä®‰ªéÂ∞èÂà∞Â§ßpollÁöÑÈ°∫Â∫è‰ºòÁÇπÔºåËá™Âä®ÂçáÂ∫èÊâ´ÊèèÔºåÊúÄÁªàËøîÂõûÊúÄÂ∞èÁöÑsum„ÄÇ","text":"Aamazon ËøëÊúüÈ´òÈ¢ëÈ¢ò ÔºÅ 1167. Minimum Cost to Connect Sticks class solution&#123; public int stickscost(int [] sticks)&#123; PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); for(int s : sticks)&#123; queue.offer(s); &#125; int sum = 0; while(queue.size&gt;1)&#123; int temp = queue.poll() + queue.poll(); sum += temp; queue.offer(temp); &#125; return sum; &#125;&#125; Âà©Áî®priority queueÁöÑËá™Âä®‰ªéÂ∞èÂà∞Â§ßpollÁöÑÈ°∫Â∫è‰ºòÁÇπÔºåËá™Âä®ÂçáÂ∫èÊâ´ÊèèÔºåÊúÄÁªàËøîÂõûÊúÄÂ∞èÁöÑsum„ÄÇ Amazon | OA 2019 | Find Pair With Given Sum public static void main(String[] args) &#123; int[] nums1 = &#123;1, 10, 25, 35, 60&#125;; int target1 = 90; System.out.println(Arrays.toString(Find2Sum(nums1, target1-30))); int[] nums2 = &#123;20, 50, 40, 25, 30, 10&#125;; int target2 = 90; System.out.println(Arrays.toString(Find2Sum(nums2, target2-30))); int[] nums3 = &#123;50, 20, 10, 40, 25, 30&#125;; int target3 = 90; System.out.println(Arrays.toString(Find2Sum(nums3, target3-30)));&#125;private static int[] Find2Sum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int max = Integer.MIN_VALUE; int[] res = new int[2]; for(int i=0;i&lt;nums.length;i++) &#123; if(map.containsKey(nums[i])) &#123; if(nums[i] &gt; mac || nums[map.get(nums[i])] &gt; max)&#123; res[0] = map.get(nums[i]); res[1] = i; max = Math.max(nums[i],nums[map.get(nums[i])]); &#125; &#125; map.put(target - nums[i], i); &#125; return res;&#125; two sumÁöÑÂèòÁßçÈ¢òÔºåÊó†Áõ∏Á≠âÊù°‰ª∂‰∏ãË¶ÅËøîÂõûÊúÄÊé•ËøëtargetÁöÑÂÄº„ÄÇÊâÄ‰ª•Â§ö‰∏ÄÊ≠•Âà§Êñ≠„ÄÇÂÖ∂‰ΩôÁöÑ‰∏étwo sum‰∏ÄÊ†∑ÁöÑÊÄùË∑Ø„ÄÇ 992. Subarrays with K Different Integers class solution&#123; public int substringarray(int[] A, int K)&#123; return atmostk(A,K) - atmost(A,K-1); &#125; int atmost(int[] A, int K)&#123; int i = 0; int ans = 0; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int j = 0 ; j &lt; A.lengthj ; j++)&#123; if(map.getOrDefault(A[j],0) == 0 )K--; map.put(A[j],map.getOrDefault(A[j],0) + 1); while(K&lt;0)&#123; map.put(A[j],map.get(A[j])-1); if(map.get(A[j])==0)&#123; K++; &#125; i++; &#125; ans + = j - i + 1; &#125; return ans; &#125;&#125; Ë¶ÅÊ±ÇÊâæÂá∫‰∏çÂêåÂÖÉÁ¥†‰∏™Êï∞‰∏∫KÁöÑsubarrayÁßçÁ±ªÊï∞ÔºåÂÖ∂ÂÆûÂèØ‰ª•Áúã‰ΩúÊòØF(K)-F(K-1)ÁöÑÁªìÊûúÔºåÊúÄÂ§öÊúâK‰∏™ÁöÑ‰∏™Êï∞ÂáèÂéªÊúÄÂ§öÊúâK-1ÁöÑ‰∏™Êï∞Â∞±ÊòØÂè™ÊúâK‰∏™ÁöÑÁßçÁ±ªÊï∞„ÄÇ ‰ΩÜÊòØËøôÈáåÁî®sliding window ‰ºöÂæàÈ∫ªÁÉ¶ÔºåÊâÄ‰ª•Â∞±Ê£ÄÊü•‰∏ÄÂÖ±ÊúâÂ§öÂ∞ë‰∏™‰∏çÂêåÁöÑÊï∞„ÄÇÂΩìK&lt;0Êó∂ÔºåËØ¥ÊòéÂΩìÂâçwindowÈáåÂ∑≤ÁªèÊúâ‰∏§‰∏™‰∏çÂêåÁöÑÊï∞‰∫ÜÔºåÁÑ∂Âêé‰ªéÂ∑¶ËæπÊî∂Áº©windowÁöÑÂ§ßÂ∞è ansËÆ∞ÂΩï‰ªéÂºÄÂßãÂà∞ÂΩìÂâçj‰ΩçÁΩÆÔºåÁßçÁ±ªÊúÄÂ§öÊúâK‰∏™(&lt;=K)ÁöÑsubarrayÊÄªÊï∞„ÄÇÁÑ∂ÂêéÂáèÂéªF(K-1)ÁöÑÂç≥ÂèØ„ÄÇ YoutubeËßÜÈ¢ëËØ¶ÁªÜËÆ≤Ëß£Ôºö","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 34","slug":"leetcode34","date":"2019-09-26T19:25:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/09/26/leetcode34/","link":"","permalink":"WangHngLeee.github.io/2019/09/26/leetcode34/","excerpt":"","text":"Aamazon ËøëÊúüÈ´òÈ¢ëÈ¢ò ÔºÅ 937. Reorder Data in Log Files class solution&#123; public String[] reorderLogFiles(String[] logs) &#123; Comparator&lt;String&gt; comp = new Comparator&lt;String&gt;()&#123; @override public int compare(String s1,String s2)&#123; int s1start=index(' '); int s2start=index(' '); char s1fc = s1.charAt(s1start+1); char s2fc = s2.charAt(s2start+1); if(s1fc &lt;= '9')&#123; if(s2fc &lt;= '9')&#123; return '0'; &#125; else return 1; &#125; if(s2fc&lt;='9')&#123; return -1; &#125; // ÂêéÈù¢ÊòØÈíàÂØπ‰∏§‰∏™‰ΩçÁΩÆÈÉΩÊòØÂ≠óÊØçÁöÑÊÉÖÂÜµÔºåÂ¶ÇÊûúÈÉΩ‰∏∫Èõ∂ÔºåËØ¥ÊòéËØ•Â≠óÊØçÂêéÈù¢Âùá‰∏∫Êï∞Â≠óÊàñËÄÖÂ≠óÊØçÔºåÂàôÈúÄË¶Å‰ªé0Âà∞ÂΩìÂâçÂà∞s1startÂíås2startËøõË°åÈáçÊñ∞Êâ´Êèè„ÄÇ // Áî®s1startÂíås2startËøõË°åÊØîËæÉ int precomp = s1.substring(s1start+1).compareTo(s1.substring(s2start+1)); if(precomp==0)&#123; return s1.substring(0,s1start).compareTo(s2.substring(0,s2start)); &#125; return precomp; &#125; &#125; //Á¨¨‰∏Ä‰ΩçÊòØË¢´sortÂà∞ÂØπË±°ÔºåÁ¨¨‰∫å‰ΩçÊòØÂèÇËÄÉÈ°∫Â∫èÔºåcomparator‰ºöÂ∞ÜÂêÑ‰∏™ÂÖÉÁ¥†Ë∑üÊØîËæÉÁªìÊûúËøõË°åÂÖ≥ËÅî„ÄÇ Array.sort(logs,comp); return logs; &#125;&#125; @override ÁöÑÁõÆÁöÑÊòØ‰∏∫‰∫ÜÈò≤Ê≠¢Âú®Êõ¥ÊîπÁà∂Á±ªÊó∂Âá∫ÈîôÔºå‰∏çÂä†‰πüÂèØ‰ª•„ÄÇÂà©Áî®javaÂÜÖÁΩÆcomparatorÊé•Âè£ÔºåÂØπÊØè‰∏Ä‰∏™logËøõË°å‰∏ªÂä®ÊéíÂ∫èÔºåÂ∞ÜÊéíÂ∫èÁªìÊûúÂíålogÂØπÂ∫îËµ∑Êù•ÔºåÂØπÊï∞Â≠óÂíåÂ≠óÊØçÁöÑÊÉÖÂÜµËøõË°åËÆæÁΩÆ„ÄÇ Â≠óÊØçÂíåÂ≠óÊØç‰πãÈó¥comparator‰ºöËá™Âä®ËøõË°åÊéíÂ∫èÔºåÊâÄ‰ª•Êàë‰ª¨Âè™ÈúÄË¶ÅÂØπÊï∞Â≠ó-Êï∞Â≠ó / Êï∞Â≠ó-Â≠óÊØçÂØπÊÉÖÂÜµËøõË°åËÆ®ËÆ∫„ÄÇ comparatorÁ¨¨‰∏Ä‰ΩçÊòØÈúÄË¶ÅËøõË°åÂÖ≥ËÅîËµãÂÄºÁöÑÂØπË±°ÔºåÂêé‰∏Ä‰ΩçÊòØËøõË°åÊØîËæÉÁöÑÂèÇËÄÉ‰Ωç„ÄÇ Ëã•‰∏§ËÄÖÈÉΩÊòØÊï∞Â≠óÔºåÂàôËøîÂõû0Ôºå‰ΩçÁΩÆ‰∏çÂä®Ôºå‰∫åËÄÖpriorityÁõ∏ÂêåÔºõ Ëã•Á¨¨‰∏Ä‰∏™ÊòØÊï∞Â≠óÔºåÁ¨¨‰∫å‰∏™ÊòØÂ≠óÊØçÔºåËøîÂõû1ÔºåÂêéËÄÖpriorityÈ´ò‰∫éÂâçËÄÖÔºàË¶ÅÊääÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑÊèêÂâçÔºåÂèàÂõ†‰∏∫ÊòØÂçáÂ∫èÊéíÂ∫èÔºåÊâÄ‰ª•Ë¶ÅÂ∞Üpriority‰ΩéÁöÑÂÖ≥ËÅîÂÄºËÆæÁΩÆÁöÑÂ§ß Ëã•Á¨¨‰∏Ä‰∏™ÊòØÂ≠óÊØçÔºåÁ¨¨‰∫å‰∏™ÊòØÊï∞Â≠óÔºåËøîÂõû-1ÔºåÂâçËÄÖÊ≠§Êó∂priorityÊúÄÈ´ò„ÄÇ Ëã•‰∫åËÄÖÈÉΩÊòØÂ≠óÊØçÔºåÂàôËøõË°åprecompËµãÂÄºÔºåÂ¶ÇÊûúËøòÊòØÊÅíÁ≠â‰∫é0ÔºåÈùûlogÂçïËØçÂêéÈù¢ÂÖ®ÊòØÊï∞Â≠óorÈÉΩÊòØÂçïËØçÔºåÊâÄ‰ª•Ë¶ÅÂØπ0-s1start/s2startÁöÑsubstringÂÜçÊâ´ÊèèÔºåÂØπs1startÂíås2start‰ΩçÁΩÆËøõË°åÊúÄÂêéÊØîËæÉ„ÄÇ ÊúÄÂêéÂØπlogÁî®compÁöÑÂèÇËÄÉÂÄºËøõË°åÊéíÂ∫èÂç≥ÂèØ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 33","slug":"leetcode33","date":"2019-09-25T18:25:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/09/25/leetcode33/","link":"","permalink":"WangHngLeee.github.io/2019/09/25/leetcode33/","excerpt":"863. All Nodes Distance K in Binary Tree class solution&#123; Map&lt;Treenode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); search(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); &#125; return -1; &#125; private void search(TreeNode root, int distance, int K, List&lt;Integer&gt; res)&#123; if(root==null)return; if(map.containsKey(root))&#123; distance=map.get(root); &#125; if(dis==K)&#123; res.add(root.val); &#125; search(root.left,distance+1,K,res); search(root.right,distance+1,K,res); &#125;&#125; Áî®HashMapÂ≠ò‰Ωè‰ªéÊ†πrootÂà∞target ÁöÑpath‰∏äÊâÄÊúâËäÇÁÇπÁ¶ªtargetÁöÑË∑ùÁ¶ª„ÄÇ Êé•ÁùÄÁî®dfsÊñπÊ≥ïÂØπÊØè‰∏™ËäÇÁÇπËøõË°åÊâ´Êèè„ÄÇÂ¶ÇÊûúmapÊúâÂΩìÂâçÁöÑËäÇÁÇπÔºåËØ¥ÊòéÂú®root-targetÁöÑpath‰∏ä„ÄÇÁõ¥Êé•Â∞ÜdistanceËÆæÁΩÆ‰∏∫ËØ•ËäÇÁÇπÂà∞targetÁöÑË∑ùÁ¶ª„ÄÇ Â¶ÇÊûúÂΩìÂâçËäÇÁÇπ‰∏çÂú®map‰∏≠‰∏îË∑ùÁ¶ª‰∏çÊòØKÔºàÂú®targetÁöÑÂ≠êÊ†ëÈáåÔºâ,Âàô‰∏ã‰∏ÄÊ¨°dfsÂ∞ÜdistanceÂÄºÂä†1„ÄÇ","text":"863. All Nodes Distance K in Binary Tree class solution&#123; Map&lt;Treenode,Integer&gt; map = new HashMap&lt;&gt;(); public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K)&#123; List&lt;Integer&gt; res = new LinkedList&lt;&gt;(); find(root,target); search(root,0,K,res); return res; &#125; private int find(TreeNode root, TreeNode target)&#123; if(root == null)return -1; if(root == target)&#123; map.put(root,0); return 0; &#125; int left = find(root.left,target); if(left&gt;=0)&#123; map.put(root,left+1); return left+1; &#125; int right = find(root.right,target); if(right&gt;=0)&#123; map.put(root,right+1); &#125; return -1; &#125; private void search(TreeNode root, int distance, int K, List&lt;Integer&gt; res)&#123; if(root==null)return; if(map.containsKey(root))&#123; distance=map.get(root); &#125; if(dis==K)&#123; res.add(root.val); &#125; search(root.left,distance+1,K,res); search(root.right,distance+1,K,res); &#125;&#125; Áî®HashMapÂ≠ò‰Ωè‰ªéÊ†πrootÂà∞target ÁöÑpath‰∏äÊâÄÊúâËäÇÁÇπÁ¶ªtargetÁöÑË∑ùÁ¶ª„ÄÇ Êé•ÁùÄÁî®dfsÊñπÊ≥ïÂØπÊØè‰∏™ËäÇÁÇπËøõË°åÊâ´Êèè„ÄÇÂ¶ÇÊûúmapÊúâÂΩìÂâçÁöÑËäÇÁÇπÔºåËØ¥ÊòéÂú®root-targetÁöÑpath‰∏ä„ÄÇÁõ¥Êé•Â∞ÜdistanceËÆæÁΩÆ‰∏∫ËØ•ËäÇÁÇπÂà∞targetÁöÑË∑ùÁ¶ª„ÄÇ Â¶ÇÊûúÂΩìÂâçËäÇÁÇπ‰∏çÂú®map‰∏≠‰∏îË∑ùÁ¶ª‰∏çÊòØKÔºàÂú®targetÁöÑÂ≠êÊ†ëÈáåÔºâ,Âàô‰∏ã‰∏ÄÊ¨°dfsÂ∞ÜdistanceÂÄºÂä†1„ÄÇ 957. Prison Cells After N Days class solution&#123; public int[] prison(int[] cells, int N)&#123; for( N = (N-1)%14 + 1 ; N &gt; 0 ; N--)&#123; int[]cells2 = new int[8]; for(int i = 1; i&lt;7;i++)&#123; cell2[i] = cells[i1]==cells[i+1]? 1:0; &#125; cells = cell2; &#125; return cells; &#125;&#125; ÂÖ≥ÈîÆË¶ÅÊâæÂà∞ËøôÈÅìÈ¢òÁöÑËßÑÂæãÔºå‰∏ÉÊ¨°‰∏ÄÂæ™ÁéØÔºåcell loop7Ê¨°Âêé‰ºöÂõûÂà∞ÂéüÂßãÁä∂ÊÄÅÔºåÊâÄ‰ª•Áî®(N-1)%14+1Êù•Âà§Êñ≠ÊÄªÁöÑÂæ™ÁéØÊ¨°Êï∞ÔºåÂè™ÈúÄË¶ÅÊâæÂà∞ÂΩìÂâçNÊòØ7Ê¨°ÈáåÈù¢ÁöÑÂì™‰∏ÄÊ¨°„ÄÇ Ê≥®ÊÑè‰∏çËÆ∫ÂºÄÂ§¥ÂíåÁªìÂ∞æÊòØ‰ªÄ‰πàÔºåÁ¨¨‰∫åÊ¨°ÂºÄÂßãÂÖ®ÈÉ®Âèò‰∏∫0ÔºåÂõ†‰∏∫Ê≤°ÊúâadjenctÔºåÊâÄ‰ª•Â∞Ücell2Áõ¥Êé•ËµãÂÄºÁªôcellsÔºåÂõ†‰∏∫cell2ÂàùÂßãÊó∂ÂºÄÂ§¥ÂíåÁªìÂ∞æÂùáÊòØ0„ÄÇ Minimum Cost to Merge Stones class Solution &#123; public int mergeStones(int[] stones, int K) &#123; int n = stones.length; if ((n - 1) % (K - 1) &gt; 0) return -1; int[] prefix = new int[n+1]; for (int i = 0; i &lt; n; i++) prefix[i + 1] = prefix[i] + stones[i]; int[][] dp = new int[n][n]; for (int m = K; m &lt;= n; ++m) for (int i = 0; i + m &lt;= n; ++i) &#123; int j = i + m - 1; dp[i][j] = Integer.MAX_VALUE; for (int mid = i; mid &lt; j; mid += K - 1) dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + 1][j]); if ((j - i) % (K - 1) == 0) dp[i][j] += prefix[j + 1] - prefix[i]; &#125; return dp[0][n - 1]; &#125;&#125; È¶ñÂÖàÂà§Êñ≠ÈïøÂ∫¶ËÉΩ‰∏çËÉΩË¢´kÊï¥Èô§„ÄÇ Áî®prefixÂ≠ò‰ΩèÊåâÈ°∫Â∫èÁõ∏Âä†ÁöÑÂíåÔºåÂ§áÁî®„ÄÇ Áî®dpÂ≠ò‰ΩèÂΩìÂâç‰∏§‰∏™‰ΩçÁΩÆ‰πãÈó¥ÁöÑmin cost„ÄÇÊ≥®ÊÑèÁî®midÂØπiÔºåj‰πãÈó¥ÁöÑ‰ΩçÁΩÆËøõË°åminÊâ´ÊèèÔºå‰øùËØÅÊØèÊ¨°ÈÉΩÂèñÂà∞ÊúÄÂ∞èÂÄº„ÄÇ ÂØπmid loopÂÆåÂêéÔºåÂ∞ÜprefixÈáåÈù¢iÂíåjÁöÑÁõ∏ÂØπ‰ΩçÁΩÆÁöÑÂÄºÁõ∏ÂáèÂπ∂‰∏îËµãÁªôdp[i][j]„ÄÇ Combinations class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(ans,new ArrayList&lt;Integer&gt;(),1 ,n,k); return ans; &#125; public static void combine(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; comb, int start, int n, int k)&#123; if(k == 0)ans.add(new ArrayList&lt;Integer&gt;(comb)); for(int i =start; i&lt;=n;i++)&#123; comb.add(i); combine(ans,comb,i+1,n,k-1); comb.remove(comb.size()-1); &#125; &#125;&#125; ÂõûÊ∫ØÊñπÊ≥ïÔºåËÆ∞ÂæóÊúÄÂêéÂ∞ÜcombÈïøÂ∫¶-1Ôºõ 22. Generate Parentheses class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res, new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res ,StringBuilder sb, int open, int close, int n)&#123; if(open == n &amp;&amp; close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+1,close,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125; Â§ç‰π†„ÄÇÂõûÊ∫ØÊñπÊ≥ïÔºåÈ¶ñÂÖàÂà§Êñ≠openÂíåcloseÁöÑÂÄºÔºåËÆ∞ÂæóÊØèÊ≠•ÊúÄÂêé‰πüË¶ÅÊäälength-1.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 32","slug":"leetcode32","date":"2019-09-21T00:25:09.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/09/20/leetcode32/","link":"","permalink":"WangHngLeee.github.io/2019/09/20/leetcode32/","excerpt":"","text":"269. Alien Dictionary class solution&#123; public String alienOrder(String[] words) &#123; Map&lt;Character,Set&lt;Character&gt;&gt; map = new HashMap&lt;Character,Set&lt;Character&gt;&gt;(); Map&lt;Character,Integer&gt; degree = new HashMap&lt;Character,Integer&gt;(); String res = \"\"; if(words==null || words.length() == 0)return res; for(String s :words)&#123; for(char c: s.toCharArray())&#123; degree.get(C,0); &#125; &#125; for(int i = 0 ; i &lt; words.length ; i ++)&#123; String cur = words[i]; String next = words[i+1]; int length = Math.min(cur.length(),next.length()); for(int j = 0 ; j &lt;length;j++)&#123; char c1 = cur.charAt(j); char c2 = next.charAt(j); if(c1!=c2)&#123; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); if(map.containsKey(c1))set = map.get(c1); if(!set.contains(c2))&#123; set.add(c2); map.put(c1,set); degree.put(c2,degree.get(c2)+1); &#125; break; &#125; &#125; &#125; Queue&lt;Character&gt; q=new LinkedList&lt;Character&gt;(); for(char c : degree.keySet())&#123; if(degree.get(c) q.add(c); &#125; while(!q.isEmpty())&#123; char c = q.remove; res += c; if(map.contains(c))&#123; for(char c2 : map.get(C))&#123; degree.put(c2,degree.get(c2)-1); if(degree.get(c2)==0)&#123; q.add(c2); &#125; &#125; &#125; &#125; if(res.length != degree.size())return \"\"; return res; &#125;&#125; Áî®mapÊûÑÂª∫graphÔºådegreeÂ≠òÊØè‰∏™Â≠óÊØçÁöÑÂÖ•Â∫¶ÔºåÂ∞ÜÊØè‰∏™Â≠óÊØçÂÖ•Â∫¶ËÆæÁΩÆ‰∏∫0. Áõ∏ÈÇªÁöÑÂçïËØçÔºåÁ¨¨‰∏Ä‰∏™‰∏çÂêåÁöÑÂ≠óÊØçÂá∫Áé∞Êó∂ÔºåÂâç‰∏Ä‰∏™Âú®Âêé‰∏Ä‰∏™‰πãÂâçÔºåÁÑ∂ÂêéÂØπÊØè‰∏Ä‰∏™Â≠óÊØçÁöÑmapËøõË°åÊõ¥Êñ∞. ÊúÄÂêéÁî®queueÊù•Â§ÑÁêÜÁªìÊûúÔºåÂ∞Üdegree‰∏∫0ÁöÑËæìÂÖ•ÔºåÁÑ∂Âêé‰∏Ä‰∏™‰∏Ä‰∏™removeÔºåÂπ∂ÂØπËØ•Â≠óÊØçËøõË°åÊâ´ÊèèÔºåÂÜçÂ∞ÜÂÖ•Â∫¶‰∏∫0ÁöÑÂ≠òÂÖ•queue„ÄÇ‰ª•Ê≠§Á±ªÊé®„ÄÇ 819. Most Common Word class Solution &#123; public String mostCommonWord(String paragraph, String[] banned) &#123; String[] words = paragraph.toLowerCase().split(\"\\\\W++)\"); Set&lt;String&gt; set = new Hashset&lt;&gt;(); for(String word :banned)&#123; set.add(word); &#125; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for(String word : words)&#123; if(!set.contains(word))&#123; map.put(word,map.getOrDefault(word,0)+1); &#125; &#125; int max = 0; String res = ''; for(String str : map.keySet())&#123; if(map.get(str) &gt; max)&#123; max = map.get(str); res = str; &#125; &#125; return res; Ê≠£ÂàôË°®ËææÂºè‰∏≠Ôºå\\wÔºàÂ∞èÂÜôwÔºâ Ë°®Á§∫Â≠óÁ¨¶, \\WÔºàÂ§ßÂÜôW)Ë°®Á§∫ÈùûÂ≠óÁ¨¶. ‚Äò+‚Äô Êàë‰ª¨Ë¶ÅÊª°Ë∂≥Â§öÈ°π„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 31","slug":"leetcode31","date":"2019-09-12T18:25:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/09/12/leetcode31/","link":"","permalink":"WangHngLeee.github.io/2019/09/12/leetcode31/","excerpt":"","text":"126. Word Ladder II class solution&#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; if (!wordList.contains(endWord)) &#123; return 0; &#125; Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList); Set&lt;String&gt; begin = new HashSet&lt;&gt;(); Set&lt;String&gt; end = new HashSet&lt;&gt;(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); begin.add(beginWord); end.add(endWrod); int step = 1; while(!begin.isEmpty() &amp;&amp; !end.isEmpty())&#123; if(begin.size() &lt; end.size())&#123; Set&lt;String&gt; set = beginSet; beginSet = endSet; endSet = set; &#125; Set&lt;String&gt; temp = new HashSet&lt;&gt;(); for(String word : begin)&#123; char[] chrs = word.charToArray(); for(int i = 0 ; i &lt; chrs.length ; i++)&#123; for(char c = 'a' ; c &lt;= 'z'; c++&gt;&#123; char old = chrs[i]; chrs[i] = c; String target = String.valueOf(chrs); if(end.contains(target))&#123; return step + 1; &#125; if(!visited.contains(target) &amp;&amp; dict.contains(target))&#123; visited.add(target); temp.add(target); &#125; chrs[i] = old; &#125; &#125; &#125; begin = temp; step++; &#125; return 0; &#125;&#125; ‰ΩøÁî®ÂèåÂêëÊâ´ÊèèÔºåbeginÂíåend‰∏ÄËµ∑Êâ´ÊèèÔºåÁõ¥Âà∞Êüê‰∏Ä‰∏™set‰∏≠Âá∫Áé∞‰∫ÜÂè¶Â§ñ‰∏Ä‰∏™ÂçïËØç‰∏∫Ê≠¢ÔºåÂÖ∑‰ΩìËÆ≤Ëß£Â¶Ç‰∏ãËßÜÈ¢ë„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Ruby learning notes(1)","slug":"ruby","date":"2019-08-27T20:35:09.000Z","updated":"2019-08-27T21:17:52.000Z","comments":true,"path":"2019/08/27/ruby/","link":"","permalink":"WangHngLeee.github.io/2019/08/27/ruby/","excerpt":"ÂâçË®Ä Áî±‰∫éÈÄâ‰∫ÜCSC517ÁöÑoopÈúÄË¶ÅÁî®rubyÊù•ÂÅöprojectÔºåËôΩÁÑ∂rubyËæÉ‰∏∫ÂÜ∑Èó®Ôºå‰ΩÜÊòØÂ§öÂ≠¶‰∏ÄÈó®ËØ≠Ë®ÄÊÄªÊòØÂ•ΩÁöÑ„ÄÇ ÁéØÂ¢ÉËÆæÁΩÆ‰ª•Âèä‰∏Ä‰∫õÂü∫Êú¨Êìç‰ΩúÂ∞±Ë∑≥Ëøá‰∫Ü„ÄÇ Ruby ËØ≠Ê≥ï ruby‰∏≠ËæìÂá∫Áî®puts puts \"Hello Ruby!\" Ruby‰∏≠ÁöÑË°åÂ∞æ ruby‰∏≠Áî®ÂàÜÂè∑ÔºõÊàñËÄÖÊç¢Ë°åÁ¨¶\\nÊù•Ë°®Á§∫Ë°åÂ∞æ„ÄÇ Ruby‰∏≠ÁöÑHere Document Here Document&quot; ÊòØÊåáÂª∫Á´ãÂ§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇ Âú® &lt;&lt; ‰πãÂêéÔºåkÂèØ‰ª•ÊåáÂÆö‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊàñÊ†áËØÜÁ¨¶Êù•ÁªàÊ≠¢Â≠óÁ¨¶‰∏≤Ôºå‰∏îÂΩìÂâçË°å‰πãÂêéÁõ¥Âà∞ÁªàÊ≠¢Á¨¶‰∏∫Ê≠¢ÁöÑÊâÄÊúâË°åÊòØÂ≠óÁ¨¶‰∏≤ÁöÑÂÄº„ÄÇ Â¶ÇÊûúÁªàÊ≠¢Á¨¶Áî®ÂºïÂè∑Êã¨Ëµ∑ÔºåÂºïÂè∑ÁöÑÁ±ªÂûãÂÜ≥ÂÆö‰∫ÜÈù¢ÂêëË°åÁöÑÂ≠óÁ¨¶‰∏≤Á±ªÂûã„ÄÇÊ≥®ÊÑè&lt;&lt; ÂíåÁªàÊ≠¢Á¨¶‰πãÈó¥ÂøÖÈ°ªÊ≤°ÊúâÁ©∫Ê†º. #!/usr/bin/ruby -w# -*- coding : utf-8 -*- print &lt;&lt;EOF ËøôÊòØÁ¨¨‰∏ÄÁßçÊñπÂºèÂàõÂª∫here document „ÄÇ Â§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇEOF print &lt;&lt;\"EOF\"; # ‰∏é‰∏äÈù¢Áõ∏Âêå ËøôÊòØÁ¨¨‰∫åÁßçÊñπÂºèÂàõÂª∫here document „ÄÇ Â§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇEOF print &lt;&lt;`EOC` # ÊâßË°åÂëΩ‰ª§ echo hi there echo lo thereEOC print &lt;&lt;\"foo\", &lt;&lt;\"bar\" # ÊÇ®ÂèØ‰ª•ÊääÂÆÉ‰ª¨ËøõË°åÂ†ÜÂè† I said foo.foo I said bar.bar","text":"ÂâçË®Ä Áî±‰∫éÈÄâ‰∫ÜCSC517ÁöÑoopÈúÄË¶ÅÁî®rubyÊù•ÂÅöprojectÔºåËôΩÁÑ∂rubyËæÉ‰∏∫ÂÜ∑Èó®Ôºå‰ΩÜÊòØÂ§öÂ≠¶‰∏ÄÈó®ËØ≠Ë®ÄÊÄªÊòØÂ•ΩÁöÑ„ÄÇ ÁéØÂ¢ÉËÆæÁΩÆ‰ª•Âèä‰∏Ä‰∫õÂü∫Êú¨Êìç‰ΩúÂ∞±Ë∑≥Ëøá‰∫Ü„ÄÇ Ruby ËØ≠Ê≥ï ruby‰∏≠ËæìÂá∫Áî®puts puts \"Hello Ruby!\" Ruby‰∏≠ÁöÑË°åÂ∞æ ruby‰∏≠Áî®ÂàÜÂè∑ÔºõÊàñËÄÖÊç¢Ë°åÁ¨¶\\nÊù•Ë°®Á§∫Ë°åÂ∞æ„ÄÇ Ruby‰∏≠ÁöÑHere Document Here Document&quot; ÊòØÊåáÂª∫Á´ãÂ§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇ Âú® &lt;&lt; ‰πãÂêéÔºåkÂèØ‰ª•ÊåáÂÆö‰∏Ä‰∏™Â≠óÁ¨¶‰∏≤ÊàñÊ†áËØÜÁ¨¶Êù•ÁªàÊ≠¢Â≠óÁ¨¶‰∏≤Ôºå‰∏îÂΩìÂâçË°å‰πãÂêéÁõ¥Âà∞ÁªàÊ≠¢Á¨¶‰∏∫Ê≠¢ÁöÑÊâÄÊúâË°åÊòØÂ≠óÁ¨¶‰∏≤ÁöÑÂÄº„ÄÇ Â¶ÇÊûúÁªàÊ≠¢Á¨¶Áî®ÂºïÂè∑Êã¨Ëµ∑ÔºåÂºïÂè∑ÁöÑÁ±ªÂûãÂÜ≥ÂÆö‰∫ÜÈù¢ÂêëË°åÁöÑÂ≠óÁ¨¶‰∏≤Á±ªÂûã„ÄÇÊ≥®ÊÑè&lt;&lt; ÂíåÁªàÊ≠¢Á¨¶‰πãÈó¥ÂøÖÈ°ªÊ≤°ÊúâÁ©∫Ê†º. #!/usr/bin/ruby -w# -*- coding : utf-8 -*- print &lt;&lt;EOF ËøôÊòØÁ¨¨‰∏ÄÁßçÊñπÂºèÂàõÂª∫here document „ÄÇ Â§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇEOF print &lt;&lt;\"EOF\"; # ‰∏é‰∏äÈù¢Áõ∏Âêå ËøôÊòØÁ¨¨‰∫åÁßçÊñπÂºèÂàõÂª∫here document „ÄÇ Â§öË°åÂ≠óÁ¨¶‰∏≤„ÄÇEOF print &lt;&lt;`EOC` # ÊâßË°åÂëΩ‰ª§ echo hi there echo lo thereEOC print &lt;&lt;\"foo\", &lt;&lt;\"bar\" # ÊÇ®ÂèØ‰ª•ÊääÂÆÉ‰ª¨ËøõË°åÂ†ÜÂè† I said foo.foo I said bar.bar Ruby ‰∏≠ÁöÑBEGIN/END ËØ≠Âè• BEGIN&#123; cdoe&#125; Ë°®Á§∫code‰ºöÂú®Á®ãÂ∫èËøêË°å‰πãÂâçË∞ÉÁî® ‰æãÂ≠êÔºö puts \"this is main code\"BEGIN&#123; puts \"this is begin code\"&#125; ÁªìÊûúÔºö this is begin codethis is main code END&#123; CODE&#125; Ë°®Êòécode‰ºöÂú®Á®ãÂ∫èËøêË°å‰πãÂêéË∞ÉÁî® ‰æãÂ≠êÔºö END&#123; puts \"this is END code\"&#125;puts \"this is main code\"BEGIN&#123; puts \"this is begin code\"&#125; ÁªìÊûúÔºö this is begin codethis is main code this is end code Ruby ‰∏≠ÁöÑÊï∞ÁªÑ Êï∞ÁªÑÂ≠óÈù¢ÈáèÈÄöËøá[]‰∏≠‰ª•ÈÄóÂè∑ÂàÜÈöîÂÆö‰πâÔºå‰∏îÊîØÊåÅrangeÂÆö‰πâ„ÄÇ Ôºà1ÔºâÊï∞ÁªÑÈÄöËøá[]Á¥¢ÂºïËÆøÈóÆ Ôºà2ÔºâÈÄöËøáËµãÂÄºÊìç‰ΩúÊèíÂÖ•„ÄÅÂà†Èô§„ÄÅÊõøÊç¢ÂÖÉÁ¥† Ôºà3ÔºâÈÄöËøá+ÔºåÔºçÂè∑ËøõË°åÂêàÂπ∂ÂíåÂà†Èô§ÂÖÉÁ¥†Ôºå‰∏îÈõÜÂêàÂÅö‰∏∫Êñ∞ÈõÜÂêàÂá∫Áé∞ Ôºà4ÔºâÈÄöËøá&lt;&lt;Âè∑ÂêëÂéüÊï∞ÊçÆËøΩÂä†ÂÖÉÁ¥† Ôºà5ÔºâÈÄöËøá*Âè∑ÈáçÂ§çÊï∞ÁªÑÂÖÉÁ¥† Ôºà6ÔºâÈÄöËøáÔΩúÂíå&amp;Á¨¶Âè∑ÂÅöÂπ∂ÈõÜÂíå‰∫§ÈõÜÊìç‰ΩúÔºàÊ≥®ÊÑèÈ°∫Â∫èÔºâ ‰∏ãÈù¢‰æãÂ≠êÂÆåÊàê‰∫ÜÊï∞ÁªÑÁöÑÈ°∫Â∫èËæìÂá∫Ôºö arr = [\"a\",\"bbb\",\"123\",\"null\",]arr.each do |i| puts iend RubyÁöÑÂìàÂ∏åÁ±ªÂûã Ruby ÂìàÂ∏åÊòØÂú®Â§ßÊã¨Âè∑ÂÜÖÊîæÁΩÆ‰∏ÄÁ≥ªÂàóÈîÆ/ÂÄºÂØπÔºåÈîÆÂíåÂÄº‰πãÈó¥‰ΩøÁî®ÈÄóÂè∑ÂíåÂ∫èÂàó =&gt; ÂàÜÈöî„ÄÇÂ∞æÈÉ®ÁöÑÈÄóÂè∑‰ºöË¢´ÂøΩÁï•„ÄÇ hsh = colors = &#123;\"red\" =&gt; 0xf00, \"green\" =&gt; 0x0f0, \"blue\" =&gt; 0x00f&#125;hsh.each do |key,value| pring key,\"is\",value,\"\\n\"end Ruby ËåÉÂõ¥Á±ªÂûã ‰∏Ä‰∏™ËåÉÂõ¥Ë°®Á§∫‰∏Ä‰∏™Âå∫Èó¥„ÄÇ ËåÉÂõ¥ÊòØÈÄöËøáËÆæÁΩÆ‰∏Ä‰∏™ÂºÄÂßãÂÄºÂíå‰∏Ä‰∏™ÁªìÊùüÂÄºÊù•Ë°®Á§∫„ÄÇËåÉÂõ¥ÂèØ‰ΩøÁî® s‚Ä¶e Âíå s‚Ä¶e Êù•ÊûÑÈÄ†ÔºåÊàñËÄÖÈÄöËøá Range.new Êù•ÊûÑÈÄ†„ÄÇ ‰ΩøÁî® ‚Ä¶ ÊûÑÈÄ†ÁöÑËåÉÂõ¥‰ªéÂºÄÂßãÂÄºËøêË°åÂà∞ÁªìÊùüÂÄºÔºàÂåÖÂê´ÁªìÊùüÂÄºÔºâ„ÄÇ‰ΩøÁî® ‚Ä¶ ÊûÑÈÄ†ÁöÑËåÉÂõ¥‰ªéÂºÄÂßãÂÄºËøêË°åÂà∞ÁªìÊùüÂÄºÔºà‰∏çÂåÖÂê´ÁªìÊùüÂÄºÔºâ„ÄÇÂΩì‰Ωú‰∏∫‰∏Ä‰∏™Ëø≠‰ª£Âô®‰ΩøÁî®Êó∂ÔºåËåÉÂõ¥‰ºöËøîÂõûÂ∫èÂàó‰∏≠ÁöÑÊØè‰∏™ÂÄº„ÄÇ ËåÉÂõ¥ (1‚Ä¶5) ÊÑèÂë≥ÁùÄÂÆÉÂåÖÂê´ÂÄº 1, 2, 3, 4, 5 ËåÉÂõ¥ (1‚Ä¶5) ÊÑèÂë≥ÁùÄÂÆÉÂåÖÂê´ÂÄº 1, 2, 3, 4 (10..15).each do|i| print i,' 'end ËæìÂá∫‰∏∫ 10 11 12 13 14 15","categories":[{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/categories/ruby/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/tags/ruby/"},{"name":"OOP","slug":"OOP","permalink":"WangHngLeee.github.io/tags/OOP/"}]},{"title":"Leetcode EveryDay 30","slug":"leetcode30","date":"2019-08-22T13:25:09.000Z","updated":"2020-02-03T01:16:22.106Z","comments":true,"path":"2019/08/22/leetcode30/","link":"","permalink":"WangHngLeee.github.io/2019/08/22/leetcode30/","excerpt":"560. Subarray Sum Equals K class soluiton&#123; public int subarray(int[] nums, int k)&#123; if(nums.length == 0) return 0; int sum = 0, res = 0; map.put(0,1); for(int cur ; nums)&#123; sum+=cur; if(map.containsKey(sum-k))res+=map.get(sum-k); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return res; &#125;&#125; presum + hashmap ÁöÑÊñπÊ≥ï sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmapÁöÑkey --&gt; hashmapÁöÑkey = sum - k hashmap‰∏≠Â≠òÁöÑÊòØ&lt;sum,sumÂá∫Áé∞ÁöÑÊ¨°Êï∞&gt;Ôºõ","text":"560. Subarray Sum Equals K class soluiton&#123; public int subarray(int[] nums, int k)&#123; if(nums.length == 0) return 0; int sum = 0, res = 0; map.put(0,1); for(int cur ; nums)&#123; sum+=cur; if(map.containsKey(sum-k))res+=map.get(sum-k); map.put(sum,map.getOrDefault(sum,0)+1); &#125; return res; &#125;&#125; presum + hashmap ÁöÑÊñπÊ≥ï sum[i, j] = sum[0, j] - sum[0, i - 1] --&gt; sum[0, i - 1] = sum[0, j] - sum[i, j] k sum hashmapÁöÑkey --&gt; hashmapÁöÑkey = sum - k hashmap‰∏≠Â≠òÁöÑÊòØ&lt;sum,sumÂá∫Áé∞ÁöÑÊ¨°Êï∞&gt;Ôºõ 547. Friend Circles class solution&#123; public int findfriend(int[][] M)&#123; boolean[] visited = new boolean[M.length]; int count = 0; for(int i = 0 ; i &lt; M.length; i++)&#123; if(!visited[i])&#123; dfs(M,visited,i); count++; &#125; &#125; return count; &#125; private void dfs(int[][] M,boolean[] visited, int person)&#123; for(int other = 0; other &lt; M.length; other++)&#123; if(M[person][other] == 1 &amp;&amp; !visited[other])&#123; visited[other] = true; dfs(M,visited,other); &#125; &#125; &#125;&#125; ÊÉ≥Ë±°Êàê‰∏Ä‰∏™Áü©ÈòµÔºåÂ∑¶ËæπÊòØpersonÔºå‰∏äÈù¢ÊòØotherÔºàÁõ∏ÂØπÁöÑÔºâÔºåÁÑ∂ÂêéÂÖà‰ªépersonÂºÄÂßãdfsÔºådfs‰∏≠ÂèàÈÄíÂΩíÂú∞ÂØπpersonÂØπÂ∫îÁöÑotherËøõË°ådfsÔºå Â∞ÜËøô‰∏™otherÁúãÊàêÊñ∞ÁöÑpersonËøõË°ådfsÔºåÊúâÁÇπÁ±ª‰ººÂõûÂêàÂà∂Ôºåperson - other - person - other ÈÉΩÊòØÁõ∏ÂØπÁöÑ„ÄÇ 652. Find Duplicate Subtrees class solution&#123; public List&lt;TreeNode&gt; findduplicate(TreeNode root)&#123; List&lt;TreeNode&gt; res = new LinkedList&lt;&gt;(); fint(root,new HashMap&lt;&gt;(),res); return res; &#125; public String find(TreeNode cur, Map&lt;String&gt; map, List&lt;TreeNode&gt; res)&#123; if(cur == null)return \"#\"; String temp = cur.val + \",\" + find(cur.left,map,res) + \",\" + find(cur.right,map,res); if(map.getOrDefault(temp,0) == 1)res.add(cur); map.put(temp,map.getOrDefault(temp,0)+1); return temp; &#125;&#125; ‰ΩøÁî®hashmapËÆ∞ÂΩïÊØè‰∏™Â≠êÊ†ëÁªèËøáÂìàÂ∏åÂêéÁöÑÊï∞ÈáèÔºåÂìàÂ∏åÊñπÊ≥ïÂèØ‰ª•Áî®ÊúÄÁÆÄÂçïÁöÑÂâçÂ∫èÈÅçÂéÜÔºåÂç≥ Ê†π,Â∑¶Â≠êÊ†ë,Âè≥Â≠êÊ†ë ÁöÑÊñπÂºèÈÄíÂΩíÊûÑÈÄ†„ÄÇ Ëã•ÂèëÁé∞ÂΩìÂâçÂ≠êÊ†ëÂú®ÂìàÂ∏åË°®Á¨¨‰∫åÊ¨°Âá∫Áé∞ÔºåÂàôÂ∞ÜËØ•ÁªìÁÇπËÆ∞ÂÖ•resÂàóË°®„ÄÇ 187. Repeated DNA Sequences class solution&#123; public List&lt;String&gt; find(String s)&#123; Set seen = new Hashset(); Set repeated = new Hashset(); for(int i = 0; i+9&lt;s.length();i++)&#123; String ten = s.substring(i,i+10); if(!seen.add(ten))&#123; repeated.add(ten); &#125; &#125; return new ArrayList(repeated); &#125;&#125; Âà©Áî®hashset‰∏çËÉΩÊ∑ªÂä†ÈáçÂ§çÂÖÉÁ¥†ÁöÑÁâπÂæÅÂíåsliding windowÁªìÂêàÁöÑÊñπÊ≥ïÔºå‰ªéiÂà∞i+10ÁöÑËåÉÂõ¥ÂÜÖÊâ´Êèè Â¶ÇÊûúseenÈáåÈù¢‰∏çËÉΩÊ∑ªÂä†ËØ•10‰ΩçstringÔºåË°®ÊòéÂ∑≤ÁªèÊúâËøáÔºåÊâÄ‰ª•Ê∑ªÂä†Âà∞repeated‰∏≠„ÄÇ 1.Two Sum class solution&#123; public twosum(int[]nums,int target)&#123; int[]res = new int[2]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i = 0; i &lt;nums.length;i++)&#123; if(map.containsKey(target - nums[i]))&#123; res[1] = i; res[0] = map.get(target - nums[i]); return res; &#125; map.put(nums[i],i); &#125; &#125;&#125; ÁªèÂÖ∏ÁöÑtwo sumÔºåjavaÁâàÊú¨Ê≥®ÊÑèÂÆö‰πâhashmapÁöÑÂÜôÊ≥ï„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 29","slug":"leetcode29","date":"2019-08-05T12:25:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/08/05/leetcode29/","link":"","permalink":"WangHngLeee.github.io/2019/08/05/leetcode29/","excerpt":"","text":"Permutations II (contains duplicates) class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, boolean[nums.length]); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist, int[] nums, boolean[] used)&#123; if(templist.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(templist)); &#125;else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1])continue; used[i] = true; templist.add(nums[i]); backtrack(list,templist,nums,used); used[i] = false; templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Ë∑ü PermutationsÁöÑËß£Ê≥ï‰∏ÄÊ†∑ÔºåÂ∞±ÊòØË¶ÅËÄÉËôë‚ÄúÂéªÈáç‚Äù„ÄÇÂÖàÂØπÊï∞ÁªÑËøõË°åÊéíÂ∫èÔºåËøôÊ†∑Âú®DFSÁöÑÊó∂ÂÄôÔºåÂèØ‰ª•ÂÖàÂà§Êñ≠ÂâçÈù¢ÁöÑ‰∏Ä‰∏™Êï∞ÊòØÂê¶ÂíåËá™Â∑±Áõ∏Á≠âÔºåÁõ∏Á≠âÁöÑÊó∂ÂÄôÂàôÂâçÈù¢ÁöÑÊï∞ÂøÖÈ°ª‰ΩøÁî®‰∫ÜÔºåËá™Â∑±ÊâçËÉΩ‰ΩøÁî®ÔºåËøôÊ†∑Â∞±‰∏ç‰ºö‰∫ßÁîüÈáçÂ§çÁöÑÊéíÂàó‰∫Ü„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 28","slug":"leetcode28","date":"2019-08-05T00:35:09.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/08/04/leetcode28/","link":"","permalink":"WangHngLeee.github.io/2019/08/04/leetcode28/","excerpt":"38. Count and Say class solution&#123; public String countandsay(int n)&#123; if(n&lt;=0)return -1; String res = '1'; for(int i = 1; i&lt;n; i++)&#123; res = build(res); &#125; return res; &#125; private build(String res)&#123; StringBuiler sb = new StringBuilder(); int idx = 0; while(idx&lt;res.length)&#123; char val = res.charAt(idx); int count = 0; while(idx &lt; res.length &amp;&amp; res.charAt(p) == val )&#123; p++; count++; &#125; sb.append(String.valueOf(count); sb.append(val); &#125; return sb.toString(); &#125;&#125; ÂàùÂßãÂè™Êúâ‰∏Ä‰∏™1ÔºåÁÑ∂ÂêéËÆ°ÁÆóÁõ∏ÂêåÊï∞Â≠óÁöÑ‰∏™Êï∞countÔºåÁÑ∂ÂêéÂ∞ÜcountÂíåÂΩìÂâçvalÁöÑÂÄºÂä†ÂÖ•res‰∏≠ÔºåÁªßÁª≠Âæ™ÁéØËÆ°ÁÆó„ÄÇ 1 11 21 1211 111221 312211 ‚Ä¶ 1 ‰∏Ä‰∏™1(11) ‰∏§‰∏™1(21) ‰∏Ä‰∏™2‰∏Ä‰∏™1(1211) ‰∏Ä‰∏™1‰∏Ä‰∏™2‰∏§‰∏™1(111221) ‰∏â‰∏™1‰∏§‰∏™2‰∏Ä‰∏™1(312211)‚Ä¶","text":"38. Count and Say class solution&#123; public String countandsay(int n)&#123; if(n&lt;=0)return -1; String res = '1'; for(int i = 1; i&lt;n; i++)&#123; res = build(res); &#125; return res; &#125; private build(String res)&#123; StringBuiler sb = new StringBuilder(); int idx = 0; while(idx&lt;res.length)&#123; char val = res.charAt(idx); int count = 0; while(idx &lt; res.length &amp;&amp; res.charAt(p) == val )&#123; p++; count++; &#125; sb.append(String.valueOf(count); sb.append(val); &#125; return sb.toString(); &#125;&#125; ÂàùÂßãÂè™Êúâ‰∏Ä‰∏™1ÔºåÁÑ∂ÂêéËÆ°ÁÆóÁõ∏ÂêåÊï∞Â≠óÁöÑ‰∏™Êï∞countÔºåÁÑ∂ÂêéÂ∞ÜcountÂíåÂΩìÂâçvalÁöÑÂÄºÂä†ÂÖ•res‰∏≠ÔºåÁªßÁª≠Âæ™ÁéØËÆ°ÁÆó„ÄÇ 1 11 21 1211 111221 312211 ‚Ä¶ 1 ‰∏Ä‰∏™1(11) ‰∏§‰∏™1(21) ‰∏Ä‰∏™2‰∏Ä‰∏™1(1211) ‰∏Ä‰∏™1‰∏Ä‰∏™2‰∏§‰∏™1(111221) ‰∏â‰∏™1‰∏§‰∏™2‰∏Ä‰∏™1(312211)‚Ä¶ 49. Group Anagrams class solution&#123; public List&lt;List&lt;String&gt;&gt; groupanagrams(String[] strs)&#123; Map&lt;String,List&lt;String&gt;&gt; map = new HashMap(); for(String s : strs)&#123; int[] arr = new int[26]; for(int i = 0; i &lt; s.length();i++)&#123; arr[s.charAt(i)-'a']++; &#125; String key = Arrays.toString(arr); List&lt;String&gt; temp = map.getOrDefault(key, new LinkedList&lt;String&gt;()); temp.add(s); map.put(key,temp); &#125; return new LinkedList&lt;&gt;map.values(); &#125;&#125; Áî®hashmapÂ≠ò‰Ωè26‰∏™Â≠óÊØçÁöÑÈ°∫Â∫è‰∏™Êï∞ÔºåÂΩìÂÅökeyÔºåÂÜçÂêéÈù¢Âæ™ÁéØ‰∏≠Âè™ÈúÄË¶ÅÂØπÊØîÊØè‰∏™stringÁöÑÂ≠óÊØç‰∏™Êï∞È°∫Â∫èÂç≥ÂèØ„ÄÇÁõ∏ÂêåÁöÑÊîæÂú®Âêå‰∏Ä‰∏™temp‰∏≠ÔºåÂπ∂‰∏îÊõ¥Êñ∞ËØ•keyÂØπÂ∫îÁöÑtempÁªÑ„ÄÇ 151. Reverse Words in a String class solution&#123; public String reversewords(String s)&#123; StingBuilder sb = new StringBuilder(); int l = s.length(); int m = l-1; while(m&gt;=0)&#123; if(s.charAt(m) == ' ')&#123; m--; continue; &#125; int n = m-1; while(s.charAt(n) != ' ' )&#123; n--; &#125; sb.append(' '); sb.append(s.substring(n+1,m+1)); m=n-1; &#125; if(sb.length()&gt;0)sb.deleteCharAt(0); return sb.toString(); &#125;&#125; Êï¥‰ΩìÊÄùË∑Ø‰ªéÂêéÂæÄÂâçÊâ´ÊèèÔºåi‰∏∫Á¨¨‰∏Ä‰∏™‰∏ç‰∏∫Á©∫Ê†ºÁöÑ‰ΩçÁΩÆÔºåj‰∏∫Á¨¨‰∏Ä‰∏™Á©∫Ê†ºÁöÑ‰ΩçÁΩÆÔºåÂ∞ÜsubstringÔºàj+1,i+1ÔºâÂä†ÂÖ•sb‰∏≠Ôºõ Ê≥®ÊÑèÂú®Âä†ÂÖ•substringÂâçÂÖàÂä†ÂÖ•‚Äô 'Ôºå‰øùËØÅÂêéÁª≠ÊØè‰∏™Â≠óÊÆµÂíå‰πãÂâçÈÉΩÊúâÁ©∫Ê†º„ÄÇÊúÄÂêéÂ∞ÜÁ¨¨‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÁ©∫Ê†ºdeleteÂç≥ÂèØ„ÄÇ 165. Compare Version Numbers class solution&#123; public int compare(String version1, String version2)&#123; String[] v1 = version1.split('\\\\.'); String[] v2 = version2.split('\\\\.'); int n = Math.max(v1.length,v2.length); for(int i = 0; i&lt;n;i++)&#123; int num1 = i&lt;v1.length ? Integer.parseInt(v1[i]) : 0; int num2 = i&lt;v2.length ? Integer.parseInt(v2[i]) : 0; if(num1 &gt; num2)return '1'; else if(num1 &lt; num2) return'-1'; else continue; &#125; return 0; &#125;&#125; java‰∏≠Âà©Áî®\\.Êù•ÂàÜÂâ≤. ÂàÜÂâ≤ÂêéÊØè‰∏ÄÈ°πËøõË°åÂØπÊØîÔºåÊ≥®ÊÑèparseIntÁî®Ê≥ï„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 27","slug":"leetcode27","date":"2019-08-02T16:35:09.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/08/02/leetcode27/","link":"","permalink":"WangHngLeee.github.io/2019/08/02/leetcode27/","excerpt":"6. ZigZag Conversion class solution&#123; public String convert(String s, int numRows)&#123; int idx = 0; StringBuilder[] sb = new StringBuilder[numRows]; for(int i = 0 ; i &lt; numRows ; i++)sb[i] = new StringBuilder(); while(idx&lt;s.length())&#123; for(int i = 0; i&lt;numRows &amp;&amp; idx&lt; s.length(); i++)sb[i].append(s.charAt(idx++));// Á´ñÁõ¥ÊñπÂêëÂ¢ûÂä† for(int i = numRows - 2 ; i&gt;0 &amp;&amp; idx&lt; s.length(); i-- ) sb[i].append(s.charAt(idx++));//ÊñúÂêëÂ¢ûÂä† &#125; StringBuilder res = new StringBuilder(); for(int i = 0 ;i&lt;sb.length; i++)res.append(sb[i]); return res.toString(); &#125;&#125; zagzigÊñπÊ≥ïÂÆûÈôÖ‰∏äÂ∞±ÊòØÊåâÁÖßÈ°∫Â∫èÂú®ÊØè‰∏ÄË°å‰∏äÂ¢ûÂä†ÂÖÉÁ¥†„ÄÇ ÂàÜÊÉÖÂÜµÔºåÁ´ñÁõ¥ÊñπÂêëÂ¢ûÂä†ÂêéÂÜçÊñúÂêëÂ¢ûÂä†„ÄÇÂæ™ÁéØÂç≥ÂèØ„ÄÇ","text":"6. ZigZag Conversion class solution&#123; public String convert(String s, int numRows)&#123; int idx = 0; StringBuilder[] sb = new StringBuilder[numRows]; for(int i = 0 ; i &lt; numRows ; i++)sb[i] = new StringBuilder(); while(idx&lt;s.length())&#123; for(int i = 0; i&lt;numRows &amp;&amp; idx&lt; s.length(); i++)sb[i].append(s.charAt(idx++));// Á´ñÁõ¥ÊñπÂêëÂ¢ûÂä† for(int i = numRows - 2 ; i&gt;0 &amp;&amp; idx&lt; s.length(); i-- ) sb[i].append(s.charAt(idx++));//ÊñúÂêëÂ¢ûÂä† &#125; StringBuilder res = new StringBuilder(); for(int i = 0 ;i&lt;sb.length; i++)res.append(sb[i]); return res.toString(); &#125;&#125; zagzigÊñπÊ≥ïÂÆûÈôÖ‰∏äÂ∞±ÊòØÊåâÁÖßÈ°∫Â∫èÂú®ÊØè‰∏ÄË°å‰∏äÂ¢ûÂä†ÂÖÉÁ¥†„ÄÇ ÂàÜÊÉÖÂÜµÔºåÁ´ñÁõ¥ÊñπÂêëÂ¢ûÂä†ÂêéÂÜçÊñúÂêëÂ¢ûÂä†„ÄÇÂæ™ÁéØÂç≥ÂèØ„ÄÇ 12345678996 1 5 9 159numRows=3 ==&gt; 2 4 6 8 9 ==&gt; 24689 3 7 6 376 3. Longest Substring Without Repeating Characters class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0)return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max = 0; for(int i = 0,j=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i)) + 1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max; &#125;&#125; ÂèåÊåáÈíàÔºåiÂÖàÂêëÂâçÊâ´ÊèèÔºåÂ¶ÇÊûúhashmapÂ∑≤ÁªèÂ≠òÂú®ÂΩìÂâçiÂÖÉÁ¥†ÔºåjÂàôË∑≥ËøáÂΩìÂâçÂÖÉÁ¥†Âà∞max(j,i+1)ÁöÑ‰ΩçÁΩÆ„ÄÇÁÑ∂ÂêéÂ≠ò‰ΩèÂΩìÂâçiÁöÑÂÖÉÁ¥†ÔºåÊõ¥Êñ∞max„ÄÇ 273. Integer to English Words class Solution &#123; private final String[] belowTen = new String[] &#123; \"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"&#125;; private final String[] belowTwenty = new String[] &#123;\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"&#125;; private final String[] belowHundred = new String[] &#123;\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"&#125;; public String numberToWords(int num) &#123; if (num == 0) return \"Zero\"; return helper(num); &#125; private String helper(int num) &#123; String result = new String(); if (num &lt; 10) result = belowTen[num]; else if (num &lt; 20) result = belowTwenty[num -10]; else if (num &lt; 100) result = belowHundred[num/10] + \" \" + helper(num % 10); else if (num &lt; 1000) result = helper(num/100) + \" Hundred \" + helper(num % 100); else if (num &lt; 1000000) result = helper(num/1000) + \" Thousand \" + helper(num % 1000); else if (num &lt; 1000000000) result = helper(num/1000000) + \" Million \" + helper(num % 1000000); else result = helper(num/1000000000) + \" Billion \" + helper(num % 1000000000); return result.trim(); &#125;&#125; È¶ñÂÖàÂª∫Á´ãÂ≠óÁ¨¶Ë°®ÔºåÊ≥®ÊÑèÂâçÈù¢Êúâ&quot;&quot;„ÄÇÁÑ∂ÂêéÂêÑËá™ÈÄíÂΩíË∞ÉÁî®helperÂáΩÊï∞ÔºåÈÄêÊ∏êÁº©Â∞èÊï∞ÂÄºÂπ∂ÊâæÂà∞ÂØπÂ∫îÁöÑÂçï‰Ωç„ÄÇ class Trie &#123; TrieNode head; /** Initialize your data structure here. */ public Trie() &#123; head = new TrieNode(); &#125; public void insert(String word) &#123; if(word == null)return; TrieNode node = head; for(char ch: word.toCharArray())&#123; if(!node.charToNode.containsKey(ch))&#123; node.charToNode.put(ch,new TrieNode()); &#125; node = node.charToNode.get(ch); &#125; node.isend = true; &#125; public boolean search(String word) &#123; TrieNode node = head; for(char ch : word.toCharArray()) &#123; if(!node.charToNode.containsKey(ch))&#123; return false; &#125; node = node.charToNode.get(ch); &#125; return node.isend; &#125; public boolean startsWith(String prefix) &#123; if(prefix == null) return false; TrieNode node = head; for(char ch : prefix.toCharArray()) &#123; if(!node.charToNode.containsKey(ch))&#123; return false; &#125; node = node.charToNode.get(ch); &#125; return true; &#125; class TrieNode&#123; Map&lt;Character, TrieNode&gt; charToNode; boolean isend = false; public TrieNode()&#123; charToNode = new HashMap(); &#125; &#125;&#125;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ ÂÆûÁé∞TrieÁªìÊûÑÔºåÂÆûÁé∞Âõõ‰∏™ÂäüËÉΩ„ÄÇÊ≥®ÊÑèÊúÄÂêéÁöÑclass TrieNodeÈáåÁöÑÂÆö‰πâ„ÄÇ 1.Âè™ÊúâÂà∞ÊúÄÂêé‰∏Ä‰∏™Â≠óÊØçÊó∂ÊâçÂ∞ÜisendÊîπ‰∏∫trueÔºåÂÖ∂‰ΩôÈÉΩ‰∏∫false„ÄÇ 2.Áî®mapÂ≠ò‰ΩèÊØè‰∏™ÂÖÉÁ¥†ÔºåÂπ∂‰∏îÂà©Áî®getÂíåcontainsKeyÊù•Êõ¥Êñ∞nodeÂíåÊü•ËØ¢ÊòØÂê¶Â≠òÂú®ÂΩìÂâçÂ≠óÊØç„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 26","slug":"leetcode26","date":"2019-06-25T12:35:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/06/25/leetcode26/","link":"","permalink":"WangHngLeee.github.io/2019/06/25/leetcode26/","excerpt":"100. Same Tree class solution&#123; public boolean issameTree(TreeNode p,TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val)&#123; return issameTree(q.left,p.left) &amp;&amp; issameTree(q.right,p.right); &#125; return false; &#125;&#125; ÈÄíÂΩíÂà§Êñ≠ÊØè‰∏™ËäÇÁÇπÊòØÂê¶ÈÉΩÁõ∏ÂêåÔºåÊØîËæÉÁÆÄÂçï„ÄÇ","text":"100. Same Tree class solution&#123; public boolean issameTree(TreeNode p,TreeNode q)&#123; if(p == null &amp;&amp; q == null) return true; if(p == null || q == null) return false; if(p.val == q.val)&#123; return issameTree(q.left,p.left) &amp;&amp; issameTree(q.right,p.right); &#125; return false; &#125;&#125; ÈÄíÂΩíÂà§Êñ≠ÊØè‰∏™ËäÇÁÇπÊòØÂê¶ÈÉΩÁõ∏ÂêåÔºåÊØîËæÉÁÆÄÂçï„ÄÇ 106. Construct Binary Tree from Inorder and Postorder Traversal(Inorder/Postorder Tree Transform) /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; int indexp; int indexi; private TreeNode buildTree(int[] inorder,int[] postorder, TreeNode end)&#123; if(indexp&lt;0)return null; TreeNode n = new TreeNode(posrorder[indexp]); indexp--; if(inorder[indexi] != n.val)&#123; n.left=buildTree(inorder,posrorder,n); &#125; indexi--; if((end == null) || (inorder[indexi] != end.val))&#123; n.right = buildTree(inorder, posrorder, null); &#125; return n; &#125; public TreeNode buildTree(int[] inorder, int[]postorder)&#123; indexp = posrorder.length -1 ; indexi = inorder.length -1; return buildTree(inorder, postorder, null); &#125; &#125; ÁªôÂÆöpostorderÂíåinorderÁöÑÊ†ëÁªìÊûÑÔºåËæìÂá∫Ê≠£Á°ÆÁöÑÊ†ëÁªìÊûÑ„ÄÇpost‰∏≠ÊúÄÂêé‰∏Ä‰ΩçÊòØrootÔºåËøõËÄåÂú®inorder‰∏≠ÊâærootÁöÑ‰ΩçÁΩÆÔºåÂà§Êñ≠ÊúâÊó†Â∑¶Âè≥Â≠êÊ†ë„ÄÇ Ëã•ÊúâÂ∑¶Â≠êÊ†ëÔºåÂàôÂ∞ÜÂΩìÂâçÁöÑn‰Ωú‰∏∫endÊù•ÈÄíÂΩíÔºõËã•ÊúâÂè≥Â≠êÊ†ëÔºåÂàôÂ∞ÜendÈáçÊñ∞ËÆæ‰∏∫null„ÄÇ ÊÄªÁªì‰∏Ä‰∏ãÂ∏∏ËßÅÁöÑ‰∏âÁßçorder traversal 94. Binary Tree Inorder Traversal public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while(root != null || !stack.empty())&#123; while(root != null)&#123; stack.push(root); root = root.left; &#125; root = stack.pop(); res.add(root.val); root = root.right; &#125; return res;&#125; inorderË¶ÅÈÅçÂéÜÂÆåÊâÄÊúâÁöÑÂ∑¶Â≠êÊ†ëÂÜçÈÅçÂéÜÊ†πËäÇÁÇπ„ÄÇ 144. Binary Tree Preorder Traversal public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; root = stack.pop(); res.add(root.val); if(root.right != null) stack.push(root.right); if(root.left != null) stack.push(root.left); &#125; return res;&#125; preorder Ê†π-Â∑¶-Âè≥ÔºåstackÂÖàÂ≠òrightÂÜçÂ≠òleftÔºå‰øùËØÅpopÊó∂ÂÖàÂ∑¶ÂêéÂè≥ 145. Binary Tree Postorder Traversal public class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if (root == null) return res; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.push(root); while (!stack.isEmpty())&#123; root = stack.pop(); res.addFirst(root.val); if (root.left != null) stack.push(root.left ); if (root.right != null) stack.push(root.right); &#125; return res; &#125;&#125; postÂ∑¶-Âè≥-Ê†πÔºåÂà©Áî®addfirstÊñπÊ≥ïÔºå‰∏çÊñ≠Êõ¥Êñ∞linkedlist„ÄÇËøôÊó∂pushÁöÑÈ°∫Â∫èÂ∫îËØ•ÂÖàÂ∑¶ÂêéÂè≥„ÄÇÂõ†‰∏∫pushÂêéË¶ÅËøõË°åaddfirstÔºåpopÂá∫Âè≥„ÄÇaddfirstÔºõÂÜçpopleftÔºåaddfirstÂêéÊ≠§Êó∂leftÂ∑≤ÁªèÂà∞‰∫ÜrightÂâçÈù¢ÔºåÁ¨¶ÂêàpostË¶ÅÊ±Ç„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 25","slug":"leetcode25","date":"2019-06-21T12:35:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/06/21/leetcode25/","link":"","permalink":"WangHngLeee.github.io/2019/06/21/leetcode25/","excerpt":"115. Distinct SubsequencesÔºàDP) class solution&#123; public distinctsu(String s, String t)&#123; int[][] mem = new int[t.length()+1][s.length()+1]; for(int i=0;i&lt;=s.length();i++)&#123; mem[0][i] = 1; &#125; for(int i=0;i&lt;t.length();t++)&#123; for(int j=;j&lt;s.length();j++)&#123; if(t.charAt(i)==s.charAt(j))&#123; mem[i+1][j+1]=mem[i][j]+mem[i+1][j]; &#125;else&#123; mem[i+1][j+1]=mem[i+1][j]; &#125; &#125; &#125; return mem[t.length()][s.length()]; &#125;&#125; dpÊÄùË∑Ø„ÄÇÂ§ßÁ•ûÁöÑÊÄùË∑ØÊ∞∏ËøúÈÉΩÊòØÁÆÄÂçïËÄåÂèàÈúáÊíº‚Üíleetcode 115. dpÈ¢òÂÅöÂ§ö‰∫Ü‰ºöÂèëÁé∞Â§ß‰Ωì‰∏äÁöÑÁ®ãÂ∫èÁªìÊûÑÂü∫Êú¨ÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ 1.Êñ∞Âª∫‰∫å/‰∏âÁª¥Êï∞ÁªÑÔºåÂπ∂ÂàùÂßãÂåñËæπÁïå„ÄÇ 2.Âæ™ÁéØÊâ´ÊèèÔºå‰∏ÄËà¨ÊòØi+1\\j+1ÁöÑ‰ΩçÁΩÆÂíåÂ∑¶‰∏äËßí/‰∏äÊñπ/Â∑¶ÊñπÁöÑ‰ΩçÁΩÆËøõË°åÊìç‰Ωú„ÄÇ 3.ËøîÂõûÊúÄÂêé‰ΩçÁΩÆÁöÑÁä∂ÊÄÅ„ÄÇ","text":"115. Distinct SubsequencesÔºàDP) class solution&#123; public distinctsu(String s, String t)&#123; int[][] mem = new int[t.length()+1][s.length()+1]; for(int i=0;i&lt;=s.length();i++)&#123; mem[0][i] = 1; &#125; for(int i=0;i&lt;t.length();t++)&#123; for(int j=;j&lt;s.length();j++)&#123; if(t.charAt(i)==s.charAt(j))&#123; mem[i+1][j+1]=mem[i][j]+mem[i+1][j]; &#125;else&#123; mem[i+1][j+1]=mem[i+1][j]; &#125; &#125; &#125; return mem[t.length()][s.length()]; &#125;&#125; dpÊÄùË∑Ø„ÄÇÂ§ßÁ•ûÁöÑÊÄùË∑ØÊ∞∏ËøúÈÉΩÊòØÁÆÄÂçïËÄåÂèàÈúáÊíº‚Üíleetcode 115. dpÈ¢òÂÅöÂ§ö‰∫Ü‰ºöÂèëÁé∞Â§ß‰Ωì‰∏äÁöÑÁ®ãÂ∫èÁªìÊûÑÂü∫Êú¨ÊòØ‰∏ÄÊ†∑ÁöÑ„ÄÇ 1.Êñ∞Âª∫‰∫å/‰∏âÁª¥Êï∞ÁªÑÔºåÂπ∂ÂàùÂßãÂåñËæπÁïå„ÄÇ 2.Âæ™ÁéØÊâ´ÊèèÔºå‰∏ÄËà¨ÊòØi+1\\j+1ÁöÑ‰ΩçÁΩÆÂíåÂ∑¶‰∏äËßí/‰∏äÊñπ/Â∑¶ÊñπÁöÑ‰ΩçÁΩÆËøõË°åÊìç‰Ωú„ÄÇ 3.ËøîÂõûÊúÄÂêé‰ΩçÁΩÆÁöÑÁä∂ÊÄÅ„ÄÇ 120. TriangleÔºàDP) class solution&#123; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle)&#123; if(triangle.size()==0) return 0; for(int i=triangle.size()-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;=i;j++)&#123; List&lt;Integer&gt; nextrow = triangle.get(i+1); int sum = Math.min(nextrow.get(j),nextrow.get(j+1))+triangle.get(i).get(j); triangle.get(i).set(j,sum); &#125; &#125; return triangle.get(0).get(0); &#125;&#125; dpÊÄùË∑Ø„ÄÇËá™‰∏ãËÄå‰∏äÂæ™ÁéØ„ÄÇ‰∫ÆÁÇπÊòØ‰∏çÁî®ÂçïÁã¨Â≠òÂÇ®sumÔºåÁõ¥Êé•Â∞ÜÈÄâÂèñÁöÑ‰ΩçÁΩÆÂ≠ò‰∏äÂΩìÂâçÁöÑsumÂÄºÔºåËäÇÁúÅÁ©∫Èó¥Â§çÊùÇÂ∫¶„ÄÇÊúÄÂêéËøîÂõûÊúÄ‰∏äÈù¢ÁöÑ‰ΩçÁΩÆÂç≥ÂèØÔºåÂ∞±ÊòØÊúÄÂêéÁöÑsum„ÄÇ 221. Maximal SquareÔºàDP) class solution&#123; public int maximalsquare(char[][] matrix)&#123; if(matrix.length == 0)return 0; int m = matrix.length,n=matrix[0].length,res = 0; int[][] ans = new int[m+1][n+1]; for(int i = 0; i&lt;=m;i++)&#123; for(int j = 0;j&lt;=n;j++)&#123; if(matrix[i-1][j-1]=='1')&#123; ans[i][j] = Math.min(Math.min(ans[i-1][j-1],ans[i-1][j]),ans[i][j-1])+1; res = Math.max(ans[i][j],res); &#125; &#125; &#125; return res*res; &#125;&#125; dpÊÄùË∑Ø„ÄÇÊâæÂà∞ÊúÄÂ§ßÁöÑ1Â≠óÊ≠£ÊñπÂΩ¢„ÄÇÁî®dpÂ≠ò‰ΩèÊØè‰∏™‰ΩçÁΩÆÂΩìÂâçÁöÑÊúÄÂ§ßÊ≠£ÊñπÂΩ¢„ÄÇÂè™ÊúâÂΩìÂ∑¶/‰∏ä/Â∑¶Êñú‰∏ä‰ΩçÁΩÆÈÉΩ‰∏ç‰∏∫0Êó∂ÔºåÊâçÂèØËÉΩÂ≠òÂú®Ê≠£ÊñπÂΩ¢„ÄÇ ÊúÄÂêéÊõ¥Êñ∞resÔºåÂ≠ò‰ΩèÊúÄÂ§ßÁöÑÊ≠£ÊñπÂΩ¢ËæπÈïø„ÄÇÊúÄÂêéËøîÂõûÈù¢ÁßØÔºåËæπÈïø**2.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 24","slug":"leetcode 24","date":"2019-06-20T12:35:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/06/20/leetcode 24/","link":"","permalink":"WangHngLeee.github.io/2019/06/20/leetcode 24/","excerpt":"99. Recover Binary Search Tree(BST In-Order-traversal) class Solution &#123; private TreeNode first; private TreeNode second; private TreeNode pre; public void recoverTree(TreeNode root) &#123; if(root==null) return; first = null; second = null; pre = null; inorder(root); int temp = first.val; first.val = second.val; second.val = temp; &#125; private void inorder(TreeNode root)&#123; if(root==null) return; inorder(root.left); if(first==null &amp;&amp; (pre==null ||pre.val&gt;=root.val))&#123; first = pre; &#125; if(first!=null &amp;&amp; pre.val&gt;=root.val)&#123; second = root; &#125; pre = root; inorder(root.right); &#125;&#125; ËÆæÁΩÆ‰∏§‰∏™ÊåáÈíàÂàÜÂà´ÊåáÂêë‰∏≠Â∫èÈÅçÂéÜ‰∏≠Âá∫Áé∞Â±ÄÈÉ®ÈôçÂ∫èÁöÑËäÇÁÇπÔºåËÆæÁΩÆpreÊåáÈíàÊåáÂêëÂΩìÂâçËäÇÁÇπÁöÑÂâç‰∏Ä‰∏™ËäÇÁÇπÔºåÂú®‰∏≠Â∫èÈÅçÂéÜ‰∏≠ÊØîËæÉÂâç‰∏ÄËäÇÁÇπÂíåÂΩìÂâçËäÇÁÇπÁöÑÊï∞ÂÄºÔºå‰ªéËÄåÂà§Êñ≠ÊòØÂê¶‰∏∫Â±ÄÈÉ®ÈôçÂ∫èÔºåÊúÄÂêéÔºåÂ∞Ü‰∏§‰∏™Â±ÄÈÉ®ÈôçÂ∫èÊåáÈíàÊåá(first\\second)ÂêëÁöÑËäÇÁÇπÁöÑÊï∞ÂÄº‰∫§Êç¢ÔºåÂç≥ÂèØÂÆåÊàêÊêúÁ¥¢‰∫åÂèâÊ†ëÁöÑÊÅ¢Â§ç.","text":"99. Recover Binary Search Tree(BST In-Order-traversal) class Solution &#123; private TreeNode first; private TreeNode second; private TreeNode pre; public void recoverTree(TreeNode root) &#123; if(root==null) return; first = null; second = null; pre = null; inorder(root); int temp = first.val; first.val = second.val; second.val = temp; &#125; private void inorder(TreeNode root)&#123; if(root==null) return; inorder(root.left); if(first==null &amp;&amp; (pre==null ||pre.val&gt;=root.val))&#123; first = pre; &#125; if(first!=null &amp;&amp; pre.val&gt;=root.val)&#123; second = root; &#125; pre = root; inorder(root.right); &#125;&#125; ËÆæÁΩÆ‰∏§‰∏™ÊåáÈíàÂàÜÂà´ÊåáÂêë‰∏≠Â∫èÈÅçÂéÜ‰∏≠Âá∫Áé∞Â±ÄÈÉ®ÈôçÂ∫èÁöÑËäÇÁÇπÔºåËÆæÁΩÆpreÊåáÈíàÊåáÂêëÂΩìÂâçËäÇÁÇπÁöÑÂâç‰∏Ä‰∏™ËäÇÁÇπÔºåÂú®‰∏≠Â∫èÈÅçÂéÜ‰∏≠ÊØîËæÉÂâç‰∏ÄËäÇÁÇπÂíåÂΩìÂâçËäÇÁÇπÁöÑÊï∞ÂÄºÔºå‰ªéËÄåÂà§Êñ≠ÊòØÂê¶‰∏∫Â±ÄÈÉ®ÈôçÂ∫èÔºåÊúÄÂêéÔºåÂ∞Ü‰∏§‰∏™Â±ÄÈÉ®ÈôçÂ∫èÊåáÈíàÊåá(first\\second)ÂêëÁöÑËäÇÁÇπÁöÑÊï∞ÂÄº‰∫§Êç¢ÔºåÂç≥ÂèØÂÆåÊàêÊêúÁ¥¢‰∫åÂèâÊ†ëÁöÑÊÅ¢Â§ç. 135. Candy(two scan ) class Solution &#123; public int candy(int[] ratings) &#123; int candies[] = new int[ratings.length]; Arrays.fill(candies, 1);// Give each child 1 candy for (int i = 1; i &lt; candies.length; i++)&#123;// Scan from left to right, to make sure right higher rated child gets 1 more candy than left lower rated child if (ratings[i] &gt; ratings[i - 1]) candies[i] = (candies[i - 1] + 1); &#125; for (int i = candies.length - 2; i &gt;= 0; i--) &#123;// Scan from right to left, to make sure left higher rated child gets 1 more candy than right lower rated child if (ratings[i] &gt; ratings[i + 1]) candies[i] = Math.max(candies[i], (candies[i + 1] + 1)); &#125; int sum = 0; for (int candy : candies) sum += candy; return sum; &#125;&#125; ÊØîËæÉÈöæÁöÑ‰∏ÄÈÅìÈ¢òÔºåÂΩìÁõ∏ÈÇªÁöÑ‰∏§‰∏™Êï∞Ôºå‰∏ã‰∏Ä‰∏™ÊØîÂΩìÂâçÂ§ßÊó∂Ôºå‰∏ã‰∏Ä‰∏™‰ΩçÁΩÆÂàÜÈÖçÁöÑÁ≥ñÊûúÂ§ö‰∏Ä‰∏™„ÄÇÊâÄ‰ª•Â∑¶Ëá≥Âè≥ÂíåÂè≥Ëá≥Â∑¶ÈÉΩÊâ´Êèè‰∏ÄÊ¨°ÔºåËß£ÂÜ≥‰∫ÜËøûÁª≠ÈáçÂ§çÊï∞Â≠óÁöÑÈóÆÈ¢ò„ÄÇ I‚Äôve come up with a simple proof of this algo. init with all 1 we only give one more when we see adjacent increase (both from left to right) I want to use some case to illustrate this ((notices we don‚Äôt care the exact value of ratings, only their relation) the rating is similar to ‚Äòwave‚Äô, increase of decrease let‚Äôs look at this case: ratings: [1,3,6,9,4,2] candies: [1,2,3,4,2,1] the highest rating is 9, when scan from left to right, num of candies should be 4, scan right to left, it should be 3, then we choose the larger value. and let‚Äôs look at some case containing adjacent-equal when there are adjacent-equal, lets look at some cases: ratings: [1,2,3,3,3,3,4,5] candies: [1,2,3,1,1,1,2,3] ratings: [1,2,8,8,8,8,8,2] candies: [1,2,3,1,1,1,2,1] with these cases it should be easier to understand.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 23","slug":"leetcode 23","date":"2019-06-17T12:35:09.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/06/17/leetcode 23/","link":"","permalink":"WangHngLeee.github.io/2019/06/17/leetcode 23/","excerpt":"109. Convert Sorted List to Binary Search Tree(linked list/recursion) /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode slow = head,fast=head,preslow=null; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; preslow = slow; slow = slow.next; fast = fast.next.next; &#125; if(preslow!=null)preslow.next=null; if(slow == null)return null; TreeNode n = new TreeNode(slow.val); if(head != slow)&#123; n.left = sortedListToBST(head) n.right = sortedListToBST(slow.next) &#125; return n; &#125;&#125;","text":"109. Convert Sorted List to Binary Search Tree(linked list/recursion) /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *//** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; if(head == null) return null; ListNode slow = head,fast=head,preslow=null; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; preslow = slow; slow = slow.next; fast = fast.next.next; &#125; if(preslow!=null)preslow.next=null; if(slow == null)return null; TreeNode n = new TreeNode(slow.val); if(head != slow)&#123; n.left = sortedListToBST(head) n.right = sortedListToBST(slow.next) &#125; return n; &#125;&#125; BSTÁöÑÈ¢òÔºåÂéüÊï∞ÁªÑÊòØsortedÁöÑÔºåÊâÄ‰ª•ÊÄùË∑ØÊØîËæÉÂ•ΩÊÉ≥„ÄÇÁõ¥Êé•ÊâæÂà∞‰∏≠Èó¥Êï∞‰Ωú‰∏∫rootÔºåÂ∑¶Âè≥ÂàÜÂà´Êâæ‰∏≠Èó¥Êï∞ÔºårecursiveË∞ÉÁî®„ÄÇ ÊØîËæÉÂ•ΩÁöÑ‰∏§ÁÇπÔºö 1.ÂÆö‰πâpreslowÔºåÁî®Êù•‰Ωú‰∏∫Â∑¶ÂçäÈÉ®ÂàÜÁöÑtailÔºåÂπ∂‰∏îÂ∞Ütail.next=null,ÂàáÊñ≠ 2.Âà©Áî®slow Âíå fast‰∏çÊñ≠Âæ™ÁéØÁöÑÊÄùË∑ØÔºåfastÈ¢ÜÂÖàslow‰∏§‰∏™Êï∞ÔºåÊâÄ‰ª•ÂΩìfast next next = nullÊó∂ÔºåslowÊ≠£Â•ΩÂú®‰∏≠Èó¥‰ΩçÁΩÆ„ÄÇ 97. Interleaving StringÔºàDP) class solution&#123; public boolean isintervleaing(String s1, String s2, String s3)&#123; if((s1.length()+s2.length())!=s3.length())return false; boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1] for(int i=1;i&lt;matrix[0].length;i++)&#123; matrix[0][i] = matix[0][i-1]&amp;&amp;(s1.charAt(i-1)==s3.charAt(i-1)); &#125; for(int i=1;i&lt;matrix.length;i++)&#123; matrix[i][0] = matrix[i-1][0] &amp;&amp; (s2.charAt(i-1)==s3.charAt(i-1)); &#125; for(int i = 1;i&lt;matrix.length;i++)&#123; for(int j = 1;j&lt;matrix[0].length;j++)&#123; matrix[i][j] = (matrix[i-1][j] &amp;&amp; (s2.charAt(i-1) == s3.charAt(i+j-1))) || (matrix[i][j-1] &amp;&amp; (s1.charAt(j-1) == s3.charAt(i+j-1))) &#125; &#125; return matrix[s2.length][s1.length]; &#125;&#125; hardÁöÑdpÈ¢òÔºåÂà§Êñ≠‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÊòØÂê¶‰∏∫‰∫§ÂèâÁöÑ„ÄÇ‰∏çËÆ∫Âì™‰∏™Âú®ÂâçÔºåËÇØÂÆöÊúâ‰∏Ä‰∏™Êª°Ë∂≥ÂàÜÂ≠óÁ¨¶‰∏≤ÁöÑ‰ΩçÁΩÆÂíåÊÄªÂ≠óÁ¨¶‰∏≤ÁöÑ‰ΩçÁΩÆÁõ∏Âêå„ÄÇÂÖàÂ∞Üs1Âíås2ÂàÜÂà´Ê£ÄÊµãÔºåÂ≠òÂú®Á¨¨‰∏ÄË°åÂíåÁ¨¨‰∏ÄÂàóÈáå„ÄÇÊúÄÂêéËøõË°åÂÖ®Â±ÄÊâ´ÊèèÔºåÊ≥®ÊÑèi+j-1ÁöÑÂ∫îÁî®„ÄÇ 77. Combinations (Backtracking) class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); combine(ans,new ArrayList&lt;&gt;(),1,n,k); return ans; &#125; public static void combine(List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; comb,int start,int n, int k)&#123; if(k==0)&#123; ans.add(new ArrayList&lt;Integer&gt;(comb)); &#125; for(int i = start; i&lt;=n,i++)&#123; comb.add(i); combine(ans,comb,i+1,n,k-1); comb.remove(comb.size()-1); &#125; &#125;&#125; backtrackingÊÄùË∑Ø„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 22","slug":"leetcode22","date":"2019-06-13T12:35:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/06/13/leetcode22/","link":"","permalink":"WangHngLeee.github.io/2019/06/13/leetcode22/","excerpt":"241. Different Ways to Add Parentheses (recursive / HashMap) class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); if(map.containsKey(input))return map.get(input); List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for(int i =0;i&lt;input.length();i++)&#123; if(input.charAt(i) == '-' || input.charAt(i) == '+' || input.charAt(i) == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2ret = diffWaysToCompute(part2); for(Integer p1 : part1ret)&#123; for(Integer p2 : part2ret)&#123; int c = 0; switch(input.charAt(i))&#123; case '+': c=p1+p2; break; case '-': c=p1-p2; break; case '*': c=p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0)&#123; ret.add(Integer.valueOf(input)); &#125; return ret; &#125;&#125; recursiveÁöÑÊÄùÊÉ≥ÔºåÂπ∂‰∏îÂà©Áî®hashmapÊù•ÈÅøÂÖçÈáçÂ§çËÆ°ÁÆóÁöÑÊÉÖÂÜµÔºåÈôç‰ΩéÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºåÊ≥®ÊÑèswitchÁöÑÁî®Ê≥ï„ÄÇ","text":"241. Different Ways to Add Parentheses (recursive / HashMap) class Solution &#123; public List&lt;Integer&gt; diffWaysToCompute(String input) &#123; Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); if(map.containsKey(input))return map.get(input); List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); for(int i =0;i&lt;input.length();i++)&#123; if(input.charAt(i) == '-' || input.charAt(i) == '+' || input.charAt(i) == '*')&#123; String part1 = input.substring(0,i); String part2 = input.substring(i+1); List&lt;Integer&gt; part1ret = diffWaysToCompute(part1); List&lt;Integer&gt; part2ret = diffWaysToCompute(part2); for(Integer p1 : part1ret)&#123; for(Integer p2 : part2ret)&#123; int c = 0; switch(input.charAt(i))&#123; case '+': c=p1+p2; break; case '-': c=p1-p2; break; case '*': c=p1*p2; break; &#125; ret.add(c); &#125; &#125; &#125; &#125; if(ret.size() == 0)&#123; ret.add(Integer.valueOf(input)); &#125; return ret; &#125;&#125; recursiveÁöÑÊÄùÊÉ≥ÔºåÂπ∂‰∏îÂà©Áî®hashmapÊù•ÈÅøÂÖçÈáçÂ§çËÆ°ÁÆóÁöÑÊÉÖÂÜµÔºåÈôç‰ΩéÊó∂Èó¥Â§çÊùÇÂ∫¶ÔºåÊ≥®ÊÑèswitchÁöÑÁî®Ê≥ï„ÄÇ 96. Unique Binary Search Trees public int numtrees(int n)&#123; int[] dp = new int[n+1]; dp[0] = dp[1] = 1; for(int i = 2; i&lt;=n;i++)&#123; for(int j = 1; j&lt;=i;j++)&#123; dp[i] += dp[j-1] *dp[i-j]; &#125; &#125; return dp[n];&#125; ‰∏ªË¶ÅÊòØÊï∞Â≠¶ÊÄùË∑ØÊØîËæÉÈöæÔºåÈúÄË¶ÅËÆ°ÁÆóÂá∫‰∏çÂêåÂ≠êÊ†ëÁªìÊûÑÁöÑÊâÄÊúâÊ†ëÁöÑÊï∞Èáè„ÄÇÂÖ∑‰ΩìÊÄùË∑ØËßÅleetcode96.","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Reactive Native (1)","slug":"rn1","date":"2019-06-10T17:23:41.000Z","updated":"2019-06-21T05:14:24.000Z","comments":true,"path":"2019/06/10/rn1/","link":"","permalink":"WangHngLeee.github.io/2019/06/10/rn1/","excerpt":"ÂºÄ‰∏™Ë¥¥ËÆ∞ÂΩï‰∏Ä‰∏ãRNÁöÑÂ≠¶‰π†ËÆ∞ÂΩïÔºåÂ∏åÊúõÊúÄÂêéËÉΩÂ§üËá™Â∑±ÂÅöÂá∫ÊØîËæÉÊª°ÊÑèÁöÑappÂêß„ÄÇ hello world import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';export default class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: \"center\", alignItems: \"center\" &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; React Native ÂÜÖÁΩÆ‰∫ÜÂØπ ES2015 Ê†áÂáÜÁöÑÊîØÊåÅ.‰∏ãÈù¢‰∏ÄË°åÔºö &lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt; Âè´ÂÅö JSX ‚Äî‚Äî ÊòØ‰∏ÄÁßçÂú® JavaScript ‰∏≠ÂµåÂÖ• XML ÁªìÊûÑÁöÑËØ≠Ê≥ï ‰ª£Á†Å‰∏≠Ôºå‰ΩøÁî®ÁöÑÊòØÂÜÖÁΩÆÁöÑÁªÑ‰ª∂ÔºåÂÆÉ‰∏ìÈó®Áî®Êù•ÊòæÁ§∫ÊñáÊú¨ÔºåËÄåÂ∞±Á±ª‰ºº html ‰∏≠ÁöÑdivÊàñÊòØspanËøôÊ†∑ÁöÑÂÆπÂô®„ÄÇ","text":"ÂºÄ‰∏™Ë¥¥ËÆ∞ÂΩï‰∏Ä‰∏ãRNÁöÑÂ≠¶‰π†ËÆ∞ÂΩïÔºåÂ∏åÊúõÊúÄÂêéËÉΩÂ§üËá™Â∑±ÂÅöÂá∫ÊØîËæÉÊª°ÊÑèÁöÑappÂêß„ÄÇ hello world import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';export default class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: \"center\", alignItems: \"center\" &#125;&#125;&gt; &lt;Text&gt;Hello, world!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; React Native ÂÜÖÁΩÆ‰∫ÜÂØπ ES2015 Ê†áÂáÜÁöÑÊîØÊåÅ.‰∏ãÈù¢‰∏ÄË°åÔºö &lt;View&gt;&lt;Text&gt;Hello world!&lt;/Text&gt;&lt;/View&gt; Âè´ÂÅö JSX ‚Äî‚Äî ÊòØ‰∏ÄÁßçÂú® JavaScript ‰∏≠ÂµåÂÖ• XML ÁªìÊûÑÁöÑËØ≠Ê≥ï ‰ª£Á†Å‰∏≠Ôºå‰ΩøÁî®ÁöÑÊòØÂÜÖÁΩÆÁöÑÁªÑ‰ª∂ÔºåÂÆÉ‰∏ìÈó®Áî®Êù•ÊòæÁ§∫ÊñáÊú¨ÔºåËÄåÂ∞±Á±ª‰ºº html ‰∏≠ÁöÑdivÊàñÊòØspanËøôÊ†∑ÁöÑÂÆπÂô®„ÄÇ Props(Â±ûÊÄß) react native‰∏≠Â§ßÂ§öÁªÑ‰ª∂ÂèØ‰ª•Áî®ÂèÇÊï∞Êù•‰øÆÊîπ„ÄÇÂèØ‰ª•‰øÆÊîπÁöÑËøô‰∫õÂèÇÊï∞Â∞±Áß∞‰∏∫props„ÄÇ ‰ª•ÊèíÂÖ•ÂõæÁâá‰∏∫‰æãÔºö import React,&#123;Components&#125; from 'react';import &#123;Image&#125; from 'react-native';export default class Bananas extends Components&#123; render()&#123; let pic = &#123; url:'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'; &#125; return&#123; &lt;Image source=&#123;pic&#125; style=&#123;&#123;width:193,height:150&#125;&#125; /&gt; &#125;; &#125;&#125; Âú®ÂàõÂª∫‰∏Ä‰∏™ÂõæÁâáÊó∂ÔºåÂèØ‰ª•‰º†ÂÖ•‰∏Ä‰∏™Âêç‰∏∫sourceÁöÑ prop Êù•ÊåáÂÆöË¶ÅÊòæÁ§∫ÁöÑÂõæÁâáÁöÑÂú∞ÂùÄÔºå‰ª•Âèä‰ΩøÁî®Âêç‰∏∫styleÁöÑ prop Êù•ÊéßÂà∂ÂÖ∂Â∞∫ÂØ∏„ÄÇ {pic}Â§ñÂõ¥Êúâ‰∏ÄÂ±ÇÊã¨Âè∑ÔºåÈúÄË¶ÅÁî®Êã¨Âè∑Êù•ÊääpicËøô‰∏™ÂèòÈáèÂµåÂÖ•Âà∞ JSX ËØ≠Âè•‰∏≠„ÄÇÊã¨Âè∑ÁöÑÊÑèÊÄùÊòØÊã¨Âè∑ÂÜÖÈÉ®‰∏∫‰∏Ä‰∏™ js ÂèòÈáèÊàñË°®ËææÂºèÔºåÈúÄË¶ÅÊâßË°åÂêéÂèñÂÄº„ÄÇÂõ†Ê≠§ÂèØ‰ª•Êää‰ªªÊÑèÂêàÊ≥ïÁöÑ JavaScript Ë°®ËææÂºèÈÄöËøáÊã¨Âè∑ÂµåÂÖ•Âà∞ JSX ËØ≠Âè•‰∏≠„ÄÇ Ëá™ÂÆö‰πâÁöÑÁªÑ‰ª∂‰πüÂèØ‰ª•‰ΩøÁî®props„ÄÇÈÄöËøáÂú®‰∏çÂêåÁöÑÂú∫ÊôØ‰ΩøÁî®‰∏çÂêåÁöÑÂ±ûÊÄßÂÆöÂà∂ÔºåÂèØ‰ª•Â∞ΩÈáèÊèêÈ´òËá™ÂÆö‰πâÁªÑ‰ª∂ÁöÑÂ§çÁî®ËåÉÁï¥„ÄÇÂè™ÈúÄÂú®renderÂáΩÊï∞‰∏≠ÂºïÁî®this.propsÔºåÁÑ∂ÂêéÊåâÈúÄÂ§ÑÁêÜÂç≥ÂèØ„ÄÇ‰∏ãÈù¢ÊòØ‰∏Ä‰∏™‰æãÂ≠êÔºö import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', marginTop: 50&#125;&#125;&gt; &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125; Âú®GreetingÁªÑ‰ª∂‰∏≠Â∞Üname‰Ωú‰∏∫‰∏Ä‰∏™Â±ûÊÄßÊù•ÂÆöÂà∂ÔºåËøôÊ†∑ÂèØ‰ª•Â§çÁî®Ëøô‰∏ÄÁªÑ‰ª∂Êù•Âà∂‰ΩúÂêÑÁßç‰∏çÂêåÁöÑ‚ÄúÈóÆÂÄôËØ≠. State Êàë‰ª¨‰ΩøÁî®‰∏§ÁßçÊï∞ÊçÆÊù•ÊéßÂà∂‰∏Ä‰∏™ÁªÑ‰ª∂ÔºöpropsÂíåstate„ÄÇpropsÊòØÂú®Áà∂ÁªÑ‰ª∂‰∏≠ÊåáÂÆöÔºåËÄå‰∏î‰∏ÄÁªèÊåáÂÆöÔºåÂú®Ë¢´ÊåáÂÆöÁöÑÁªÑ‰ª∂ÁöÑÁîüÂëΩÂë®Êúü‰∏≠Âàô‰∏çÂÜçÊîπÂèò„ÄÇ ÂØπ‰∫éÈúÄË¶ÅÊîπÂèòÁöÑÊï∞ÊçÆÔºåÊàë‰ª¨ÈúÄË¶Å‰ΩøÁî®state„ÄÇ ‰∏ÄËà¨Êù•ËØ¥Ôºå‰Ω†ÈúÄË¶ÅÂú® constructor ‰∏≠ÂàùÂßãÂåñstateÔºàËØëÊ≥®ÔºöËøôÊòØ ES6 ÁöÑÂÜôÊ≥ïÔºåÊó©ÊúüÁöÑÂæàÂ§ö ES5 ÁöÑ‰æãÂ≠ê‰ΩøÁî®ÁöÑÊòØ getInitialState ÊñπÊ≥ïÊù•ÂàùÂßãÂåñ stateÔºåËøô‰∏ÄÂÅöÊ≥ï‰ºöÈÄêÊ∏êË¢´Ê∑òÊ±∞ÔºâÔºåÁÑ∂ÂêéÂú®ÈúÄË¶Å‰øÆÊîπÊó∂Ë∞ÉÁî®setStateÊñπÊ≥ï„ÄÇ Ê≥®ÊÑèÁª©Âá†ÁÇπÔºö 1.‰∏ÄÂàáÁïåÈù¢ÂèòÂåñÈÉΩÊòØÁä∂ÊÄÅstateÂèòÂåñ 2.stateÁöÑ‰øÆÊîπÂøÖÈ°ªÈÄöËøásetState()ÊñπÊ≥ï 3.this.state.likes = 100Ôºå ËøôÊ†∑ÁöÑÁõ¥Êé•ËµãÂÄº‰øÆÊîπÊó†ÊïàÔºÅ 4.setState ÊòØ‰∏Ä‰∏™ merge ÂêàÂπ∂Êìç‰ΩúÔºåÂè™‰øÆÊîπÊåáÂÆöÂ±ûÊÄßÔºå‰∏çÂΩ±ÂìçÂÖ∂‰ªñÂ±ûÊÄß 5.setState ÊòØÂºÇÊ≠•Êìç‰ΩúÔºå‰øÆÊîπ‰∏ç‰ºöÈ©¨‰∏äÁîüÊïà","categories":[{"name":"web/appÂºÄÂèëÔºåÊ°ÜÊû∂","slug":"web-appÂºÄÂèëÔºåÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/web-appÂºÄÂèëÔºåÊ°ÜÊû∂/"}],"tags":[{"name":"React-Native","slug":"React-Native","permalink":"WangHngLeee.github.io/tags/React-Native/"},{"name":"app","slug":"app","permalink":"WangHngLeee.github.io/tags/app/"},{"name":"webapp","slug":"webapp","permalink":"WangHngLeee.github.io/tags/webapp/"}]},{"title":"Leetcode EveryDay 21","slug":"leetcode21","date":"2019-06-10T12:56:09.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/06/10/leetcode21/","link":"","permalink":"WangHngLeee.github.io/2019/06/10/leetcode21/","excerpt":"82. Remove Duplicates from Sorted List IIÔºàtwo pointer / linked list) class solution&#123; public ListNode deletedupliate(ListNode head)&#123; if(head == null)return null; ListNode dummy = head; dummy.next = head; ListNode pre = dummy; ListNode cur = head; ListNode fisrt = dummy;//Êñ∞Âª∫‰∏Ä‰∏™firstÈìæË°®Êù•Â≠òÂÇ®‰∏çÈáçÂ§çÁöÑËäÇÁÇπ while(cur!=null &amp;&amp; cur.next!=null)&#123;//Âà§Êñ≠ËØ•ËäÇÁÇπÂíåÂêéËäÇÁÇπ‰∏ç‰∏∫Á©∫ if(cur.val!=cur.next.val&amp;&amp;cur.val!=pre.val)&#123;//ÂâçÂêéÈÉΩÊó†ÈáçÂ§ç first = cur; first.next = first; &#125; pre = cur; cur = cur.next; &#125; if(cur.val!=pre.val)&#123;//Â§ÑÁêÜÊúÄÂêé‰∏Ä‰∏™ËäÇÁÇπÊó∂Âè™ËÄÉËôëpreÂíåcur first = cur; first.next = first; &#125; first.next = null;//Ê≥®ÊÑèÔºåËøôÊòØ‰∏∫‰∫ÜÂ§ÑÁêÜÂΩìÈìæË°®ÈÉΩ‰∏∫ÈáçÂ§çÊó∂ÔºåÂ∞ÜÂÖ®ÈÉ®ÂâîÈô§„ÄÇ return dummy.next; &#125;&#125; linked list Âíå two pointer ÁöÑÊÄùË∑ØÔºåÊñ∞Âª∫firstÈìæË°®Â≠òÁ≠îÊ°àÔºåÂà§Êñ≠ÂΩìÂâçÂêéÂùá‰∏ç‰∏∫ÈáçÂ§çÊó∂ËøõË°åÊìç‰Ωú„ÄÇ","text":"82. Remove Duplicates from Sorted List IIÔºàtwo pointer / linked list) class solution&#123; public ListNode deletedupliate(ListNode head)&#123; if(head == null)return null; ListNode dummy = head; dummy.next = head; ListNode pre = dummy; ListNode cur = head; ListNode fisrt = dummy;//Êñ∞Âª∫‰∏Ä‰∏™firstÈìæË°®Êù•Â≠òÂÇ®‰∏çÈáçÂ§çÁöÑËäÇÁÇπ while(cur!=null &amp;&amp; cur.next!=null)&#123;//Âà§Êñ≠ËØ•ËäÇÁÇπÂíåÂêéËäÇÁÇπ‰∏ç‰∏∫Á©∫ if(cur.val!=cur.next.val&amp;&amp;cur.val!=pre.val)&#123;//ÂâçÂêéÈÉΩÊó†ÈáçÂ§ç first = cur; first.next = first; &#125; pre = cur; cur = cur.next; &#125; if(cur.val!=pre.val)&#123;//Â§ÑÁêÜÊúÄÂêé‰∏Ä‰∏™ËäÇÁÇπÊó∂Âè™ËÄÉËôëpreÂíåcur first = cur; first.next = first; &#125; first.next = null;//Ê≥®ÊÑèÔºåËøôÊòØ‰∏∫‰∫ÜÂ§ÑÁêÜÂΩìÈìæË°®ÈÉΩ‰∏∫ÈáçÂ§çÊó∂ÔºåÂ∞ÜÂÖ®ÈÉ®ÂâîÈô§„ÄÇ return dummy.next; &#125;&#125; linked list Âíå two pointer ÁöÑÊÄùË∑ØÔºåÊñ∞Âª∫firstÈìæË°®Â≠òÁ≠îÊ°àÔºåÂà§Êñ≠ÂΩìÂâçÂêéÂùá‰∏ç‰∏∫ÈáçÂ§çÊó∂ËøõË°åÊìç‰Ωú„ÄÇ 83. Remove Duplicates from Sorted ListÔºàlinked lilstÔºâ class solutoin&#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode list = head; while(list!=null)&#123; if(list.next == null)break; if(list.val == list.next.val)&#123; list.next = list.next.next; &#125;else&#123; list.next = list; &#125; &#125; return head; &#125;&#125; easyÁöÑ82È¢òÔºåË¶ÅÊ±ÇÂ∞ÜÈáçÂ§çÊï∞Â≠óÁöÑÂè™Áïô‰∏ã‰∏Ä‰∏™ËæìÂá∫ÔºåËÄå82ÊòØË¶ÅÊ±ÇÂ∞ÜÈáçÂ§çÁöÑÂÖ®ÈÉ®ÂâîÈô§ÔºåÊâÄ‰ª•83Áõ∏ÊØî82ÊØîËæÉÁÆÄÂçï Âè™ÈúÄË¶ÅÂ∞ÜÈáçÂ§çÊÉÖÂÜµ‰∏ãlist.next = list.next.next;Âæ™ÁéØ‰∏ãÂéª„ÄÇ 86. Partition List(listed node / two pointers) class solution&#123; public ListNode partation(ListNode head,int x)&#123; ListNode smallhead = new ListNode(0),bighead = new ListNode(0); ListNode smalltail = smallhead, bigtail = bighead; while(head!=null)&#123; if(head.val&lt;x)&#123; smalltail.next = head; smalltail = smalltail.next; &#125;else&#123; bigtail.next = head; bigtail = bigtail.next; &#125; head = head.next; &#125; bigtail.next = null; smalltail.next = bighead.next; return smallhead.next; &#125;&#125; Êñ∞Âª∫smallÂíåbig‰∏§‰∏™ÈìæË°®ÔºåÂàÜÂà´Áî®Êù•Â≠òÂ∞è‰∫éxÂíåÂ§ß‰∫éxÁöÑËäÇÁÇπÔºåÊúÄÂêéÂ∞ÜÂ§ßÁöÑËäÇÁÇπÂêàÂπ∂Âú®Â∞èÁöÑËäÇÁÇπÂêéÈù¢Âç≥ÂèØ„ÄÇÊ≥®ÊÑèbigtail.next=nullËøô‰∏ÄÊ≠•ÈùûÂ∏∏ÂÖ≥ÈîÆÔºåÈÅøÂÖç‰∫ÜÈìæË°®ÁöÑÂæ™ÁéØÔºåÈò≤Ê≠¢TLE„ÄÇ 92. Reverse Linked List II(linked list / two pointers) class solution&#123; public ListNode reverselinkedlist(ListNode head, int m, int n)&#123; if(head == null)return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for(int i = 0; i&lt;m-1;i++)pre=pre.next; ListNode start = pre.next; ListNode then = start.next; for(int i = 0; i &lt;n-m;i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; return dummy.next; &#125;&#125; ÂèåÊåáÈíàÈóÆÈ¢ò„ÄÇpreÔºåstartÔºåthenË°®Á§∫Ââç‰∏ÄËäÇÁÇπÔºåÂΩìÂâçÔºåÂêéËäÇÁÇπÔºåÂæ™ÁéØm-1Ê¨°ÊâæÂà∞preÔºåÂ∞Üpre.nextÂèò‰∏∫start„ÄÇÊâßË°ån-mÊ¨°Êç¢‰Ωç„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 20","slug":"leetcode 20","date":"2019-06-06T12:56:09.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/06/06/leetcode 20/","link":"","permalink":"WangHngLeee.github.io/2019/06/06/leetcode 20/","excerpt":"ÂÜôÂú®ÂâçÈù¢ ÊúÄËøë‰∫ãÊÉÖÊØîËæÉÂ§öÔºåÂäûÁ≠æËØÅÔºåÂÜôËÆ∫ÊñáÔºåÊîπÊ†ºÂºèÔºåÊ≤°‰ªÄ‰πàÊó∂Èó¥Âà∑È¢òÂíåÁúãÁΩëËØæ‰∫ÜÔºåÁé∞Âú®ÊÄªÁÆóÊòØÈó≤‰∏ãÊù•‰∫ÜÔºå‰πãÂêéÂ§ßÊ¶ÇÂ∞±ÊòØ‰∏ÄÈÅçÂáÜÂ§áÁ≠îËæ©ppt‰∏ÄÈÅçÂà∑È¢òÂêß„ÄÇÂä†Ê≤πÂä†Ê≤π„ÄÇ 209. Minimum Size Subarray Sum(two pointers) class solution&#123; public int minsub(int s, int[] nums)&#123; int sum = 0, int from = 0, mn = Integer.MAX_VALUE; for(int i = 0; i&lt; nums.length;i++)&#123; sum+=nums[i]; while(sum&gt;=s)&#123; mn = Math.min(mn,i-from+1); sum-=nums[from]; from++; &#125; &#125; return (mn == Integer.MAX_VALUE)? 0 : mn; &#125;&#125; ÂèåÊåáÈíàÈóÆÈ¢òÔºåfrom‰∏∫Ëµ∑Âßã‰ΩçÁΩÆÔºåsliding windowÊÄùÊÉ≥Âæ™ÁéØ‰∏ãÂéªÔºåÂΩìsum&gt;sÊó∂ÔºåÂ∞Üfrom‰ªésumÂáèÂéªÔºåÂêåÊó∂from++ÔºåÊªëÂä®Ê£ÄÁ¥¢„ÄÇ","text":"ÂÜôÂú®ÂâçÈù¢ ÊúÄËøë‰∫ãÊÉÖÊØîËæÉÂ§öÔºåÂäûÁ≠æËØÅÔºåÂÜôËÆ∫ÊñáÔºåÊîπÊ†ºÂºèÔºåÊ≤°‰ªÄ‰πàÊó∂Èó¥Âà∑È¢òÂíåÁúãÁΩëËØæ‰∫ÜÔºåÁé∞Âú®ÊÄªÁÆóÊòØÈó≤‰∏ãÊù•‰∫ÜÔºå‰πãÂêéÂ§ßÊ¶ÇÂ∞±ÊòØ‰∏ÄÈÅçÂáÜÂ§áÁ≠îËæ©ppt‰∏ÄÈÅçÂà∑È¢òÂêß„ÄÇÂä†Ê≤πÂä†Ê≤π„ÄÇ 209. Minimum Size Subarray Sum(two pointers) class solution&#123; public int minsub(int s, int[] nums)&#123; int sum = 0, int from = 0, mn = Integer.MAX_VALUE; for(int i = 0; i&lt; nums.length;i++)&#123; sum+=nums[i]; while(sum&gt;=s)&#123; mn = Math.min(mn,i-from+1); sum-=nums[from]; from++; &#125; &#125; return (mn == Integer.MAX_VALUE)? 0 : mn; &#125;&#125; ÂèåÊåáÈíàÈóÆÈ¢òÔºåfrom‰∏∫Ëµ∑Âßã‰ΩçÁΩÆÔºåsliding windowÊÄùÊÉ≥Âæ™ÁéØ‰∏ãÂéªÔºåÂΩìsum&gt;sÊó∂ÔºåÂ∞Üfrom‰ªésumÂáèÂéªÔºåÂêåÊó∂from++ÔºåÊªëÂä®Ê£ÄÁ¥¢„ÄÇ 222. Count Complete Tree Nodes /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; int leftdepth = leftdepth(root); int rightdepth = rightdepth(root); if(leftdepth == rightdepth)&#123; return (1 &lt;&lt; leftdepth) -1; &#125; else&#123; return 1+countNodes(root.left) + countNodes(root.right); &#125; &#125; private int leftdepth(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; root = root.right; dep++; &#125; return dep; &#125; private int rightdepth(TreeNode root)&#123; int dep = 0; while(root!=null)&#123; root = root.left; dep++; &#125; return dep; &#125;&#125; Âà§Êñ≠ËäÇÁÇπÁöÑ‰∏™Êï∞ÔºåËäÇÁÇπÊï∞NÂíåÂ±ÇÊï∞depthÂØπÂÖ≥Á≥ªÔºöN = 2^depth - 1„ÄÇÁÑ∂ÂêéÂàÜÂ∑¶Âè≥‰ø©‰∏™depthÂáΩÊï∞Êù•ËÆ°ÁÆóÊ∑±Â∫¶„ÄÇ 87. Scramble String class solution&#123; public boolean isScramble(String s1, String s2)&#123; if(s1 == null || s2 == null) return false; if(s1.equals(s2)) return true; if(s1.length() != s2.length()) return false; int[] letters = new int[26]; int len = s1.length(); for(int i = 0;i&lt;len;i++)&#123; letters[s1.charAt(i) - 'a']++; letters[s2.charAt(i) - 'a']--; &#125; for(int i = 0;i&lt;26;i++)&#123; if(letters[i] !=0)return false; &#125; for(int i = 1; i&lt;len;i++)&#123; if(isScramble(s1.substring(0,i), s2.substring(0,i)) &amp;&amp; isScramble(s1.substring(i),s2.substring(i))) return true; if(isScramble(s1.substring(0,i), s2.substring(len-i)) &amp;&amp; isScramble(s1.substring(i), s2.substring(0,len-i))) return true; &#125; return false; &#125;&#125; Á±ª‰ººtrieÁöÑÊ†ëÂ≠óÂÖ∏Ôºå‰ΩÜÊòØÂÅöÊ≥ïÊØîËæÉÁÆÄÂçï„ÄÇÂà§Êñ≠‰∏§‰∏™Â≠óÁ¨¶‰∏≤ÊòØÂê¶ÊòØÂêå‰∏Ä‰∏™ÔºåÂÖàÂà§Êñ≠ÊòØÂê¶‰∏∫Á©∫ÔºåÂÖ∂Ê¨°Âà§Êñ≠ÊòØÂê¶Áõ¥Êé•Áõ∏Á≠âÔºåÂú®Âà§Êñ≠ÈïøÂ∫¶ÔºàËøôÈáåÂ¶ÇÊûúÈïøÂ∫¶‰∏çÂêåÁõ¥Êé•falseÔºâ Áî®letter Â≠ò‰ΩèÊØè‰∏™Â≠óÊØçÁöÑÂÄºÔºås1ÁöÑ++Ôºås2ÁöÑ‚ÄìÔºåÂ¶ÇÊûúÁõ∏ÂêåÂ∫îËØ•‰ªç‰∏∫0„ÄÇÊ≥®ÊÑèsubstringÁöÑÁî®Ê≥ï„ÄÇÔºàËµ∑ÂßãÔºåÁªìÊùüÔºâor(Êüê‰ΩçÁΩÆ‰ª•ÂêéÁöÑÂÖ®ÈÉ®ÂÖÉÁ¥†)„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"F-1 VISA ApprovedÔºÅ","slug":"«©÷§","date":"2019-06-05T02:29:43.000Z","updated":"2019-10-02T05:07:38.172Z","comments":true,"path":"2019/06/04/«©÷§/","link":"","permalink":"WangHngLeee.github.io/2019/06/04/«©÷§/","excerpt":"","text":"‰ªäÂ§©ÂéªÂåó‰∫¨ÂÆâÂÆ∂Ê•ºÈù¢Á≠æÔºå‰∫∫Ë∂ÖÂ§öÔºåÊ≤°ÊÉ≥Âà∞voÂè™Ë¶Å‰∫ÜÊàëÁöÑcvÂíåstudy plan Â∞±Áªôapproved‰∫ÜÔºåÊØîËæÉÂπ∏Ëøê„ÄÇ Êé•‰∏ãÊù•ÁªßÁª≠Âä™ÂäõÂêß~ Â•ΩÂá†Â§©Ê≤°Âà∑È¢ò‰∫ÜÔºå‰∫ãÊÉÖÊØîËæÉÂ§öÔºåÂä†Ê≤πÂä†Ê≤π„ÄÇ","categories":[{"name":"Life","slug":"Life","permalink":"WangHngLeee.github.io/categories/Life/"}],"tags":[{"name":"F-1 VISA","slug":"F-1-VISA","permalink":"WangHngLeee.github.io/tags/F-1-VISA/"}]},{"title":"Leetcode EveryDay 19","slug":"leetcode 19","date":"2019-05-30T12:41:06.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/05/30/leetcode 19/","link":"","permalink":"WangHngLeee.github.io/2019/05/30/leetcode 19/","excerpt":"153. Find Minimum in Rotated Sorted Array (Binary search) class solution&#123; public int findmin(int[] nums)&#123; int left = 0; int right = nums.length-1; while(left&lt;right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else&#123; left = mid+1; &#125; &#125;return nums[left]; &#125;&#125;","text":"153. Find Minimum in Rotated Sorted Array (Binary search) class solution&#123; public int findmin(int[] nums)&#123; int left = 0; int right = nums.length-1; while(left&lt;right)&#123; int mid = left + (right - left)/2; if(nums[mid] &lt; nums[right])&#123; right = mid; &#125;else&#123; left = mid+1; &#125; &#125;return nums[left]; &#125;&#125; ÊÄùË∑Ø Êó†ÈáçÂ§çÊï∞Â≠ó„ÄÇ‰∫åÂàÜÊü•ÊâæÁöÑÂü∫Êú¨ÊÄùÊÉ≥„ÄÇÁ®çÂæÆÈöæÂ∫¶Â¢ûÂä†ÔºåË¶ÅÊ±ÇÊâæÂà∞ÊúÄÂ∞èÂÄºÔºåÂπ∂‰∏îÊï∞ÁªÑsort rotated„ÄÇÂü∫Êú¨ÊÄùË∑ØÂíå‰∫åÂàÜÂ∑Æ‰∏çÂ§öÔºåËÆæÁΩÆmidÔºåÂà§Êñ≠midÂíårightÁöÑÂ§ßÂ∞è„ÄÇÂ¶ÇÊûúmid&lt;rightÔºåÈÇ£‰πàËØ¥ÊòémidÂú®È°∫Â∫èsortÁöÑÊï∞ÁªÑÈáåÔºåÊ≠£Â∏∏Áº©Â∞èrightËåÉÂõ¥Âç≥ÂèØ„ÄÇÂ¶ÇÊûúmid&gt;rightÊó∂ÔºåËØ¥ÊòérotateÁöÑÊï∞ÁªÑÈÉ®ÂàÜÂú®midÂè≥‰æßÔºåÊâÄ‰ª•Êõ¥Êñ∞left‰∏∫mid+1„ÄÇÊúÄÂêéËøîÂõûleftÂÄº„ÄÇ 154. Find Minimum in Rotated Sorted Array II (Binary search) class solution&#123; public int findmin2(int nums)&#123; int start = 0; int end = nums.length-1; while(start&lt;end)&#123; int mid = start + (end-start)/2; if(nums[mid] &gt; nums[end])&#123; start = mid+1; &#125; else if(nums[mid] &lt; nums[end])&#123; end = mid; &#125; else&#123; end--; &#125; &#125; return nums[start]; &#125;&#125; ÊÄùË∑Ø ‰∏ä‰∏ÄÈ¢òÁöÑÂçáÁ∫ßÁâàÔºåÂ≠òÂú®ÈáçÂ§çÁöÑÊï∞Â≠ó„ÄÇ ÊØîÁ¨¨‰∏ÄÈÅìÈ¢òÂ§ö‰∫Ü‰∏Ä‰∏™ÂàÜÊûêÊÉÖÂÜµÔºåÂΩìmid = endÊó∂ÔºåendË¶Å‚ÄìÔºå‰æùÊóßÊòØÂíåendÁöÑÊï∞Â≠óÊØîËæÉÔºåÊØîÁõ¥Êé•ÂíåstartÊï∞Â≠óÊØîËæÉÊñπ‰æøÂø´Êç∑„ÄÇ 167. Two Sum II - Input array is sorted Ëá™Â∑±ÂÅöÁöÑbinary search ÊñπÊ≥ïÔºå4msÔºåË∂ÖËøá19%ÔºåÊúâÁÇπÊÖ¢ class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; for(int i = 0; i &lt;numbers.length;i++)&#123; int left = i+1,right = numbers.length -1; int temp = target - numbers[i]; while(left &lt;= right)&#123; int mid = left + (right - left) /2; if(numbers[mid] == temp)&#123; return new int[]&#123;i+ 1, mid+ 1&#125;; &#125;else if(numbers[mid] &lt; temp)&#123; left = mid+1; &#125;else&#123; right = mid -1; &#125; &#125; &#125; return null; &#125;&#125; Áúã‰∫ÜdiscussÔºåÊØîËæÉÂ•ΩÁöÑÊòØtwo pointerÊñπÊ≥ï„ÄÇ class souliton&#123; public int[] twoSum(int[] num, int target) &#123; int[] index = new int[2]; if(num == null || num.length&lt;2)return index; int left = 0, right = num.length -1; while(left&lt;right)&#123; long v = nums[left] + nums[right]; if(v == target)&#123; index[0] = left + 1; index[1] = right + 1; brerak; &#125; else if(v &gt;target)&#123; right --; &#125;else&#123; left ++; &#125; &#125; return index; &#125;&#125; ÊØîËæÉÁõ¥ËßÇÔºåÂÆπÊòìÁêÜËß£ÁöÑÊÄùË∑ØÔºåÁî®long v ‰ª£Êõø int vÊòØ‰∏™ÂæàÂ•ΩÁöÑÊñπÊ≥ïÔºå‰∏∫‰∫ÜÈò≤Ê≠¢int overflow„ÄÇ 174. Dungeon Game (dp programming) class solution&#123; public int caculationminHP(int[][] dungeon)&#123; if(dungeon == null || dungeon.length == 0 || dungeon[0].length == 0)return 0; int m = dungeon.length; int n = dungeon[0].length; int[][]hp = new int[m][n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; if(i == m-1 &amp;&amp; j == n-1)&#123; hp[i][j] = Math.max(1-dungeon[i][j], 1); &#125; else if( i == m-1)&#123; hp[i][j] = Math.max(hp[i][j+1] - dungeon[i][j], 1); &#125; else if( j == n-1)&#123; hp[i][j] = Math.max(hp[i+1][j] - dungeon[i][j], 1); &#125; else&#123; hp[i][j] = Math.min(Math.max(hp[i][j+1] - dungeon[i][j],1 ),Math.max(hp[i+1][j] - dungeon[i][j], 1)); &#125; &#125; &#125; return hp[0][0]; &#125;&#125; ÊÄùË∑Ø ÈùûÂ∏∏ÁÉßËÑëÁöÑ‰∏ÄÈÅìÈ¢ò„ÄÇËá™‰∏ãËÄå‰∏äÁöÑdpÊÄùÊÉ≥„ÄÇÂΩìÂâç‰ΩçÁΩÆÁöÑÁîüÂëΩÂÄºÊúÄÂ∞ë‰∏∫1ÔºåÊâÄ‰ª•Ë¶ÅÊª°Ë∂≥ÂΩìÂâçhpÂáèÂéªÂú∞Áâ¢ÊçüËÄóÂÄº &gt;=1„ÄÇ ÂõõÁßçÊÉÖÂÜµÔºö 1.ÊúÄÂè≥‰∏ãËßíÁöÑ‰ΩçÁΩÆÔºåÁªàÁÇπÂ§ÑÁîüÂëΩÂÄºÂà§Êñ≠Ôºõ 2.ÊúÄÂêé‰∏ÄË°åÔºå‰ªéÂè≥Ëá≥Â∑¶Êâ´ÊèèÔºå‰∏ä‰∏Ä‰∏™hpÂáèÂéªÂΩìÂâçÁöÑÂú∞Áâ¢ÊçüËÄóÂÄº&gt;1Âç≥ÂèØ 3.ÊúÄÂêé‰∏ÄÂàóÔºå‰ªé‰∏ãËá≥‰∏äÊâ´ÊèèÔºå‰∏ä‰∏Ä‰∏™hpÂáèÂéªÂΩìÂâçÁöÑÂú∞Áâ¢ÊçüËÄóÂÄº&gt;1Âç≥ÂèØ 4.‰ªªÊÑè‰ΩçÁΩÆÔºåË¶ÅÊ±ÇËøô‰∏™‰ΩçÁΩÆÁöÑÂè≥ÊñπÊàñËÄÖ‰∏ãÊñπÁöÑÂÄºÂáèÂéªÁõ∏ÂØπÂ∫îÁöÑÊçüËÄóÂÄºÂêéÈÉΩË¶ÅÂ§ß‰∫é1ÔºåÂπ∂‰∏îÂú®Á¨¶ÂêàË¶ÅÊ±ÇÁöÑhp‰∏≠ÈÄâÂèñÊúÄÂ∞èÁöÑÊúÄ‰∏∫ÊúÄ‰ºòÈÄâ„ÄÇ ÊúÄÂêéËøîÂõûhp[0][0],‰πüÂ∞±ÊòØËµ∑Âßã‰ΩçÁΩÆÁöÑÊúÄÂ∞èÂÄº„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 18","slug":"leeetcode18","date":"2019-05-29T12:41:06.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/05/29/leeetcode18/","link":"","permalink":"WangHngLeee.github.io/2019/05/29/leeetcode18/","excerpt":"138. Copy List with Random Pointer (Hashmap &amp;&amp; linkedlist)","text":"138. Copy List with Random Pointer (Hashmap &amp;&amp; linkedlist) /*// Definition for a Node.class Node &#123; public int val; public Node next; public Node random; public Node() &#123;&#125; public Node(int _val,Node _next,Node _random) &#123; val = _val; next = _next; random = _random; &#125;&#125;;*/class Solution &#123; public RandomListNode copyRandomlist(RandomListNode head)&#123; if (head == null)return head; Node cur = head; while(curr!=null)&#123; Node next = cur.next; cur.next = new Node(cur.val, next, null); cur = next; &#125; cur = head; while(cur!=null)&#123; if(cur.random!=null)&#123; cur.next.random = c.random.next; &#125; cur = cur.next.next; &#125; cur = head; Node copyhead = head.next; while(cur!=null)&#123; Node curnext = cur.next.next;//curÈìæË°® Node copy = cur.next;//copyÈìæË°® cur.next = curnext; if(curnext!=null)&#123; copy.next = curnext.next; &#125; cur = curnext; &#125; return copyhead; &#125;&#125; ÊÄùË∑Ø Âú®ÂéünodeÁöÑÂêéÈù¢Â§çÂà∂‰∏Ä‰∏™node‚ÄôÔºåÁÑ∂ÂêéÂ∞ÜrandomÊåáÂêëÂØπÂ∫îÁöÑ‰ΩçÁΩÆÔºåÊúÄÂêéÂêÑËá™ËøûÊé•ÈìæË°®ÔºåÂÖ±‰∏âÊ¨°Âæ™ÁéØÔºåÁ¨¨‰∏ÄÊ¨°Â§çÂà∂ÔºåÁ¨¨‰∫åÊ¨°randomËøûÁ∫øÔºåÁ¨¨‰∏âÊ¨°ÂêÑËá™ÊàêÁ∫ø„ÄÇ Â§ßÊ¶ÇÊÄùË∑ØÂ¶ÇÂõæÔºö 74. Search a 2D Matrix (Binary Search) class solution&#123; public boolean search(int[][] matrix, int target)&#123; int start = 0; int rows = matrix.length; int cols = matrix[0].length; int end = rows*cols-1; while(start&lt;=end)&#123; mid = (start+end)/2; if(matrix[mid/cols][mid%cols] == target)&#123; return true; &#125; else if(matrix[mid/cols][mid%cols] &lt; target)&#123; start = mid + 1; &#125; else&#123; end = mid -1; &#125; &#125; return false; &#125;&#125; ÊÄùË∑Ø ‰∫åÂàÜÊü•ÊâæÁöÑÈ¢òÔºåÂéüÈ¢òÊòØ2DÁü©ÈòµÔºå‰ΩÜÂÖ∂ÂÆû‰∏çÁî®ÈÇ£‰πàÂ§çÊùÇÔºåËÄÉËôë‰∏∫‰∏Ä‰ΩçÊï∞ÁªÑÂ∞±ÂèØ‰ª•ÔºåÂà©Áî®mid/colsÂèØ‰ª•Âà§Êñ≠ÊòØÁ¨¨Âá†Â∞èÊÆµÔºåÁ±ª‰ººÊ®™ÂêëÊéíÂ∏ÉÔºåÊâÄ‰ª•matrix[mid/cols][mid%cols]ÊñπÊ≥ïÂ∞Ü‰∫åÁª¥Áü©ÈòµËΩ¨Êç¢Êàê‰∫Ü‰∏ÄÁª¥Êï∞ÁªÑÁöÑÈóÆÈ¢ò„ÄÇ‰∏çÈîôÁöÑidea„ÄÇ 81. Search in Rotated Sorted Array II(Binary Search) class solution&#123; public boolean search(int[] nums ,int target)&#123; int start = 0, end = nums.length - 1; //check each num so we will check start == end //We always get a sorted part and a half part //we can check sorted part to decide where to go next while(start&lt;=end)&#123; int mid = start + (end-start)/2; if(nums[mid] == target)return true; //if left part is sorted if(nums[mid] &gt; nums[start])&#123; if(target &gt; nums[mid] || target &lt; nums[start])&#123; //target is in rotated part start = mid +1; &#125;else&#123; end = mid -1; &#125; &#125;else if(nums[mid] &lt; nums[start])&#123; //right part is rotated //target is in rotated part if(target &lt; nums[mid] || target &gt; nums[end])&#123; end = mid -1; &#125;else&#123; start = mid + 1; &#125; &#125;else&#123; //duplicates, we know nums[mid] != target, so nums[start] != target //based on current information, we can only move left pointer to skip one cell //thus in the worest case, we would have target: 2, and array like 11111111, then //the running time would be O(n) start++;//ËøôÈáåÁî®end--‰πüÊòØÂèØ‰ª•ÁöÑ &#125; &#125;return false; &#125;&#125; ÊÄùË∑Ø ‰∏ÄÈÅìÊØîËæÉÂ§çÊùÇÁöÑ‰∫åÂàÜÊü•ÊâæÔºåÊï∞ÁªÑÊó†ËßÑÂæãsortÔºåÂàÜ‰∏∫È´ò‰Ωé‰∏§Âå∫ÔºåÈúÄË¶ÅÂà§Êñ≠Âì™‰∏™Âå∫ÁÑ∂ÂêéÂÜçËøõ‰∏ÄÊ≠•ÂÅöÂÜ≥ÂÆöÔºåÂÖ∑‰ΩìÊØîËæÉÁπÅÁêê„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 17","slug":"leetcode17","date":"2019-05-28T12:36:39.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/28/leetcode17/","link":"","permalink":"WangHngLeee.github.io/2019/05/28/leetcode17/","excerpt":"ÂÜôÂú®ÂºÄÂ§¥ ÂàöÊâçÂà∑‰∏Ä‰∫©‰∏âÂàÜÂú∞ÔºåÁúãÂà∞ÊúâÂ§ß‰Ω¨Âú®ÂàÜ‰∫´Ëá™Â∑±ÁöÑ‰∏äÂ≤∏ÂøÉÂæóÔºåÊÑüËß¶Êå∫Â§ö„ÄÇ‰ªñËØ¥Âà∑È¢òÊòØ‰∏ÄÈ°πÈïø‰πÖÁöÑÂ∑•‰ΩúÔºåÂÉèÂêÉÈ•≠‰∏ÄÊ†∑Ôºå‰∏çËÉΩÂÅúÔºåË¶ÅÊØèÂ§©Âà∑È¢òÔºå‰øùÊåÅÊâãÊÑüÔºåÂ§öÂ§ç‰π†Â§öÊÄªÁªì„ÄÇ Ëøô‰∏ÄÁÇπÊàëËôΩÁÑ∂ÂÅöÂà∞‰∫Ü‰ΩÜÊòØËøòË¶ÅÂùöÊåÅ‰∏ãÂéª„ÄÇÂà∑È¢òÁöÑÊó∂ÂÄôË¶ÅÊÄùËÄÉÔºåÂ¶ÇÊûúÈù¢ËØïÈóÆÂà∞‰∫ÜËøôÈÅìÈ¢ò, ‰∫∫ÂÆ∂‰∏∫‰ªÄ‰πàË¶ÅÈóÆÔºüÂ∏ñÂ≠êÁöÑÊ•º‰∏ªËØ¥ÂæóÊúâÈÅìÁêÜÔºåÂÖ¨Âè∏ÂÆûÈôÖÈÅá‰∏çÂà∞ÁöÑÈóÆÈ¢òÊÄé‰πà‰ºöËÄÉ‰Ω†Âë¢Ôºü ÊâÄ‰ª•Ë¶ÅÊääËøôÈÅìÈ¢òÂΩìÊàêÁõÆÊ†áÂÖ¨Âè∏ÈúÄË¶ÅËß£ÂÜ≥ÁöÑÈóÆÈ¢òÊù•ÊÄùËÄÉÔºåÂ§öË∑ühr‰∫§ÊµÅÊ≤üÈÄöÊÄùË∑ØÔºå‰∏çË¶ÅÈó∑Â§¥Ëß£È¢ò„ÄÇ ÊØïÁ´ü‰∏ÄÂÖ±‰∏ÄÂçÉÂ§öÈÅìÈ¢òÔºå‰∏ÄÊ¨°ÊäïÂÖ•ÊåÅ‰πÖÊÄß‰∫ßÂá∫ÔºàÊªëÁ®ΩËÑ∏Ôºâ„ÄÇ Ë®ÄÂΩíÊ≠£‰º†ÔºåÁªßÁª≠Âà∑È¢òÂêß„ÄÇ‰ªäÂêé‰∏ªË¶ÅÊåâtagÊù•Âà∑È¢òÔºåÊõ¥ÊúâÈíàÂØπÊÄß‰∫Ü„ÄÇ","text":"ÂÜôÂú®ÂºÄÂ§¥ ÂàöÊâçÂà∑‰∏Ä‰∫©‰∏âÂàÜÂú∞ÔºåÁúãÂà∞ÊúâÂ§ß‰Ω¨Âú®ÂàÜ‰∫´Ëá™Â∑±ÁöÑ‰∏äÂ≤∏ÂøÉÂæóÔºåÊÑüËß¶Êå∫Â§ö„ÄÇ‰ªñËØ¥Âà∑È¢òÊòØ‰∏ÄÈ°πÈïø‰πÖÁöÑÂ∑•‰ΩúÔºåÂÉèÂêÉÈ•≠‰∏ÄÊ†∑Ôºå‰∏çËÉΩÂÅúÔºåË¶ÅÊØèÂ§©Âà∑È¢òÔºå‰øùÊåÅÊâãÊÑüÔºåÂ§öÂ§ç‰π†Â§öÊÄªÁªì„ÄÇ Ëøô‰∏ÄÁÇπÊàëËôΩÁÑ∂ÂÅöÂà∞‰∫Ü‰ΩÜÊòØËøòË¶ÅÂùöÊåÅ‰∏ãÂéª„ÄÇÂà∑È¢òÁöÑÊó∂ÂÄôË¶ÅÊÄùËÄÉÔºåÂ¶ÇÊûúÈù¢ËØïÈóÆÂà∞‰∫ÜËøôÈÅìÈ¢ò, ‰∫∫ÂÆ∂‰∏∫‰ªÄ‰πàË¶ÅÈóÆÔºüÂ∏ñÂ≠êÁöÑÊ•º‰∏ªËØ¥ÂæóÊúâÈÅìÁêÜÔºåÂÖ¨Âè∏ÂÆûÈôÖÈÅá‰∏çÂà∞ÁöÑÈóÆÈ¢òÊÄé‰πà‰ºöËÄÉ‰Ω†Âë¢Ôºü ÊâÄ‰ª•Ë¶ÅÊääËøôÈÅìÈ¢òÂΩìÊàêÁõÆÊ†áÂÖ¨Âè∏ÈúÄË¶ÅËß£ÂÜ≥ÁöÑÈóÆÈ¢òÊù•ÊÄùËÄÉÔºåÂ§öË∑ühr‰∫§ÊµÅÊ≤üÈÄöÊÄùË∑ØÔºå‰∏çË¶ÅÈó∑Â§¥Ëß£È¢ò„ÄÇ ÊØïÁ´ü‰∏ÄÂÖ±‰∏ÄÂçÉÂ§öÈÅìÈ¢òÔºå‰∏ÄÊ¨°ÊäïÂÖ•ÊåÅ‰πÖÊÄß‰∫ßÂá∫ÔºàÊªëÁ®ΩËÑ∏Ôºâ„ÄÇ Ë®ÄÂΩíÊ≠£‰º†ÔºåÁªßÁª≠Âà∑È¢òÂêß„ÄÇ‰ªäÂêé‰∏ªË¶ÅÊåâtagÊù•Âà∑È¢òÔºåÊõ¥ÊúâÈíàÂØπÊÄß‰∫Ü„ÄÇ 64. Minimum Path Sum Ëá™Â∑±ÂÅöÂá∫Êù•ÁöÑdpÈ¢òÔºåÊÄùË∑ØÂæàÁÆÄÂçïÔºå‰πãÂâçÂÅöËøáËÆ∏Â§öÁ±ª‰ººÁöÑÔºåÁõ¥Êé•‰∏ä‰ª£Á†ÅÂêß„ÄÇ class solution&#123; public int minpath(int[][] grid)&#123; int m = grid.length; int n = grid[0].length; for(int i = 0 ; i&lt; m;i++)&#123; for(int j =0; j&lt;n; j++)&#123; if(i==0 &amp;&amp; j !=0)&#123;//Á¨¨‰∏ÄË°å grid[i][j]+=grid[i][j-1]; &#125; else if (i!=0 &amp;&amp; j == 0)&#123;//Á¨¨‰∏ÄÂàó grid[i][j] += grid[i-1][j]; &#125; else if(i==0&amp; j ==0)&#123;//Â∑¶‰∏äËßíÂéüÁÇπ grid[i][j]=grid[i][j]; &#125; else&#123;//Ê≠£Â∏∏Á¥ØÂä†ÔºåÂèñÊúÄÂ∞èÂÄº grid[i][j]+=Math.min(grid[i][j-1],grid[i-1][j]); &#125; &#125; &#125; return grid[m-1][n-1]; &#125;&#125; ÊÄùË∑Ø Âíå‰πãÂâçÁöÑunique path ‰∏Ä‰∏™ÊÄùË∑ØÔºå‰πãÂêé‰∏çËøáÊòØÂ∞ÜÊØè‰∏™ÁÇπÁöÑË∑ØÂæÑÊï∞ÈáèÊç¢Êàê‰∫ÜÊùÉÂÄºÔºåÈúÄË¶ÅÂú®ÊúÄÂêéÁ¥ØÂä†Êó∂Áî®minÊù•ÂÜ≥ÂÆöÊúÄÂ∞èÂÄºÁöÑË∑ØÂæÑ„ÄÇ 67. Add Binary class solution&#123; public String addbinary(String a, String b)&#123; int i = a.length()-1;//‰ªéÊú´Â∞æÂºÄÂßãÁ¥ØÂä† int j = b.length()-1; int carry = 0; StringBuilder sb = new StringBuilder(); while( i &gt;=0 || j&gt;= 0)&#123; int sum = carry; if( i &gt;=0)&#123; sum += a.charAt(i)-'0'; i--; &#125; if(j&gt;=0)&#123; sum += b.charAt(j)-'0'; j--; &#125; sb.append(sum%2);//sumÂíå2ÁöÑÂÖ≥Á≥ªÔºåÈÅáÂà∞sum=2 Âä†0,1Âíå0Âàô‰∏∫Êú¨Ë∫´„ÄÇ carry = sum/2;// Âà§Êñ≠Ëøõ‰ΩçÔºåÂè™ÊúâÈÅáÂà∞2Êó∂Êâç‰∏∫1ÔºåÂÖ∂‰ΩôÈÉΩ‰∏∫0. &#125; if(carry!=0) sb.append(carry);//Âä†ÂÖ•ÊúÄÂêé‰∏Ä‰∏™carry return sb.reverse().toString();//ÈÄÜËΩ¨‰∏Ä‰∏ãÔºåÂõ†‰∏∫‰ªéÊú´Â∞æÂºÄÂßãÊòØÈ°∫Â∫èÂä†ÂÖ•stringÁöÑÔºåÊâÄ‰ª•Ë¶ÅÈÄÜÂ∫èËæìÂá∫ &#125;&#125; ÊÄùË∑Ø ‰∫åËøõÂà∂Âä†Ê≥ïÈ¢òÔºå‰ªéÊú´‰ΩçÁõ∏Âä†ÔºåÈáçË¶ÅÁöÑÊòØsum%2 Âíå sum/2ÁöÑÊÄùÊÉ≥„ÄÇÊúÄÂêéÈÄÜÂ∫èËæìÂá∫„ÄÇ ÂÖ∂ÂÆû‰πüÂèØ‰ª•Áî®stackÂÅöÔºåÊúÄÂêésb.add(stack.pop())Â∞±ÂèØ‰ª•Ôºå‰ΩÜÊòØÊØîËæÉÈ∫ªÁÉ¶ÔºåËøòÊòØÂñúÊ¨¢StringBuilder ÁöÑÂÅöÊ≥ï„ÄÇ 85. Maximal Rectangle class Solution &#123; public int maximalRectangle(char[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return 0; int m = matrix.length, n = matrix[0].length, maxArea = 0; int[] left = new int[n]; int[] right = new int[n]; int[] height = new int[n]; Arrays.fill(right, n - 1); for (int i = 0; i &lt; m; i++) &#123;//right ‰ªéÂè≥Ëá≥Â∑¶Êâ´ÊèèÔºåÊâæmin int rB = n - 1; for (int j = n - 1; j &gt;= 0; j--) &#123; if (matrix[i][j] == '1') &#123; right[j] = Math.min(right[j], rB); &#125; else &#123; right[j] = n - 1; rB = j - 1; &#125; &#125; int lB = 0; for (int j = 0; j &lt; n; j++) &#123;//left ‰ªéÂ∑¶Ëá≥Âè≥Êâ´ÊèèÔºåÊâæmax if (matrix[i][j] == '1') &#123; left[j] = Math.max(left[j], lB); height[j]++; maxArea = Math.max(maxArea, height[j] * (right[j] - left[j] + 1)); &#125; else &#123; height[j] = 0; left[j] = 0; lB = j + 1; &#125; &#125; &#125; return maxArea; &#125;&#125; ÊÄùË∑Ø Êå∫ÈöæÁöÑ‰∏ÄÈÅìÈ¢òÔºåÊâæÂá∫ÊúÄÂ§ßÁöÑÁü©ÂΩ¢Èù¢ÁßØ„ÄÇ ÊòéÊòæÁöÑDPÊñπÊ≥ïÔºå‰ΩÜÊòØÂÖ∑‰ΩìÁöÑÊÄùË∑ØËøòÊòØÂê¨ÁÉßËÑëÁöÑ„ÄÇ Á≠ñÁï•: ÊäämatrixÁúãÊàêÂ§ö‰∏™Áõ¥ÊñπÂõæ, ÊØè‰∏ÄË°åÂèäÂÖ∂‰∏äÊñπÁöÑÊï∞ÊçÆÈÉΩÊûÑÊàê‰∏Ä‰∏™Áõ¥ÊñπÂõæ, ÈúÄË¶ÅËÄÉÂØümatrix.size()‰∏™Áõ¥ÊñπÂõæ ÂØπ‰∫éÊØè‰∏™ÁÇπ(row, col), Êàë‰ª¨ÊúÄÂêéÈÉΩËÆ°ÁÆó‰ª•Ëøô‰∏™ÁÇπ‰∏äÊñπÁöÑËøûÁª≠ÁöÑ‚Äô1‚ÄôÂæÄleft, rightÊñπÂêëÂª∂Áî≥ÂèØ‰ª•ÂæóÂà∞ÁöÑÊúÄÂ§ßÁöÑÁü©ÂΩ¢ÁöÑÈù¢ÁßØ ÈÄöËøáËøôÁßçÊñπÊ≥ïËé∑ÂèñÁöÑÁü©ÂΩ¢‰∏ÄÂÆö‰ºöÊääÊúÄÂ§ßÁöÑÁü©ÂΩ¢ÂåÖÂê´Âú®ÂÜÖ height[row][col]ËÆ∞ÂΩïÁöÑÊòØ(row, col)Ëøô‰∏™ÂùêÊ†á‰∏∫Â∫ïÂ∫ßÁöÑÁõ¥ÊñπÂõæÊü±Â≠êÁöÑÈ´òÂ∫¶, Â¶ÇÊûúËøô‰∏™ÁÇπÊòØ‚Äô0‚Äô, ÈÇ£‰πàÈ´òÂ∫¶ÂΩìÁÑ∂ÊòØ0‰∫Ü left[row][col]ËÆ∞ÂΩïÁöÑÊòØ(row, col)Ëøô‰∏™ÂùêÊ†áÁÇπÂØπÂ∫îÁöÑheightÂèØ‰ª•Âª∂Áî≥Âà∞ÁöÑÊúÄÂ∑¶ËæπÁöÑ‰ΩçÁΩÆ right[row][col]ËÆ∞ÂΩïÁöÑÊòØ(row, col)Ëøô‰∏™ÂùêÊ†áÁÇπÂØπÂ∫îÁöÑheightÂèØ‰ª•Âª∂Áî≥Âà∞ÁöÑÊúÄÂè≥ËæπÁöÑ‰ΩçÁΩÆ+1 ‰ª•‰∏äÈù¢ÁöÑmatrix‰∏∫‰æã, ÂØπ‰∫é(row=2, col=1)Ëøô‰∏™ÁÇπ, left=0, right=5, height=1 ÂØπ‰∫é(row=2, col=2)Ëøô‰∏™ÁÇπ, left=2, right=3, height=3 (2,2)Ëøô‰∏™ÁÇπ‰∏é(2,1)Á¥ßÊå®ÁùÄ,leftÂíårightÂç¥Â∑≤ÁªèÂèòÂåñÂ¶ÇÊ≠§‰πãÂ§ß‰∫Ü, ËøôÊòØÂõ†‰∏∫leftÂíårightÈô§‰∫ÜÂèóÂ∑¶Âè≥‰∏§ËæπÁöÑ‚Äô1‚ÄôÂΩ±Âìç, ËøòÂèóÂà∞‰∫ÜÂÖ∂‰∏äÊñπËøûÁª≠ÁöÑ‚Äô1‚ÄôÁöÑÂà∂Á∫¶ Áî±‰∫éÁÇπ(2,2)‰∏äÊúâheight=3‰∏™‚Äô1‚Äô, ËøôÂá†‰∏™‚Äô1‚ÄôÁöÑleftÁöÑÊúÄÂ§ßÂÄº‰Ωú‰∏∫ÂΩìÂâçÁÇπÁöÑleft, ËøôÂá†‰∏™‚Äô1‚ÄôÁöÑrightÁöÑÊúÄÂ∞èÂÄº‰Ωú‰∏∫ÂΩìÂâçÁÇπÁöÑright Âõ†Ê≠§, ÂÆûÈôÖ‰∏ä, Êàë‰ª¨ÊòØË¶ÅÊâæ‰ª•hightÂØπÂ∫îÁöÑËøôÊù°Á∫øÊÆµÂæÄÂ∑¶Âè≥‰∏§ËæπÁßªÂä®(Âè™ËÉΩÂæÄÂÖ®ÊòØ‚Äô1‚ÄôÁöÑÂú∞ÊñπÁßªÂä®), ÂèØ‰ª•Êâ´ËøáÁöÑÊúÄÂ§ßÈù¢ÁßØ ÂΩìhight‰∏éÁõÆÊ†áÊúÄÂ§ßÁü©ÂΩ¢Âå∫ÂüüÁöÑÊúÄÁü≠ÁöÑheightÈáçÂêàÊó∂, ÊúÄÂ§ßÁü©ÂΩ¢ÁöÑÈù¢ÁßØÂ∞±ÊâæÂà∞‰∫Ü, Â¶Ç‰∏äÈù¢ÁöÑ‰æãÂ≠ê, Â∞±ÊòØÁÇπ(2,3)Êàñ(2,4)ÂØπÂ∫îÁöÑheight 72. Edit Distance class solution&#123; public int mindistance(String word1,String word2)&#123; int m = word1.length(); int n = word2.length(); int[][] dp = new int[m+1][n+1]; for(int i = 0;i&lt;=m;i++)// ÊúÄÂ∑¶ÂàóÊÉÖÂÜµÔºåword1Â≠òÂú®Ôºåword2‰∏∫Á©∫ cost[i][0] = i; for(int i = 1; i&lt;=n;i++)//ÊúÄ‰∏äË°åÊÉÖÂÜµÔºåword2Â≠òÂú®Ôºåword1‰∏∫Á©∫ cost[0][i]=i; for(int i = 0; i &lt;=m;i++)&#123; for(int j = 0; j &lt;=n;j++)&#123; if(word1.charAt(i) == word2.charAt(j))&#123;// i Âíåj ÂÖÉÁ¥†Áõ∏Âêå dp[i][j] = dp[i-1][j-1]; &#125; else&#123;//‰∏çÂêåÁöÑÊÉÖÂÜµ‰∏ãÔºå‰∏âÁßçÊé™ÊñΩ int replace = dp[i-1][j-1]; int delete = dp[i-1][j]; int insert = dp[i][j-1]; cost[i][j] = Math.min(replace,Math.min(delete,insert))+1; &#125; &#125; &#125; return dp[m][n]; &#125;&#125; ÊÄùË∑Ø ÂÖ∏ÂûãÁöÑdpÈ¢òÔºåÂ≠óÁ¨¶‰∏≤ÁöÑÂ¢ûÂà†ÊõøÊç¢ÔºåÁî®dpÊÄùÊÉ≥Ôºå‰∏ÄÂÖ±ÊúâÂõõÁßçÊìç‰Ωú„ÄÇ 1.word1 ÁöÑiÂÖÉÁ¥†Âíåword2ÁöÑjÂÖÉÁ¥†Áõ∏ÂêåÔºåÊó†Êìç‰ΩúÔºåÂÖ∂Êìç‰ΩúÊ¨°Êï∞‰∏∫dp[i-1][j-1]Âç≥‰∏ä‰∏Ä‰∏™Â≠óÊØçÁöÑÊÉÖÂÜµ„ÄÇ2.Ëøô‰∏§‰∏™ÂÖÉÁ¥†‰∏çÁõ∏ÂêåÔºåÂèØ‰ª•Êúâ‰∏âÁßçÊìç‰ΩúÔºö (1) replace ÊõøÊç¢Ôºådp[i-1][j-1]ÔºåÂ∞Ü‰∏ä‰∏Ä‰∏™Â≠óÊØçÊõøÊç¢‰∏∫ÂΩìÂâçÂ≠óÊØçÔºå (2) delete Âà†Èô§ÔºåÂ∞Üword1ÈáåÂΩìÂâçÂÖÉÁ¥†Âà†Èô§Ôºådp[i-1][j]ÔºåÂèò‰∏∫ÂÖ∂Ââç‰∏Ä‰∏™Â≠óÊØç (3) insert ÊèíÂÖ•ÔºåÂêëword1ÈáåÊèíÂÖ•word2ÁöÑÂâç‰∏Ä‰∏™ÂÖÉÁ¥†Ôºådp[i][j-1]Ôºå Ê≥®ÊÑèÂèñËøô‰∏âËÄÖÁöÑÊúÄÂ∞èÂÄºÔºåÁÑ∂ÂêéÂä†1„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 16","slug":"leetcode16","date":"2019-05-27T13:19:39.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/05/27/leetcode16/","link":"","permalink":"WangHngLeee.github.io/2019/05/27/leetcode16/","excerpt":"52. N-Queens II class solution&#123; int res = 0; public int nqueen2(int n)&#123; boolean[] col = new boolean[n]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; private void solve(int row, int n, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0;j&lt;nlj++)&#123; if(!col[j] &amp;&amp; !diag1[row+j] &amp;&amp; ! diag2[row-j+n-1])&#123; col[j]=true; diag1[row + j] = true; diag2[row-j+n-1]= true; solve(row+1,n,col,diag1,diag2); diag2[row-j+n-1]= false; diag1[row + j] = false; col[j]=false; &#125; &#125; &#125;&#125;","text":"52. N-Queens II class solution&#123; int res = 0; public int nqueen2(int n)&#123; boolean[] col = new boolean[n]; boolean[] diag1 = new boolean[n*2-1]; boolean[] diag2 = new boolean[n*2-1]; solve(0,n,col,diag1,diag2); return res; &#125; private void solve(int row, int n, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; res++; return; &#125; for(int j=0;j&lt;nlj++)&#123; if(!col[j] &amp;&amp; !diag1[row+j] &amp;&amp; ! diag2[row-j+n-1])&#123; col[j]=true; diag1[row + j] = true; diag2[row-j+n-1]= true; solve(row+1,n,col,diag1,diag2); diag2[row-j+n-1]= false; diag1[row + j] = false; col[j]=false; &#125; &#125; &#125;&#125; ÊÄùË∑Ø ÂíåNQueenÊÄùË∑ØÂü∫Êú¨‰∏ÄËá¥ÔºåÂè™‰∏çËøáËæìÂá∫ÁöÑÊòØÁßçÁ±ªÊï∞ÈáèËÄå‰∏çÊòØQÁöÑÊéíÂàóÊñπÂºè„ÄÇÊâÄ‰ª•Áõ∏ÊØî‰∫éQueen1Êù•ËØ¥ÊØîËæÉÁÆÄÂçï„ÄÇbacktrackingÁöÑÊÄùÊÉ≥„ÄÇ 57. Insert Interval class solution&#123; public int[][] insert(int[][] intervals, int[] newInterval)&#123; List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for(int [] interval : intervals)&#123; if(newInterval[1]&lt;interval[0])&#123; ans.add(newInterval); newInterval = interval; &#125; else if(newInterval[0] &gt; interval[1])&#123; ans.add(interval); &#125; else&#123; newInterval[0] = Math.max(newInterval[0],interval[0]); newInterval[1] = Math.min(newInterval[1],interval[1]); &#125; &#125; ans.add(newInterval); return ans.toArray( new int[][] &#123;&#125;); &#125;&#125; Ê≥®ÊÑèÂèñËàçÁöÑÊÉÖÂÜµÔºåintervalÁöÑÂºÄÂ§¥ÁªìÂ∞æÂíånewintervalÁöÑÂºÄÂ§¥ÁªìÂ∞æËøõË°åÊØîËæÉ„ÄÇ‰∏âÁßçÊÉÖÂÜµ„ÄÇnewÂ∞èÔºåÂ∞ÜnewÂä†ÂÖ•ansÔºåÂπ∂Êõ¥Êñ∞newÔºõintervalÂ∞èÔºåÂ∞ÜintervalÂä†ÂÖ•ans„ÄÇÔºõÊúâÈáçÂêàÈÉ®ÂàÜÔºåÂºÄÂ§¥ÂèñÊúÄÂ∞èÔºåÁªìÂ∞æÂèñÊúÄÂ§ß„ÄÇ 58. Length of Last Word class solution&#123; public int length(String s)&#123; if(s == null || s.length() == 0)&#123; return 0; &#125; int end = s.length() -1; while(end&gt;=0 &amp;&amp; s.charAt(end) == ' ')&#123; end--; &#125; if(end == -1)return 0; int start = end; while(start&gt;=0 &amp;&amp; s.charAt(start) != ' ')&#123; start--; &#125; return end - start; &#125;&#125; ÊåâÁÖßÁ©∫Ê†ºÂàÜÈöîÔºåendÈÅáÂà∞Á©∫Ê†ºÂáè‰∏ÄÔºåËÄåstartÈÅáÂà∞ÈùûÁ©∫Ê†ºÂáè‰∏ÄÔºå‰ªéÂêéÂêëÂâçÊ£ÄÁ¥¢ÔºåÊúÄÂêéËæìÂá∫end-start„ÄÇ 59. Spiral Matrix II class solution&#123; public int[][] generateMatrix(int n)&#123; int [][] res = new int[n][n]; int cur = 1; int rowbegin = 0; int rowend = n-1; int colbegin = 0; int colend = n-1; while( cur &lt; n*n)&#123; int i = rowbegin; int j = colbegin; for(j = colbegin; j &lt;= colend;j++)&#123; res[rowbegin][j] = cur; cur++; &#125; rowbegin++;// Á¨¨‰∏ÄÊ≠•ÊòØ‰ªé‰∏äËá≥‰∏ã for(i = rowbegin ; i &lt;= rowend ; i++)&#123; res[i][colend] = cur; cur++; &#125; colend--;//Á¨¨‰∫åÊ≠•‰ªéÂè≥Ëá≥Â∑¶ for(j = colend ; j &gt;= colbegin ; j++)&#123; res[rowend][j] = cur; cur++; &#125; rowend--;//Á¨¨‰∏âÊ≠•‰ªé‰∏ãËá≥‰∏ä for(i = rowend; i&gt;=rowbegin; i++)&#123; res[i][colbegin] = cur; cur++; &#125; colbegin ++;//ÊúÄÂêé‰∏ÄÊ≠•‰ªéÂ∑¶Ëá≥Âè≥ &#125; &#125;&#125; ÊÄùË∑Ø Ëû∫ÊóãËæìÂá∫Áü©ÈòµÔºåÂàÜÂõõÂ§ßÊ≠•Ôºå‰∏äËá≥‰∏ãÔºåÂè≥Ëá≥Â∑¶Ôºå‰∏ãËá≥‰∏äÔºåÂ∑¶Ëá≥Âè≥„ÄÇ 61. Rotate List /** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; public ListNode rotatelinkedlist(ListNode head, int k)&#123; if(head == null || head.next == null)&#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy, slow = dummy; int i; for (i = 0 ; fast.next!=null;i++)&#123; fast = fast.next; &#125; for(int j = i-k%n;j&gt;0;j--)&#123; slow = slow.next; &#125; fast.next = dummy.next; dummy.next = slow.next; slow.next = null; return dummy.next; &#125; &#125; ÊÄùË∑Ø ÂèçËΩ¨ÈìæË°®ÔºåÂÖ≥ÈîÆÁöÑÈóÆÈ¢òÂú®‰∫éÊñ≠ÁÇπslowÁöÑÈÄâÂèñÔºåÂÖ∑‰ΩìËØÅÊòéÂèÇËÄÉleetcode 61ÁöÑdiscussÔºåÂæàÂ∑ßÂ¶ô„ÄÇÂú®ÂæóÂá∫Êñ≠ÁÇπÁöÑ‰ΩçÁΩÆÂêéÔºåÁõ¥Êé•ËøõË°å‰∫§Êç¢Âç≥ÂèØ„ÄÇ 62. Unique Paths class solution&#123; public int uniquePath(int m, int n)&#123; Integer[][] map = new Integer[m][n]; for(int i =0 i&lt; m;i++)&#123; map[i][0] = 1; &#125; for(int j = 0; j &lt; n; j++)&#123; map[0][j] = 1; &#125; for(int i = 0; i&lt; m;i++)&#123; for(int j = 0; j &lt; n ; j ++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; &#125;return map[m-1][n-1]&#125; ÊÄùË∑Ø ÈáçÊñ∞Â§ç‰π†‰∏Ä‰∏ãÔºåÂÖàÂ∞ÜËæπÁºòËÆæ‰∏∫1ÔºåÁÑ∂ÂêéÊØè‰∏™‰ΩçÁΩÆÁöÑÁßçÁ±ªÊòØÂÆÉtopÂíåleftÁßçÁ±ªÂíå„ÄÇÁÑ∂ÂêéÂæ™ÁéØ‰∏ãÂéª„ÄÇÂ§çÊùÇÂ∫¶ÊòØO(m*n)„ÄÇ 63. Unique Paths II class solution&#123; public int uniquepath(int [][] obstaclegrid)&#123; int width = obstaclegrid[0].length; int [] dp = new int[width]; dp[0] = 1; for(int [] row : obstaclegrid)&#123; for(int j = 0; j&lt; width;j++)&#123; if(row[j] == 1)&#123; dp[j] = 0; &#125; else if (j&gt;0)&#123; dp[j] += dp[j-1]; &#125; &#125; &#125; return dp[width-1]; &#125;&#125; ÊÄùË∑Ø Êñ∞Â•áÁöÑÂÅöÊ≥ï„ÄÇÂ∏∏ËßÑÊÄùË∑ØÁî®2DÁöÑdpÊù•Â≠òÂÇ®ÔºåËøôÈÅìÈ¢òÈááÁî®1DÁöÑdpÊù•Â≠òÂÇ®ÔºåÂè™ËÄÉËôëjÔºåÁî®jÊù•Êõ¥Êñ∞dpÂÄº„ÄÇ dp [ j ] += dp [ j - 1 ] is dp [ j ] = dp [ j ] + dp [j - 1]; Âç≥ new dp [ j ] = old dp [ j ] + dp [ j-1 ] Âç≥ current cell = top cell + left cell„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 15","slug":"leetcode15","date":"2019-05-26T13:13:39.000Z","updated":"2020-02-03T01:16:22.247Z","comments":true,"path":"2019/05/26/leetcode15/","link":"","permalink":"WangHngLeee.github.io/2019/05/26/leetcode15/","excerpt":"45. Jump Game II class solution&#123; public int jump(int[] nums)&#123; int jumps = 0, curend = 0, int curfast = 0; for(int i = 0; i&lt;nums.length-1;i++)&#123; curfast = Math.max(curfast, i+nums[i]); if(i == curend)&#123; jumps ++; curend = curfast; if(curend &gt;= nums.length)&#123; break; &#125; &#125; &#125; return jumps; &#125;&#125;","text":"45. Jump Game II class solution&#123; public int jump(int[] nums)&#123; int jumps = 0, curend = 0, int curfast = 0; for(int i = 0; i&lt;nums.length-1;i++)&#123; curfast = Math.max(curfast, i+nums[i]); if(i == curend)&#123; jumps ++; curend = curfast; if(curend &gt;= nums.length)&#123; break; &#125; &#125; &#125; return jumps; &#125;&#125; ÊÄùË∑Ø Greddy ÊÄùÊÉ≥ÁöÑ‰∏ÄÈÅìÈ¢òÔºåÁî®curendÂ≠ò‰ΩèÂΩìÂâç‰ΩçÁΩÆËÉΩÂ§üË∑≥Âà∞ÁöÑÊúÄËøú‰ΩçÁΩÆÔºåcurfastÂ≠ò‰Ωè‰ªéÂΩìÂâçËäÇÁÇπÂà∞curend‰πãÈó¥ÔºåÂêÑ‰∏™ËäÇÁÇπËÉΩÂ§üËµ∞Âà∞ÁöÑÊúÄËøú‰ΩçÁΩÆÔºåÊâÄ‰ª•ÂΩìi=curendÊó∂Ôºå‰πüÂ∞±ÊòØËµ∞Âà∞ÂΩìÂâçËäÇÁÇπÊâÄËÉΩÂ§üËß¶ÂèäÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†Êó∂ÔºåjumpÂøÖÂÆöÂä†‰∏ÄÔºåÂπ∂‰∏îÂ∞ÜcurendÊõ¥Êñ∞‰∏∫curfast„ÄÇÂΩìcurendÂ§ß‰∫éÊï¥‰∏™Êï∞ÂàóÈïøÂ∫¶Êó∂ÔºåÂç≥Ê£ÄÁ¥¢ÂÆåÊàêÔºåÂàôÊèêÂâçbreakÈÄÄÂá∫Âæ™ÁéØ„ÄÇ 55. Jump Game class solution&#123; public boolean jump(int [] nums)&#123; int dis = ; for(int i =0; i&lt;=dis;i++)&#123; dis = Math.max(dis,i+nums[i]); if(dis &gt; = nums.length -1)return true; &#125; return false; &#125;&#125; ÊÄùË∑Ø Âíå‰∏ä‰∏ÄÈ¢òÂ∑Æ‰∏çÂ§öÁöÑÊÄùË∑ØÔºåÂè™‰∏çËøáÊòØÊç¢ÊàêbooleanËæìÂá∫ÔºåÂè™Ë¶ÅÂà§Êñ≠Âæ™ÁéØ‰∏≠ÊúâÊó†‰∏Ä‰∏™Êó∂ÂàªÔºådisË∂ÖÂá∫ÊàñËÄÖÁ≠â‰∫énums.lengthÔºåÂ¶ÇÊûúÊúâÂàôËÇØÂÆö‰∏∫trueÔºåËã•Ê≤°ÊúâÂàô‰∏∫false„ÄÇ 47. Permutations II class solution&#123; public List&lt;List&lt;Integer&gt;&gt; permutations(int [] nums)&#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list,new ArrayList&lt;&gt;(),nums, new boolean[nums.length]); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist , int[]nums,boolean[] used)&#123; if(templist.size()==nums.length)&#123; list.add(new ArrayList&lt;&gt;(templist)); &#125; else&#123; for(int i = 0; i &lt;nums.length;i++)&#123; if(used[i] || i&gt;0 &amp;&amp;nums[i]==nums[i-1] &amp;&amp; !used[i-1]) continue; used[i] = true; templist.add(nums[i]); backtrack(list,templist,nums,used); used[i] = false; templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; ÊÄùË∑Ø backtrackÁöÑÊÄùÊÉ≥Ôºåleetcode 13 ÈáåÊúâËÆ≤Ôºå‰ªäÂ§©ÁÆóÊòØÂ§ç‰π†‰∏ÄÈÅç„ÄÇ ÊúÄÂêéforÈáåÈù¢ÁöÑifÊù°‰ª∂Ôºö1.ËØ•ÂÖÉÊú™‰ΩøÁî® 2. i„Äã0ÔºåËØ•ÂÖÉÁ¥†Âú®numsÈáåÂíåÂâçÈù¢ÈáçÂ§ç‰∏îÂâçÈù¢ÁöÑÂÖÉÁ¥†Êú™‰ΩøÁî®ËøáÔºàÂ¶ÇÊûúÂâç‰∏Ä‰∏™ÈáçÂ§çÁöÑÂÖÉÁ¥†‰ΩøÁî®ËøáÁöÑËØùÔºåÊòØÂèØ‰ª•Áî®ÂΩìÂâçÂÖÉÁ¥†ÁöÑÔºâ„ÄÇ 51. N-Queens class solution&#123; public List&lt;List&lt;String&gt;&gt; solvequeens( int n)&#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); char[][] curr = new char[n][n]; for(int i = 0; i &lt;n;i++)&#123; for(int j = 0 ; j &lt; n ; j++)&#123; char[i][j] = '.'; &#125; &#125; boolean col = new boolean[n]; boolean diag1 = new boolean[n*2-1]; boolean diag2 = new boolean[n*2-1]; solve(curr,0,,n,res,col,diag1,diag2); return res; &#125; private void solve(char[][] curr, int row, int n, List&lt;List&lt;String&gt;&gt; ret, boolean[] col, boolean[] diag1, boolean[] diag2)&#123; if(row == n)&#123; List&lt;String&gt; toadd = new ArrayList&lt;&gt;(); for(int i =0; i&lt;n;i++)&#123; toadd.add(String.valueOf(curr[i])); &#125; res.add(toadd); return; &#125; for(int j = 0; j &lt; n; j++)&#123; if(col[j] || diag1[row + n -j - 1] || diag2[row + j])continue; col[i]=true; diag1[row + n -j - 1]=true; diag2[row + j] = true; curr[row][j]='Q'; solve(curr,row+1,n,res,col,diag1,diag2); curr[row][j]='.'; diag2[row + j] = false; diag1[row + n -j - 1]=false; &#125; &#125;&#125; ÊÄùË∑Ø ÊØîËæÉÈöæÁöÑ‰∏ÄÈÅìÈ¢òÔºåÂü∫Êú¨ÊÄùÊÉ≥‰πüÊòØbacktrackingÔºåÂÖÉÁ¥†ÊØîËæÉÂ§ö„ÄÇ ÁöáÂêéÊ£ãÊØîËæÉÊÅ∂ÂøÉÁöÑÊòØÂØπËßíÁ∫ø‰πüÂèØ‰ª•Ëµ∞ÔºåÊâÄ‰ª•Ë¶ÅËÆæÁΩÆ‰∏§‰∏™diag1 Âíådiag2Êù•Â≠òÂÇ®Ê≠£ÂèçÂØπËßíÁ∫øÁöÑÂÖÉÁ¥†ÔºåÊ≥®ÊÑè[]ÂÜÖÁöÑË°®ËææÂºè„ÄÇÁî±‰∫éÊØè‰∏ÄÊ¨°ÈÄíÂΩíÂêérowÈÉΩ+1ÔºåÊâÄ‰ª•‰∏çÈúÄË¶ÅËÄÉËôëÊØè‰∏ÄË°åÁöÑÂÜ≤Á™ÅÔºåÂõ†‰∏∫ÊØèÊ¨°ÊØèË°åÂè™‰ºöÂ≠ò‰∏Ä‰∏™Q„ÄÇ ÊØèÊ¨°ÈÄíÂΩíÂêéË¶ÅÂÖ®ÈÉ®ÊÅ¢Â§çÂéüÊ†∑ÔºÅÔºÅÔºÅbacktrackÁöÑÂü∫Êú¨ÊÄùÊÉ≥„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 14","slug":"leeticode14","date":"2019-05-25T20:13:39.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/05/25/leeticode14/","link":"","permalink":"WangHngLeee.github.io/2019/05/25/leeticode14/","excerpt":"","text":"44. Wildcard Matching class solutoin&#123; public boolean isMatch(String str, String pattern)&#123; int s =0,p=0,startidx=-1,match=0; while(s&lt;str.length())&#123; if(p&lt;pattern.length() &amp;&amp; (pattern.charAt(p) == '?' || str.charAt(s)==pattern.charAt(p))&#123; p++; s++; &#125; else if(p&lt;pattern.length() &amp;&amp; pattern.charAt(p) == '*')&#123; staridx = p; match = s; p++; &#125;else if(staridx !=-1)&#123; p = staridx + 1; match++; s=match; &#125; else return false; &#125; while (p&lt;pattern.length()&amp;&amp; pattern.charAt(p) =='*')&#123; p++; &#125; return p == pattern.length(); &#125;&#125; Hint ÁÆÄÂçïÁöÑÂá†‰∏™ifÂà§Êñ≠ÔºåÂèåÊåáÈíàÈóÆÈ¢ò„ÄÇ sÊåáÂêëstr-ÂéüstringÔºåpÊåáÂêëpattern-ÂæÖÊ£ÄÊµãÁöÑstring„ÄÇ ÈáçË¶ÅÁöÑÊòØÁ¨¨‰∏â‰∏™ifÔºåÂΩìstaridx‰∏ÄÁõ¥‰∏ç‰∏∫-1Êó∂ÔºåpÂßãÁªà‰∏∫staridxÁöÑÂêé‰∏Ä‰ΩçÔºå‰øùËØÅ‰∫ÜÂâçÈù¢ÁöÑÊòüÂè∑ÂèØ‰ª•‰∏ÄÁõ¥È°∫ÁùÄsÊ£ÄÊµã‰∏ãÂéª‰∏ç‰∏≠Êñ≠„ÄÇ 10. Regular Expression Matching class solution&#123; public boolean isMatch(String s, String p)&#123; if(s == null || p == null)return false; boolean[][] state = boolean[s.length()+1][p.length()+1]; state[0][0] = true; for(j = 1; j&lt;state[0].length();j++)&#123; if(p.charAt(j-1) == '*')&#123; if(state[0][j-1] || j&gt;1 &amp;&amp; state[0][j-2])&#123; state[0][j] = true; &#125; &#125; &#125; for(int i = 1; i&lt;state.legnth();i++)&#123; for(int j = 1 ; j &lt; state[0].legnth();j++)&#123; if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')&#123; state[i][j] =state[i-1][j-1]; &#125; if(p.charAt(j) == '*')&#123; if(s.charAt(i-1)!= p.charAt(j-2) &amp;&amp; p.charAt(j-2)!='.')&#123; state[i][j] = state[i][j-2]; &#125;else&#123; state[i][j] = state[i-1][j]||state[i][j-1]||state[i][j-2]; &#125; &#125; &#125; &#125; return state[s.length()][p.legnth()]; &#125;&#125; Hint hardÁöÑ‰∏ÄÈÅìÈ¢òÔºå‰πüÊòØÂà§Êñ≠.* ÁöÑÈ¢òÔºå 1, Â¶ÇÊûúp.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]; 2, Â¶ÇÊûúp.charAt(j) == ‚Äò.‚Äô : dp[i][j] = dp[i-1][j-1]; 3, Â¶ÇÊûúp.charAt(j) == '‚Äô: (ÁªÜÂàÜ‰∏âÁßçÊÉÖÂÜµ) 1 ÂΩìp.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] // a Ë°®Á§∫‰∏∫Á©∫ 2 ÂΩìp.charAt(j-1) == s.charAt(i) or p.charAt(j-1) == ‚Äò.‚Äô:ÔºàÁªÜÂàÜ‰∏âÁßçÔºâ dp[i][j] = dp[i-1][j] //a* Ë°®Á§∫‰∏§‰∏™a or dp[i][j] = dp[i][j-1] // a* Ë°®Á§∫‰∏Ä‰∏™a or dp[i][j] = dp[i][j-2] // a* Ë°®Á§∫‰∏∫Á©∫","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 13","slug":"leetcode13","date":"2019-05-24T20:13:39.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/05/24/leetcode13/","link":"","permalink":"WangHngLeee.github.io/2019/05/24/leetcode13/","excerpt":"ÂâçÂá†Â§©Âú®ÂøôÊØïËÆæÂíåÁîªÂõæÔºåÂØºËá¥Âà∑È¢òËøõÂ∫¶‰∏ÄÁõ¥ÂÅúÊªû‰∏çÂâç„ÄÇ ‰ªäÂ§©ÂàöÂà∞ÂÖ¨Âè∏ÂÆû‰π†ÔºåÊÑüËßâÂíåÂ§ß‰Ω¨ÁöÑÂ∑ÆË∑ù‰ªçÁÑ∂ÊòØ‰ª•ÂÖâÂπ¥‰∏∫Âçï‰Ωç„ÄÇ ÂóØÔºåÂä™Âäõ‰∏çËÉΩÂÅúÂïä„ÄÇ Â∫üËØù‰∏çÂ§öËØ¥ÔºåÁªßÁª≠ÂºÄÂßãÂà∑È¢ò„ÄÇ Backtracking Á±ªÂûãÈ¢ò backtrackingÊÄùË∑ØÔºåÊØèÊ¨°recursiveÂêéÂ∞ÜtamplistÁöÑÊï∞ÁªÑÂ§ßÂ∞èÂèòÂõû‰πãÂâçÔºå‰∏∫‰∫ÜÊñπ‰æø‰∏ã‰∏ÄËΩÆÈÄíÂΩí„ÄÇÂπ∂‰∏îÂ∞ÜremainÂèò‰∏∫remain-candidates„Äêi„Äë Â§ßÊ¶ÇÂàÜ‰∏∫‰∏§Á±ªÔºå‰∏ÄÁ±ªÊòØÂèØ‰ª•ÈáçÂ§ç‰ΩøÁî®Ôºå‰∏çÁî®ÊãÖÂøÉÊï∞Â≠óÈáçÂ§çÂá∫Áé∞ÁöÑÊÉÖÂÜµÔºõÂè¶‰∏ÄÁßçÊòØ‰∏çËÉΩÈáçÂ§ç‰ΩøÁî®Ôºå‰πü‰∏çËÉΩÂá∫Áé∞ÈáçÂ§çÊï∞Â≠ó„ÄÇ","text":"ÂâçÂá†Â§©Âú®ÂøôÊØïËÆæÂíåÁîªÂõæÔºåÂØºËá¥Âà∑È¢òËøõÂ∫¶‰∏ÄÁõ¥ÂÅúÊªû‰∏çÂâç„ÄÇ ‰ªäÂ§©ÂàöÂà∞ÂÖ¨Âè∏ÂÆû‰π†ÔºåÊÑüËßâÂíåÂ§ß‰Ω¨ÁöÑÂ∑ÆË∑ù‰ªçÁÑ∂ÊòØ‰ª•ÂÖâÂπ¥‰∏∫Âçï‰Ωç„ÄÇ ÂóØÔºåÂä™Âäõ‰∏çËÉΩÂÅúÂïä„ÄÇ Â∫üËØù‰∏çÂ§öËØ¥ÔºåÁªßÁª≠ÂºÄÂßãÂà∑È¢ò„ÄÇ Backtracking Á±ªÂûãÈ¢ò backtrackingÊÄùË∑ØÔºåÊØèÊ¨°recursiveÂêéÂ∞ÜtamplistÁöÑÊï∞ÁªÑÂ§ßÂ∞èÂèòÂõû‰πãÂâçÔºå‰∏∫‰∫ÜÊñπ‰æø‰∏ã‰∏ÄËΩÆÈÄíÂΩí„ÄÇÂπ∂‰∏îÂ∞ÜremainÂèò‰∏∫remain-candidates„Äêi„Äë Â§ßÊ¶ÇÂàÜ‰∏∫‰∏§Á±ªÔºå‰∏ÄÁ±ªÊòØÂèØ‰ª•ÈáçÂ§ç‰ΩøÁî®Ôºå‰∏çÁî®ÊãÖÂøÉÊï∞Â≠óÈáçÂ§çÂá∫Áé∞ÁöÑÊÉÖÂÜµÔºõÂè¶‰∏ÄÁßçÊòØ‰∏çËÉΩÈáçÂ§ç‰ΩøÁî®Ôºå‰πü‰∏çËÉΩÂá∫Áé∞ÈáçÂ§çÊï∞Â≠ó„ÄÇ Á¨¨‰∏ÄÁ±ª Combination Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Permutations public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Subsets class solution&#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Á¨¨‰∫åÁ±ª Áî±‰∫éË¶ÅÊ±Ç‰∏çËÉΩÂá∫Áé∞ÈáçÂ§çÊï∞Â≠óÔºåËÄå‰∏î‰∏çËÉΩÈáçÂ§ç‰ΩøÁî®ÔºåÊâÄ‰ª•Ë¶ÅÂà§Êñ≠nums[i]==nums[i+1]ÁöÑÊÉÖÂÜµ‰∏ãÁõ¥Êé•Ë∑≥ËøáÔºåÂπ∂‰∏îÈÄíÂΩíÊó∂i+1„ÄÇ Combination Sum 2 (‰∏Ä‰∏™Êï∞Âè™Áî®‰∏ÄÊ¨°‰∏î‰∏çËÉΩÊúâÈáçÂ§çÁöÑÊï∞Â≠ó) class solution&#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=start;i&lt;nums.length;i++)&#123; if(i&gt;start&amp;&amp;nums[i]==nums[i+1])continue; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i+1); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; Permutations II (contains duplicates) public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; Ê≥®ÊÑèËøôÈÅìÈ¢òÂíåÂÖ∂‰ªñÊúâÁï•ÂæÆ‰∏çÂêåÁöÑÂú∞ÊñπÔºåÈ¢ùÂ§ñ‰ΩøÁî®booleanÂÄºÊù•Âà§Êñ≠ËØ•‰ΩçÁΩÆÊòØÂê¶‰ΩøÁî®ËøáÔºå Subsets II (contains duplicates) class solution&#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort() backtrack(list, new ArrayList&lt;&gt;(),candidates,target,0); return list; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; templist,int[] candidates, int remain,int start)&#123; if(remain&lt;0)return; else if(remain == 0)list.add(new ArrayList&lt;&gt;(templist)); else&#123; for(i=0;i&lt;nums.length;i++)&#123; if(i&gt;start&amp;&amp;nums[i]==nums[i+1])continue; templist.add(candidates[i]); backtrack(list,templist,candidates,remain-candidates[i],i+1); templist.remove(templist.size()-1); &#125; &#125; &#125;&#125; 43. Multiply Strings class solution&#123; public String multiply(String num1, String num2) &#123; int m = num1.length(), n = num2.length(); int [] pos = new int[m+n]; for(int i = m-1;i&gt;=0;i--)&#123; for(int j = n-1;j&gt;=0;j--)&#123; int mul = (num1charAt(i)-'0')*(num2charAt(j)-'0'); int p1 = i+j, p2 = i+j+1; int sum = mul + pos[p1]; &#125; &#125; StringBuilder sb = new StringBuilder(); for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p); return sb.length() == 0 ? '0':sb.toString();&#125; ÊÄùË∑Ø Â∞Ü‰πòÊ≥ïËøáÁ®ãÂÜôÂá∫Êù•„ÄÇ ÂÖ∑‰ΩìËß£ÈáäËßÅ leetcode 43 ËØ¶Ëß£,ÂÖ∂ÂÆûÂü∫Êú¨ÊÄùÊÉ≥Â∞±ÊòØÂ∞ÜÁõ∏‰πòËøáÁ®ãÂÜôÂá∫Êù•ÔºåÂèëÁé∞ÊØè‰ΩçÁõ∏‰πòÂêéÂêëÂâçÁßªÂä®‰∏Ä‰ΩçÔºåÊâÄ‰ª•ÂèØ‰ª•ÈááÁî®i+jÔºåi+j+1ËøõË°åposËµãÂÄº„ÄÇ ÂõæËß£Â¶Ç‰∏ãÔºö","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 12","slug":"leetcode12","date":"2019-05-17T13:33:07.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/05/17/leetcode12/","link":"","permalink":"WangHngLeee.github.io/2019/05/17/leetcode12/","excerpt":"22. Generate Parentheses class Solution&#123; public List&lt;String&gt; generate(int n)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res,new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res, StringBuilder sb, int open, int close, int n)&#123; if(open==n&amp;&amp;close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+,slose,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125;","text":"22. Generate Parentheses class Solution&#123; public List&lt;String&gt; generate(int n)&#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); helper(res,new StringBuilder(),0,0,n); return res; &#125; private void helper(List&lt;String&gt; res, StringBuilder sb, int open, int close, int n)&#123; if(open==n&amp;&amp;close==n)&#123; res.add(sb.toString()); return; &#125; if(open&lt;n)&#123; sb.append('('); helper(res,sb,open+,slose,n); sb.setLength(sb.length()-1); &#125; if(close&lt;open)&#123; sb.append(')'); helper(res,sb,open,close+1,n); sb.setLength(sb.length()-1); &#125; &#125;&#125; Hint backtrack ÂíåbuildstringÁªìÂêà„ÄÇÈ¶ñÂÖàÁ¨¨‰∏Ä‰∏™ÂøÖÈ°ªÊòØÔºàÔºå‰∏ã‰∏ÄÊ≠•Ôºàor)ÈÉΩÂèØ‰ª•Ôºå‰ΩÜÊòØÊâìÂç∞ÔºâÁöÑÂâçÊèêÊòØÔºàÁöÑÊï∞ÈáèË¶ÅÂ§ß‰∫éÔºâÁöÑÊï∞ÈáèÔºåËÆ∞‰ΩèÊØè‰∏ÄÊ¨°Ë¶ÅÂ∞ÜsbÁöÑlength backtrack Âáè1. 25. Reverse Nodes in k-Group class solution&#123; public ListNode reverseGroup(ListNode head,int k)&#123; ListNode curr = head; int count = 0; while(curr!=null&amp;&amp;count!=k)&#123; curr=curr.next; count++; &#125; if(count == k)&#123; curr = reverseGroup(curr,k); while(count--&gt;0)&#123; ListNode temp = head.next; head.next = curr; curr = head; head = temp; &#125; head = curr; &#125; return head; &#125;&#125; Hint ÊØèÈÅáÂà∞k‰∏™ÂÖÉÁ¥†Â∞±Ë¶ÅÁøªËΩ¨‰∏ÄÊ¨°ÔºåÊØè‰∏™Âæ™ÁéØÁöÑÁøªËΩ¨Ê¨°Êï∞‰∏ÄÂÖ±ÊòØcount‰πüÂ∞±ÊòØkÊ¨°ÔºåÊ≥®ÊÑèÁøªËΩ¨ÁöÑcodeË°®Ëææ„ÄÇ 30. Substring with Concatenation of All Words class Solution &#123; public List&lt;Integer&gt; find(String s, String[] words)&#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int wordnum = words.length(); if (wordnum==0)&#123; return res; &#125; int wordlen = words[0].length(); HashMap&lt;String,Integer&gt; allwords = new HashMap&lt;String,Integer&gt;(); for(String w :words)&#123; int value = allwords.gerOrDefault(w,0); allwords.put(w,value+1); &#125; for(int i =0;i&lt;s.length()-wordnum*wordlen+1;i++)&#123; HashMap&lt;String,Integer&gt; haswords = new HashMap&lt;String,Integer&gt;(); int num = 0; while(num&lt;wordnum)&#123; String word = s.substring(i+num*wordlen,i+(num+1)*wordlen); if(allwords.containKey(word))&#123; int value = haswords.gerOrDefault(word,0); haswords.put(word,value+1); if(haswords.get(word)&gt;allwords.get(word))&#123; break; &#125; &#125;else&#123; break; &#125; num++; &#125; if(num==wordnum)&#123; res.add(i); &#125; &#125; return res; &#125;&#125; Hint HardÈ¢òÔºå‰∫ÆÁÇπÊòØÁî®Âà∞‰∏§‰∏™HashMapÔºåÁ¨¨‰∏Ä‰∏™ÊòØÂ∞ÜwordsÈáåÈù¢ÂçïËØçÁöÑ‰∏™Êï∞Â≠òÂÖ•Ôºåhashmap2ÊòØÁî®Êù•ÈÅçÂéÜstringÁöÑÊó∂ÂÄôÔºåÂ∞ÜÂΩìÂâçwordÂ≠óÊÆµÁöÑ‰∏™Êï∞Â≠òÂÖ•hashmap2ÔºåÂú®ËøõË°åÊØîËæÉÔºåËã•map1ÈáåÁöÑ‰∏™Êï∞Â∞è‰∫émap2ÈáåÁöÑ‰∏™Êï∞ÔºåÊàñËÄÖÊúâÊñ∞ÁöÑÂ≠óÊÆµÔºåÂàôbreakÔºõÂê¶ÂàôËøõË°å‰∏ã‰∏Ä‰∏™Â≠óÊÆµÔºåÁõ¥Âà∞ÂΩìÂâçÈïøÂ∫¶ÁöÑwordsÂÖ®ÈÉ®Ê£ÄÊü•ÂêéÔºåÊ≤°ÊúâÂºÇÂ∏∏ÂàôÂ∞ÜiÂ≠òÂÖ•res„ÄÇ ÂÖ∑‰ΩìÊÄùË∑ØÂú® leetcode 30 31. Next Permutation class Solution &#123; public void next(int[] nums)&#123; int n = nums.length-1; p=-1; pv=0; for(int i = n;i&gt;=0;i--)&#123; if(nums[i]&lt;nums[i+1])&#123; p=i; pv = nums[i]; break; &#125; &#125; if(p==-1)&#123; reverse(nums,0,n); &#125; for(int i = n; i&gt;=0;i--)&#123; if(nums[i]&gt;pv)&#123; swap(nums,p,i); break; &#125; &#125; reverse(nums,p+1,n); &#125; void reverse(int[] nums, int s, int e)&#123; while(s&lt;e)&#123; swap(nums,s,e); s++; e--; &#125; &#125; void swap(int [] nums, int s, int e)&#123; int t = nums[s]; nums[s] = nums[e]; nums[e] = t; &#125;&#125; È¢ùÂ§ñÂÆö‰πâreverseÂíåswapÂáΩÊï∞ÔºåÂéüÁêÜÂ§ßÊ¶ÇÂ∞±ÊòØ‰ªéÂè≥ÂêëÂ∑¶Êâ´ÊèèÔºåÊâæÂà∞Á¨¨‰∏Ä‰∏™‰∏çÊòØsortÈ°∫Â∫èÁöÑÊï∞ÔºåÂ≠ò‰ΩèÔºåÁ¨¨‰∫åÊ¨°‰ªéÂè≥Êâ´ÊèèÊâæÊØî‰πãÂâçÈÇ£‰∏™ÂÖÉÁ¥†Â§ßÁöÑÊï∞Ôºå‰∫§Êç¢‰ΩçÁΩÆ„ÄÇÁÑ∂ÂêéÂÜçp+1,n‰πãÈó¥ÁªßÁª≠swap„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 11","slug":"leetcode11","date":"2019-05-16T13:33:07.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/16/leetcode11/","link":"","permalink":"WangHngLeee.github.io/2019/05/16/leetcode11/","excerpt":"15. 3 Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int lo = i+1,hi=nums.length-1,sum=0-nums[i]; while(lo&lt;hi)&#123; if(nums[lo] + nums[hi] == sum)&#123; res.add(Array.asList(nums[i],nums[lo],nums[hi])); while(lo&lt;hi &amp;&amp; nums[lo] == nums[lo+1])lo++; while(lo&lt;hi &amp;&amp; nums[hi] == nums[hi-1])hi--; lo++; hi--; &#125;else if(nums[lo] + nums[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res; &#125;&#125;","text":"15. 3 Sum class solution&#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums)&#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int lo = i+1,hi=nums.length-1,sum=0-nums[i]; while(lo&lt;hi)&#123; if(nums[lo] + nums[hi] == sum)&#123; res.add(Array.asList(nums[i],nums[lo],nums[hi])); while(lo&lt;hi &amp;&amp; nums[lo] == nums[lo+1])lo++; while(lo&lt;hi &amp;&amp; nums[hi] == nums[hi-1])hi--; lo++; hi--; &#125;else if(nums[lo] + nums[hi]&lt;sum)lo++; else hi--; &#125; &#125; &#125; return res; &#125;&#125; Hint ÂÖàÊéíÂ∫èÔºå3 pointerÊñπÊ≥ïÔºåiÔºåloÔºåhiÔºåsum = ÁõÆÊ†áÂÄº-nums[i],ÁÑ∂ÂêéÂºÄÂßãÊØîËæÉloÂíåhiÁöÑÂíå‰∏ésumÁöÑÂ§ßÂ∞èÂÖ≥Á≥ª„ÄÇ Ê≥®ÊÑèarray.aslistÁöÑÁî®Ê≥ï„ÄÇ 16. 3 sum closet class solution&#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int sum = nums[0] + nums[1] + nums[nums.length - 1]; int closetnums = sum; for(int i =0;i&lt;nums.lenght-2;i++)&#123; if(i == 0 || nums[i]!=nums[i-1])&#123; int left = i+1,right = nums.length - 1; while (left&lt;right)&#123; sum = nums[left] + nums[right] + nums[i]; if (sum&lt;target)&#123; while(left&lt;right&amp;&amp;nums[left] == nums[left+1])&#123; left++; &#125; left ++; &#125;else if(sum &gt; target)&#123; while(left&lt;right&amp;&amp; nums[right]==nums[right-1])&#123; right--; &#125; right--; &#125;else&#123; return sum; &#125; if (Math.abs(target-sum)&lt;Math.abs(target - closetnums))&#123; closetnums = sum; &#125; &#125; &#125; &#125; &#125; return closetnums;&#125; Hint Âíå3sum‰∏ÄÊ†∑ÁöÑÊÄùË∑ØÔºå3 pointerÔºåiÔºåleftÔºårightÔºåÂ∞ÜÊéíÂ∫èÂêéÁöÑÁ¨¨‰∏ÄÔºåÁ¨¨‰∫åÔºåÊúÄÂêé‰∏â‰∏™Êï∞ÁöÑÂíåÊöÇÊó∂Â≠ò‰∏∫closetnums,Âæ™ÁéØÈáåÁî®sumÂ≠ò‰∏ã‰∏¥Êó∂ÁöÑÂíåÔºå‰∏étargetÊØîËæÉÔºåÂè™ÊúâÁõ∏Á≠âÊó∂ËøîÂõûsumÔºåÂê¶ÂàôÈÉΩË¶ÅËøõË°åÊØîËæÉÔºåÂèñÂ∑ÆÂÄºÊúÄÂ∞èÁöÑ‰Ωú‰∏∫‰∏ã‰∏Ä‰∏™closetnums„ÄÇ 18. 4 Sum public class Solution { int len = 0; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { len = nums.length; Arrays.sort(nums); return ksum(nums,target,4,0) private ArrayList&lt;List&lt;Integer&gt;&gt; ksum(int[] nums, int target, int k, int index){ ArrayList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (index &gt;= len){ return res; } if (k==2){ int i = index, j = len - 1; while(i&lt;j){ if(target-nums[i] == nums[j]){ List&lt;List&lt;Integer&gt;&gt; temp = new ArraysList&lt;&gt;(); temp.add(nums[i]); temp.add(target - nums[i]); res.add(temp); while(i&lt;j&amp;&amp; nums[i]==nums[i+1]) i++; while(i&lt;j &amp;&amp; nums[j]==nums[j-1])j--; i++; j--; }else if(target - nums[i]&gt;nums[j]){ i++; }else{ j--; } } }else{ for(int i = index; i&lt; len - k + 1;i++){ ArrayList&lt;List&lt;Integer&gt;&gt; temp = ksum(nums,target - nums[i], k-1,i++); if(temp!=null){ for(List&lt;Integer&gt; t : temp){ t.add(0,nums[i]); } res.addAll(temp); } while(i&lt;len-1 &amp;&amp; nums[i] == nums[i+1]){ i++; } } } return res; } }","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 10","slug":"leetcode10","date":"2019-05-12T13:33:07.000Z","updated":"2020-02-03T01:16:22.105Z","comments":true,"path":"2019/05/12/leetcode10/","link":"","permalink":"WangHngLeee.github.io/2019/05/12/leetcode10/","excerpt":"557. Reverse Words in a String III class solution&#123; public reversewords(String s)&#123; char[] s1 = s.toCharArray; int i = 0; for(int j=0;j&lt;s1.length;j++)&#123; if (s1[j] == ' ')&#123; reverse(s1,i,j-1); i-j+1; &#125; &#125; reverse(s1,i,s.length-1); return new String(s1); &#125; public void reverse(s1,l,r)&#123; char[] temp=s[l]; s[l] = s[r]; s[r] = temp; l++;r--; &#125;&#125; ÊÄùË∑Ø Áî®Á©∫Ê†ºÊù•ÂàÜÂâ≤Â≠óÁ¨¶‰∏≤ÔºåÈÅáÂà∞spaceËøêË°å‰∏ÄÊ¨°reverseÔºåÊ≥®ÊÑèÊúÄÂêéÁ©∫Ê†º‰πãÂêéËøòÊúâÊúÄÂêé‰∏ÄÈÉ®ÂàÜÂ≠óÁ¨¶‰∏≤ÔºåÊâÄ‰ª•Ë¶ÅÈ¢ùÂ§ñËøêË°å‰∏ÄÊ¨°reverse„ÄÇ reverseÂü∫Êú¨ÊÄùÊÉ≥Â∞±ÊòØswap„ÄÇ","text":"557. Reverse Words in a String III class solution&#123; public reversewords(String s)&#123; char[] s1 = s.toCharArray; int i = 0; for(int j=0;j&lt;s1.length;j++)&#123; if (s1[j] == ' ')&#123; reverse(s1,i,j-1); i-j+1; &#125; &#125; reverse(s1,i,s.length-1); return new String(s1); &#125; public void reverse(s1,l,r)&#123; char[] temp=s[l]; s[l] = s[r]; s[r] = temp; l++;r--; &#125;&#125; ÊÄùË∑Ø Áî®Á©∫Ê†ºÊù•ÂàÜÂâ≤Â≠óÁ¨¶‰∏≤ÔºåÈÅáÂà∞spaceËøêË°å‰∏ÄÊ¨°reverseÔºåÊ≥®ÊÑèÊúÄÂêéÁ©∫Ê†º‰πãÂêéËøòÊúâÊúÄÂêé‰∏ÄÈÉ®ÂàÜÂ≠óÁ¨¶‰∏≤ÔºåÊâÄ‰ª•Ë¶ÅÈ¢ùÂ§ñËøêË°å‰∏ÄÊ¨°reverse„ÄÇ reverseÂü∫Êú¨ÊÄùÊÉ≥Â∞±ÊòØswap„ÄÇ 344. Reverse String public class solution&#123; public reverstring(String s)&#123; char start; char end; for( int i =0;i&lt;(s.length)/2;i++)&#123; start = s[i]; end=s[(s.length-1)-i]; s[i] = end; s[(s.length-1)-i] = start; &#125; &#125; ÊÄùË∑Ø Êó∂Èó¥Â§çÊùÇÂ∫¶O(n/2)ÔºåÁ©∫Èó¥Â§çÊùÇÂ∫¶O(1),right place ÊîπÂèòÈ°∫Â∫èÔºå‰∏çËÉΩÁî®ËøîÂõûÊñ∞StringÁöÑÊñπÊ≥ï‰∫Ü„ÄÇ‰∫åÂàÜÊ≥ïÊõøÊç¢„ÄÇ 821. Shortest Distance to a Character class solutoin&#123; public int[] shortestToChar(String S. char C)&#123; int n = S.length(); int pos = -n; int[] res = new int[n]; for( int i =0;i&lt;n;i++)&#123; if(S.charAt(i) == C)&#123; pos = i; &#125; res[i] = i - pos; &#125; for( int i =n-1;i&gt;=0;i--)&#123; if(S.charAt(i) == C)&#123; pos = i; &#125; res[i] = Math.min(res[i], Math.abs(i-pos)); &#125; return res; &#125;&#125; ÊÄùË∑Ø two passÔºåÂ∑¶Âè≥ÂêÑÈÅçÂéÜ‰∏ÄÈÅçÔºåÊâæÂà∞minÂÄº„ÄÇ Â∞Üpos=-nÁ∫ØÁ≤πÊòØ‰∏∫‰∫ÜÂ∞ÜÂÖ∂ËÆæÁöÑË∂≥Â§üÂ§ß„ÄÇBrilliant„ÄÇ 867. Transpose Matrix class solution&#123; public int[][] transpose(int[][] A)&#123; int M = A.length; int N = A[0].length; int[][] B = new int[N][M]; for(int j =0;j&lt;N;j++)&#123; for(int i = 0; i&lt;M;i++)&#123; B[j][i] = A[i][j]; &#125; &#125; return B; &#125;&#125; ÊÄùË∑Ø Áü©ÈòµËΩ¨Êç¢È¢òÔºåÊ≥®ÊÑèÊñ∞ÂÆö‰πâÁü©ÈòµBÁöÑË°åÂàóÊï∞ÂíåforÁöÑÈ°∫Â∫èÔºåËΩ¨ÁΩÆÁü©ÈòµÂêéMxN Âèò‰∏∫NxM, ÊâÄ‰ª•ÂÖàj&lt;N Âêé i&lt;M. 912. Sort an Array class solution: def sortinarray(self,nums:List[int] -&gt; List[int]): if len(nums)&lt;1: return nums pivot = random.choice(nums) l=[v for v in nums if v &lt; pivot] m=[v for v in nums if v == pivot] r=[v for v in nums if v &gt; pivot] return self.sortinarray(l) + m + self.sortinarray(r) ÊÄùË∑Ø ÊØîËæÉeasyÁöÑÈ¢òÔºå‰ΩÜÊòØË¶ÅËÆ∞‰Ωèquick sort ÁöÑÊéíÂ∫èÊñπÊ≥ïÔºåÂÖàrandomÈÄânumsÔºåÂàÜÊàê&lt;=&gt;‰∏âÈÉ®ÂàÜÔºåÂú®ÂêÑËá™ÈÄíÂΩíË∞ÉÁî®ÔºåËøîÂõûÊó∂Ê≥®ÊÑèÂä†‰∏ämÔºå‰∏≠Èó¥ÂÄº„ÄÇ 876. Middle of the Linked List class solution&#123; public ListNode middlelinked(ListNode head)&#123; ListNode slow = head; fast = head; while (fast!=null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; return slow; &#125;&#125; ÊÄùË∑Ø ÈùûÂ∏∏ÈáçË¶ÅÁöÑ‰∏ÄÁßçÊÄùË∑ØÔºåfastÂíåslowÊåáÈíàÂêåÊó∂Êâ´ÊèèÔºåÂΩìfastÂà∞ËææÁªìÂ∞æÊó∂Ôºåslow‰∏ÄÂÆöÂú®middle(Â•áÂÅ∂Êï∞ÂÆöÁêÜÂèØ‰ª•ËØÅÊòé).ËøîÂõûslowÊ≠§Êó∂‰ΩçÁΩÆÁöÑÂêéÁª≠ÊåáÈìæ„ÄÇ 872. Leaf-Similar Trees /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class solution&#123; public boolean leafSimilar(TreeNode root1, TreeNode root2) &#123; Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); s1.push(root1); s2.push(root2); while(!s1.empty() &amp;&amp; !s2.empty())&#123; if(dfs(s1)!=dfs(s2))&#123; return false; &#125; return (s1.empty() &amp;&amp; s2.empty()); &#125; &#125; public int dfs(Stack&lt;TreeNode&gt; s)&#123; while(true)&#123; TreeNode node = s.pop(); if(node.left !=null) s.push(node.left); if(node.right !=null) s.push(node.right); if(node.left ==null &amp;&amp; node.right == null) return node.val; &#125; &#125;&#125; ÊÄùË∑Ø Âà§Êñ≠Ê†ëÊúÄÂêéÂêÑ‰∏™ËäÇÁÇπÊòØÂê¶Áõ∏ÂêåÔºåÈÄöÂ∏∏ÊÄùË∑ØÊòØÁî®DFSÈÅçÂéÜtreeÊàêlist,ÁÑ∂ÂêéÊØîËæÉ‰∏§‰∏™list„ÄÇ‰ΩÜÊòØÊØîËæÉÈ∫ªÁÉ¶„ÄÇ ËøôÈáåÂ∞ÜÈÄê‰∏™Âè∂ËäÇÁÇπËøõË°åÊØîËæÉÔºåÈááÁî®stackÂ≠òÂÇ®ÔºåÂÖ∂ÂÆûËøôÈáåÈÅçÂéÜÁöÑÊñπÊ≥ïÁ±ª‰ººpre-orderÔºåÂè™‰∏çËøá‰∏çËæìÂá∫„ÄÇ ÂÆö‰πâdfsÂáΩÊï∞ÔºåÊØîËæÉÊØè‰∏™ËäÇÁÇπÊòØÂê¶‰∏∫ÊúÄÂêé‰∏Ä‰∏™ËäÇÁÇπÔºåËã•Â∑¶Âè≥‰∏çÁ©∫ÔºåÂ∞ÜÂÖ∂ÂéãÂÖ•Â†ÜÊ†àÔºåËã•‰∏∫Á©∫ÔºåËøîÂõûÊúÄÂêéËäÇÁÇπÁöÑÂÄºÔºås1Âíås2ÁöÑÂÄºËøõË°åÊØîËæÉ„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 9","slug":"leetcode9","date":"2019-05-11T13:41:30.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/11/leetcode9/","link":"","permalink":"WangHngLeee.github.io/2019/05/11/leetcode9/","excerpt":"951. Flip Equivalent Binary Trees O(n)ÊñπÊ°à class solution&#123; public boolean flipequv(TreeNode root1, TreeNode root2)&#123; if(root 1 == null &amp;&amp; root2 == null) return true; if(root1 == null || root2 == null || root1.val != root2.val) return false; if((root1.left != null ? root1.left.val : -1) != (root2.left != null ? root2.left.val : -1))&#123; TreeNode t = root1.left; root1.left = root1.right; root1.right = t; &#125; return flipequv(root1.left,root2.left) &amp;&amp; flipequv(root1.right,root2.right); &#125;&#125;","text":"951. Flip Equivalent Binary Trees O(n)ÊñπÊ°à class solution&#123; public boolean flipequv(TreeNode root1, TreeNode root2)&#123; if(root 1 == null &amp;&amp; root2 == null) return true; if(root1 == null || root2 == null || root1.val != root2.val) return false; if((root1.left != null ? root1.left.val : -1) != (root2.left != null ? root2.left.val : -1))&#123; TreeNode t = root1.left; root1.left = root1.right; root1.right = t; &#125; return flipequv(root1.left,root2.left) &amp;&amp; flipequv(root1.right,root2.right); &#125;&#125; ÊÄùË∑Ø Âà§Êñ≠‰∏§‰∏™Ê†ëÁªèËøáflipÂêéÊòØÂê¶ÊòØÂêå‰∏ÄÊ£µÊ†ë„ÄÇ È¶ñÂÖà1.Ëã•‰∏§‰∏™rootÈÉΩ‰∏∫nullÔºå‰∏∫true 2.Ëã•ÂÖ∂‰∏≠‰∏Ä‰∏™‰∏∫nullËÄåÂè¶‰∏Ä‰∏™‰∏çÊòØÔºåÊàñËÄÖ‰∏§‰∏™ÁöÑval‰∏çÂêåÔºåfalse 3.ÈáçÁÇπÂú®Á¨¨‰∏â‰∏™ifÔºåÂàÜÂà´Âà§Êñ≠ÂêÑËá™Â∑¶Â≠©Â≠êÊòØÂê¶‰∏∫Á©∫ÔºåÂ¶ÇÊûúÂ∑¶Âè≥Â≠©Â≠êÈÉΩÁõ∏ÂêåÔºåÂàôË∑≥ËøáËØ•ifÔºåÊâßË°åÈÄíÂΩíÔºõ Ëã•ÔºÅ=ÔºåÂàÜ‰∏â‰∏™ÊÉÖÂÜµÔºö a. root1.left = null ËÄåroot2.leftÂ≠òÂú® b. root1.left Â≠òÂú® ËÄå root2.left = null c. root1.left.val != root2.left.val Âú®‰ª•‰∏ä‰∏âÁßçÊÉÖÂÜµ‰∏ãÔºåËØÅÊòéÂíåÂéüÊ†ë‰∏ç‰∏ÄÊ†∑Ôºå‰∏∫‰∫ÜÈ™åËØÅÊòØÂê¶ÊòØflipËøáÔºåÁî®swapÊÄùÊÉ≥ÔºåÂ∞Üroot1.left ÂíårightÂÄº‰∫íÊç¢ÔºåÂÜçËøõË°åÂà§Êñ≠„ÄÇ 338. Counting Bits class solution&#123; public int[] countbits(int num)&#123; int[] f = new int[num + 1]; for (int i=1; i&lt;=num; i++)&#123; f[i] = f[i &gt;&gt; 1] + (i &amp; 1); &#125; return f;&#125; ÊÄùË∑Ø Â∞ÜÊï¥Êï∞ÂàÜ‰∏∫‰∏§ÈÉ®ÂàÜÔºåÊúÄÂêé‰∏Ä‰ΩçÂíåÂâçÈù¢ÊâÄÊúâ„ÄÇ ÊúÄÂêé‰∏Ä‰Ωç1 or 0ÔºåÁî® i&amp;1 (1%2)Ë°®Á§∫ÔºåÂà§Êñ≠ÊúÄÂêé‰∏Ä‰Ωç1ÁöÑ‰∏™Êï∞Ôºà‰πüÂ∞±ÊòØÁúãÊòØ‰∏çÊòØ1Ôºâ ÂÖ∂‰ªñ‰ΩçÊï∞ÔºåÁî®f[i&gt;&gt;1]Âç≥(i/2)Ë°®Á§∫ÔºåÂà§Êñ≠ÂâçÈù¢ÁöÑÊâÄÊúâ1ÁöÑ‰∏™Êï∞ ÂÖ∂ÂÆûÁªÜÁúãÔºåÂÅ∂Êï∞ÁöÑf[i/2]ÂèØ‰ª•Ë∞ÉÁî®ÂâçÈù¢Â∑≤ÊúâÁöÑÊï∞ÂÄºÔºåÊúÄÂêéÁöÑ‰∏™‰ΩçËÇØÂÆö‰∏∫0ÔºåÂ•áÊï∞ÊúÄÂêé‰∏™‰ΩçËÇØÂÆö‰∏∫1ÔºåÁ±ª‰ººdpÔºü 985. Sum of Even Numbers After Queries class Solution &#123; public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int sum = 0; int i = 0; for (int a : A)&#123; if(a%2 == 0)&#123; sum+=a; &#125; &#125; int [] ans = new int[queries.length]; for(int [] q:queries)&#123; if(A[q[1]] % 2 == 0)&#123; sum-=A[q[1]]; &#125; A[q[1]] += q[0]; if (A[q[1]] % 2 == 0)&#123; sum+=A[q[1]] &#125; ans[i] = sum; i++; &#125; return ans; &#125;&#125; ÊÄùË∑Ø Áé∞Â∞ÜÂΩìÂâçÊï∞ÁªÑÁöÑÂÅ∂Êï∞Âä†Ëµ∑Êù•ÔºåÂºÄÂßãÂæ™ÁéØÔºåÂΩìq[1]‰ΩçÁΩÆ‰∏∫ÂÅ∂Êï∞Êó∂Ôºå‰øùÈô©Ëµ∑ËßÅÔºåÂÖà‰ªésumÈáåÂáèÊéâÔºå‰πãÂêéq[0]Âä†‰∏äÔºåÂÜçÊ¨°Âà§Êñ≠ÊòØÂê¶‰∏∫ÂÅ∂Êï∞ÔºåÂ¶ÇÊûúÊòØÂàôÂä†ËøõsumÔºå‰∏çÊòØÁöÑËØùÁõ¥Êé•ÊîæÂºÉÔºåÂ∞ÜÂΩìÂâçÂÅ∂Êï∞ÊîæËøõans[i],i++ 885. Spiral Matrix III class solution&#123; public int[][] spiralMatrixIII(int R, int C, int r0, int c0) &#123; int[][] dirt = new int[][] &#123;&#123;0,1&#125;Ôºå&#123;1,0&#125;Ôºå&#123;0Ôºå-1&#125;Ôºå&#123;-1,0&#125;&#125;Ôºõ List&lt;int[]&gt; res = new ArrayList&lt;&gt;(); int len = 0, d =0; res.add(new int[]&#123;r0,c0&#125;); while (res.size() &lt; R*C)&#123; if (d == 0 || d == 2)&#123; len++; &#125; for(int =0; i&lt; len;i++)&#123; r0+=dirt[d][0]; c0+=dirt[d][1]; if(r0 &gt;= 0 &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= 0 &amp;&amp; c0 &lt; C)&#123; res.add(new int[]&#123;r0,c0&#125;); &#125; &#125; d = (d+1)%4; &#125; return res.toArray(new int[R*C][2]);&#125; ÊÄùË∑Ø È°∫Êó∂ÈíàÂõûÂ≠óÂΩ¢‰ªéËµ∑ÁÇπÂºÄÂßãÊâ´ÊèèÔºådirtËÆæÁΩÆÊØèÊ¨°ÁßªÂä®ÂêéÁöÑÂùêÊ†áÔºådËÆæÁΩÆÁßªÂä®ÁöÑÊ≠•Êï∞ÔºåÁîªÂõæÂêéÂèëÁé∞ÔºåÂè≥‰∏ãÂêÑ1Ê≠•ÔºåÂ∑¶‰∏äÂêÑ2Ê≠•ÔºåÂè≥‰∏ãÂêÑ3Ê≠•ÔºåÂ∑¶‰∏äÂêÑ4Ê≠•‚Ä¶Ôºå‰ª•Ê≠§Á±ªÊé®ÔºådÊòØÁßªÂä®ÊñπÂêëÂú®dirtÈáåÁöÑ‰ΩçÁΩÆÔºå0Âè≥1‰∏ã2Â∑¶3‰∏äÔºåÊâÄ‰ª•ÂΩìd=0ÔºàËµ∑ÁÇπÊàñËÄÖÁªèËøá‰∏ÄËΩÆÂêéÔºâ ÊàñËÄÖ d=2ÔºåÊØèÊ¨°Áä∂ÊÄÅÊîπÂèòÁöÑÊó∂ÂÄôÔºåÁßªÂä®Ê≠•ÈïølenË¶Å+1„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 8","slug":"Leetcode-8","date":"2019-05-10T15:11:27.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/10/Leetcode-8/","link":"","permalink":"WangHngLeee.github.io/2019/05/10/Leetcode-8/","excerpt":"979. Distribute Coins in Binary Tree class solution&#123; int res =0; public int distribute(TreeNode root)&#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 0; int left = dfs(root.left), right = dfs(root.right); res+=Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; ÊÄùË∑Ø ÊúâÁÇπÁªïÁöÑ‰∏ÄÈÅìdfsÈ¢ò„ÄÇË¶ÅÊ±ÇÂ∞ÜÊØè‰∏™‰ΩçÁΩÆÈÉΩÂèò‰∏∫1ÔºåÊ±ÇÂèòÂä®Ê¨°Êï∞ÔºåÂÖ∂ÂÆûÂèçËøáÊù•ÊÉ≥ÔºåÂ¶ÇÊûú‰∏Ä‰∏™ÊúÄÂêéËäÇÁÇπÂéüÊù•‰∏∫x,Ë¶ÅÂèò‰∏∫1ÔºåÈÇ£‰πàÂèòÂä®ÁöÑÊï∞ÂÄºÂ∞±ÊòØx-1ÁöÑÁªùÂØπÂÄºÔºå‰πüÂ∞±ÊòØÊÉ≥Áà∂ËäÇÁÇπ‰º†ÈÄÅÁöÑÂÄºÊàñËÄÖÂêëÁà∂ËäÇÁÇπÁ¥¢Ë¶ÅÁöÑÂÄºÔºåÂç≥ÂèòÂä®Ê¨°Êï∞ÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÈÄíÂΩíÁöÑÂ∞ÜÊØè‰∏™ËäÇÁÇπÁöÑx-1Á¥ØÂä†Ëµ∑Êù•Âç≥ÂèØ„ÄÇÂ§öÁúã„ÄÇ","text":"979. Distribute Coins in Binary Tree class solution&#123; int res =0; public int distribute(TreeNode root)&#123; dfs(root); return res; &#125; public int dfs(TreeNode root)&#123; if(root == null) return 0; int left = dfs(root.left), right = dfs(root.right); res+=Math.abs(left) + Math.abs(right); return root.val + left + right - 1; &#125;&#125; ÊÄùË∑Ø ÊúâÁÇπÁªïÁöÑ‰∏ÄÈÅìdfsÈ¢ò„ÄÇË¶ÅÊ±ÇÂ∞ÜÊØè‰∏™‰ΩçÁΩÆÈÉΩÂèò‰∏∫1ÔºåÊ±ÇÂèòÂä®Ê¨°Êï∞ÔºåÂÖ∂ÂÆûÂèçËøáÊù•ÊÉ≥ÔºåÂ¶ÇÊûú‰∏Ä‰∏™ÊúÄÂêéËäÇÁÇπÂéüÊù•‰∏∫x,Ë¶ÅÂèò‰∏∫1ÔºåÈÇ£‰πàÂèòÂä®ÁöÑÊï∞ÂÄºÂ∞±ÊòØx-1ÁöÑÁªùÂØπÂÄºÔºå‰πüÂ∞±ÊòØÊÉ≥Áà∂ËäÇÁÇπ‰º†ÈÄÅÁöÑÂÄºÊàñËÄÖÂêëÁà∂ËäÇÁÇπÁ¥¢Ë¶ÅÁöÑÂÄºÔºåÂç≥ÂèòÂä®Ê¨°Êï∞ÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÈÄíÂΩíÁöÑÂ∞ÜÊØè‰∏™ËäÇÁÇπÁöÑx-1Á¥ØÂä†Ëµ∑Êù•Âç≥ÂèØ„ÄÇÂ§öÁúã„ÄÇ ##968. Binary Tree Cameras class solution&#123; int res = 0; public int camera(TreeNode root)&#123; int state = dfs(root); return (dfs(root) &lt; 1? 1:0) + res; &#125; public int dfs(TreeNode root)&#123; int needcamera = 0; int covered = 0; if (root.left == null &amp;&amp; root.right == null) return 0;// Áä∂ÊÄÅ‰∏∫0ÁöÑÂè∂ËäÇÁÇπ if (root.left!=null)&#123; int state = dfs(root.left); if (state==0)&#123;//Â≠©Â≠ê‰∏∫Âè∂ËäÇÁÇπÔºåÂàôËØ•‰ΩçÁΩÆËÆæ‰∏∫cameraÔºåÂπ∂Ë¢´cover needcamera = 1; covered = 1; &#125; else if(state ==1)&#123;//Â≠©Â≠ê‰∏∫cameraÔºåË¢´cover covered =1; &#125; &#125; if (root.right!=null)&#123;//‰∏éÂ∑¶Â≠êÊ†ëÁõ∏Âêå int state = dfs(root.right); if (state==0)&#123; needcamera = 1; covered = 1; &#125; else if(state ==1)&#123; covered =1; &#125; &#125; if (needcamera&gt;0)&#123;//ËøôÈáåÂæÄ‰∏ãÂºÄÂßãËøîÂõûstateÁöÑÂÄºÔºåËÆæ‰∏∫cameraÁöÑÁÇπ res++; return 1; &#125; if(covered&gt;0)&#123;//‰∏çÊòØcameraÁÇπÂπ∂‰∏îË¢´coverËøáÔºåÂàôÊòØcameraÁöÑÁà∂ËäÇÁÇπÔºåÊâÄ‰ª•ËøîÂõûÁä∂ÊÄÅ2 return 2; &#125; return 0;//ÂàôÂèò‰∏∫0Áä∂ÊÄÅÔºåÁ≠õÊéâË¢´ËÆøÈóÆËøáÁöÑËäÇÁÇπÂêéÁöÑËµ∑ÂßãËäÇÁÇπÔºåÂèØ‰ª•ÁúãÊàêÊñ∞ÁöÑÂè∂ËäÇÁÇπ„ÄÇ &#125;&#125; ÊÄùË∑Ø Á¨¨‰∏ÄÊ¨°Ëá™Â∑±ÂÅöÂá∫Êù•ÁöÑhardÈ¢òÔºå‰∏çÂ§™Â•ΩÂÅö„ÄÇ ‰ªé‰∏äËá≥‰∏ãÊØîËæÉÈ∫ªÁÉ¶ÔºåÊâÄ‰ª•Âπ≤ËÑÜ‰ªé‰∏ãËá≥‰∏äÈÄíÂΩí„ÄÇÈ¶ñÂÖàÂàÜ‰∏âÁßçÁä∂ÊÄÅÔºö Ê≤°ÊúâÂ∑¶Âè≥Â≠©Â≠êÁöÑÂè∂ËäÇÁÇπÔºåÁä∂ÊÄÅ‰∏∫0Ôºõ Â∑¶Âè≥Â≠©Â≠ê‰∏∫Âè∂ËäÇÁÇπÁöÑÂ≠êËäÇÁÇπÔºå‰πüÂ∞±ÊòØË¶ÅËÆæ‰∏∫cameraÁöÑËäÇÁÇπÔºåÁä∂ÊÄÅ‰∏∫1Ôºõ ËÆæ‰∏∫cameraËäÇÁÇπÁöÑÁà∂ËäÇÁÇπÔºåÂç≥Ë¢´coveredÁöÑÈùûcameraËäÇÁÇπÔºõ Ê≥®ÊÑèstateÊòØËØ•ËäÇÁÇπÁöÑÂ≠©Â≠êËäÇÁÇπÔºåÂπ∂ÈùûÊú¨ËäÇÁÇπÁöÑÁä∂ÊÄÅÔºåÊâÄ‰ª•ÂΩìstate‰∏∫0ÔºåÂç≥Â≠©Â≠êËäÇÁÇπ‰∏∫Âè∂ËäÇÁÇπÊòØÔºåÊú¨ËäÇÁÇπÂ∞±Â∫î‰∏∫1ÔºåËÆæ‰∏∫cameraÔºõÂΩìstate=1Êó∂ÔºåË°®ÊòéÂÖ∂Â≠©Â≠êËäÇÁÇπ‰∏∫cameraÔºåÂàôËØ•ËäÇÁÇπÁä∂ÊÄÅ‰∏∫2ÔºåcameraÁöÑÁà∂ËäÇÁÇπ„ÄÇ ÊúÄÂêéÂâ©‰∏ãÁöÑÂàôÊòØÊú™Ë¢´coverÁöÑËäÇÁÇπÔºåÂèØ‰ª•ÈáçÊñ∞ÂØªÊâæÈÄÇÂêàÁöÑcameraËäÇÁÇπ„ÄÇ ÈÄíÂΩíÁöÑÊó∂ÂÄôÂÖàÂà§Êñ≠rootÂ≠©Â≠êËäÇÁÇπÁöÑÁä∂ÊÄÅÔºåÁÑ∂ÂêéÊîπÂèòÂΩìÂâçrootÁöÑcameraÂíåcoverÔºåÊúÄÂêéËøîÂõûËØ•rootÁöÑÁä∂ÊÄÅÂÄºÔºà0,1,2ÔºâÔºå‰ª•‰æõ‰∏ãÊ¨°ÈÄíÂΩí‰ΩøÁî®„ÄÇ ÈÄíÂΩí‰∏ÄËà¨Ê†πÊçÆÂ≠©Â≠êËäÇÁÇπÁä∂ÊÄÅÂà§Êñ≠ÂΩìÂâçËäÇÁÇπÁöÑÈóÆÈ¢òÂÄºÔºåÊúÄÂêéÂÜçËøîÂõûÂΩìÂâçËäÇÁÇπÁöÑÁä∂ÊÄÅ„ÄÇ Â§öÁªÉÁ±ª‰ººÁöÑÈ¢ò„ÄÇ 419. Battleships in a Board class solution&#123; public int countbattleship(char[][] board)&#123; int m = board.length; int n = board[0].length; int count = 0; if(m==0)&#123; return 0; &#125; for (int i = 0 ; i&lt;m;i++)&#123; for(int j =0; j&lt;n;j++)&#123; if (board[i][j] == '.') continue; if(j&gt;0 &amp;&amp; board[i][j-1] == 'x') continue;//Á∫µÂàóÈó¥ÊúâÊ≤°Êúâadjacent if (i&gt;0 &amp;&amp; board[i-1][j] == 'X') continue;//Ë°åÈó¥ÊúâÊ≤°Êúâadjacent count++; &#125; &#125; return count; &#125;&#125; ÊÄùË∑Ø Ê≥®ÊÑèÂàó.Ë°åÁöÑÂà§Êñ≠ÊñπÊ≥ï„ÄÇ 559. Maximum Depth of N-ary Tree class solution&#123; public maxDepth(Node root)&#123; if(root == null) return 0; int maxDepth=0; for(Node child:root.children)&#123; maxDepth = Math.max(maxDepth,maxDepth(child)) &#125; return maxDepth+1 &#125;&#125; ÊÄùË∑Ø Ê≤°‰ªÄ‰πàÂ•ΩËØ¥ÁöÑÔºåÁÆÄÂçïÁöÑÈÄíÂΩíÔºå‰∏äÈù¢ÊòØÁî®ÁöÑnodeÈìæË°®ÔºåqueueÈòüÂàó‰πüÂèØ‰ª•Ëß£ÂÜ≥Ôºå‰ª£Á†ÅÂ¶Ç‰∏ã„ÄÇ class solution&#123; public int maxDepth(Node root)&#123; if(root == null) return 0; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty())&#123; int size = queue.size(); for(int i =0; i&lt;size;i++)&#123; Node curr = queue.poll(); for(Node child:root.children)&#123; queue.offer(child); &#125; &#125; depth++; &#125; return depth; &#125;&#125;","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Lazy Day 1","slug":"Lazy-Day-1","date":"2019-05-10T02:35:21.000Z","updated":"2019-06-21T05:14:14.000Z","comments":true,"path":"2019/05/09/Lazy-Day-1/","link":"","permalink":"WangHngLeee.github.io/2019/05/09/Lazy-Day-1/","excerpt":"","text":"lazy day 1 ÊÅ©ÔºåÂºÄ‰∏™Ë¥¥ËÆ∞ÂΩï‰∏Ä‰∏ãÈ∏ΩÁöÑÊØè‰∏ÄÂ§©ÔºåË≠¶ÈÜí‰∏Ä‰∏ã„ÄÇ ‰∏çËøá‰ªäÂ§©‰πüÁÆó‰æãÂ§ñÔºå‰∏ÄÁõ¥Âú®ÂøôÊâæÂÆû‰π†ÁöÑ‰∫ãÊÉÖÔºåËÄΩËØØ‰∫Ü‰∏ÄÂ§©ÔºåÂ∏åÊúõÊúÄÂêéËÉΩÊúâÈÄÇÂêàÁöÑÂÆû‰π†Âêß„ÄÇ Â∞±ËøôÊ†∑„ÄÇ Ps: ÂÜçÂêÉ‰∏≠ÂøÉÈ£üÂ†ÇÁöÑÂÜ∑Èù¢ÊàëÂ∞±ÊòØÂºüÂºüÔºåÂºü‰∏≠ÂºüÈÇ£Áßç„ÄÇ","categories":[{"name":"lazyday","slug":"lazyday","permalink":"WangHngLeee.github.io/categories/lazyday/"}],"tags":[{"name":"È∏Ω","slug":"È∏Ω","permalink":"WangHngLeee.github.io/tags/È∏Ω/"}]},{"title":"Leetcode EveryDay 7","slug":"Leetcocde-7","date":"2019-05-08T13:28:27.000Z","updated":"2020-02-03T01:16:22.255Z","comments":true,"path":"2019/05/08/Leetcocde-7/","link":"","permalink":"WangHngLeee.github.io/2019/05/08/Leetcocde-7/","excerpt":"Êò®Â§©ÂàöÂºÄÂßã‰∏äUdemyÁöÑThe Web Developer BootcampÔºåÂÖ®Ê†àÂºÄÂèëÊå∫ÊúâÊåëÊàòÊÄß„ÄÇ ÂÅöËøô‰∏™ÂçöÂÆ¢ÁöÑÊó∂ÂÄôÊ≤°Â≠¶ÈÇ£‰πàÊ∑±ÔºåÂ∏åÊúõËøôÈó®ËØæÁªìÊùüÂêéËÉΩÂÆåÊàê‰∏Ä‰∏™ÊãøÂæóÂá∫ÊâãÁöÑÂÆûÈôÖÂ∫îÁî®ÁΩëÁ´ô„ÄÇÂ•Ω‰∫ÜÔºåÁªßÁª≠Âà∑È¢òÊâìÂç°ÔºÅ 561. Array Partition I public class solution&#123; public arraypart(int[] nums)&#123; int res=0; Arrays.sort(nums); for(int i =0; i&lt;nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125;","text":"Êò®Â§©ÂàöÂºÄÂßã‰∏äUdemyÁöÑThe Web Developer BootcampÔºåÂÖ®Ê†àÂºÄÂèëÊå∫ÊúâÊåëÊàòÊÄß„ÄÇ ÂÅöËøô‰∏™ÂçöÂÆ¢ÁöÑÊó∂ÂÄôÊ≤°Â≠¶ÈÇ£‰πàÊ∑±ÔºåÂ∏åÊúõËøôÈó®ËØæÁªìÊùüÂêéËÉΩÂÆåÊàê‰∏Ä‰∏™ÊãøÂæóÂá∫ÊâãÁöÑÂÆûÈôÖÂ∫îÁî®ÁΩëÁ´ô„ÄÇÂ•Ω‰∫ÜÔºåÁªßÁª≠Âà∑È¢òÊâìÂç°ÔºÅ 561. Array Partition I public class solution&#123; public arraypart(int[] nums)&#123; int res=0; Arrays.sort(nums); for(int i =0; i&lt;nums.length;i+=2)&#123; res+=nums[i]; &#125; return res; &#125;&#125; ÊÄùË∑Ø Á∫ØÊï∞Â≠¶È¢òÔºåÂ∞Ü2nÊï∞ÁªÑÂàÜÊàênÂØπÔºåÂàÜÂà´Ê±ÇnÂØπÈáåÊúÄÂ∞èÂÄºÁöÑÂíå„ÄÇÂæàÁÆÄÂçïÔºåÂÖàsortÊéíÂ∫èÔºåÁÑ∂ÂêéÁ¥ØÂä†Â•áÊï∞‰ΩçÁΩÆÁöÑÊï∞Â∞±ÂèØ‰ª•„ÄÇ 700. Search in a Binary Search Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode searchBST(TreeNode root,int val)&#123; if(root == null) return root; if(root.val == val) return root; else&#123; if(root.val&gt;val)&#123; return searchBST(root.left,val); &#125; return searchBST(root.right,val); &#125; &#125;&#125; ÊÄùË∑Ø ÁÆÄÂçïÁöÑBSTÔºåÊ≥®ÊÑènullÊó∂ÁöÑËøîÂõûÂÄº‰πüÊòØroot„ÄÇ 590. N-ary Tree Postorder Traversal // Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;class solution&#123; public List&lt;Integer&gt; postorder(Node root)&#123; LinkedList&lt;Integer&gt; list = newe LinkedList(); if (root==null) return list;//ÂàõÂª∫Â†ÜÊ†àÊù•Â≠òË¥ÆÂΩìÂâçËäÇÁÇπ Stack(Node) s = new Stack() s.push(root); while(!isEmpty(s))&#123; Node temp = s.pop(); //‰ΩøÁî®AddFirstÂ∞ÜËäÇÁÇπÂä†Âà∞listÂâçÈù¢ÔºåÈÅøÂÖç‰ΩøÁî®reverse list.AddFirst(temp.val); for(Node n :temp.children)&#123; s.push(n); &#125; &#125; return list; &#125;&#125; ÊÄùË∑Ø Á±ª‰ººÂÄíÂ∫èËæìÂá∫ËäÇÁÇπÔºå‰∏éÂ±ÇÊ¨°ÈÅçÂéÜÈ°∫Â∫è‰∏çÂêå„ÄÇ Â±ÇÊ¨°ÈÅçÂéÜÊòØÂ∞ÜËäÇÁÇπpopÂá∫Êù•Âç≥ÂèØÔºåÊ≠§È¢òÈúÄË¶ÅÈÄÜÂ∫èËæìÂá∫ÔºåÊâÄ‰ª•ÂæàÂ•ΩÁöÑ‰∏Ä‰∏™ÁÇπÂ∞±ÊòØÂ∞ÜlistËÆæÁΩÆ‰∏∫ÈìæË°®ÔºåÁÑ∂ÂêéÂ∞ÜÊñ∞ÂÖÉÁ¥†‰∏ÄÁõ¥Âä†Âà∞Â§¥ÈÉ®Â∞±ÂèØ‰ª•ÔºåÊúÄÂêéËæìÂá∫list„ÄÇ 589. N-ary Tree Preorder Traversal // Definition for a Node.class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val,List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;class solution&#123; public List&lt;Integer&gt; postorder(Node root)&#123; LinkedList&lt;Integer&gt; list = newe LinkedList(); if (root==null) return list; Stck&lt;Node&gt; stack = new Stack(); stack.add(root); while (!isEmpty)&#123; root=stack.pop(); list.add(root.val); for(int i =root.children.size()-;i&gt;=0;i++)&#123; stack.add(root.childre.get(i)); &#125; &#125; return list; &#125;&#125; ÊÄùË∑Ø ÊòØ‰∏ä‰∏ÄÈ¢òÁöÑÁÆÄÂåñÁâàÔºåÈÅçÂéÜÂÆåËØ•ÊîØÂÖ®ÈÉ®ËäÇÁÇπÂêéÊâçËΩ¨Âà∞‰∏ã‰∏ÄÊîØÔºå‰∏çÈúÄË¶ÅÈÄÜËΩ¨listÔºåÊ≥®ÊÑèroot.children.getÁöÑÊñπÊ≥ï„ÄÇ 965. Univalued Binary Tree /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class solution&#123; public boolean UnivalTree(Treenode root)&#123; if(root.left!=null)&#123; if(!isUnivalTree(root.left)) return false; if(root.left.val!=root.val) return false; &#125; if(!isUnivalTree(root.right)) return false; if(root.right.val!=root.val) return false; &#125; return true; &#125; ÊÄùË∑Ø Ëá™Ë∫´ÈÄíÂΩíÁöÑBST,Ê≥®ÊÑèÈÄíÂΩíÂíåÂà§Êñ≠valÁöÑÂâçÂêéÈ°∫Â∫è„ÄÇÂíåleetcode 5 ÈáåÈù¢‰∏ÄÈÅìÈ¢òÂæàÁõ∏‰ººÔºåÈúÄË¶ÅËá™Â∑±Âä†‰∏Ä‰∏™privateÂáΩÊï∞ 1030. Matrix Cells in Distance Order class solution&#123; public int[][] allcellsindis(int R, int C, int r0, int c0)&#123; boolean[][] visited = new boolean[R][C]; int[][] res = new int[R*C][2]; int i =0; Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); queue.offer(new int[]&#123;r0,c0&#125;); while(!queue.isEmpty())&#123; int[] cell = queue.poll(); int r = cell[0]; int c = cell[1]; if( r &lt; 0 || r &gt;= R || c &lt; 0 ||c &gt;= C)&#123; continue; &#125; if(visited[r][c])&#123; continue; &#125; res[i] = cell; i++; visited[r][c] = true; queue.offer(new int[]&#123;r, c - 1&#125;); queue.offer(new int[]&#123;r, c + 1&#125;); queue.offer(new int[]&#123;r - 1, c&#125;); queue.offer(new int[]&#123;r + 1, c&#125;); &#125; return res; &#125;&#125; ÊÄùË∑Ø Êüê‰∏™Áü©ÈòµÔºåÁªôÂÆö‰∏Ä‰∏™ÂùêÊ†áÔºåËÆ©ËæìÂá∫ÂÖ∂‰ªñ‰ΩçÁΩÆÂíåËøô‰∏™‰ΩçÁΩÆÁöÑË∑ùÁ¶ªÂ∑ÆÔºåÁªôÂÆör0c0Ôºåx‰ΩçÁΩÆ‰∏éËØ•‰ΩçÁΩÆÁöÑË∑ùÁ¶ªÂ∑ÆÂ∞±ÊòØnx-n0Ôºåcx-c0 ÂΩìÈöè‰æøÁîªÂá†‰∏™Áü©ÈòµÂá∫Êù•‰πãÂêéÂèëÁé∞ÔºåËæìÂá∫ÁöÑÁªìÊûúÂÖ∂ÂÆûÂ∞±ÊòØ‰ªéËØ•ÊåáÂÆö‰ΩçÁΩÆbfsÊêúÁ¥¢ÁöÑÁªìÊûúÔºàÊÅ©ÔºåÂ∞±ÊòØËøô‰πàÂ∑ßËøô‰πàÁ•ûÂ•áÔºâ ÊâÄ‰ª•Â∞±ÂèØ‰ª•ÊåâÁÖßbfsÁöÑÊÄùË∑ØÊù•ËÆæËÆ°codeÔºåÁî®queueÊù•ÂÆûÁé∞ÔºåËÆæÁΩÆvisitedÂèòÈáèÊù•ËÆ∞ÂΩïÊòØÂê¶ËÆøÈóÆËøáËØ•ËäÇÁÇπ„ÄÇ Ê≥®ÊÑèpoll() Âíå offer() Ôºå‰∏épop() Âíåpush()Á±ª‰ººÔºå‰ΩÜÊòØÊïàÊûúÊõ¥Â•ΩÔºåÂá∫ÈîôÊó∂Ëá™Âä®ÂÅúÊ≠¢„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 6","slug":"Leetcode-6","date":"2019-05-07T14:01:06.000Z","updated":"2020-02-03T01:16:22.104Z","comments":true,"path":"2019/05/07/Leetcode-6/","link":"","permalink":"WangHngLeee.github.io/2019/05/07/Leetcode-6/","excerpt":"ÂÜôÂú®ÂºÄÂ§¥ ‰ª•ÂêéÂ∞ΩÈáèÂ§öÁî®javaÂÅöcodingÂêßÔºåÊò®ÊôöÊâçÁü•ÈÅìAmazonÁöÑonsiteÊ≤°ÊúâpythonËøô‰∏™ÈÄâÈ°π‚Ä¶orzÔºåÊâÄ‰ª•ÂºÄÂßãÂïÉjavaÂêß~ 797. All Paths From Source to Target class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; allPassSourceTarget(int[][] graph)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); path.add(0); dfsSearch(graph,0,res,path); return res; &#125; private void dfsSearch(int [][] graph, int node,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path )&#123; if ( node == graph.length -1)&#123; res.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; for ( int nextNode:graph[node])&#123; path.add(nextNode); dfsSearch(graph,nextNode,res,path); path.remove(path.size()-1);// ÂæàÈáçË¶ÅÁöÑ‰∏ÄÊ≠•ÔºåbackstrackÂõûÂéª &#125; &#125;&#125;","text":"ÂÜôÂú®ÂºÄÂ§¥ ‰ª•ÂêéÂ∞ΩÈáèÂ§öÁî®javaÂÅöcodingÂêßÔºåÊò®ÊôöÊâçÁü•ÈÅìAmazonÁöÑonsiteÊ≤°ÊúâpythonËøô‰∏™ÈÄâÈ°π‚Ä¶orzÔºåÊâÄ‰ª•ÂºÄÂßãÂïÉjavaÂêß~ 797. All Paths From Source to Target class Solution&#123; public List&lt;List&lt;Integer&gt;&gt; allPassSourceTarget(int[][] graph)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); path.add(0); dfsSearch(graph,0,res,path); return res; &#125; private void dfsSearch(int [][] graph, int node,List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; path )&#123; if ( node == graph.length -1)&#123; res.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; for ( int nextNode:graph[node])&#123; path.add(nextNode); dfsSearch(graph,nextNode,res,path); path.remove(path.size()-1);// ÂæàÈáçË¶ÅÁöÑ‰∏ÄÊ≠•ÔºåbackstrackÂõûÂéª &#125; &#125;&#125; ÊÄùË∑Ø ‰∏ÄÈÅìdfsÊÄùË∑ØÁöÑË∑ØÂæÑÈ¢òÔºåËæìÂÖ•ÁªìÊûÑÂ¶Ç‰∏ãÔºögraph [[1,2],[3],[3],[]] graph[i]‰∏≠Â≠òÊîæÁöÑÊòØËäÇÁÇπiËÉΩÂ§üÂà∞ËææÁöÑËäÇÁÇπÈõÜÂêàÔºåÊØîÂ¶Çgraph[0]‰∏≠Â≠òÊîæÁöÑÊòØ1Âíå2ÔºåÊÑèÊÄùÂ∞±ÊòØ0ËÉΩÂ§üÂà∞Ëææ1Âíå2Ôºå‰ª•Ê≠§Á±ªÊé®Ôºå1 Âíå 2 ÂùáÂêÑËá™ËÉΩÂà∞Ëææ3 „ÄÇ ÊâÄ‰ª•ÂàõÂª∫‰∏Ä‰∏™privateÂáΩÊï∞ÔºåÁî®Êù•ÈÄíÂΩídfs„ÄÇÊ≥®ÊÑèÁöÑÊòØÂú®nextnodeË∞ÉÁî®dfs‰πãÂêéÔºåË¶ÅbackstrackÂõûÂéªÔºåÂ∞ÜpathÁöÑsize()-1,‰ª•‰øùËØÅÂÖ∂‰ªñË∑ØÂæÑdfsÊó∂‰∏ç‰ºöÂèóÂΩ±Âìç„ÄÇ 942. DI String Match class solution&#123; public int[] distringmatch(String S)&#123; int n = S.length(),left=0,right = n; int [] res = new int[n+1] for ( int i=0; i&lt;n;i++)&#123; res[i] = S.charAt(i) == 'I' ? left++:right--; &#125; res[n] = left; return res &#125;&#125; ÊÄùË∑Ø ‰∏ÄÈÅìeasyÈ¢òÔºåoutside-inÁöÑÊñπÊ≥ïÔºåÂà§Êñ≠Â¶ÇÊûú‰∏∫IÔºåÂ∞ÜleftËµãÂÄºÁªôres[i]Ôºå Âê¶ÂàôËµãÂÄºrightÔºå‰πãÂêéÂ∞ÜleftÊàñËÄÖrightËøõË°å++ Êàñ‚ÄìÔºåÊúÄÂêéÈÄÄÂá∫Âæ™ÁéØÁöÑÊó∂ÂÄôÔºåÊúÄÂêé‰∏Ä‰ΩçËÇØÂÆöÊòØÂΩìÂâçÁöÑleftÁöÑÂÄº„ÄÇ 763. Partition Labels class solution&#123; public List&lt;Integer&gt; partitionlabels(String S)&#123; if (S is null||S.length() == 0)&#123; return null; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int[] map = new int[26]; for (int i =0;i&lt;S.length();i++)&#123; map[S.charAt(I)-'a'] = i; &#125; int last = 0; int start = 0; for (int i=0;i&lt;S.length;i++)&#123; last = Math.max(last,map[S.charAt(i) - 'a']); if (last == i):&#123; list.add(last-start+1); start = last + 1; &#125; &#125; return list; &#125;&#125; ÊÄùË∑Ø Áî®mapÂ≠ò‰ΩèÊØè‰∏Ä‰∏™Â≠óÊØçÂá∫Áé∞ÁöÑÊúÄÂêé‰∏Ä‰∏™‰ΩçÁΩÆÔºå‰∏çÈîôÁöÑÂ∞èÊäÄÂ∑ßmap[S.charAt(i)-‚Äòa‚Äô] = iÔºåÂèØ‰ª•‰∏çÊñ≠Êõ¥Êñ∞ÊüêÂ≠óÊØçÊúÄÂêéÂá∫Áé∞ÁöÑ‰ΩçÁΩÆ„ÄÇ ÈáçÊñ∞ÈÅçÂéÜ‰∏ÄÈÅçSÔºåÊØîËæÉÂΩìÂâçÂ≠óÊØçÁöÑÊúÄÂêé‰ΩçÁΩÆÔºåÂ∞ÜÊúÄÂ§ßÂ≠ò‰∏∫lastÔºåÂΩìlast== i Âç≥ËØ•Â≠óÊØçÈáçÂêàÊó∂ÔºåÂ∞ÜËØ•Â≠óÊÆµÈïøÂ∫¶Â≠òÂÖ•listÔºåÊõ¥Êñ∞start„ÄÇ 617. Merge Two Binary Trees /** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ class solution&#123; public TreeNode mergetree(TreeNode t1, TreeNode t2)&#123; if (t1 == null &amp;&amp; t2 == null)&#123; return null; &#125; elif (t1 == null)&#123; return t2; &#125; elif (t2 == null)&#123; return t1; &#125; TreeNode n = new TreeNode(t1.val + t2.val); n.left = mergetree(t1.left,t2.left); n.right = mergetree(t1.right, t2.right); return n; &#125; &#125; ÊÄùË∑Ø ÁÆÄÂçïÁöÑËûçÂêà‰∏§‰∏™‰∫åÂèâÊ†ëÁöÑÈ¢òÔºåÂà§Êñ≠ÂêÑËá™ÊòØÂê¶‰∏∫Á©∫ÂêéÔºåËá™Ë∫´ÁÆÄÂçïÈÄíÂΩíÂç≥ÂèØÔºåÊ≥®ÊÑèÂÆö‰πânÊó∂Ë¶ÅÂÖàËØ¥ÊòéÁ±ªÂà´Ôºå‰∏épython‰∏çÂêåÔºåËøòÈúÄË¶ÅÂ§öÂ§öÁªÉ‰π†~ 861. Score After Flipping Matrix class solution&#123; public int matrixScore(int[][] A) &#123; int M = A.length, N = A[0].length, res = (1&lt;&lt;(N-1))*M; for(int j = 1;j&lt;N;j++)&#123; int cur = 0; for(int i = 0; i&lt; M;i++)&#123; cur + = A[i][0]==A[i][j] ? 1 :0; res + = Math.max(cur,M-cur) * (1&lt;&lt;(N-1-j)); &#125; &#125; return res; &#125;&#125; ÊÄùË∑Ø ËôΩÁÑ∂Ë°åÊï∞‰∏çÂ§öÔºå‰ΩÜÊòØÊòØÊØîËæÉÁÉßËÑëÁöÑ‰∏ÄÈÅìÈ¢ò„ÄÇ‰∏∫‰∫Ü‰∫åËøõÂà∂ËææÂà∞ÊúÄÂ§ßÂÄºÔºåËÇØÂÆöË¶ÅÊääÁ¨¨‰∏ÄÂàóÁöÑÊâÄÊúâÊï∞ÂÖ®ÈÉ®ËÆæ‰∏∫1 1&lt;&lt;(N-1) Â∞Ü1ÁöÑ‰∫åËøõÂà∂Â∑¶ÁßªN-1‰ΩçÔºå‰∫åËøõÂà∂Ë°®Á§∫‰∏∫10000Ôºàn-1‰∏™0ÔºâÔºåÁ¨¶ÂêàÊú¨È¢òÁöÑËæìÂÖ•ÁªìÊûÑÊï∞ÁªÑ„ÄÇ ËÆæÁΩÆÂÆåÁöÑÁ¨¨‰∏ÄÂàó‰Ωú‰∏∫ÂØπÊØîÂàóÔºåÊâÄ‰ª•j‰ªé1ÂºÄÂßã„ÄÇÁÑ∂ÂêéÂ∞ÜÊØè‰∏ÄÂàóÁöÑÊØèË°åÂÖÉÁ¥†ÂíåÊØèË°åÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÊØîËæÉÔºåÂ¶ÇÊûúÁõ∏ÂêåÔºåcur+1ÔºåÊØîËæÉcurÂíåM-curÔºåÂà§Êñ≠ÊØèÂàóÊúÄÂ§öÂèØ‰ª•ÂæóÂà∞1ÁöÑ‰∏™Êï∞ÔºåËøõËÄåËÆæÁΩÆ1&lt;&lt;(N-1-j)ÁöÑÂ∑¶Áßª‰∫åËøõÂà∂ÔºåË∑üÂú®Á¨¨‰∏ÄÂàóÁöÑÂêéÈù¢„ÄÇ cur ËÆ∞ÂΩïÂíåA[i][0]Áõ∏ÂêåÁöÑÂÖÉÁ¥†‰∏™Êï∞ÔºåÂõ†‰∏∫‰∏ÄÂºÄÂßãÂ∞ÜÁ≠îÊ°àÁ¨¨‰∏ÄÂàóËÆæ‰∏∫1ÔºåÊâÄ‰ª•‰∏çÁÆ°ÂéüÂßãÁ¨¨‰∏ÄÂàóÊòØ1ËøòÊòØ0ÔºåA[i][j]Â¶ÇÊûúÁõ∏ÂêåÔºåÁî±‰∫éÈùû0Âç≥1ÔºåÂàô‰ª£Ë°®ËØ•‰ΩçÁΩÆÂèØ‰ª•ÊòØ1.‰∏çÁÆ°ÂéüÊù•Â∞±ÊòØËøòÊòØÊõ¥Êîπ‰∏∫1ÔºåÊâÄ‰ª•curÂèØ‰ª•ËÆ∞ÂΩïËØ•ÂàóËÉΩÂ§üÂ≠òÊîæ1ÁöÑÊúÄÂ§ß‰∏™Êï∞ ÂÖ∂ÂÆûÊØè‰∏ÄÂàó1ÁöÑ‰ΩçÁΩÆÂπ∂‰∏çÈáçË¶ÅÔºåÂõ†‰∏∫ÂºÄÂ§¥ÈÉΩÊòØ1ÔºåÊâÄ‰ª•Âè™Êúâ‰∏™Êï∞ÊâçËÉΩÂÜ≥ÂÆöÊúÄÁªàÂíåÁöÑÂ§ßÂ∞èÔºåÊ≠§È¢òË¶ÅÂèçÂ§çÁê¢Á£®ÔºåemmmÔºåÊå∫ÁªïÁöÑ„ÄÇ 921. Minimum Add to Make Parentheses Valid class solution&#123; public int minaddtomamkeparentheses(String S)&#123; int left = 0,int right = 0; for (char i : S.toCharArray())&#123; if (right == 0 &amp;&amp; i ==')')&#123; left++ &#125; else right += i =='(' ? 1: -1; &#125; return left + right &#125;&#125; ÊÄùË∑Ø Âà§Êñ≠ÈúÄË¶ÅÂä†Â§öÂ∞ë‰∏™Êã¨Âè∑ÊâçËÉΩ‰ΩøstringÂèòÊàêÂÆåÊï¥ÁöÑÊã¨Âè∑Áæ§Ôºå())))Â∞±ÈúÄË¶Å‰∏â‰∏™Â∑¶Êã¨Âè∑ÊâçËÉΩÂèòÂÆåÊï¥„ÄÇ 728. Self Dividing Numbers class solution&#123; public List&lt;Integer&gt; selfdividingnum(int left, int right)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;() for( int i = left; i&lt;=right;i++)&#123; if(valid(i))&#123; res.add(i) &#125; &#125; return res &#125; public void valid(int num)&#123; int cur = num; while( cur!=0)&#123; digit = cur%10; if (digit == 0 || num % digit != 0)&#123; return false; &#125; cur/=10; &#125; return true; &#125;&#125; ÊÄùË∑Ø ‰∏ÄÈÅìÊï∞Â≠¶È¢òÔºåËæìÂá∫‰ªéleftÂà∞rightÈáåÔºåËÉΩÂ§üÊï¥Èô§ÂÖ∂ÊâÄÊúâdigitÁöÑÊï∞Ôºå‰æãÂ¶Ç 128 ËÉΩÂ§üÊï¥Èô§1 2 8„ÄÇ Âú®validÂáΩÊï∞‰∏≠ÔºåÂÖà%10 Âèñ‰∏™‰ΩçÊï∞ÔºåÂà§Êñ≠ËÉΩÂê¶Êï¥Èô§ÔºåËã•ÂèØ‰ª•ÔºåÂÜçÊé•ÁùÄÂ∞Ücur/10ÊäõÂéª‰∏™‰ΩçÊï∞ÔºåÂÜçÈáçÂ§ç‰πãÂâçÁöÑÊ≠•È™§Âç≥ÂèØ ‰∏æ‰æã128Ôºö È¶ñÂÖà128%10=8ÔºåËÉΩÂ§üÊï¥Èô§ÔºåÂàô128/10=12Ôºå 12%10 = 2ÔºåÂèØ‰ª•Êï¥Èô§ÔºåÂÜçÁúã12/10=1,1%10=1ÔºåÂèØÊï¥Èô§ÔºåÂÜçËøõË°å1/10=0ÔºåÈÄÄÂá∫Âæ™ÁéØÔºåËæìÂá∫true","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 5","slug":"Leetcode-5","date":"2019-05-06T12:56:09.000Z","updated":"2020-02-03T01:16:22.103Z","comments":true,"path":"2019/05/06/Leetcode-5/","link":"","permalink":"WangHngLeee.github.io/2019/05/06/Leetcode-5/","excerpt":"1038. Binary Search Tree to Greater Sum Tree # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: val = 0 def bstToGst(self, root: TreeNode) -&gt; TreeNode: if root.right: self.bstToGst(root.right) root.val = self.val = root.val + self.val if root.left: self.bstToGst(root.left) return root ÊÄùË∑Ø ‰∏ÄÈÅì‰∏≠Á≠âÁöÑÂÄíÂ∫èÈÅçÂéÜsumÁöÑÈ¢òÔºå‰πãÂêéÈ°∫Â∫èËæìÂá∫Âç≥ÂèØ„ÄÇ Áî±‰∫étreeÁöÑÂè≥Â≠©Â≠êÊ∞∏ËøúÂ§ß‰∫éÂ∑¶Â≠©Â≠êÔºåÊâÄ‰ª•ÂèØ‰ª•ËÆæÁΩÆ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèvalÊù•ËÆ∞ÂΩïÂΩìÂâçÁöÑÂíåÔºå‰ªéÊúÄÂè≥Á´ØÁöÑÊ†πËäÇÁÇπÂºÄÂßãÂêë‰∏äÂæ™ÁéØÔºåÂπ∂Êõ¥Êñ∞root.val","text":"1038. Binary Search Tree to Greater Sum Tree # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: val = 0 def bstToGst(self, root: TreeNode) -&gt; TreeNode: if root.right: self.bstToGst(root.right) root.val = self.val = root.val + self.val if root.left: self.bstToGst(root.left) return root ÊÄùË∑Ø ‰∏ÄÈÅì‰∏≠Á≠âÁöÑÂÄíÂ∫èÈÅçÂéÜsumÁöÑÈ¢òÔºå‰πãÂêéÈ°∫Â∫èËæìÂá∫Âç≥ÂèØ„ÄÇ Áî±‰∫étreeÁöÑÂè≥Â≠©Â≠êÊ∞∏ËøúÂ§ß‰∫éÂ∑¶Â≠©Â≠êÔºåÊâÄ‰ª•ÂèØ‰ª•ËÆæÁΩÆ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèvalÊù•ËÆ∞ÂΩïÂΩìÂâçÁöÑÂíåÔºå‰ªéÊúÄÂè≥Á´ØÁöÑÊ†πËäÇÁÇπÂºÄÂßãÂêë‰∏äÂæ™ÁéØÔºåÂπ∂Êõ¥Êñ∞root.val 980. Unique Paths III class Solution: def uniquePathsIII(self, A: List[List[int]]) -&gt; int: self.res = 0 m,n,empty = len(A),len(A[0]),1 for i in range(m): for j in range(n): if A[i][j] == 1: x,y = (i,j) elif A[i][j] == 2: end =(i,j) elif A[i][j] == 0: empty +=1 def dfs(x,y,empty): if not ( 0&lt;=x&lt;=m and 0&lt;=y&lt;=n and A[x][y] &gt;=0 ):return if (x,y) == end: self.res += empty == 0 return A[i][j] = -2 dfs(x+1,y,empty-1) dfs(x-1,y,empty-1) dfs(x,y+1,empty-1) dfs(x,y-1,empty-1) A[i][j] = 0 dfs(x,y,empty) return res ÊÄùË∑Ø ‰∏ÄÈÅìÁ±ª‰ººbfsÂíådpÁöÑÈ¢òÔºåÈááÁî®Brute Force Backstracking ÊñπÊ≥ï„ÄÇ È¶ñÂÖàÊâæÂà∞startÂíåendÁöÑÂùêÊ†áÔºåËÆ°ÁÆóÂá∫emptyÁöÑÊï∞ÈáèÔºåÁÑ∂ÂêéÂêëÂõõÂë®Êâ©Êï£Ôºå Âú®ÊØè‰∏ÄÊ¨°bfsËøáÁ®ãÂºÄÂßãÔºåÂÖàÂ∞ÜËØ•‰ΩçÁΩÆËÆæÁΩÆ‰∏∫-2ÔºåÈÅøÂÖçÂÜçÊ¨°ËÆøÈóÆÔºõÂΩìËØ•Ê¨°bfsÁªìÊùüÂêéÔºå‰∏ÄÂÆöË¶ÅËÆ∞ÂæóbackstrackingÂõûÂéªÔºåÂ∞ÜËØ•‰ΩçÁΩÆÈáçÊñ∞ËÆæÁΩÆ‰∏∫0ÔºåÈÅøÂÖçÂÖ∂‰ªñbfsÈÅáÂà∞ËØ•ÁÇπÂá∫Èîô„ÄÇÊó∂Èó¥Â§çÊùÇÂ∫¶Âíådp‰∏ÄÊ†∑Ôºå‰ΩÜÊòØÁ©∫Èó¥Â§çÊùÇÂ∫¶Ë¶ÅÂ∞ëËÆ∏Â§ö„ÄÇ 1028. Recover a Tree From Preorder Traversal # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def recoverFromPreorder(self, S: str) -&gt; TreeNode: stack,i = [],0 while i &lt; len(S): level, val = 0,'' while i &lt; len(S) and S[i] =='-': level,i = level + 1,i+1 while i &lt; len(S) and S[i] !='-': val,i = val + S[i], i+1 while len(stack) &gt; len(level): stack.pop() node = TreeNode(val) if stack and stack[-1].left is None: stack[-1].left = node elif stack: stack[-1].right = node stack.append(node) return stack[0] ÊÄùË∑Ø Áî±‰∫éÈ¢òÂπ≤ËæìÂÖ•ÊòØÂÖàÂ∫èÁªìÊûÑÔºåÁî®stackÂâçÂ∫èÂ≠òÂÇ®ÂΩìÂâçÁöÑÊ†πËäÇÁÇπÔºå‰πãÂêéÂ±ÇÊ¨°ËæìÂá∫ÔºåÁî®levelËÆ∞ÂΩïÂΩìÂâçËäÇÁÇπÊ∑±Â∫¶ÔºåstackÂÖÉÁ¥†‰∏™Êï∞Ë∂ÖÂá∫levelÊó∂ÔºåpopÁ¨¨‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÊØèÊ¨°Âæ™ÁéØÂºÄÂßãÂ∞ÜlevelÂàùÂßã‰∏∫0ÔºåÂΩìi&gt;ËæìÂÖ•Êï∞Â≠óÁöÑÈïøÂ∫¶Êó∂ÔºåÈÄÄÂá∫Á¨¨‰∏Ä‰∏™whileÂæ™ÁéØÔºåÁî±‰∫éÊ≠§Êó∂stackÂè™Ââ©‰∏ã‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÊúÄÂêéÂÜçËøîÂõûstack[0]Âç≥ÂèØ„ÄÇ 961. N-Repeated Element in Size 2N Array class Solution &#123; public int repeatedNTimes(int[] A) &#123; for (i = 2 ;i &lt; A.length;i++) if (A[i] == A [i-1] || A[i] == A[i-2]) return A[i]; return A[0]; &#125;&#125; ÊÄùË∑Ø ÊÅ©ÔºåÊúÄËøë‰πüÂú®Â≠¶javaÔºå‰∫éÊòØÂπ≤ËÑÜÂ∞±Áî®javaÂÜô‰∏ÄÈÅìÈ¢òÂêß„ÄÇ ÁÆóÊòØ‰∏ÄÈÅìÊï∞Â≠¶È¢òÂêßÔºåÁªôÂÆö2NÂ§ßÂ∞èÁöÑÊï∞ÁªÑÔºåÊâæÂá∫ÈáçÂ§çNÊ¨°ÁöÑÊï∞Â≠óÔºåÊúÄÂàÜÊï£ÁöÑÊÉÖÂÜµÊó†ÈùûÂ∞±ÊòØabacadaeafÔºåaÈáçÂ§ç‰∫Ü5Ê¨°ÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÂà§Êñ≠ËØ•ÂÖÉÁ¥†Âíå‰ªñÂâçÈù¢‰∏§‰∏™ÂÖÉÁ¥†ÊòØÂê¶Áõ∏Á≠âÂç≥ÂèØÔºåÂ¶ÇÊª°Ë∂≥‰ªªÊÑè‰∏Ä‰∏™Êù°‰ª∂ÔºåÂàôËØ•Êï∞Â∞±ÊòØÊâÄÊ±ÇÊï∞„ÄÇ 1008. Construct Binary Search Tree from Preorder Traversal # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: i=0 def bstFromPreorder(self, A: List[int],bound = float('inf')) -&gt; TreeNode: if self.i == 0 or A[self.i]&gt; bound: return None root = TreeNode(A[self.i]) self.i + =1 root.left = self.bstFromPreorder(A,root.val) root.right = self.bstFromPreorder(A,bound) return root ÊÄùË∑Ø ÂèàÊòØ‰∏ÄÈÅìÈÅçÂéÜÊ†ëÁöÑÈóÆÈ¢òÔºåËÆæÁΩÆ‰∏Ä‰∏™boundÊó†ÈôêÂ§ßËæπÁïåÔºåÈÄíÂΩíÂè≥Â≠êÊ†ëÊó∂Êñπ‰æøÁî®ÔºåÈÄíÂΩíÂâçÂ∞Üself.i Âä†‰∏ÄÂç≥ÂèØ„ÄÇ Sort Array By Parity class Solution &#123; public int[] sortArrayByParity(int[] A) &#123; int i = 0; int j = A.length - 1; while (i &lt; j) &#123; if(A[i] % 2 == 0) &#123; // Even first i++; &#125; else &#123; if(A[j] % 2 != 0) &#123; // Both odd j--; &#125; if (A[j] % 2 == 0) &#123; // Odd, Even swap(A, i, j); i++; j--; &#125; &#125; &#125; return A; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; ÊÄùË∑Ø ‰∏ÄÈÅìÁÆÄÂçïÁöÑÂ•áÂÅ∂ÊéíÂ∫èÈóÆÈ¢òÔºåÂ∞ÜÂÅ∂Êï∞ÂÖ®ÈÉ®ÊèêËá≥ÂâçÈù¢ËæìÂá∫ÔºåÂçïÁã¨ÂÆö‰πâ‰∫ÜswapÂáΩÊï∞ÔºåÊØîËæÉÂü∫Êú¨ÔºåjavaÁâàÊú¨ 814. Binary Tree Pruning # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def pruneTree(self, root: TreeNode) -&gt; TreeNode: if not root: return None root.left = self.pruneTree(root.left) root.right = self.pruneTree(root.right) if not root.left and not root.right and not root.val: return None return root ÊÄùË∑Ø ÁÆÄÂçïÁöÑ‰∏ÄÈÅì‰∫åÂèâÊ†ëÁöÑÈ¢òÔºå‰ºëÊÅØ‰ºëÊÅØËÑëÂ≠ê233333„ÄÇËäÇÁÇπÂè™Êúâ0Âíå1ÔºåÂ∞ÜËäÇÁÇπ‰∏∫0ÁöÑËÄå‰∏îÊ≤°ÊúâÂ∑¶Âè≥Â≠êÊ†ëÁöÑËäÇÁÇπÂèò‰∏∫nullÔºå‰æùÊ¨°ÈÄíÂΩíË∞ÉÁî®„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 4","slug":"Leetcode4","date":"2019-05-06T03:03:39.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/05/05/Leetcode4/","link":"","permalink":"WangHngLeee.github.io/2019/05/05/Leetcode4/","excerpt":"Âæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞leetcodeÁ¨îËÆ∞‰∫ÜÔºå‰πãÂâçÂè™Âà∑È¢òÊ≤°ÊúâÂÜôBlogËÆ∞ÂΩïÂøÉÂæó„ÄÇ‰∏çËøá‰πüÂ•ΩÔºåÊúÄËøëÂàöÂà∑ÂÆåtop interview 100 È¢òÔºåÂÄüÊ≠§Êú∫‰ºöÂ§ç‰π†Â∑©Âõ∫+ÂÜôbolg~ ‰ªäÂêéÊØèÊó•‰∏ÄÁØáÂêßÔºåÊØèÁØá4-6È¢òÔºå‰∏ä‰∏çÂ∞ÅÈ°∂„ÄÇ Max Increase to Keep City Skyline class Solution: def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int: row, col = list(map(max,grid)), list(map(max,zip(*grid))) return sum(min(i,j) for i in row for j in col ) - sum(map(max,grid)) rowÈáåÂ≠òÊîæÊØèË°åÊúÄÂ§ßÂÄºÔºåcolÂ≠òÊîæÊØèÂàóÊúÄÂ§ßÂÄºÔºåÂ¢ûÂä†ÂêéÁöÑÊØè‰∏™‰ΩçÁΩÆÁöÑÂÖÉÁ¥†ÈÉΩ‰∏çËÉΩË∂ÖËøáËØ•Ë°åorËØ•ÂàóÁöÑÊúÄÂ§ßÂÄºÔºåÊâÄ‰ª•Ë¶ÅÂèñmin(row,col),Âæ™ÁéØÈÅçÂéÜÂêéÂèñsum,ÂÜçÂáèÂéªÂéüÂßãÁü©ÈòµÁöÑÂÖÉÁ¥†ÂíåÂ∞±ÊòØÊâÄÊ±ÇÁöÑMax increase„ÄÇ","text":"Âæà‰πÖÊ≤°ÊúâÊõ¥Êñ∞leetcodeÁ¨îËÆ∞‰∫ÜÔºå‰πãÂâçÂè™Âà∑È¢òÊ≤°ÊúâÂÜôBlogËÆ∞ÂΩïÂøÉÂæó„ÄÇ‰∏çËøá‰πüÂ•ΩÔºåÊúÄËøëÂàöÂà∑ÂÆåtop interview 100 È¢òÔºåÂÄüÊ≠§Êú∫‰ºöÂ§ç‰π†Â∑©Âõ∫+ÂÜôbolg~ ‰ªäÂêéÊØèÊó•‰∏ÄÁØáÂêßÔºåÊØèÁØá4-6È¢òÔºå‰∏ä‰∏çÂ∞ÅÈ°∂„ÄÇ Max Increase to Keep City Skyline class Solution: def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -&gt; int: row, col = list(map(max,grid)), list(map(max,zip(*grid))) return sum(min(i,j) for i in row for j in col ) - sum(map(max,grid)) rowÈáåÂ≠òÊîæÊØèË°åÊúÄÂ§ßÂÄºÔºåcolÂ≠òÊîæÊØèÂàóÊúÄÂ§ßÂÄºÔºåÂ¢ûÂä†ÂêéÁöÑÊØè‰∏™‰ΩçÁΩÆÁöÑÂÖÉÁ¥†ÈÉΩ‰∏çËÉΩË∂ÖËøáËØ•Ë°åorËØ•ÂàóÁöÑÊúÄÂ§ßÂÄºÔºåÊâÄ‰ª•Ë¶ÅÂèñmin(row,col),Âæ™ÁéØÈÅçÂéÜÂêéÂèñsum,ÂÜçÂáèÂéªÂéüÂßãÁü©ÈòµÁöÑÂÖÉÁ¥†ÂíåÂ∞±ÊòØÊâÄÊ±ÇÁöÑMax increase„ÄÇ Range Sum of BST # Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def rangeSumBST(self, root: TreeNode, L: int, R: int) -&gt; int: if not root: return None l = self.rangeSumBST(root.left,L,R) r = self.rangeSumBST(root.right, L,R) temp = 0 if L &lt;= temp &lt;= R: temp+= root.val return l + r + temp ÂóØÔºåÂèàÈÅáÂà∞‰∏ÄÈÅìBSTÔºåËØù‰∏çÂ§öËØ¥Ôºå‰∏äÊù•Áõ¥Êé•Ëá™Ë∫´ÈÄíÂΩíË∞ÉÁî®ÂáΩÊï∞ÔºåÂà§Êñ≠Ê†πËäÇÁÇπÂÄºÊòØÂê¶Âú®L,RÂå∫Èó¥ÂÜÖÔºå‰ªéÊúÄÂ∫ï‰∏ãÁöÑËäÇÁÇπÂºÄÂßãÂêë‰∏äÂæ™ÁéØËøîÂõûÂÄºÔºåÊúÄÂêéËæìÂá∫ÁªìÊûú„ÄÇ Encode and Decode TinyURL class Codec: sample = string.acsii_letters + '1234567890' def __init__(self): self.url2code = &#123;&#125; self.code2url = &#123;&#125; def encode(self,longUrl): while longUrl not in self.url2code: code = ''.join(random.choice(Codec.sample) for _ in range(6)) if code not in self.code2url: self.code2url[longUrl] = code self.url2code[code] - longUrl return 'http://tinyurl.com/' + self.url2code[longUrl] def decode(self,shortUrl): return self.code2url[shortUrl[-6:]] ÁΩïËßÅÁöÑ‰∏ÄÈÅìdesignÈ¢òÔºåËÆæËÆ°encodeÂíådecode‰∏§‰∏™ÂäüËÉΩÊ®°ÂùóÔºåÂ∞ÜurlÂä†ÂØÜÂíåËß£Á†ÅÔºåÊ†∏ÂøÉÈÉ®ÂàÜÊòØsampleÁöÑËÆæÁΩÆÔºåÂ∞ÜsampleÂ∫ìËÆæÁΩÆ‰∏∫asciiÁ†ÅÂíåÊï∞Â≠óÁöÑÁªÑÂêàÔºåÁÑ∂ÂêéencodeÊó∂randomÊäΩÂèñÂÖ≠‰ΩçÂä†Âú®ÂéüÈìæÊé•ÁöÑÂêéÈù¢ÔºåÈ°∫‰æøÂ∞ÜÂèåÊñπÂêÑËá™‰Ωú‰∏∫keyÂä†ÂÖ•Â≠óÂÖ∏‰∏≠ÔºåÂú®decode‰∏≠Êñπ‰æøÁõ¥Êé•Ë∞ÉÁî®encodeÂêéÂÖ≠‰ΩçÊâÄÂØπÂ∫îÁöÑÁöÑÂéüÈìæÊé•Âç≥ÂèØ„ÄÇ Maximum Binary Tree # Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def constructMaximumBinaryTree(self, nums): if not nums: return None i = nums.index(max(nums)) node = TreeNode(nums[i]) node.left = constructMaximumBinaryTree(nums[:i]) node.right = constructMaximumBinaryTree(nums[i+1:]) return node ‰∏ÄÈÅìÂü∫Êú¨ÁöÑÈÅçÂéÜÊ†ëÈóÆÈ¢òÔºåËæìÂÖ•Ê†∑Êú¨ÊòØ‰∏≠Â∫èÈÅçÂéÜÁöÑÈ°∫Â∫èÔºåÊâÄ‰ª•Áõ¥Êé•ÈÄâÂèñÂΩìÂâçnums‰∏≠ÊúÄÂ§ßÁöÑÊï∞‰Ωú‰∏∫nodeÂ∞±ÂèØ‰ª•‰∫ÜÔºåÁÑ∂ÂêéËÄÅÊ†∑Â≠êÔºåÈÄíÂΩíËµãÂÄºnode.leftÂíånode.rightÔºåÊúÄÂêéËøîÂõûnodeÂç≥ÂèØ„ÄÇ Divide Two Integers class Solution: def divide(self, dividend: int, divisor: int) -&gt; int: pos = (divisor &lt; 0) is (dividend &lt; 0) dividend = abs(dividend) divisor = abs(divisor) res = 0 while divisor &lt;= dividend: temp,i = divisor,1 while dividend&gt;= temp: temp&lt;&lt;=1 i&lt;&lt;=1 res+=i if not pos: res = -res return min(max(-2147483648,res),2147483647) emmmÁ∫ØÊï∞Â≠¶È¢ò‚Ä¶Èô§Êï∞ÂíåË¢´Èô§Êï∞ÁöÑÂÖ≥Á≥ªÔºåÂÖ∂‰∏≠ÊúâÂá†‰∏™Êàë‰∏™‰∫∫ÊØîËæÉÂñúÊ¨¢ÁöÑÂ∞ècheatÊñπÊ≥ï„ÄÇ 1.(a &lt;0) is (b&lt;0) ÂèØ‰ª•ÂêåÊó∂Âà§Êñ≠aÂíåbÁöÑÊüêÁßçÂÖ±ÂêåÁâπÊÄßÂÖ≥Á≥ªÔºåÂ∞§ÂÖ∂ÊòØÊ≠£Ë¥ü 2.a&lt;&lt;=1 Ë∂ÖÁ∫ßpreferÁöÑcheatÔºåÂè¶Â§ñ‰∏ÄÁßçË°®Á§∫‰πò‰ª•‰∫åÁöÑÊñπÂºèÔºåÂéüÁêÜÊòØÈááÁî®‰∫åËøõÂà∂Â∑¶Áßª1ÁöÑÊñπÊ≥ïÔºåÈÄüÂ∫¶ÂæàÂø´ 3.Â¶ÇÊûúÈ¢òÁõÆÂ≠òÂú®ËæìÂá∫ÂÄºËåÉÂõ¥ÁöÑÈóÆÈ¢òÔºåÂèØ‰ª•ÈááÁî®ÊúÄÂêé‰∏ÄË°åÁöÑmin(max(a,answer),b)ÁöÑÊñπÊ≥ïÔºåÂÖ∂‰∏≠aÊòØÊúÄÂ∞èÂÄºÔºåbÊòØÊúÄÂ§ßÂÄºÔºåanswerÊòØÊâÄÊ±ÇÂÄº„ÄÇ","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 3","slug":"Leetcode3","date":"2019-03-31T02:59:41.000Z","updated":"2020-02-03T01:16:22.101Z","comments":true,"path":"2019/03/30/Leetcode3/","link":"","permalink":"WangHngLeee.github.io/2019/03/30/Leetcode3/","excerpt":"Problem 1 Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5","text":"Problem 1 Sort List Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Hint: Due to the topic of time complexity and space complexity is higher, so looked at various solutions, the best solution is to merge sort, because the list in the merge operation does not need to be like an array of merge operation assigned a temporary array space, space complexity, so it is constant, of course, there is no consideration of recursive system call stack. This involves a linked list commonly used operation, that is, fast and slow pointer skills.Set slow and fast Pointers, both of which start at the top of the table, fast takes two steps at a time, slow takes one step at a time, fast goes to the end of the list, slow goes right to the middle, and that cuts the list in two. class Solution: def sortlist(self,head:ListNode) -&gt; ListNode: if not head or not head.next: return head pre,slow,fast = None,head,head while fast and fast.next: pre,slow,fast = slow,slow.next,fast.next.next pre.next = None return self.merge(self.sortlist(head),self.sortlist(slow))# def merge(self,h1,h2): dummy = tail = ListNode(None) while h1 and h2: if h1.val &lt; h2.val: tail.next,h1 = h1,h1.next else: tail.next,h2 = h2,h2.next tail = tail.next tail.next = h1 or h2 return dummy.next Problem 2 Course Schedule II There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] Hint: Topological sorting application.The topological order is like the backward order of every small project completed in a project, and our task is to find out the sequence of successful completion. The method is to delete a node whose entry degree is 0 at a time, and subtract the entry degree of the node it points to by one.And each time the degree of entry is 0 node saved, and finally return it.That‚Äôs pretty much the same thing. class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]: dic = [0 for i in range(numCourses)] neigh = collections.defaultdict(set) for i,j in prerequisites: dic[i]+=1 neigh[j].add(i) stack = [i for i in range(numCourses) if dic[i]==0] res = [] while stack: node = stack.pop() res.append(node) for i in neigh[node]: dic[i]-=1 if dic[i] == 1: stack.append(i) for i in range(numCourses): if dic[i] &gt; 0: return [] return res","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 2","slug":"Leetcode2","date":"2019-03-15T02:28:58.000Z","updated":"2020-02-03T01:16:22.102Z","comments":true,"path":"2019/03/14/Leetcode2/","link":"","permalink":"WangHngLeee.github.io/2019/03/14/Leetcode2/","excerpt":"Problem1: Group Anagrams Given an array of strings, group anagrams together. Example: Input: [‚Äúeat‚Äù, ‚Äútea‚Äù, ‚Äútan‚Äù, ‚Äúate‚Äù, ‚Äúnat‚Äù, ‚Äúbat‚Äù], Output: [ [‚Äúate‚Äù,‚Äúeat‚Äù,‚Äútea‚Äù], [‚Äúnat‚Äù,‚Äútan‚Äù], [‚Äúbat‚Äù] ] ‰ª£Á†ÅÂ¶Ç‰∏ã","text":"Problem1: Group Anagrams Given an array of strings, group anagrams together. Example: Input: [‚Äúeat‚Äù, ‚Äútea‚Äù, ‚Äútan‚Äù, ‚Äúate‚Äù, ‚Äúnat‚Äù, ‚Äúbat‚Äù], Output: [ [‚Äúate‚Äù,‚Äúeat‚Äù,‚Äútea‚Äù], [‚Äúnat‚Äù,‚Äútan‚Äù], [‚Äúbat‚Äù] ] ‰ª£Á†ÅÂ¶Ç‰∏ã class Solution(object): def groupAnagrams(self, strs): d = &#123;&#125; #Âª∫Á´ãÁ©∫ÁöÑÂ≠óÂÖ∏ for w in strs: #ÈÅçÂéÜstr‰∏≠ÊâÄÊúâÁöÑÂ≠óÁ¨¶‰∏≤ key = tuple(sorted(w)) #Â∞ÜÂ≠óÁ¨¶‰∏≤ÂéªÈáçÔºåÂà©Áî®sort()ÂáΩÊï∞ d[key] = d.get(key,[]) + [str(w)] # Â∞Üd‰∏≠ÁöÑkeyÊåáÂêëÂåÖÂê´ËØ•keyÁöÑÂÄº Âπ∂‰∏îÂú®for‰∏≠Âæ™ÁéØÁõ¥Ëá≥ÂÖ®ÈÉ®ÈÅçÂéÜÂÆåÊàê return list(d.values()) #Â∞ÜÂ≠óÂÖ∏d‰∏≠ÁöÑvalues‰ª•listÁöÑÂΩ¢ÂºèËøîÂõû Problem2 :Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö def climbStairs1(self, n): if n == 1: #ËÆæÁΩÆËµ∞‰∏ÄÊ≠•ÁöÑÊÉÖÂÜµ return 1 if n == 2: # ËÆæÁΩÆËµ∞‰∏§Ê≠•ÁöÑÊÉÖÂÜµ return 2 return self.climbStairs(n-1)+self.climbStairs(n-2) # ÂáΩÊï∞ÂÜÖÂºïÁî®Ëá™Ë∫´ÂáΩÊï∞ÔºåËøõË°åËø≠‰ª£ÔºåÂÆåÊï¥ÈÅçÂéÜ‰∏ÄÈÅç Âú®leetcode‰∫ëÊúçÂä°Âô®‰∏äËøêË°åÂêéÔºåÂá∫Áé∞‰∫ÜTLEÈîôËØØÔºåÂéüÂõ†ÊòØÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫ O(2^n)Ôºå‰∏çÂêàÈ¢òÊÑè ÂêéÊù•Âú® leetÂ§ßÁ•û @sfdye Â∏ÆÂä©‰∏ãÔºåÂ≠¶Âà∞‰∫Ü‰∏Ä‰∏™Êñ∞trickÔºåÂà©Áî®Ë£ÖÈ•∞Âô®@lru_cache()ËøõË°åË°•Êïë Ë£ÖÈ•∞Âô®Â∞Ü‰ΩøÁî®Áõ∏ÂêåÁöÑÊñπÊ≥ïË∞ÉÁî®ÂèÇÊï∞Ëá™Âä®ÁºìÂ≠òÁªìÊûú ÂÖ∂‰∏≠Ôºå()ÂÜÖÂ°´ÂÜô‰Ω†ÊÉ≥ËÆæÁΩÆÁöÑËåÉÂõ¥ÔºåNoneË°®Á§∫Êó†ÈôêÂà∂ÔºåÊâÄ‰ª•Êó∂Èó¥TLEÈóÆÈ¢òÂ∞±ÂæóÂà∞‰∫ÜËß£ÂÜ≥ÔºÅ Êñ∞‰ª£Á†ÅÂ¶Ç‰∏ã from functools import lru_cacheclass Solution: @lru_cache(None) #ÊèíÂÖ•Ë£ÖÈ•∞Âô®ru_cache.() def climbStairs(self, n): if n == 1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1) + self.climbStairs(n-2) Problems3:Unique Paths(DPÂä®ÊÄÅËßÑÂàíÈóÆÈ¢ò) A robot is located at the top-left corner of a m x n grid (marked ‚ÄòStart‚Äô in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‚ÄòFinish‚Äô in the diagram below). How many possible unique paths are there? Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: Right -&gt; Right -&gt; Down Right -&gt; Down -&gt; Right Down -&gt; Right -&gt; Right ÂÖ∂ÂÆûÁîªÂõæÂêéÂèëÁé∞ÔºåÂú®Á¨¨‰∏ÄË°åÊàñËÄÖÊúÄÂ∑¶ÂàóÔºåÁî±‰∫éÊòØÂè™ËÉΩÂêë‰∏äÊàñËÄÖÂêë‰∏ãÁßªÂä®ÔºåÊâÄ‰ª•Êó†ËÆ∫Âì™‰∏™‰ΩçÁΩÆ‰∏äÈÉΩÂè™ËÉΩÊúâ‰∏ÄÁßçË∑ØÂæÑÔºåÂõ†Ê≠§ÂèØ‰ª•ÂÖàÂ∞ÜÂÖ®ÈÉ®ÁöÑÊ†ºÂ≠êÂÜÖÁöÑÊ≠•Êï∞ËÆæ‰∏∫1ÔºåÁÑ∂Âêé‰ªéÁ¨¨‰∫åË°åÁ¨¨‰∫åÂàóÂºÄÂßãËø≠‰ª£(Áî±‰∫éÁ®ãÂ∫è‰∏≠ÈªòËÆ§‰ªé0ÂºÄÂßãÔºåÊâÄ‰ª•‰ª£Á†Å‰∏≠Áî®1Êù•Ë°®Á§∫Á¨¨‰∫åË°åÁ¨¨‰∫åÂàó) Ê†πÊçÆÂä®ÊÄÅËßÑÂàíÊù•ÊÄùËÄÉÔºåÂè™Ë¶ÅÊàë‰ª¨Ê±ÇÂá∫‰∫ÜÂà∞ËææÊØè‰∏Ä‰∏™ÁÇπÁöÑÊúÄÂ§ßË∑ØÂæÑÊï∞ÔºåÁî±‰∫éÂè™ËÉΩÂêë‰∏ãÂêëÂè≥Ëµ∞ÔºåÂàôÊúÄÂêé‰∏Ä‰∏™ÁÇπÁöÑÊúÄÂ§ßË∑ØÂæÑÊï∞‰∏çÂ∞±ÊòØÂâç‰∏§‰∏™ÁöÑÊúÄÂ§ßË∑ØÂæÑ‰πãÂíåÊÉ≥Âä†‰πà,Âç≥ÂæóÂá∫Áä∂ÊÄÅËΩ¨ÁßªÊñπÁ®ã p[i][j] = p[i][j-1]+p[i-1][j] ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö class Solution(object): def uniquePaths(self, m, n): # È¶ñÂÖàÊéíÈô§Âè™Êúâ‰∏ÄË°å‰∏ÄÂàóÁöÑÊÉÖÂÜµÔºåÊ≠§Êó∂Âè™Êúâ‰∏ÄÁßçË∑ØÂæÑ if n == 1 or m == 1: return 1 # Â∞ÜÊï¥‰∏™Êï∞ÁªÑÂùáËÆæÁΩÆ‰∏∫1ÔºåÂàùÂßãÂåñ dp = [[1 for _ in range(n) for _ in range(m)]] for i in (1,m): for j in (1,n): # ÈíàÂØπÊØè‰∏Ä‰∏™ÂùêÊ†á(i,j)‰∏ãÁöÑ‰ΩçÁΩÆËøõË°åÁä∂ÊÄÅËΩ¨ÁßªÔºå #ÂÖ∂ÂÄº‰∏∫ËØ•‰ΩçÁΩÆ‰∏äÊñπÂíåÂ∑¶ÊñπÁöÑË∑ØÂæÑÊï∞‰πãÂíå dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[-1][-1]# ËøîÂõûdp‰∏≠ÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥† Problems 4 : Pascal‚Äôs Triangle(DPÂä®ÊÄÅËßÑÂàíÈóÆÈ¢ò) Given a non-negative integer numRows, generate the first numRows of Pascal‚Äôs triangle. ÁªôÂá∫‰∏ÄÂÆöÁöÑË°åÊï∞ÔºåËæìÂá∫Êé•‰∏ãÊù•ÁöÑÊØè‰∏ÄË°åÂÖÉÁ¥†‰∏™Êï∞ Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] ‰ªîÁªÜÂØªÊâæËßÑÂæãÂêéÔºåÂèëÁé∞ÊØè‰∏ÄË°åÈô§‰∫Ü1‰ª•Â§ñÔºåÊØè‰∏™ÂÖÉÁ¥†ÈÉΩÊòØÂÖ∂‰∏ä‰∏ÄË°åÂØπÂ∫î‰ΩçÁΩÆÂíåÂâç‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÂíå ‰ª£Á†ÅÂ¶Ç‰∏ãÔºö class Solution(object): def generate(self, numRows): # ÂàùÂßãÂåñ‰∏Ä‰∏™ÂÖ®‰∏∫1ÁöÑ‰∏âËßíÂΩ¢ÔºåÊØè‰∏ÄË°åÂÖÉÁ¥†‰∏™Êï∞ÊòØË°åÊï∞Âä†‰∏Ä(‰ª£Á†Å‰∏≠0‰∏∫Á¨¨‰∏ÄË°å) tree = [[1]* (i+1) for i in range(numRows)] for i in range(numRows): for j in range(1,i): # ËøõË°åÁä∂ÊÄÅËΩ¨Áßª tree[i][j]=tree[i-1][j-1] + tree[i-1][j] return tree","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"Leetcode EveryDay 1","slug":"Leetcode1","date":"2019-03-07T02:33:07.000Z","updated":"2020-02-03T01:16:22.248Z","comments":true,"path":"2019/03/06/Leetcode1/","link":"","permalink":"WangHngLeee.github.io/2019/03/06/Leetcode1/","excerpt":"Problem 1 : Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1].","text":"Problem 1 : Two Sum Description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. class solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: r = &#123;&#125; #create dict for x in range(0,len(nums)): n = target - nums(x) #find the other number if n in r: # return [r[n],x] #return the addresses of matched numbers r[nums[x]] = x #input the address of number to r&#123;&#125; Problem 2 : Add two numbers Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: carry = 0 root = n = ListNode(0) while l1 or l2 or carry: v1 = v2 = 0 if l1: v1 = l1.val l1 = l1.next if l2: v2 = l2.val l2 = l2.next carry, val = divmod(v1+v2+carry,10) n.next = ListNode(val) n = n.next return root.next Problems 3 : Longest Substring Without Repeating Characters Description Given a string, find the length of the longest substring without repeating characters. Example 1: Input: ‚Äúabcabcbb‚Äù Output: 3 Explanation: The answer is ‚Äúabc‚Äù, with the length of 3. class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: usedchar = &#123;&#125; for i in range(len(s)): if s[i] in usedchar and start&lt;= usedchar(s[i]): start = usedchar(s[i])+1 else: maxlength = max(maxlength, i-start+1) return maxlength Problems 4 : Longest Palindromic Substring Description Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: ‚Äúbabad‚Äù Output: ‚Äúbab‚Äù Note: ‚Äúaba‚Äù is also a valid answer. class Solution(object): def self.helper(object): while i &gt;=0 and r&lt;len(s) and s[l]==s[r]: l-=1;r+=1 return s[l+1:r] def longestPalindrome(self, s): res = \"\" tem = self.helper(s,i,i) if len(tem)&gt;len(res): res = tem tem = self.helper(s,i,i+1) if len(tem) &gt; len(res): res = tem return res","categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"}]},{"title":"OpenCv Learning Notes (1)","slug":"OpenCv","date":"2019-03-06T14:23:41.000Z","updated":"2019-11-03T21:42:16.034Z","comments":true,"path":"2019/03/06/OpenCv/","link":"","permalink":"WangHngLeee.github.io/2019/03/06/OpenCv/","excerpt":"Representation of image As a computer, an image is just a bunch of dots of varying brightness. An M by N image can be represented by an M by N matrix. The value of the matrix element indicates the brightness of the pixel at this position. Generally, the larger the pixel value is, the brighter the point will be. In general, grayscale images are represented by a 2-dimensional matrix, and color (multi-channel) images are represented by a 3-dimensional matrix (M by N by 3).For image display, most devices currently use unsigned 8-bit integer The number (of type CV_8U) represents the pixel brightness.The order in which image data is stored in the computer memory starts at the top left (or possibly bottom left) of the image, as shown in the figure","text":"Representation of image As a computer, an image is just a bunch of dots of varying brightness. An M by N image can be represented by an M by N matrix. The value of the matrix element indicates the brightness of the pixel at this position. Generally, the larger the pixel value is, the brighter the point will be. In general, grayscale images are represented by a 2-dimensional matrix, and color (multi-channel) images are represented by a 3-dimensional matrix (M by N by 3).For image display, most devices currently use unsigned 8-bit integer The number (of type CV_8U) represents the pixel brightness.The order in which image data is stored in the computer memory starts at the top left (or possibly bottom left) of the image, as shown in the figure Iij represents the pixel value of row I, column j.If it is a multi-channel image, such as an RGB image, each pixel is represented by three bytes.In OpenCV, the channel order of RGB image is BGR, as stored As shown in figure. Mat In the early OpenCV, IplImage and CvMat data structures were used to represent images. In the new version of OpenCV, Mat class is introduced, which can manage memory automatically. With Mat, you no longer have to spend a lot of effort on memory management, and your code becomes cleaner and fewer lines of code. IplImage and CvMat are still available in the new version of OpenCV, but some of the new functions only provide Mat interfaces. The Mat class is defined as follows, and the key properties are as follows: class CV_EXPORTS Mat&#123;public: // A series of functions ... /* The flag parameter contains a lot of information about matrices, such as:- logo Mat- whether the data is continuous- depth - number of channels */ int flags; // The dimension of the matrix should be greater than or equal to 2 int dims; // The number of rows and columns in the matrix, if the matrix exceeds 2 dimensions, both of these variables have a value of 1 int rows, cols; // A pointer to data uchar* data; // A pointer to a reference count // NULL if the data is assigned by the user int* refcount;24 // Other member variables and member functions ...&#125;; Create Mat object Constructor method The Mat class provides a series of constructors that make it easy to create Mat objects as needed. Mat M(3,2, CV_8UC3, Scalar(0,0,255)); cout &lt;&lt; \"M = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; M &lt;&lt; endl; The first line of code creates an image with 3 rows (height) and 2 columns (width), and the image element is an 8-bit unsigned integer type with three channels.All pixel values of the image are initialized to (0, 0, 255).Since the default color order in OpenCV is BGR, this is an all-red image.The second line outputs all the pixel values of an instance M of the Mat class.Mat redefines the &lt;&lt; operator, With this operator, you can easily output all pixel values without having to use a for loop to output each pixel individually. The output of the code is shown in the figure Common constructors are: Mat::Mat () Parameterless construction method; Mat::Mat(int rows, int cols, int type) Create an image with rows, col and type rows. Mat::Mat (Size Size, int type) Create an image of size and type. Mat::Mat(int rows, int cols, int type, const Scalar&amp; s) Create an image with rows, col and type, and initialize all elements with the value s ‚Ä¶ If more channels are needed, use the macro CV_8UC(n), for example: Mat M(3,2, CV_8UC(5));// Create images with rows 3, columns 2, and channels 5 Create the object with the create() function In addition to creating images in the constructor, you can also create images using the create() function of the Mat class. If the create() function specifies the same parameters as before the image, no real memory is used.Application for operation; If the parameters are different, the index of the original data memory is reduced and the memory is reapplied.The use method is as follows: Mat M(2,2, CV_8UC3);// The constructor creates the imageM.create(3,2, CV_8UC2);// Free up memory to recreate the image Note that the initial value of the image pixel cannot be set using the create() function. Create objects using Matlab Matlab style functions such as zeros(), ones() and eyes() are provided in OpenCV 2.It makes the code very simple and easy to use.Using these functions requires specifying the size and type of the image. Mat Z = Mat::zeros(2,3, CV_8UC1);cout &lt;&lt; \"Z = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; Z &lt;&lt; endl;Mat O = Mat::ones(2, 3, CV_32F); cout &lt;&lt; \"O = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; O &lt;&lt; endl;Mat E = Mat::eye(2, 3, CV_64F); cout &lt;&lt; \"E = \" &lt;&lt; endl &lt;&lt; \" \" &lt;&lt; E &lt;&lt; endl; In this code, some type parameters do not indicate the number of channels, in which case it represents a single channel.The output of the above code is shown in the figure","categories":[{"name":"Image Recognition","slug":"Image-Recognition","permalink":"WangHngLeee.github.io/categories/Image-Recognition/"}],"tags":[{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"OpenCv","slug":"OpenCv","permalink":"WangHngLeee.github.io/tags/OpenCv/"}]},{"title":"TensorFlow Learning Notes (1)","slug":"Tensorflow","date":"2019-03-02T04:29:43.000Z","updated":"2019-06-21T05:14:28.000Z","comments":true,"path":"2019/03/01/Tensorflow/","link":"","permalink":"WangHngLeee.github.io/2019/03/01/Tensorflow/","excerpt":"Tensorflow graphs Tensorflow is a graph based parallel computing model (refer to the official document) Circular or square nodes are called nodes, and the streams of data that flow through them are called tensors. More about tensor in the official documentation. The zero order tensor == scalar1 order tensor == Vector (one-dimensional array)2 order tensor == 2 d array‚Ä¶n order tensor == n d array","text":"Tensorflow graphs Tensorflow is a graph based parallel computing model (refer to the official document) Circular or square nodes are called nodes, and the streams of data that flow through them are called tensors. More about tensor in the official documentation. The zero order tensor == scalar1 order tensor == Vector (one-dimensional array)2 order tensor == 2 d array‚Ä¶n order tensor == n d array The relationship between tensor and node: If the dimension of the input tensor is 5,000 by 64, 5000 x 64 means there are 5000 training samples, each sample has 64 characteristics, so the input layer must have 64 nodes to accept these characteristics. The three layers of the network shown in the figure above include the input layer (input in the figure), the hidden layer (named ReLU layer here to indicate that its activation function is ReLU), and the output layer (Logit layer in the figure). As you can see, each of these layers have their associated tensor Gradient nodes flowing into them to compute the Gradient, and then the Gradient tensor will go into the SGD Trainer node to do network optimization (which is to say, update the network parameters). It is through graph that Tensorflow represents the neural network to realize the parallel computation of the network and improve the efficiency. We will introduce the basic syntax of TensorFlow with a simple example. Examples A = calculated using Tensorflow (b + c) ‚àó (c + 2) A = (b + c) ‚àó (c + 2), Define data: import tensorflow as tf# First, create a TensorFlow constant =&gt;2=&gt;2const = tf.constant(2.0, name='const')# Create the TensorFlow variables b and cb = tf.Variable(2.0, name='b')c = tf.Variable(1.0, dtype=tf.float32, name='c') As mentioned above, in TensorFlow, constant is defined with tf.constant() and Variable is defined with tf.variable (). Tensorflow can perform data type detection automatically, for example: assignment 2.0 defaults to tf.float32, but is best defined explicitly.For more information on the TensorFlow data type, see the official documentation. Define operation (also known as TensorFlow operation) : # create operationd = tf.add(b, c, name='d')e = tf.add(c, const, name='e')a = tf.multiply(d, e, name='a') In TensorFlow, + has its own special function representation. In fact, TensorFlow defines enough functions to represent all of the math, and of course overloads some of the math, but to be on the safe side, it is recommended to use functions instead of operators. All variables in TensorFlow must be initialized before they can be used. Initialization consists of two steps: Define initialization operation Run initialization operation # 1. define init operationinit_op = tf.global_variables_initializer() The construction of TensorFlow graph has been completed above. The next step is to calculate and output. To run graph, we need to call the tf.session () function to create a Session.The session is the handle that interacts with the graph. # sessionwith tf.Session() as sess: # 2. init operation sess.run(init_op) # caculate a_out = sess.run(a) print(\"Variable a is &#123;&#125;\".format(a_out)) TensorFlow has an excellent visualization tool called TensorBoard(see the official documentation) An improvement to the above example: make the variable b accept any value.Values are received in TensorFlow as placeholders, created through tf.placeholder(). # create placeholderb = tf.placeholder(tf.float32, [None, 1], name='b') The value of the second parameter is [None, 1], where None indicates uncertainty, namely the size of the first dimension, which can be any size.In particular, the number of tensor inputs (or the number of samples) will be 32, 64‚Ä¶ Now, if you get the result of the calculation, you need the value of feed placeholder b during the run by changing a_out = sess.run(a) to: a_out = sess.run(a, feed_dict=&#123;b: np.arange(0, 10)[:, np.newaxis]&#125;) OutputÔºö Variable a is [[ 3.] [ 6.] [ 9.] [ 12.] [ 15.] [ 18.] [ 21.] [ 24.] [ 27.] [ 30.]]","categories":[{"name":"Deep-Learning","slug":"Deep-Learning","permalink":"WangHngLeee.github.io/categories/Deep-Learning/"}],"tags":[{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"WangHngLeee.github.io/tags/TensorFlow/"}]},{"title":"HOG Learning Notes (1)","slug":"HURF","date":"2019-03-01T16:07:54.000Z","updated":"2019-06-21T05:14:16.000Z","comments":true,"path":"2019/03/01/HURF/","link":"","permalink":"WangHngLeee.github.io/2019/03/01/HURF/","excerpt":"HOG features Currently, HOG (Histogram of Oriented Gradient) is one of the mainstream feature descriptors of pedestrian detection based on machine learning method. HOG feature is a feature descriptor used for target detection. It forms features by calculating and counting the histogram of gradient direction in the local area of the image, and describes the image with these features. This method is similar to the histogram of edge direction and scale-invariant feature transform, but hog‚Äôs computation is based on the density matrix of consistent space to improve the accuracy. Navneet Dalal and Bill Triggs first proposed HOG in 2005‚Äôs CVPR for pedestrian detection in static images or video.","text":"HOG features Currently, HOG (Histogram of Oriented Gradient) is one of the mainstream feature descriptors of pedestrian detection based on machine learning method. HOG feature is a feature descriptor used for target detection. It forms features by calculating and counting the histogram of gradient direction in the local area of the image, and describes the image with these features. This method is similar to the histogram of edge direction and scale-invariant feature transform, but hog‚Äôs computation is based on the density matrix of consistent space to improve the accuracy. Navneet Dalal and Bill Triggs first proposed HOG in 2005‚Äôs CVPR for pedestrian detection in static images or video. The feature of Histogram of Oriented Gradient (HOG) is a descriptor used for object detection in computer vision and image processing. By calculating and statistics the gradient direction histogram of the local area to form the feature. Hog feature combining SVM classifier has been widely used in image recognition, especially in pedestrian detection, which has achieved great success. Nowadays, although many pedestrian detection algorithms are constantly proposed, they are mainly based on HOG + SVM. Principle of HOG characteristics Core method HOG core method is the detection of local object shape can be the distribution of light intensity gradient or the edge direction described, through the image segmentation into small connection area (called cells), each cell to generate a gradient direction histogram or cell edge pixel in image, the histogram of combination can be expressed by detecting target of the target descriptor. In order to improve the accuracy, the local histogram can be compared and standardized by calculating the light intensity of a large area in the image (called block) as the measure, and then use this value (measure) to normalize all cells in the block. This normalization process achieves better light/shadow invariance. The main steps Grayscale an image, that is, treat the image as a three-dimensional image of x,y and z, where z is the grayscale value. Divide into small connected areas called cells (2x2) Calculate the gradient or edge orientation histogram of each pixel in each cells Count the gradient histogram of each cell (the number of different gradients) to form the feature descriptor of each cell. The differences and applications between HOG/SIFT/ PCA-SIFT The HOG feature has no rotation and scale invariance, so the computation is small Each feature in SIFT needs to be described by 128-dimensional vectors, so the computation is relatively large 3 Since SIFT cannot be used for pedestrian detection due to its huge computation, the pca-sift method filters out a lot of dimensional information and only retains 20 principal components, so it is only applicable for object detection with little change in behavior. HOG feature extraction is realized with python+opencv Read in the required detection target, i.e. the input image Grayscale the image (convert the r,g and b values of the input color image into grayscale values through a specific formula) Use Gamma correction method to normalize the color space of the input image (normalization) Calculate the gradient (including size and direction) of each pixel of the image, and capture the contour information Count the gradient histogram (number of different gradients) of each cell to form the descriptor of each cell Every few cells are grouped into a block (take 3*3 as an example), and all cell features in a block are strung together to get the HOG feature descriptor of the block HOG feature descriptor of all blocks in the image is concatenated to obtain the HOG feature descriptor of the image (detection target), which is the final classification feature vector (HOG parameter setting is: 22 cells/interval, 88 pixels/cell, 8 histogram channels, step size is 1)","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"WangHngLeee.github.io/categories/Machine-Learning/"},{"name":"Algorithm","slug":"Machine-Learning/Algorithm","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/"},{"name":"Models","slug":"Machine-Learning/Algorithm/Models","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/Models/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"HOG","slug":"HOG","permalink":"WangHngLeee.github.io/tags/HOG/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"}]},{"title":"Python & Web","slug":"pythonEmail","date":"2019-02-27T13:35:09.000Z","updated":"2019-06-21T05:14:22.000Z","comments":true,"path":"2019/02/27/pythonEmail/","link":"","permalink":"WangHngLeee.github.io/2019/02/27/pythonEmail/","excerpt":"Python network programming Python provides two levels of access to network services: Low-level network services support basic Sockets, which provide the standard BSD Sockets API and access to all methods of the Socket interface of the underlying operating system. Advanced network service module SocketServer, which provides a server center class, can simplify the development of network server.","text":"Python network programming Python provides two levels of access to network services: Low-level network services support basic Sockets, which provide the standard BSD Sockets API and access to all methods of the Socket interface of the underlying operating system. Advanced network service module SocketServer, which provides a server center class, can simplify the development of network server. Socket Socket also known as the ‚ÄúSocket‚Äù, the application usually through the ‚ÄúSocket‚Äù to the network to make a request or reply to the network request, so that the host or a computer between the process can communicate. Socket() function In Python, socket () function is used to create socket. The syntax format is as follows: socket.socket([family[, type[, proto]]]) Parameters: Family: the socket family can be AF_UNIX or AF_INET Type: socket types can be classified as SOCK_STREAM or SOCK_DGRAM depending on whether they are connection-oriented or connection-free Protocol: don‚Äôt use 0 as the default. The service side Use the socket function of the socket module to create a socket object.A socket object can set up a socket service by calling other functions. Now we can specify the port of the service by calling the bind(hostname, port) function. Next, call the accept method of the socket object. This method waits for the client to connect and returns a connection object indicating that it is connected to the client. The complete code is as follows: #!/usr/bin/python# -*- coding: UTF-8 -*-# file nameÔºöserver.pyimport socket # input socket models = socket.socket() # create socket objecthost = socket.gethostname() # Gets the localhost nameport = 12345 # Set ports.bind((host, port)) # Binding ports.listen(5) # Wait for client connectionwhile True: c, addr = s.accept() # Establish a client connection. print 'Address:', addr c.send('Welcome to the rookie tutorial!') c.close() # close the connection The client Next, write a simple client instance that connects to the service created above.The port number is 12345. The socket.connect(hosname, port) method opens a TCP connection to a service provider that has a hostname of port.After the connection. We can then retrieve the data from the server and remember to close the connection when the operation is complete. The complete code is as follows: #!/usr/bin/python# -*- coding: UTF-8 -*-# file nameÔºöclient.pyimport socket # import socket models = socket.socket() # create socket objecthost = socket.gethostname() # Gets the localhost nameport = 12345 # Set ports.connect((host, port))print s.recv(1024)s.close() Now we open the two terminals. The first terminal executes the server.py Ôºö $ python server.py Second terminal execution client.py Ôºö $ python client.py Welcome to the rookie tutorial! When we open the first terminal, we will see the following information output: AddressÔºö ('192.168.0.118', 62461)","categories":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"Web","slug":"Web","permalink":"WangHngLeee.github.io/tags/Web/"}]},{"title":"Using python-turtle to create images","slug":"tree1","date":"2019-02-21T13:35:09.000Z","updated":"2019-06-21T05:14:28.000Z","comments":true,"path":"2019/02/21/tree1/","link":"","permalink":"WangHngLeee.github.io/2019/02/21/tree1/","excerpt":"Turtle Urzig has created a language for children to learn to program ‚Äì LOGO language, which features a programming command for a turtle to draw on a screen. Turtle Graphics were later ported to various high-level languages, and the Python library was built in, essentially 100% duplicating all the functionality of the original Turtle Graphics.","text":"Turtle Urzig has created a language for children to learn to program ‚Äì LOGO language, which features a programming command for a turtle to draw on a screen. Turtle Graphics were later ported to various high-level languages, and the Python library was built in, essentially 100% duplicating all the functionality of the original Turtle Graphics. The first one is the one with the falling leaves effect, which I‚Äôll talk about later. Let‚Äôs start with a simple tree. The code is as follows: from turtle import *from random import *from math import *def tree(n, l): pd() # put the pen down # shadow effect t = cos(radians(heading() + 45)) / 8 + 0.25 pencolor(t, t, t) pensize(n / 3) forward(l) # draw the twigsif n &gt; 0: b = random() * 15 + 10 # Right branch deflection Angle c = random() * 15 + 10 # Left branch deflection Angle d = l * (random() * 0.25 + 0.7) # The length of the next branch # Turn right at an Angle and draw the right branch right(b) tree(n - 1, d) # Turn left at an Angle and draw the left branch left(b + c) tree(n - 1, d) # turn back right(c)else:# draw the leaves right(90) n = cos(radians(heading() - 45)) / 4 + 0.5 pencolor(n, n, n) circle(3) left(90) pu() # pen up backward(l) # backwardbgcolor(0.5, 0.5, 0.5) # backgroundht() # hide turtlespeed(0) # speedÔºåslow down from 1-10Ôºå0 is the fastesttracer(0, 0)left(90) # turn left for 90 anglespu() # pen upbackward(300) # backward 300tree(13, 100) # recursive 7 layersdone() Run the code with PythonIDLEÔºö Add fallen leaves Replace all the codes after drawing the leaves with: if(random()&gt;0.7): pu()#falling t = heading() an = -40 +random()*40 setheading(an) dis = int(800*random()*0.5 + 400*random()*0.3 + 200*random()*0.2) # set the falling equation forward(dis) setheading(t) # draw leaves pd() #pen up right(90) n = cos(radians(heading()-45))/4+0.5 pencolor(n*0.5+0.5,0.4+n*0.4,0.4+n*0.4) circle(2) left(90) pu() #back t=heading() setheading(an) backward(dis) setheading(t) pu() backward(l) #backwardbgcolor(0.5,0.5,0.5) #backgroundht() #hide turtlespeed(0) #speedtracer(0,0)pu() backward(100)left(90) pu() backward(300) tree(12,100) done() The effect after running: At this point, a basic tree is drawn, and the tutrl library still has a lot for me to learn.","categories":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"Turtle","slug":"Turtle","permalink":"WangHngLeee.github.io/tags/Turtle/"}]},{"title":"Talk is cheap. Show me the code.","slug":"hello-world","date":"2019-02-20T13:35:09.000Z","updated":"2019-11-08T04:51:08.897Z","comments":true,"path":"2019/02/20/hello-world/","link":"","permalink":"WangHngLeee.github.io/2019/02/20/hello-world/","excerpt":"","text":"HiÔºÅ Hi, here is my personal website and my first blog. From the beginning of the determination to switch to the code farmers, I have always hoped to have a home in the network world. Because I have been busy studying abroad, I am now on the winter vacation and can finally free up time to build my own blog. Non-technical origin, from the front-end basic language, to the popular front-end framework React, Angular, Spring, Firebase, etc., slowly explored by themselves, relying on interest and perseverance. I hope that when I lose the last line of code, the entire website appears completely in front of me, and I have no hard work. Of course, this is just a simple beginning. There are still many things to learn. Keep hungry and keep learning. Âó®ÔºÅ Âó®ÔºåËøôÈáåÊòØÊàë‰∏™‰∫∫ÁΩëÁ´ôÔºå‰πüÊòØÊàëÁöÑÁ¨¨‰∏Ä‰∏™ÂçöÂÆ¢„ÄÇ‰ªé‰∏ãÂÆöÂÜ≥ÂøÉËΩ¨Ë°åÁ†ÅÂÜúÂºÄÂßãÔºåÂ∞±‰∏ÄÁõ¥Â∏åÊúõËÉΩÂú®ÁΩëÁªú‰∏ñÁïåÈáåÈáåÊúâ‰∏Ä‰∏™Â±û‰∫éËá™Â∑±ÁöÑÂÆ∂„ÄÇÁî±‰∫é‰πãÂâç‰∏ÄÁõ¥Âú®ÂøôÁïôÂ≠¶ÁöÑ‰∫ãÊÉÖÔºåÁé∞Âú®ÊîæÂØíÂÅá‰∫ÜÔºåÁªà‰∫éËÉΩÁ©∫Âá∫Êó∂Èó¥Êù•ÊâìÈÄ†‰∏Ä‰∏™Ëá™Â∑±ÁöÑBlog„ÄÇ ÈùûÁßëÁè≠Âá∫Ë∫´Ôºå‰ªéÂâçÁ´ØÁöÑÂü∫Êú¨ËØ≠Ë®ÄÔºåÂÜçÂà∞ÊµÅË°åÂâçÂêéÁ´ØÊ°ÜÊû∂React,Angular,Spring,FirebaseÁ≠âÔºåËá™Â∑±ÊÖ¢ÊÖ¢Êë∏Á¥¢ÔºåÂÖ®Èù†ÂÖ¥Ë∂£ÂíåÊØÖÂäõÊîØÊíë„ÄÇÂ¶ÇÊÑø‰ª•ÂÅøÂú∞ÔºåÂΩìÊàëËæìÂÆåÊúÄÂêé‰∏ÄË°å‰ª£Á†ÅÁöÑÊó∂ÂÄôÔºåÊï¥‰∏™ÁΩëÁ´ôÂÆåÊï¥Âú∞Âá∫Áé∞Âú®ÊàëÁúºÂâçÔºå‰πüÁÆóÊ≤°ÊúâÁôΩÂä™ÂäõÂêß„ÄÇÂΩìÁÑ∂ÔºåËøôÂè™ÊòØ‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂºÄÂßãÔºåË¶ÅÂ≠¶‰π†ÁöÑËøòÊúâÂæàÂ§öÔºåÂ∞ëËØ¥Â§öÂÅö„ÄÇKeep hungry and keep learning„ÄÇ","categories":[],"tags":[]}],"categories":[{"name":"Leetcode Cracking","slug":"Leetcode-Cracking","permalink":"WangHngLeee.github.io/categories/Leetcode-Cracking/"},{"name":"Interview","slug":"Interview","permalink":"WangHngLeee.github.io/categories/Interview/"},{"name":"Depolyed Web App","slug":"Depolyed-Web-App","permalink":"WangHngLeee.github.io/categories/Depolyed-Web-App/"},{"name":"ÂâçÁ´ØÊ°ÜÊû∂","slug":"ÂâçÁ´ØÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/"},{"name":"React","slug":"ÂâçÁ´ØÊ°ÜÊû∂/React","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/React/"},{"name":"HTML","slug":"Interview/HTML","permalink":"WangHngLeee.github.io/categories/Interview/HTML/"},{"name":"CSS","slug":"Interview/CSS","permalink":"WangHngLeee.github.io/categories/Interview/CSS/"},{"name":"Vue","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/"},{"name":"Interview","slug":"ÂâçÁ´ØÊ°ÜÊû∂/Vue/Interview","permalink":"WangHngLeee.github.io/categories/ÂâçÁ´ØÊ°ÜÊû∂/Vue/Interview/"},{"name":"Weekly Contest","slug":"Weekly-Contest","permalink":"WangHngLeee.github.io/categories/Weekly-Contest/"},{"name":"JS","slug":"Interview/JS","permalink":"WangHngLeee.github.io/categories/Interview/JS/"},{"name":"Language","slug":"Language","permalink":"WangHngLeee.github.io/categories/Language/"},{"name":"IBM-OA","slug":"IBM-OA","permalink":"WangHngLeee.github.io/categories/IBM-OA/"},{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/categories/ruby/"},{"name":"web/appÂºÄÂèëÔºåÊ°ÜÊû∂","slug":"web-appÂºÄÂèëÔºåÊ°ÜÊû∂","permalink":"WangHngLeee.github.io/categories/web-appÂºÄÂèëÔºåÊ°ÜÊû∂/"},{"name":"Life","slug":"Life","permalink":"WangHngLeee.github.io/categories/Life/"},{"name":"lazyday","slug":"lazyday","permalink":"WangHngLeee.github.io/categories/lazyday/"},{"name":"Image Recognition","slug":"Image-Recognition","permalink":"WangHngLeee.github.io/categories/Image-Recognition/"},{"name":"Deep-Learning","slug":"Deep-Learning","permalink":"WangHngLeee.github.io/categories/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"WangHngLeee.github.io/categories/Machine-Learning/"},{"name":"Algorithm","slug":"Machine-Learning/Algorithm","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/"},{"name":"Models","slug":"Machine-Learning/Algorithm/Models","permalink":"WangHngLeee.github.io/categories/Machine-Learning/Algorithm/Models/"},{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/categories/python/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"WangHngLeee.github.io/tags/Leetcode/"},{"name":"Problems List","slug":"Problems-List","permalink":"WangHngLeee.github.io/tags/Problems-List/"},{"name":"Code-Review","slug":"Code-Review","permalink":"WangHngLeee.github.io/tags/Code-Review/"},{"name":"Graph","slug":"Graph","permalink":"WangHngLeee.github.io/tags/Graph/"},{"name":"DFS","slug":"DFS","permalink":"WangHngLeee.github.io/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"WangHngLeee.github.io/tags/BFS/"},{"name":"Tree","slug":"Tree","permalink":"WangHngLeee.github.io/tags/Tree/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"WangHngLeee.github.io/tags/Two-Pointers/"},{"name":"Array","slug":"Array","permalink":"WangHngLeee.github.io/tags/Array/"},{"name":"String","slug":"String","permalink":"WangHngLeee.github.io/tags/String/"},{"name":"DP","slug":"DP","permalink":"WangHngLeee.github.io/tags/DP/"},{"name":"Palindromic","slug":"Palindromic","permalink":"WangHngLeee.github.io/tags/Palindromic/"},{"name":"LinkedList","slug":"LinkedList","permalink":"WangHngLeee.github.io/tags/LinkedList/"},{"name":"Design","slug":"Design","permalink":"WangHngLeee.github.io/tags/Design/"},{"name":"Stack","slug":"Stack","permalink":"WangHngLeee.github.io/tags/Stack/"},{"name":"BST","slug":"BST","permalink":"WangHngLeee.github.io/tags/BST/"},{"name":"Second-Round","slug":"Second-Round","permalink":"WangHngLeee.github.io/tags/Second-Round/"},{"name":"Front-end","slug":"Front-end","permalink":"WangHngLeee.github.io/tags/Front-end/"},{"name":"Interview Questions","slug":"Interview-Questions","permalink":"WangHngLeee.github.io/tags/Interview-Questions/"},{"name":"BackTracking","slug":"BackTracking","permalink":"WangHngLeee.github.io/tags/BackTracking/"},{"name":"Web Application","slug":"Web-Application","permalink":"WangHngLeee.github.io/tags/Web-Application/"},{"name":"React","slug":"React","permalink":"WangHngLeee.github.io/tags/React/"},{"name":"Vue","slug":"Vue","permalink":"WangHngLeee.github.io/tags/Vue/"},{"name":"SilidingWindow","slug":"SilidingWindow","permalink":"WangHngLeee.github.io/tags/SilidingWindow/"},{"name":"Contest","slug":"Contest","permalink":"WangHngLeee.github.io/tags/Contest/"},{"name":"Union-Find","slug":"Union-Find","permalink":"WangHngLeee.github.io/tags/Union-Find/"},{"name":"TwoPointer","slug":"TwoPointer","permalink":"WangHngLeee.github.io/tags/TwoPointer/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"WangHngLeee.github.io/tags/BinarySearch/"},{"name":"UnionFind","slug":"UnionFind","permalink":"WangHngLeee.github.io/tags/UnionFind/"},{"name":"Topological","slug":"Topological","permalink":"WangHngLeee.github.io/tags/Topological/"},{"name":"Tricky","slug":"Tricky","permalink":"WangHngLeee.github.io/tags/Tricky/"},{"name":"Partition","slug":"Partition","permalink":"WangHngLeee.github.io/tags/Partition/"},{"name":"Presum","slug":"Presum","permalink":"WangHngLeee.github.io/tags/Presum/"},{"name":"Golang","slug":"Golang","permalink":"WangHngLeee.github.io/tags/Golang/"},{"name":"TwoPointers","slug":"TwoPointers","permalink":"WangHngLeee.github.io/tags/TwoPointers/"},{"name":"BucketSort","slug":"BucketSort","permalink":"WangHngLeee.github.io/tags/BucketSort/"},{"name":"Sort","slug":"Sort","permalink":"WangHngLeee.github.io/tags/Sort/"},{"name":"Interval","slug":"Interval","permalink":"WangHngLeee.github.io/tags/Interval/"},{"name":"Linkedlist","slug":"Linkedlist","permalink":"WangHngLeee.github.io/tags/Linkedlist/"},{"name":"tree","slug":"tree","permalink":"WangHngLeee.github.io/tags/tree/"},{"name":"algorithms","slug":"algorithms","permalink":"WangHngLeee.github.io/tags/algorithms/"},{"name":"OnlineAssignments","slug":"OnlineAssignments","permalink":"WangHngLeee.github.io/tags/OnlineAssignments/"},{"name":"ruby","slug":"ruby","permalink":"WangHngLeee.github.io/tags/ruby/"},{"name":"OOP","slug":"OOP","permalink":"WangHngLeee.github.io/tags/OOP/"},{"name":"React-Native","slug":"React-Native","permalink":"WangHngLeee.github.io/tags/React-Native/"},{"name":"app","slug":"app","permalink":"WangHngLeee.github.io/tags/app/"},{"name":"webapp","slug":"webapp","permalink":"WangHngLeee.github.io/tags/webapp/"},{"name":"F-1 VISA","slug":"F-1-VISA","permalink":"WangHngLeee.github.io/tags/F-1-VISA/"},{"name":"È∏Ω","slug":"È∏Ω","permalink":"WangHngLeee.github.io/tags/È∏Ω/"},{"name":"Image Process","slug":"Image-Process","permalink":"WangHngLeee.github.io/tags/Image-Process/"},{"name":"OpenCv","slug":"OpenCv","permalink":"WangHngLeee.github.io/tags/OpenCv/"},{"name":"CV","slug":"CV","permalink":"WangHngLeee.github.io/tags/CV/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"WangHngLeee.github.io/tags/TensorFlow/"},{"name":"python","slug":"python","permalink":"WangHngLeee.github.io/tags/python/"},{"name":"HOG","slug":"HOG","permalink":"WangHngLeee.github.io/tags/HOG/"},{"name":"Web","slug":"Web","permalink":"WangHngLeee.github.io/tags/Web/"},{"name":"Turtle","slug":"Turtle","permalink":"WangHngLeee.github.io/tags/Turtle/"}]}